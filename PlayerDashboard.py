import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import os
import re
import traceback
try:
    import RPi.GPIO as GPIO
except ImportError:
    # Mock para ambiente de desenvolvimento sem GPIO
    class MockGPIO:
        BCM = "BCM"
        IN = "IN"
        PUD_UP = "PUD_UP"
        LOW = False
        @staticmethod
        def setmode(mode): pass
        @staticmethod  
        def setup(pin, mode, pull_up_down=None): pass
        @staticmethod
        def input(pin): return True
        @staticmethod
        def cleanup(): pass
    GPIO = MockGPIO()
import random
from Store_v2 import StoreWindow
# Importar sistema de integração da base de dados
try:
    from card_integration import IntegratedCardDatabase
    from cards_database import ActionType
    print("DEBUG: IntegratedCardDatabase e ActionType importadas com sucesso")
except ImportError as e:
    print(f"DEBUG: ERRO ao importar IntegratedCardDatabase ou ActionType: {e}")
    IntegratedCardDatabase = None
    ActionType = None

IMG_DIR = os.path.join(os.path.dirname(__file__), "img")
# Verificar se existe no Raspberry Pi
if not os.path.exists(IMG_DIR):
    raspberry_img_dir = "/home/joao_rebolo/netmaster_menu/img"
    if os.path.exists(raspberry_img_dir):
        IMG_DIR = raspberry_img_dir
        print(f"DEBUG: Usando img do Raspberry Pi: {IMG_DIR}")
    else:
        print(f"DEBUG: Diretório img não encontrado, usando fallback: {IMG_DIR}")

# Detectar automaticamente onde estão as cartas
def detect_cartas_base_dir():
    """Detecta automaticamente o diretório base das cartas"""
    possible_dirs = [
        # Raspberry Pi - nova estrutura
        "/home/joao_rebolo/netmaster_menu",
        # Desenvolvimento local - nova estrutura  
        os.path.dirname(__file__),
        # Fallback para img/cartas se existir
        os.path.join(os.path.dirname(__file__), "img", "cartas")
    ]
    
    for dir_path in possible_dirs:
        # Verificar se existe pelo menos um dos diretórios de cartas esperados
        test_paths = [
            os.path.join(dir_path, "Activities", "Residential-level"),
            os.path.join(dir_path, "Users", "Residential-level"),
            os.path.join(dir_path, "Events", "Residential-level")
        ]
        
        if any(os.path.exists(test_path) for test_path in test_paths):
            print(f"DEBUG: Usando diretório de cartas: {dir_path}")
            return dir_path
    
    print("DEBUG: Nenhum diretório de cartas encontrado!")
    return possible_dirs[0]  # fallback

def detect_player_inventory_base_dir():
    """Detecta automaticamente o diretório base do inventário do jogador"""
    # Detectar se estamos no Raspberry Pi
    is_raspberry_pi = os.path.exists("/home/joao_rebolo") or "raspberry" in os.uname().nodename.lower()
    
    if is_raspberry_pi:
        possible_dirs = [
            # Raspberry Pi - estruturas possíveis
            "/home/joao_rebolo/netmaster_menu/img/cartas",
            "/home/joao_rebolo/netmaster_menu",
            "/home/joao_rebolo/netmaster_menu/img",
        ]
    else:
        possible_dirs = [
            # Desenvolvimento local - inventário do jogador  
            os.path.dirname(__file__),
            # Fallback para estrutura local
            os.path.join(os.path.dirname(__file__), "img", "cartas")
        ]
    
    print(f"DEBUG: [detect_player_inventory_base_dir] Ambiente detectado: {'Raspberry Pi' if is_raspberry_pi else 'Desenvolvimento Local'}")
    print(f"DEBUG: [detect_player_inventory_base_dir] Verificando diretórios possíveis...")
    for i, dir_path in enumerate(possible_dirs):
        print(f"DEBUG: [detect_player_inventory_base_dir] Opção {i+1}: {dir_path}")
        print(f"DEBUG: [detect_player_inventory_base_dir] Diretório existe? {os.path.exists(dir_path)}")
        
        # Verificar se existe pelo menos um dos diretórios de inventário esperados
        test_paths = [
            os.path.join(dir_path, "Activities", "Residential-level"),
            os.path.join(dir_path, "Users", "Residential-level"),
            os.path.join(dir_path, "Events", "Residential-level"),
            # Para Raspberry Pi, testar também estrutura alternativa
            os.path.join(dir_path, "activities", "Residential-level"),
            os.path.join(dir_path, "users", "Residential-level"),
            os.path.join(dir_path, "events", "Residential-level")
        ]
        
        print(f"DEBUG: [detect_player_inventory_base_dir] Testando caminhos:")
        for j, test_path in enumerate(test_paths):
            exists = os.path.exists(test_path)
            print(f"DEBUG: [detect_player_inventory_base_dir]   Teste {j+1}: {test_path} -> {exists}")
        
        if any(os.path.exists(test_path) for test_path in test_paths):
            print(f"DEBUG: Usando diretório de inventário do jogador: {dir_path}")
            return dir_path
    
    print("DEBUG: Nenhum diretório de inventário do jogador encontrado!")
    # Retornar o primeiro diretório como fallback
    fallback = possible_dirs[0] if possible_dirs else os.path.dirname(__file__)
    print(f"DEBUG: Usando fallback: {fallback}")
    return fallback
    return possible_dirs[1]  # fallback para desenvolvimento local

CARTAS_BASE_DIR = detect_cartas_base_dir()
COIN_IMG = os.path.join(IMG_DIR, "picoin.png")
USER_ICONS = [
    os.path.join(IMG_DIR, "red_user_icon.png"),
    os.path.join(IMG_DIR, "green_user_icon.png"),
    os.path.join(IMG_DIR, "blue_user_icon.png"),
    os.path.join(IMG_DIR, "yellow_user_icon.png"),
]

CARD_IMG = os.path.join(IMG_DIR, "cartas", "back_card.png")

# GPIO setup para botão KEY1
KEY1_PIN = 23
GPIO.setmode(GPIO.BCM)
GPIO.setup(KEY1_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

BOARD = [
    # Top row (left to right)
    ("start", "neutral"),      # 0 canto azul
    ("users", "blue"),         # 1
    ("actions", "neutral"),     # 2 (cinzento)
    ("equipments", "blue"),     # 3
    ("challenges", "neutral"), # 4 (cinzento)
    ("activities", "red"),      # 5
    ("events", "neutral"),     # 6 (cinzento)
    ("services", "red"),       # 7

    # Right column (top to bottom)
    ("start", "neutral"),      # 8 canto vermelho
    ("users", "red"),          # 9
    ("actions", "neutral"),     # 10 (cinzento)
    ("equipments", "red"),      # 11
    ("challenges", "neutral"), # 12 (cinzento)
    ("activities", "yellow"),   # 13
    ("events", "neutral"),     # 14 (cinzento)
    ("services", "yellow"),    # 15

    # Bottom row (right to left)
    ("start", "neutral"),      # 16 canto amarelo
    ("users", "yellow"),       # 17
    ("actions", "neutral"),     # 18 (cinzento)
    ("equipments", "yellow"),   # 19
    ("challenges", "neutral"), # 20 (cinzento)
    ("activities", "green"),    # 21
    ("events", "neutral"),     # 22 (cinzento)
    ("services", "green"),     # 23

    # Left column (bottom to top)
    ("start", "neutral"),      # 24 canto verde
    ("users", "green"),        # 25
    ("actions", "neutral"),     # 26 (cinzento)
    ("equipments", "green"),    # 27
    ("challenges", "neutral"), # 28 (cinzento)
    ("activities", "blue"),     # 29
    ("events", "neutral"),     # 30 (cinzento)
    ("services", "blue"),      # 31
]
NUM_CASAS = len(BOARD)

START_POSITIONS = {
    "blue": 0,
    "red": 8,
    "yellow": 16,
    "green": 24
}

def check_gpio_key(root):
    if GPIO.input(KEY1_PIN) == GPIO.LOW:
        GPIO.cleanup()
        root.destroy()
    root.after(100, lambda: check_gpio_key(root))
    
def mostrar_carta_fullscreen_root(root, carta_path, selected_card_idx=0):
    # Limpa tudo do root
    for widget in root.winfo_children():
        widget.destroy()
    root.configure(bg="black")

    pil_img = Image.open(carta_path)
    img_w, img_h = pil_img.size
    max_w, max_h = root.winfo_screenwidth(), root.winfo_screenheight()
    ratio = min(max_w/img_w, max_h/img_h)
    new_w, new_h = int(img_w*ratio), int(img_h*ratio)
    pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

    carta_img = ImageTk.PhotoImage(pil_img)
    carta_real_lbl = tk.Label(root, image=carta_img, bg="black")
    carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
    carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

    # Botão de fechar (X)
    x_img_path = os.path.join(os.path.dirname(__file__), "img", "X_button.png")
    x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
    x_btn = tk.Label(root, image=x_img, cursor="hand2", bg="black")
    x_btn.image = x_img  # type: ignore[attr-defined]
    x_btn.place(relx=0.98, rely=0.02, anchor="ne")

    def fechar():
        carta_real_lbl.destroy()
        x_btn.destroy()
        # Restaura o dashboard mantendo a carta selecionada
        PlayerDashboard(root, player_color="green", saldo=1000, other_players=["red", "blue", "yellow"], selected_card_idx=selected_card_idx)
    x_btn.bind("<Button-1>", lambda e: fechar())

def make_card_callback(parent, idx):
    def callback(event):
        # Remove destaque de todas as cartas
        for lbl in parent.card_labels:
            try:
                if lbl.winfo_exists():
                    lbl.config(highlightthickness=0)
            except tk.TclError:
                continue
            # lbl.selected = False  # Removido para linter
        # Destaca a carta clicada
        clicked_label = event.widget
        try:
            if clicked_label.winfo_exists():
                clicked_label.config(highlightbackground="#8000FF", highlightcolor="#8000FF", highlightthickness=4)
        except tk.TclError:
            pass
        # clicked_label.selected = True  # Removido para linter
        parent.selected_label = clicked_label # Adicionado para armazenar a referência
        parent.selected_card_idx = idx
        parent.update_progress_bars_for_card(idx)
    return callback

class PlayerDashboard(tk.Toplevel):
    def __init__(self, root, player_color, saldo, other_players, player_name="Player", selected_card_idx=0):
        super().__init__(root)
        self.player_color = player_color 
        self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        self.selected_card_idx = selected_card_idx
        self.progress_bars = {}
        self.title("")
        self.configure(bg="black")
        self.player_name = player_name
        self.saldo = saldo
        self.other_players = other_players
        self.card_idx = 0

        # Garantir flags de interação desbloqueadas ao iniciar um novo turno/interface
        self._final_phase_active = False
        self._next_phase_active = False
        self._final_phase_gestao_ativa = False
        
        # Flag para controlar quando carta foi removida e próxima deve ficar virada para baixo
        self._action_recently_removed = False
        
        # Variáveis para controlar a casa atual (para o botão Store)
        self.current_casa_tipo = "neutral"
        self.current_casa_cor = "neutral"
        self.current_other_player_house = False  # Se está numa casa de outro jogador
        
        self.cards = [
        # Carrossel inicial: cartas viradas para baixo, cor do jogador
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        ]
        self.card_stats = [
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
        ]
        
        # NOVA FUNCIONALIDADE: Sistema de flags para rastrear estado das cartas no carrossel
        # True = carta virada para cima (ativa), False = carta virada para baixo (inativa/back_card)
        self.card_face_up_flags = [False, False, False, False]
        print(f"DEBUG: [INIT] Sistema de flags de cartas inicializado: {self.card_face_up_flags}")
        
        # CORREÇÃO: Restaurar estatísticas preservadas do turno anterior (se existirem)
        if hasattr(root, '_backup_card_stats') and hasattr(root, '_backup_cards'):
            print("DEBUG: [INIT] Encontradas estatísticas preservadas do turno anterior")
            
            # Restaurar estatísticas
            if len(root._backup_card_stats) == len(self.card_stats):
                for i, backup_stats in enumerate(root._backup_card_stats):
                    self.card_stats[i] = {
                        'To send': backup_stats['To send'],
                        'Rxd': backup_stats['Rxd'],
                        'Lost': backup_stats['Lost']
                    }
                    print(f"DEBUG: [INIT] Carta {i} estatísticas restauradas: To send={backup_stats['To send']}, Rxd={backup_stats['Rxd']}, Lost={backup_stats['Lost']}")
            
            # Restaurar caminhos das cartas
            if len(root._backup_cards) == len(self.cards):
                for i, backup_path in enumerate(root._backup_cards):
                    self.cards[i] = backup_path
                    print(f"DEBUG: [INIT] Carta {i} path restaurado: {os.path.basename(backup_path) if backup_path else 'None'}")
            
            # CORREÇÃO CRÍTICA: Restaurar mapeamento de Activities preservadas
            if hasattr(root, '_activity_preserved_stats'):
                self._activity_preserved_stats = root._activity_preserved_stats.copy()
                print(f"DEBUG: [INIT] Mapeamento de Activities preservadas restaurado: {len(self._activity_preserved_stats)} entries")
                for activity_path, stats in self._activity_preserved_stats.items():
                    print(f"DEBUG: [INIT] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # Não limpar já aqui: serão atualizados no end_turn e preservados entre interfaces
            print("DEBUG: [INIT] Backups preservados para consistência entre interfaces")
        else:
            print("DEBUG: [INIT] Nenhuma estatística preservada encontrada - usando valores padrão")
        
        self.inventario = {
            "users": [],
            "equipments": [],
            "services": [],
            "actions": [],
            "events": [],
            "challenges": [], 
            "activities": [],
        }

        # Variável para controlar se o botão Store deve estar desabilitado
        self._store_button_disabled = False
        
        # Variável para controlar se um Challenge foi aceite (esconde Next Phase)
        self._challenge_accepted = False
        
        # Inicializar base de dados integrada para valores das cartas
        try:
            if IntegratedCardDatabase:
                self.card_database = IntegratedCardDatabase(".")
                print("DEBUG: Base de dados de cartas inicializada com sucesso")
            else:
                self.card_database = None
                print("DEBUG: Base de dados de cartas não disponível")
        except Exception as e:
            print(f"DEBUG: ERRO ao inicializar base de dados: {e}")
            self.card_database = None
        
        # Variável para controlar se Next Phase está ativo (desabilita vendas)
        self._next_phase_active = False
        
        # Variável para controlar se Next Phase foi ativado manualmente pelo jogador (esconde botão Store)
        self._next_phase_manually_activated = False
        
        # Variável para controlar se Final Phase está ativo (bloqueia ativação/desativação de cartas)
        self._final_phase_active = False
        
        # Variável para controlar se o botão End Turn deve ser mostrado (só após clicar Final Phase)
        self._show_end_turn_button = False
        
        # NOVA VARIÁVEL: Flag para controlar se Final Phase foi clicado NESTE turno específico
        # Evita restauração automática de gestão de pacotes em turnos subsequentes
        self._final_phase_clicked_this_turn = False
        
        # NOVO: ID do turno em que Final Phase foi clicado (para evitar cross-turn contamination)
        self._final_phase_turn_id = None

        # SISTEMA DE CONTROLE DE RATE_MAX POR TURNO
        # Variáveis que resetam a cada turno para controlar quantos pacotes foram processados
        self._rxd_processed_this_turn = {}    # {carta_path: quantidade_processada}
        self._lost_processed_this_turn = {}   # {carta_path: quantidade_processada}
        self._current_turn_id = 1             # ID do turno atual para controle

        # PROTEÇÃO CONTRA LOOP: Flag para evitar abrir inventário recursivamente
        self._inventory_opening = False
        
        # Cache de User IDs para controlo do carrossel durante Next Phase
        self._cached_user_ids = []

        # SISTEMA DE TRACKING TEMPORAL PARA CHALLENGES
        self._challenge_start_turns = {}  # {carta_path: turno_inicio}
        
        # CORREÇÃO CRÍTICA: Preservar contadores de turnos entre sessões
        # Restaurar contadores de turnos preservados ou inicializar em 1
        print(f"DEBUG: [TURN_INIT] ======= INICIALIZAÇÃO DOS CONTADORES DE TURNO =======")
        print(f"DEBUG: [TURN_INIT] Verificando se há contadores preservados no root...")
        print(f"DEBUG: [TURN_INIT] hasattr(root, '_backup_turn_counters'): {hasattr(root, '_backup_turn_counters')}")
        
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            print(f"DEBUG: [TURN_INIT] Contadores encontrados: {backup_counters}")
            self._current_turn_number = backup_counters.get('_current_turn_number', 1)
            self._current_turn = backup_counters.get('_current_turn', 1)
            self._current_turn_id = backup_counters.get('_current_turn_id', 1)
            print(f"DEBUG: [TURN_RESTORE] Contadores de turnos restaurados:")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_number (Challenges): {self._current_turn_number}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn (Events): {self._current_turn}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_id (Processing): {self._current_turn_id}")
        else:
            self._current_turn_number = 1     # Contador de turnos do jogador
            self._current_turn = 1           # Contador de turnos para o sistema de Events (começa em 1)
            self._current_turn_id = 1        # ID do turno atual para controle
            print(f"DEBUG: [TURN_INIT] Contadores de turnos inicializados em 1 (primeiro jogo)")
        
        print(f"DEBUG: [TURN_INIT] ======= CONTADORES FINAIS =======")
        print(f"DEBUG: [TURN_INIT] _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [TURN_INIT] _current_turn: {self._current_turn}")
        print(f"DEBUG: [TURN_INIT] _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [TURN_INIT] ======= FIM INICIALIZAÇÃO =======")
        
        # SISTEMA DE TRACKING TEMPORAL PARA EVENTS
        self._event_start_turns = {}     # {carta_path: turno_inicio}
        self._event_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # SISTEMA DE TRACKING TEMPORAL PARA SERVICES TEMPORARY
        self._service_start_turns = {}   # {carta_path: turno_inicio}
        self._service_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # INICIALIZAÇÃO DAS LISTAS DE CARTAS ATIVAS (movido do playerdashboard_interface)
        self.active_challenge = None  # Só pode haver 1 challenge ativo
        self.active_users = []        # Lista de users ativos (máx 4)
        self.active_equipments = []   # Lista de equipments ativos (sem limite)
        self.active_services = []     # Lista de services ativos (sem limite)
        self.max_users = 4
        # Equipments e Services não têm limite após Next Phase

        # CONTROLE DE SELEÇÃO DO CARROSSEL
        self.selected_carousel_card = None  # Carta atualmente selecionada
        self.selected_carousel_index = None  # Índice da carta selecionada

        # ADICIONA ISTO:
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        self.screen_width = screen_width
        self.screen_height = screen_height

        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)
        self.attributes("-fullscreen", True)        
        
        # Definir bar_color para botões e barra inferior
        color_map = {
            "green": "#70AD47",
            "yellow": "#F2BA0D",
            "red": "#EE6F68",
            "blue": "#43BEF2"
        }
        self.bar_color = color_map.get(self.player_color.lower(), "#AAAAAA")
        
        self.selected_card_idx = selected_card_idx
        self.store_window = None
        
        # Cargas de cartas usando a nova estrutura: cartas/[tipo]/Residential-level/[cor]/
        def load_cards_from_new_structure(card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Tentar múltiplas estruturas de pastas
            possible_paths = []
            
            # Para cartas que têm cores específicas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estruturas possíveis:
                for color_var in color_variants:
                    # 1. cartas/[tipo]/Residential-level/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level", color_var))
                    # 2. cartas/Residential-[tipo]-[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}-{color_var}"))
                    # 3. cartas/[tipo]/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, color_var))
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                possible_paths = [
                    # 1. cartas/[tipo]/Residential-level/
                    os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level"),
                    # 2. cartas/Residential-[tipo]/
                    os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}"),
                    # 3. cartas/[tipo]/
                    os.path.join(CARTAS_BASE_DIR, card_type)
                ]
            
            # Tentar encontrar cartas em qualquer uma das estruturas possíveis
            for path in possible_paths:
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            break  # Para no primeiro caminho que funcionar
                    except Exception as e:
                        continue
            
            return cards
        
        print("DEBUG: [PlayerDashboard] Iniciando carregamento de cartas do inventário...")
        
        # INVENTÁRIO INICIAL: O jogador deve começar com inventário vazio ou apenas algumas cartas básicas
        # As cartas são adicionadas quando compradas na Store, não carregadas de pastas externas
        
        # Verificar se há cartas do inventário do jogador nas pastas do NetMaster
        def load_player_inventory_cards(card_type, player_color):
            """Carrega cartas do inventário do jogador (não da loja)"""
            cards = []
            # Usar a detecção automática para Raspberry Pi e desenvolvimento local
            base_path = detect_player_inventory_base_dir()
            
            # Para cartas que têm cores específicas
            if card_type in ["equipments", "services", "users", "activities"]:
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estrutura: NetMaster/[Tipo]/Residential-level/[Cor]/
                folder_mapping = {
                    "users": "Users",
                    "equipments": "Equipments", 
                    "services": "Services",
                    "activities": "Activities"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                
                for color_var in color_variants:
                    path = os.path.join(base_path, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: [PlayerDashboard] Cartas do inventário encontradas em: {path}")
                                break
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                folder_mapping = {
                    "challenges": "Challenges",
                    "actions": "Actions",
                    "events": "Events"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                path = os.path.join(base_path, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: [PlayerDashboard] Cartas do inventário encontradas em: {path}")
                    except Exception as e:
                        print(f"DEBUG: [PlayerDashboard] Erro ao carregar {card_type}: {e}")
            
            return cards
        
        # INVENTÁRIO INICIAL VAZIO - o jogador começa sem cartas
        # As cartas só são adicionadas quando compradas na Store
        print("DEBUG: [PlayerDashboard] Inicializando inventário vazio - cartas serão adicionadas via compras na Store")
        
        # OPCIONAL: Se quiseres dar algumas cartas iniciais ao jogador, descomenta isto:
        print("DEBUG: [PlayerDashboard] CHAMANDO add_starter_cards()...")
        self.add_starter_cards()  # ✅ ATIVADO - adicionar cartas de exemplo
        print("DEBUG: [PlayerDashboard] add_starter_cards() TERMINADO")

        print(f"DEBUG: [PlayerDashboard] Inventário inicial:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")

        # --- BARRA SUPERIOR COM IMAGEM ---
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            print(f"DEBUG: Tentando carregar TopBar de: {topbar_img_path}")
            
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar criada com sucesso!")
            else:
                print(f"DEBUG: Arquivo TopBar não encontrado, criando fallback")
                # Fallback: criar uma barra colorida simples
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: TopBar fallback criada!")
        except Exception as e:
            print(f"DEBUG: ERRO ao criar TopBar: {e}")
            # Fallback: criar uma barra colorida simples
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
            self.topbar_label = topbar_frame
            print("DEBUG: TopBar fallback criada após erro!")

        # Chama a tela de lançamento de dado
        print("DEBUG: [PlayerDashboard] Chamando show_dice_roll_screen...")
        self.show_dice_roll_screen(player_name, saldo, other_players, screen_width, screen_height)
    
    def _capturar_estado_botoes_imediato(self):
        """Captura o estado atual dos botões + e seta no momento exato"""
        print("DEBUG: [CAPTURA_IMEDIATA] === CAPTURA NO MOMENTO DO CLIQUE ===")
        
        # CORREÇÃO CRÍTICA: Durante Final Phase gestão ativa, preservar o estado dos botões
        # baseado na lógica de gestão, não na existência física dos widgets
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_ativo = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CAPTURA_IMEDIATA] gestao_ativa: {gestao_ativa}, final_phase_ativo: {final_phase_ativo}")
        
        if gestao_ativa and final_phase_ativo:
            print("DEBUG: [CAPTURA_IMEDIATA] ✅ MODO GESTÃO ATIVA - Determinando estado baseado na lógica de gestão")
            
            # Durante gestão ativa, determinar que botões DEVEM estar visíveis
            # baseado no estado atual da carta e valores das barras
            estado = self._determinar_estado_gestao_logico()
            
            print(f"DEBUG: [CAPTURA_IMEDIATA] Estado determinado logicamente: {estado}")
            
        else:
            print("DEBUG: [CAPTURA_IMEDIATA] Modo normal - verificando estado físico dos widgets")
            
            # LIMPAR qualquer estado antigo primeiro para evitar interferência
            if hasattr(self, '_estado_botoes_imediato'):
                print("DEBUG: [CAPTURA_IMEDIATA] ⚠️ Limpando estado antigo antes de capturar novo")
                self._estado_botoes_imediato = None
            
            print("DEBUG: [CAPTURA_IMEDIATA] Capturando estado dos botões AGORA...")
            
            estado = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            try:
                # NOVA LÓGICA MAIS ROBUSTA: Verificar se botão existe E está visível na tela
                print("DEBUG: [CAPTURA_IMEDIATA] === VERIFICAÇÃO DETALHADA DOS BOTÕES ===")
                
                # Verificar botão + Rxd
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão + Rxd...")
                rxd_existe = hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_rxd existe? {rxd_existe}")
                
                if rxd_existe:
                    try:
                        rxd_winfo_exists = self._btn_plus_rxd.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {rxd_winfo_exists}")
                        
                        if rxd_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            rxd_ismapped = self._btn_plus_rxd.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {rxd_ismapped}")
                            
                            if rxd_ismapped:
                                estado['btn_plus_rxd_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] ✅ Botão + Rxd está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Rxd existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Rxd foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro TclError no + Rxd: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro geral no + Rxd: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Rxd não existe")
                    
                # Verificar botão + Lost
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão + Lost...")
                lost_existe = hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_lost existe? {lost_existe}")
                
                if lost_existe:
                    try:
                        lost_winfo_exists = self._btn_plus_lost.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {lost_winfo_exists}")
                        
                        if lost_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            lost_ismapped = self._btn_plus_lost.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {lost_ismapped}")
                            
                            if lost_ismapped:
                                estado['btn_plus_lost_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] ✅ Botão + Lost está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Lost existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Lost foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro TclError no + Lost: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro geral no + Lost: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão + Lost não existe")
                    
                # Verificar botão seta
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão seta...")
                seta_existe = hasattr(self, '_btn_seta') and self._btn_seta is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_seta existe? {seta_existe}")
                
                if seta_existe:
                    try:
                        seta_winfo_exists = self._btn_seta.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {seta_winfo_exists}")
                        
                        if seta_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            seta_ismapped = self._btn_seta.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {seta_ismapped}")
                            
                            if seta_ismapped:
                                estado['btn_seta_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] ✅ Botão seta está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão seta existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão seta foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro TclError no seta: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro geral no seta: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ❌ Botão seta não existe")
                    
            except Exception as e:
                print(f"DEBUG: [CAPTURA_IMEDIATA] ❌ Erro durante captura: {e}")
        
        # Guardar estado capturado
        self._estado_botoes_imediato = estado
        print(f"DEBUG: [CAPTURA_IMEDIATA] === RESULTADO FINAL ===")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado capturado: {estado}")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado armazenado com timestamp único para evitar conflitos")
    
    def _reset_turn_processing_counters(self):
        """
        Reseta os contadores de processamento por turno para todas as cartas.
        Deve ser chamado no início de cada turno (dice roll screen).
        CORREÇÃO: NÃO incrementar contador aqui - contadores já vêm incrementados do end_turn anterior
        """
        print("DEBUG: [TURN_RESET] === RESETANDO CONTADORES DE PROCESSAMENTO ===")
        print(f"DEBUG: [TURN_RESET] ✅ Turno atual preservado do end_turn anterior: {self._current_turn_id}")
        print(f"DEBUG: [TURN_RESET] ✅ Todos os contadores estão sincronizados:")
        print(f"DEBUG: [TURN_RESET]   _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TURN_RESET]   _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TURN_RESET]   _current_turn_id (Processing): {self._current_turn_id}")
        
        # Resetar contadores de processamento SEM incrementar turno
        old_rxd_counters = self._rxd_processed_this_turn.copy()
        old_lost_counters = self._lost_processed_this_turn.copy()
        
        self._rxd_processed_this_turn = {}
        self._lost_processed_this_turn = {}
        
        print(f"DEBUG: [TURN_RESET] Contadores Rxd anteriores: {old_rxd_counters}")
        print(f"DEBUG: [TURN_RESET] Contadores Lost anteriores: {old_lost_counters}")
        print(f"DEBUG: [TURN_RESET] ✅ Contadores resetados - botões + podem aparecer novamente")
        print("DEBUG: [TURN_RESET] === FIM RESET CONTADORES ===")

    def _get_processed_this_turn(self, carta_path, tipo):
        """
        Retorna quantos pacotes foram processados neste turno para uma carta específica.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost'
        
        Returns:
            int: Quantidade processada neste turno
        """
        if tipo == 'rxd':
            return self._rxd_processed_this_turn.get(carta_path, 0)
        elif tipo == 'lost':
            return self._lost_processed_this_turn.get(carta_path, 0)
        else:
            return 0

    def _increment_processed_this_turn(self, carta_path, tipo, quantidade=1):
        """
        Incrementa o contador de processamento para este turno.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost' 
            quantidade (int): Quantidade a incrementar (default: 1)
        """
        print(f"DEBUG: [PROCESSED] Incrementando {tipo} para {os.path.basename(carta_path)}: +{quantidade}")
        
        if tipo == 'rxd':
            current = self._rxd_processed_this_turn.get(carta_path, 0)
            self._rxd_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Rxd processado neste turno: {current} -> {current + quantidade}")
        elif tipo == 'lost':
            current = self._lost_processed_this_turn.get(carta_path, 0)
            self._lost_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Lost processado neste turno: {current} -> {current + quantidade}")

    def _determinar_estado_gestao_logico(self):
        """
        Durante gestão ativa, determina logicamente que botões devem estar visíveis
        baseado no estado das barras e progresso da gestão
        CORREÇÃO: Verificar corretamente os pacotes processados neste turno
        """
        print("DEBUG: [GESTAO_LOGICA] === DETERMINANDO ESTADO LÓGICO DOS BOTÕES ===")
        
        estado = {
            'btn_plus_rxd_visivel': False,
            'btn_plus_lost_visivel': False,
            'btn_seta_visivel': False
        }
        
        try:
            # Obter carta atual da gestão
            carta_atual = self._get_current_actual_card()
            if not carta_atual:
                print("DEBUG: [GESTAO_LOGICA] ❌ Nenhuma carta atual encontrada")
                return estado
            
            # Obter valores atuais das barras de progresso
            if self.selected_carousel_index is not None and self.selected_carousel_index < len(self.card_stats):
                stats = self.card_stats[self.selected_carousel_index]
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print("DEBUG: [GESTAO_LOGICA] ⚠️ Usando valores padrão para barras")
                rxd_atual = 0
                lost_atual = 0
            
            # Obter dados da carta
            rate_max = self._obter_rate_carta(carta_atual)
            carta_dados = self._obter_dados_carta(carta_atual)
            message_size = carta_dados.get('message_size', rate_max) if carta_dados else rate_max
            
            carta_basename = os.path.basename(carta_atual).lower()
            is_challenge = "challenge" in carta_basename
            is_activity = "activity" in carta_basename
            
            print(f"DEBUG: [GESTAO_LOGICA] Carta atual: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [GESTAO_LOGICA] Tipo: {'Challenge' if is_challenge else 'Activity'}")
            print(f"DEBUG: [GESTAO_LOGICA] Rate máximo (por turno): {rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA] Message size (limite total): {message_size}")
            print(f"DEBUG: [GESTAO_LOGICA] Rxd atual: {rxd_atual}, Lost atual: {lost_atual}")
            
            # CORREÇÃO CRÍTICA: Durante gestão de pacotes, verificar contadores POR CARTA
            # O rate_max aplica-se POR CARTA, não globalmente durante gestão
            print(f"DEBUG: [GESTAO_LOGICA] ===== VERIFICAÇÃO DETALHADA DE PROCESSAMENTO =====")
            
            # Durante gestão de pacotes, verificar contadores da carta ESPECÍFICA
            if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                print("DEBUG: [GESTAO_LOGICA] MODO GESTÃO ATIVA - Verificando contadores da carta específica")
                # Verificar contadores apenas para a carta atual sendo gerenciada
                rxd_processed = self._get_processed_this_turn(carta_atual, 'rxd')
                lost_processed = self._get_processed_this_turn(carta_atual, 'lost')
                
                print(f"DEBUG: [GESTAO_LOGICA] Carta específica: {os.path.basename(carta_atual)}")
                print(f"DEBUG: [GESTAO_LOGICA]   Rxd processado: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Lost processado: {lost_processed}")
            else:
                print("DEBUG: [GESTAO_LOGICA] MODO NORMAL - Verificando contadores globais")
                # Fora da gestão, verificar o máximo global (comportamento anterior)
                max_rxd_processed = 0
                max_lost_processed = 0
                
                if hasattr(self, '_rxd_processed_this_turn'):
                    for carta_path, count in self._rxd_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Rxd processados")
                        max_rxd_processed = max(max_rxd_processed, count)
                
                if hasattr(self, '_lost_processed_this_turn'):
                    for carta_path, count in self._lost_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Lost processados")
                        max_lost_processed = max(max_lost_processed, count)
                
                rxd_processed = max_rxd_processed
                lost_processed = max_lost_processed
                
                print(f"DEBUG: [GESTAO_LOGICA] MÁXIMO GLOBAL processado neste turno:")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Rxd: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Lost: {lost_processed}")
            
            print(f"DEBUG: [GESTAO_LOGICA] ===== FIM VERIFICAÇÃO PROCESSAMENTO =====")
            
            # Verificar se Rxd pode ser incrementado
            pode_incrementar_rxd = (rxd_atual < message_size) and (rxd_processed < rate_max)
            print(f"DEBUG: [GESTAO_LOGICA] Rxd permitido:")
            print(f"DEBUG: [GESTAO_LOGICA]   atual ({rxd_atual}) < message_size ({message_size}): {rxd_atual < message_size}")
            print(f"DEBUG: [GESTAO_LOGICA]   processado ({rxd_processed}) < rate_max ({rate_max}): {rxd_processed < rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_rxd}")
            
            if pode_incrementar_rxd:
                estado['btn_plus_rxd_visivel'] = True
                print("DEBUG: [GESTAO_LOGICA] ✅ Botão + Rxd deve estar visível")
            else:
                print("DEBUG: [GESTAO_LOGICA] ❌ Botão + Rxd NÃO deve estar visível")
                if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - ⚠️ MOTIVO: Carta já processou {rxd_processed}/{rate_max} pacotes Rxd neste turno")
                else:
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - ⚠️ MOTIVO: Já processou {rxd_processed}/{rate_max} pacotes Rxd neste turno (GLOBALMENTE)")
            
            # Verificar se Lost pode ser incrementado
            if carta_dados:
                drops_allowed = carta_dados.get('drops_allowed', True)
                penalty_per_packet = carta_dados.get('penalty_per_packet', None)
                
                # Determinar se Lost é permitido para esta carta
                if is_challenge:
                    lost_permitido = drops_allowed or (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Challenge - Lost permitido: drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
                else:
                    lost_permitido = (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Activity - Lost permitido: penalty_per_packet existe ({penalty_per_packet is not None})")
                
                print(f"DEBUG: [GESTAO_LOGICA] Verificando botão Lost:")
                print(f"DEBUG: [GESTAO_LOGICA]   drops_allowed: {drops_allowed}")
                print(f"DEBUG: [GESTAO_LOGICA]   penalty_per_packet: {penalty_per_packet}")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                
                pode_incrementar_lost = (lost_permitido and 
                                       lost_atual < message_size and 
                                       lost_processed < rate_max)
                print(f"DEBUG: [GESTAO_LOGICA] Lost incremento permitido:")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                print(f"DEBUG: [GESTAO_LOGICA]   atual ({lost_atual}) < message_size ({message_size}): {lost_atual < message_size}")
                print(f"DEBUG: [GESTAO_LOGICA]   processado ({lost_processed}) < rate_max ({rate_max}): {lost_processed < rate_max}")
                print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_lost}")
                
                if pode_incrementar_lost:
                    estado['btn_plus_lost_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] ✅ Botão + Lost deve estar visível")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ❌ Botão + Lost NÃO deve estar visível")
                    if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost não permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - ⚠️ MOTIVO: Carta já processou {lost_processed}/{rate_max} pacotes Lost neste turno")
                    else:
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost não permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - ⚠️ MOTIVO: Já processou {lost_processed}/{rate_max} pacotes Lost neste turno (GLOBALMENTE)")
            
            # Verificar se botão seta deve estar visível
            if not estado['btn_plus_rxd_visivel'] and not estado['btn_plus_lost_visivel']:
                # Verificar se há mais cartas para gerir
                total_cartas = len(getattr(self, '_cartas_gestao', []))
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                if carta_atual_idx + 1 < total_cartas:
                    estado['btn_seta_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] ✅ Botão seta deve estar visível (há mais cartas)")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ❌ Não há mais cartas para gerir - sem botão seta")
            else:
                print("DEBUG: [GESTAO_LOGICA] ❌ Botões + ainda disponíveis - botão seta NÃO deve estar visível")
                    
        except Exception as e:
            print(f"DEBUG: [GESTAO_LOGICA] ❌ Erro geral: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: [GESTAO_LOGICA] Estado lógico determinado: {estado}")
        print("DEBUG: [GESTAO_LOGICA] === FIM DETERMINAÇÃO LÓGICA ===")
        
        return estado
    
    def _get_current_actual_card(self):
        """
        Retorna a carta atual baseada na posição real no carrossel, não na variável cached
        CORREÇÃO CRÍTICA: Durante gestão de pacotes, usar sempre a carta da posição atual
        """
        try:
            print(f"DEBUG: [CURRENT_CARD] ===== DIAGNÓSTICO DETALHADO _get_current_actual_card =====")
            print(f"DEBUG: [CURRENT_CARD] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(_carta_atual_gestao): {hasattr(self, '_carta_atual_gestao')}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(cards): {hasattr(self, 'cards')}")
            print(f"DEBUG: [CURRENT_CARD] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
            print(f"DEBUG: [CURRENT_CARD] len(cards): {len(self.cards) if hasattr(self, 'cards') else 'N/A'}")
            print(f"DEBUG: [CURRENT_CARD] selected_carousel_index: {getattr(self, 'selected_carousel_index', 'N/A')}")
            
            # CORREÇÃO CRÍTICA: Durante gestão de pacotes, priorizar selected_carousel_index
            gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            tem_cards = hasattr(self, 'cards') and self.cards
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [CURRENT_CARD] gestao_ativa: {gestao_ativa}")
            print(f"DEBUG: [CURRENT_CARD] tem_cards: {tem_cards}")
            print(f"DEBUG: [CURRENT_CARD] selected_index: {selected_index}")
            
            # Se estamos em gestão e há um índice selecionado válido, usar esse
            if gestao_ativa and tem_cards and selected_index is not None:
                if selected_index < len(self.cards):
                    carta_real = self.cards[selected_index]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] ✅ Gestão ativa - usando selected_carousel_index {selected_index}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ❌ selected_carousel_index {selected_index} fora dos limites ({len(self.cards)})")
            
            # Se estamos em gestão de pacotes mas sem selected_index, usar _carta_atual_gestao
            if gestao_ativa and tem_cards and hasattr(self, '_carta_atual_gestao'):
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                print(f"DEBUG: [CURRENT_CARD] carta_atual_idx: {carta_atual_idx}, len(cards): {len(self.cards)}")
                if carta_atual_idx < len(self.cards):
                    carta_real = self.cards[carta_atual_idx]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] ✅ Gestão ativa - usando _carta_atual_gestao {carta_atual_idx}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ❌ _carta_atual_gestao {carta_atual_idx} fora dos limites ({len(self.cards)})")
            
            # Se não estamos em gestão mas há índice selecionado válido, usar esse
            if tem_cards and selected_index is not None and selected_index < len(self.cards):
                carta_real = self.cards[selected_index]
                carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                print(f"DEBUG: [CURRENT_CARD] ✅ Usando selected_carousel_index normal {selected_index}: {carta_nome}")
                return carta_real
            
            # Fallback para selected_carousel_card se ainda é válida
            carta_cached = getattr(self, 'selected_carousel_card', None)
            carta_cached_nome = carta_cached.split('/')[-1] if carta_cached else 'None'
            print(f"DEBUG: [CURRENT_CARD] carta_cached: {carta_cached_nome}")
            if carta_cached:
                print(f"DEBUG: [CURRENT_CARD] ✅ Fallback para carta cached: {carta_cached_nome}")
                return carta_cached
            
            print("DEBUG: [CURRENT_CARD] ❌ Nenhuma carta atual encontrada")
            print(f"DEBUG: [CURRENT_CARD] ===== FIM DIAGNÓSTICO =====")
            return None
            
        except Exception as e:
            print(f"DEBUG: [CURRENT_CARD] ERRO CRÍTICO na função: {e}")
            import traceback
            print(f"DEBUG: [CURRENT_CARD] Stack trace: {traceback.format_exc()}")
            return getattr(self, 'selected_carousel_card', None)
    
    def _save_dashboard_state(self):
        """Salva o estado atual da interface principal do dashboard"""
        # PROTEÇÃO: Não salvar estado se estivermos numa página especial
        if getattr(self, '_in_router_selection_page', False):
            print("DEBUG: [ESTADO] ⚠️ Salvamento de estado cancelado - estamos numa página de seleção de router")
            return
            
        print("DEBUG: [ESTADO] Salvando estado da interface principal...")
        
        # CORREÇÃO CRÍTICA: Preservar valores das barras ANTES de salvar estado
        # Isto é especialmente importante durante gestão de pacotes
        if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa and
            hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None):
            try:
                # Capturar valores das barras visíveis e preservar em card_stats
                if hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    idx = self.selected_carousel_index
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual,
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [ESTADO] ✅ Valores preservados antes de salvar estado:")
                        print(f"DEBUG: [ESTADO]   Carta índice {idx}: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            except Exception as e:
                print(f"DEBUG: [ESTADO] ❌ Erro ao preservar valores antes de salvar: {e}")
        
        # CORREÇÃO CRÍTICA: NÃO modificar _final_phase_gestao_ativa durante navegação
        # Os widgets são destruídos durante navegação, mas isso não significa que a gestão foi finalizada
        gestao_pretende_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        if gestao_pretende_ativa:
            print("DEBUG: [ESTADO] === PRESERVANDO ESTADO DE GESTÃO DURANTE NAVEGAÇÃO ===")
            print("DEBUG: [ESTADO] _final_phase_gestao_ativa permanece True - apenas navegação temporária")
            print("DEBUG: [ESTADO] Widgets podem estar destruídos mas gestão não foi finalizada pelo usuário")

        state = {
            # Estado do carrossel - CORREÇÃO: Usar carta atual real
            'selected_carousel_card': self._get_current_actual_card(),
            'selected_carousel_index': getattr(self, 'selected_carousel_index', None),
            'destaque_roxo_index': getattr(self, '_carta_atual_gestao', getattr(self, 'selected_carousel_index', None)),  # NOVO: preserva índice do destaque roxo
            'cards': self.cards[:] if hasattr(self, 'cards') else [],
            'card_stats': [stats.copy() for stats in self.card_stats] if hasattr(self, 'card_stats') else [],
            
            # Estado das barras de progresso
            'progress_bar_values': {},
            
            # Estados dos botões e fases
            '_final_phase_active': getattr(self, '_final_phase_active', False),
            '_next_phase_active': getattr(self, '_next_phase_active', False),
            '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
            '_show_end_turn_button': getattr(self, '_show_end_turn_button', False),
            '_challenge_accepted': getattr(self, '_challenge_accepted', False),
            '_store_button_disabled': getattr(self, '_store_button_disabled', False),
            '_next_phase_manually_activated': getattr(self, '_next_phase_manually_activated', False),
            
            # Estado da gestão de pacotes
            '_cartas_gestao': getattr(self, '_cartas_gestao', []),
            '_carta_atual_gestao': getattr(self, '_carta_atual_gestao', 0),
            '_valores_pacotes': getattr(self, '_valores_pacotes', {}),
            
            # Estados de controles visíveis
            'controles_gestao_visiveis': False,
            'botao_seta_visivel': False,
            'final_phase_turn_id': getattr(self, '_final_phase_turn_id', None)  # NOVO: ID do turno
        }
        
        # Salvar valores das barras de progresso se existirem
        if hasattr(self, 'progress_bars'):
            for nome, barra in self.progress_bars.items():
                try:
                    state['progress_bar_values'][nome] = barra.get()
                except:
                    state['progress_bar_values'][nome] = 0
        
        # Verificar se controles de gestão estão visíveis
        print("DEBUG: [ESTADO] === VERIFICAÇÃO DETALHADA DOS CONTROLES ===")
        print(f"DEBUG: [ESTADO] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # Sistema de flags específicas para cada botão - DETECÇÃO SIMPLES E DIRETA
        state['btn_plus_rxd_visivel'] = False
        state['btn_plus_lost_visivel'] = False
        state['btn_seta_visivel'] = False
        
        print(f"DEBUG: [ESTADO] === VERIFICANDO ESTADO IMEDIATO ===")
        
        # CORREÇÃO CRÍTICA: Usar estado imediato se disponível e NÃO DELETAR ainda
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] ✅ USANDO ESTADO IMEDIATO CAPTURADO ANTES DO CLIQUE:")
            print(f"DEBUG: [ESTADO] Estado original capturado: {self._estado_botoes_imediato}")
            
            # USAR EXATAMENTE o que foi capturado - sem modificações
            state['btn_plus_rxd_visivel'] = self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False)
            state['btn_plus_lost_visivel'] = self._estado_botoes_imediato.get('btn_plus_lost_visivel', False)
            state['btn_seta_visivel'] = self._estado_botoes_imediato.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [ESTADO] Estado usado para save:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {state['btn_seta_visivel']}")
            
            # CRÍTICO: NÃO deletar ainda - preservar para debug e restauração
            print("DEBUG: [ESTADO] ✅ Estado imediato preservado - será limpo apenas após restauração completa")
        else:
            print("DEBUG: [ESTADO] ⚠️ Nenhum estado imediato disponível - usando detecção fallback")
            print(f"DEBUG: [ESTADO] === DETECÇÃO SIMPLES DOS BOTÕES ===")
            
            # MÉTODO SIMPLES: Verificar apenas os atributos de classe diretamente
            try:
                # Verificar botão + Rxd
                if (hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None):
                    try:
                        if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                            state['btn_plus_rxd_visivel'] = True
                            print(f"DEBUG: [ESTADO] ✅ Botão + Rxd DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ❌ Botão + Rxd existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ❌ Erro ao verificar + Rxd: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ❌ Atributo _btn_plus_rxd não existe ou é None")
                    
                # Verificar botão + Lost  
                if (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None):
                    try:
                        if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                            state['btn_plus_lost_visivel'] = True
                            print(f"DEBUG: [ESTADO] ✅ Botão + Lost DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ❌ Botão + Lost existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ❌ Erro ao verificar + Lost: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ❌ Atributo _btn_plus_lost não existe ou é None")
                    
                # Verificar botão seta
                if (hasattr(self, '_btn_seta') and self._btn_seta is not None):
                    try:
                        if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                            state['btn_seta_visivel'] = True
                            print(f"DEBUG: [ESTADO] ✅ Botão seta DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ❌ Botão seta existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ❌ Erro ao verificar seta: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ❌ Atributo _btn_seta não existe ou é None")
                    
            except Exception as e:
                print(f"DEBUG: [ESTADO] ❌ Erro geral na detecção: {e}")
        
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETECÇÃO ===")
        
        # Atualizar flags legadas para compatibilidade
        if state['btn_plus_rxd_visivel'] or state['btn_plus_lost_visivel']:
            state['controles_gestao_visiveis'] = True
        if state['btn_seta_visivel']:
            state['botao_seta_visivel'] = True
        
        # Relatório final da detecção
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETECÇÃO ===")
        print(f"DEBUG: [ESTADO] btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
        print(f"DEBUG: [ESTADO] btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
        print(f"DEBUG: [ESTADO] btn_seta_visivel: {state['btn_seta_visivel']}")
        print(f"DEBUG: [ESTADO] controles_gestao_visiveis: {state.get('controles_gestao_visiveis', False)}")
        print(f"DEBUG: [ESTADO] botao_seta_visivel: {state.get('botao_seta_visivel', False)}")
        
        self._saved_dashboard_state = state
        print(f"DEBUG: [ESTADO] ✅ Estado salvo com sucesso!")
        print(f"DEBUG: [ESTADO] Carta selecionada: {state.get('selected_carousel_card')}")
        print(f"DEBUG: [ESTADO] Índice selecionado: {state.get('selected_carousel_index')}")
        print(f"DEBUG: [ESTADO] Índice destaque roxo: {state.get('destaque_roxo_index')}")
        print(f"DEBUG: [ESTADO] Final phase active: {state.get('_final_phase_active')}")
        print(f"DEBUG: [ESTADO] Gestão ativa: {state.get('_final_phase_gestao_ativa')}")
        print(f"DEBUG: [ESTADO] Botões preservados: rxd={state.get('btn_plus_rxd_visivel')}, lost={state.get('btn_plus_lost_visivel')}, seta={state.get('btn_seta_visivel')}")
        
        # GARANTIA ADICIONAL: Também salvar no estado imediato para fallback
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print(f"DEBUG: [ESTADO] ✅ Estado imediato também disponível como backup")
        else:
            print(f"DEBUG: [ESTADO] ⚠️ Estado imediato não disponível")
            # Criar backup baseado no estado atual
            self._estado_botoes_imediato = {
                'btn_plus_rxd_visivel': state.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': state.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': state.get('btn_seta_visivel', False)
            }
            print(f"DEBUG: [ESTADO] ✅ Estado imediato criado como backup")
    
    def _restore_gestao_buttons_specifically(self, btn_plus_rxd_visivel, btn_plus_lost_visivel, btn_seta_visivel):
        """
        Método específico para restaurar apenas os botões de gestão que estavam visíveis.
        Este método é chamado após voltar de páginas de inventário ou fullscreen.
        """
        print("DEBUG: [RESTORE_BUTTONS] === RESTAURAÇÃO ESPECÍFICA DE BOTÕES ===")
        print(f"DEBUG: [RESTORE_BUTTONS] Botões a restaurar:")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Rxd: {btn_plus_rxd_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Lost: {btn_plus_lost_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   Seta: {btn_seta_visivel}")
        
        # CORREÇÃO CRÍTICA: Se estamos em gestão de pacotes ativa, sempre restaurar o destaque roxo
        # mesmo que não hajam botões específicos para restaurar
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        # Verificar se há pelo menos um botão para restaurar OU se gestão está ativa
        algum_botao_para_restaurar = btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel
        
        if not algum_botao_para_restaurar and not gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] ❌ Nenhum botão para restaurar e gestão não ativa")
            return
        
        if not algum_botao_para_restaurar and gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] ⚠️ Gestão ativa mas nenhum botão específico para restaurar - determinando botões corretos")
            # CORREÇÃO CRÍTICA: Se gestão está ativa mas não há flags específicas,
            # redeterminar que botões devem estar visíveis baseado na carta atual
            estado_logico = self._determinar_estado_gestao_logico()
            btn_plus_rxd_visivel = estado_logico.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_visivel = estado_logico.get('btn_plus_lost_visivel', False) 
            btn_seta_visivel = estado_logico.get('btn_seta_visivel', False)
            print(f"DEBUG: [RESTORE_BUTTONS] Estado redeterminado: rxd={btn_plus_rxd_visivel}, lost={btn_plus_lost_visivel}, seta={btn_seta_visivel}")
            
            # Se ainda não há nenhum botão para restaurar, não há nada a fazer
            if not (btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel):
                print("DEBUG: [RESTORE_BUTTONS] ❌ Redeterminação também não encontrou botões - cancelando restauração")
                return
        
        # Garantir que a gestão está ativa se há botões para restaurar
        self._final_phase_gestao_ativa = True
        self._final_phase_active = True
        
        # CORREÇÃO FUNDAMENTAL: Restaurar para a carta que ESTAVA sendo gerenciada antes do fullscreen
        # A gestão estava na carta 1 (Challenge_9.png), não na carta 0 (back_card_red.png)
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            carta_gestao_original = self._saved_dashboard_state.get('selected_carousel_index', 1)
            print(f"DEBUG: [RESTORE_BUTTONS] ✅ CORREÇÃO FUNDAMENTAL:")
            print(f"DEBUG: [RESTORE_BUTTONS]   Carta que estava sendo gerenciada: {carta_gestao_original}")
            print(f"DEBUG: [RESTORE_BUTTONS]   Restaurando gestão para esta carta")
            self.selected_carousel_index = carta_gestao_original
            self._carta_atual_gestao = carta_gestao_original
            
            # Atualizar selected_carousel_card se possível
            if (hasattr(self, 'cards') and self.cards and 
                carta_gestao_original < len(self.cards)):
                self.selected_carousel_card = self.cards[carta_gestao_original]
                print(f"DEBUG: [RESTORE_BUTTONS] ✅ Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        else:
            # CORREÇÃO PROBLEMA 2: Preservar a posição correta do destaque roxo
            # NÃO redefinir selected_carousel_index se já está definido corretamente
            posicao_destaque_roxo = getattr(self, '_carta_atual_gestao', 1)  # Default para 1, não 0
            
            print(f"DEBUG: [RESTORE_BUTTONS] ⚠️ Usando fallback - posição gestão: {posicao_destaque_roxo}")
            self.selected_carousel_index = posicao_destaque_roxo
            self._carta_atual_gestao = posicao_destaque_roxo
            
            # Atualizar selected_carousel_card se possível
            if (hasattr(self, 'cards') and self.cards and 
                posicao_destaque_roxo < len(self.cards)):
                self.selected_carousel_card = self.cards[posicao_destaque_roxo]
                print(f"DEBUG: [RESTORE_BUTTONS] ✅ Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        
        print(f"DEBUG: [RESTORE_BUTTONS] ✅ POSIÇÃO GESTÃO CORRIGIDA:")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_index: {self.selected_carousel_index}")
        print(f"DEBUG: [RESTORE_BUTTONS]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_card: {os.path.basename(self.selected_carousel_card) if self.selected_carousel_card else 'None'}")
        
        # CORREÇÃO FUNDAMENTAL: Recriar _cartas_gestao se estiver vazia ou inconsistente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print("DEBUG: [RESTORE_BUTTONS] ⚠️ _cartas_gestao vazia - recriando com cartas ativas do carrossel")
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            self._cartas_gestao = cartas_ativas
            print(f"DEBUG: [RESTORE_BUTTONS] ✅ _cartas_gestao recriada: {[os.path.basename(c) for c in cartas_ativas]}")
            
            # Ajustar _carta_atual_gestao se está fora de range
            if self._carta_atual_gestao >= len(self._cartas_gestao):
                self._carta_atual_gestao = len(self._cartas_gestao) - 1 if self._cartas_gestao else 0
                print(f"DEBUG: [RESTORE_BUTTONS] ⚠️ _carta_atual_gestao ajustada para: {self._carta_atual_gestao}")
        
        # CORREÇÃO CRÍTICA: Aplicar destaque roxo na posição correta
        if self.selected_carousel_index is not None:
            print(f"DEBUG: [RESTORE_BUTTONS] ✅ Aplicando destaque roxo na posição: {self.selected_carousel_index}")
            self._adicionar_destaque_roxo(self.selected_carousel_index)
            self._update_carousel_selection_highlights()
        
        # CORREÇÃO CRÍTICA: Remover controles existentes SEM criar botão seta automaticamente
        print("DEBUG: [RESTORE_BUTTONS] Limpando controles existentes sem criar botão seta...")
        self._remover_controles_gestao_silencioso()
        
        # CORREÇÃO FUNDAMENTAL: Obter rate da carta CORRETA (não da fallback)
        carta_para_gestao = self.selected_carousel_card or self._get_current_actual_card()
        rate_max = self._obter_rate_carta(carta_para_gestao)
        dados_carta = self._obter_dados_carta(carta_para_gestao)
        rate_options = dados_carta.get('rate_options', [0, 1])
        print(f"DEBUG: [RESTORE_BUTTONS] ✅ Rate obtido da carta correta {os.path.basename(carta_para_gestao)}: rate_max={rate_max}, rate_options={rate_options}")
        
        # Restaurar botão + Rxd se estava visível
        if btn_plus_rxd_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão + Rxd roxo...")
            
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gestão de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            self._btn_plus_rxd.lift()
            print("DEBUG: [RESTORE_BUTTONS] ✅ Botão + Rxd roxo restaurado")
        
        # Restaurar botão + Lost se estava visível
        if btn_plus_lost_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão + Lost roxo...")
            
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gestão de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            self._btn_plus_lost.lift()
            print("DEBUG: [RESTORE_BUTTONS] ✅ Botão + Lost roxo restaurado")
        
        # Restaurar botão seta se estava visível
        if btn_seta_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão seta...")
            self._mostrar_botao_seta()
            print("DEBUG: [RESTORE_BUTTONS] ✅ Botão seta restaurado")
        
        # Garantir que End Turn está disabled
        if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
            self.end_turn_btn.config(state="disabled")
            print("DEBUG: [RESTORE_BUTTONS] End Turn mantido disabled")
        
        # Atualizar barras para a carta atual
        try:
            if self.selected_carousel_index is not None:
                self._atualizar_barras_gestao_carta_atual()
        except Exception as e:
            print(f"DEBUG: [RESTORE_BUTTONS] ⚠️ Erro ao atualizar barras: {e}")
        
        print("DEBUG: [RESTORE_BUTTONS] ✅ Restauração específica concluída")

    def _restore_dashboard_state(self):
        """Restaura o estado salvo da interface principal do dashboard"""
        # CORREÇÃO CRÍTICA: Verificar múltiplos locais onde o estado pode estar salvo
        state = None
        
        # 1. Verificar se há estado salvo normal
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            state = self._saved_dashboard_state
            print("DEBUG: [ESTADO] Estado encontrado em _saved_dashboard_state")
        
        # 2. Verificar se há estado capturado imediatamente (NOVO)
        elif hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] Usando estado imediato capturado como fallback")
            # Criar estado mínimo baseado na captura imediata
            state = {
                'btn_plus_rxd_visivel': self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': self._estado_botoes_imediato.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': self._estado_botoes_imediato.get('btn_seta_visivel', False),
                '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
                '_final_phase_active': getattr(self, '_final_phase_active', False),
                'selected_carousel_card': getattr(self, 'selected_carousel_card', None),
                'selected_carousel_index': getattr(self, 'selected_carousel_index', None)
            }
        
        # 3. Se não há estado, não há nada para restaurar
        if not state:
            print("DEBUG: [ESTADO] Nenhum estado salvo encontrado - pular restauração")
            return
        print("DEBUG: [ESTADO] Restaurando estado da interface principal...")
        
        # Restaurar estado do carrossel
        self.selected_carousel_card = state.get('selected_carousel_card')
        self.selected_carousel_index = state.get('selected_carousel_index')
        
        # Restaurar cards e stats se necessário
        if state.get('cards'):
            self.cards = state['cards'][:]
        if state.get('card_stats'):
            self.card_stats = [stats.copy() for stats in state['card_stats']]
        
        # Restaurar estados dos botões e fases
        self._final_phase_active = state.get('_final_phase_active', False)
        self._next_phase_active = state.get('_next_phase_active', False)
        self._final_phase_gestao_ativa = state.get('_final_phase_gestao_ativa', False)
        self._show_end_turn_button = state.get('_show_end_turn_button', False)
        self._challenge_accepted = state.get('_challenge_accepted', False)
        self._store_button_disabled = state.get('_store_button_disabled', False)
        self._next_phase_manually_activated = state.get('_next_phase_manually_activated', False)
        
        # Restaurar estado da gestão de pacotes
        self._cartas_gestao = state.get('_cartas_gestao', [])
        self._carta_atual_gestao = state.get('_carta_atual_gestao', 0)
        self._valores_pacotes = state.get('_valores_pacotes', {})
        
        print(f"DEBUG: [ESTADO] Estado restaurado: carta_selecionada={self.selected_carousel_card}, "
              f"final_phase_active={self._final_phase_active}, "
              f"gestao_ativa={self._final_phase_gestao_ativa}, "
              f"controles_visiveis={state.get('controles_gestao_visiveis')}")
        
        # NOVO: Utilizar flags específicas dos botões para restauração precisa
        gestao_ativa = self._final_phase_gestao_ativa
        btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
        btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
        btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
        
        print(f"DEBUG: [ESTADO] Flags específicas detectadas:")
        print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_seta_visivel: {btn_seta_estava_visivel}")
        
        # Executar restauração após a interface estar pronta
        def restore_gestao_state():
            if gestao_ativa:
                print("DEBUG: [ESTADO] Gestão de pacotes estava ativa - restaurando botões específicos...")
                
                # Verificar se há botões para restaurar
                algum_botao_estava_visivel = btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel or btn_seta_estava_visivel
                
                if algum_botao_estava_visivel:
                    print("DEBUG: [ESTADO] ✅ Botões estavam visíveis - chamando restauração específica")
                    self._restore_gestao_buttons_specifically(
                        btn_plus_rxd_estava_visivel,
                        btn_plus_lost_estava_visivel, 
                        btn_seta_estava_visivel
                    )
                else:
                    print("DEBUG: [ESTADO] ⚠️ Gestão ativa mas sem botões visíveis - mantendo gestão e verificando necessidade")
                    # Manter gestão ativa mas verificar se precisa de botões
                    self._final_phase_gestao_ativa = True
                    self._final_phase_active = True
                    
                    # Aplicar destaque roxo se há carta selecionada
                    if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                        print(f"DEBUG: [ESTADO] ✅ Aplicando destaque roxo na posição {self.selected_carousel_index}")
                        self._adicionar_destaque_roxo(self.selected_carousel_index)
                        self._update_carousel_selection_highlights()
                        
                        # Verificar se precisa de botões baseado no estado atual
                        self.after(300, self._verificar_e_mostrar_botao_seta_se_necessario)
                    else:
                        print("DEBUG: [ESTADO] ❌ Nenhuma carta selecionada para destaque roxo")
            else:
                print("DEBUG: [ESTADO] Gestão não estava ativa - verificando se End Turn deve estar enabled")
                
                # CORREÇÃO CRÍTICA: Se Final Phase está ativo mas gestão não está ativa,
                # significa que a gestão foi finalizada e End Turn deve estar enabled
                if self._final_phase_active and not gestao_ativa:
                    print("DEBUG: [ESTADO] ✅ Final Phase ativo sem gestão - ativando End Turn")
                    self.after(150, self._ativar_botao_end_turn)
                else:
                    print("DEBUG: [ESTADO] Final Phase não ativo - End Turn deve permanecer disabled")
        
        # Executar restauração após a interface estar pronta (delay menor para restauração rápida)
        def restore_and_cleanup():
            # PROTEÇÃO: Não executar se estivermos numa página especial
            if getattr(self, '_in_router_selection_page', False):
                print("DEBUG: [ESTADO] ⚠️ Restauração cancelada - estamos numa página de seleção de router")
                return
                
            restore_gestao_state()
            
            # LIMPEZA FINAL: Remover estado imediato após restauração completa
            print("DEBUG: [ESTADO] ✅ LIMPEZA FINAL: Removendo estado imediato após restauração completa")
            if hasattr(self, '_estado_botoes_imediato'):
                self._estado_botoes_imediato = None
                print("DEBUG: [ESTADO] ✅ Estado imediato limpo - sistema pronto para próxima captura")
        
        self.after(100, restore_and_cleanup)
    
    def debug_click_events(self, event=None):
        """Debug para clicks que não são processados"""
        print(f"DEBUG: [debug_click_events] Click detectado na coordenada: x={event.x if event else 'N/A'}, y={event.y if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Widget: {event.widget if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Estado da interface: widgets={len(self.winfo_children())}")
        return "break"  # Impede propagação do evento
    
    def add_starter_cards(self):
        """
        Função opcional para dar cartas iniciais ao jogador.
        Adicionado para demonstração das páginas de inventário.
        """
        print("DEBUG: [PlayerDashboard] Adicionando cartas iniciais de demonstração...")
        
        # Usar a detecção automática para Raspberry Pi e desenvolvimento local
        base_path = detect_player_inventory_base_dir()
        print(f"DEBUG: [add_starter_cards] Base path detectado: {base_path}")
        print(f"DEBUG: [add_starter_cards] Player color: {self.player_color}")
        
        # Exemplo: dar 2-3 cartas de cada tipo da cor do jogador
        card_types = {
            "users": "Users",
            "equipments": "Equipments", 
            "services": "Services",
            "activities": "Activities"
        }
        
        color_variants = []
        if self.player_color == "blue":
            color_variants = ["Blue", "blue", "BLUE"]
        elif self.player_color == "green": 
            color_variants = ["Green", "green", "GREEN"]
        elif self.player_color == "red":
            color_variants = ["Red", "red", "RED"]
        elif self.player_color == "yellow":
            color_variants = ["Yellow", "yellow", "YELLOW"]
        else:
            color_variants = ["Blue", "blue"]  # default
        
        for card_type, folder_name in card_types.items():
            print(f"DEBUG: [add_starter_cards] Processando tipo: {card_type} -> pasta: {folder_name}")
            cards_found = False
            for color_var in color_variants:
                # Tentar estrutura do desenvolvimento local: NetMaster/Users/Residential-level/Red/
                path1 = os.path.join(base_path, folder_name, "Residential-level", color_var)
                # Tentar estrutura do Raspberry Pi: /img/cartas/users/Residential-level/Red/
                path2 = os.path.join(base_path, card_type, "Residential-level", color_var)
                
                for path_attempt, path_name in [(path1, "estrutura local"), (path2, "estrutura Raspberry Pi")]:
                    print(f"DEBUG: [add_starter_cards] Tentando {path_name}: {path_attempt}")
                    print(f"DEBUG: [add_starter_cards] Caminho existe? {os.path.exists(path_attempt)}")
                    if os.path.exists(path_attempt):
                        try:
                            files_in_path = os.listdir(path_attempt)
                            print(f"DEBUG: [add_starter_cards] Arquivos encontrados: {files_in_path}")
                            card_files = [os.path.join(path_attempt, f) for f in files_in_path 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            print(f"DEBUG: [add_starter_cards] Arquivos de carta filtrados: {[os.path.basename(f) for f in card_files]}")
                            if card_files:
                                # ESPECIAL: Para Activities, adicionar especificamente Activity_10.png e Activity_8.png se disponíveis
                                if card_type == "activities":
                                    target_activities = ["Activity_10.png", "Activity_8.png"]
                                    activities_added = []
                                    
                                    for target_activity in target_activities:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_activity:
                                                self.inventario[card_type].append(card_file)
                                                activities_added.append(target_activity)
                                                print(f"DEBUG: [add_starter_cards] Activity ESPECÍFICA adicionada: {os.path.basename(card_file)}")
                                                break
                                    
                                    if not activities_added:
                                        print(f"DEBUG: [add_starter_cards] Nenhuma activity específica encontrada, adicionando activities padrão")
                                        # Adicionar 2-3 cartas de activities normais se nenhuma específica estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                elif card_type == "users":
                                    # ESPECIAL: Para Users, adicionar especificamente User_2, User_3 e User_4
                                    target_users = ["User_2.png", "User_3.png", "User_4.png"]
                                    users_added = []
                                    
                                    for target_user in target_users:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_user:
                                                self.inventario[card_type].append(card_file)
                                                users_added.append(target_user)
                                                print(f"DEBUG: [add_starter_cards] User ESPECÍFICO adicionado: {os.path.basename(card_file)}")
                                                break
                                    
                                    if not users_added:
                                        print(f"DEBUG: [add_starter_cards] Nenhum user específico encontrado, adicionando users padrão")
                                        # Adicionar 2-3 cartas de users normais se nenhum específico estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                elif card_type == "services":
                                    # ESPECIAL: Para Services, adicionar especificamente Service_5.png para testar expiração
                                    target_services = ["Service_5.png"]
                                    services_added = []
                                    
                                    for target_service in target_services:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_service:
                                                self.inventario[card_type].append(card_file)
                                                services_added.append(target_service)
                                                print(f"DEBUG: [add_starter_cards] Service ESPECÍFICO adicionado: {os.path.basename(card_file)} (TEMPORARY - 4 turnos)")
                                                break
                                    
                                    if not services_added:
                                        print(f"DEBUG: [add_starter_cards] Service_5.png não encontrado, adicionando services padrão")
                                        # Adicionar 2-3 cartas de services normais se Service_5 não estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                    else:
                                        # Adicionar também alguns services normais além do Service_5
                                        remaining_files = [f for f in card_files if os.path.basename(f) not in target_services]
                                        max_additional = min(2, len(remaining_files))
                                        for i in range(max_additional):
                                            self.inventario[card_type].append(remaining_files[i])
                                            print(f"DEBUG: [add_starter_cards] Service adicional adicionado: {os.path.basename(remaining_files[i])}")
                                else:
                                    # Para outros tipos de carta (equipments), usar comportamento normal
                                    max_cards = min(3, len(card_files))
                                    print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas de {card_type}")
                                    for i in range(max_cards):
                                        self.inventario[card_type].append(card_files[i])
                                        print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                cards_found = True
                                break
                            else:
                                print(f"DEBUG: [add_starter_cards] Nenhum arquivo de carta encontrado em {path_attempt}")
                        except Exception as e:
                            print(f"DEBUG: [add_starter_cards] Erro ao listar arquivos em {path_attempt}: {e}")
                            continue
                    else:
                        print(f"DEBUG: [add_starter_cards] Caminho não existe: {path_attempt}")
                
                if cards_found:
                    break
            
            if not cards_found:
                print(f"DEBUG: [add_starter_cards] NENHUMA ESTRUTURA FUNCIONOU para {card_type}")
        
        # Adicionar algumas cartas neutras (actions, events) + CHALLENGES ADICIONADAS ESPECIFICAMENTE
        print("DEBUG: [add_starter_cards] Processando cartas neutras...")
        neutral_types = {
            "challenges": "Challenges",  # ✅ CHALLENGES HABILITADAS - adicionar Challenge_3.png
            "actions": "Actions", 
            "events": "Events"
        }
        
        for card_type, folder_name in neutral_types.items():
            # Tentar estrutura do desenvolvimento local: NetMaster/Challenges/Residential-level/
            path1 = os.path.join(base_path, folder_name, "Residential-level")
            # Tentar estrutura do Raspberry Pi: /img/cartas/challenges/Residential-level/
            path2 = os.path.join(base_path, card_type, "Residential-level")
            
            print(f"DEBUG: [add_starter_cards] Processando tipo neutro: {card_type} -> pasta: {folder_name}")
            cards_found = False
            
            for path_attempt, path_name in [(path1, "estrutura local"), (path2, "estrutura Raspberry Pi")]:
                print(f"DEBUG: [add_starter_cards] Tentando {path_name}: {path_attempt}")
                print(f"DEBUG: [add_starter_cards] Caminho neutro existe? {os.path.exists(path_attempt)}")
                if os.path.exists(path_attempt):
                    try:
                        files_in_path = os.listdir(path_attempt)
                        print(f"DEBUG: [add_starter_cards] Arquivos neutros encontrados: {files_in_path}")
                        
                        # ESPECIAL: Para Actions, verificar explicitamente se Action_70.png existe
                        if card_type == "actions":
                            action_70_path = os.path.join(path_attempt, "Action_70.png")
                            print(f"DEBUG: [add_starter_cards] Verificação explícita Action_70.png em: {action_70_path}")
                            print(f"DEBUG: [add_starter_cards] Action_70.png existe? {os.path.exists(action_70_path)}")
                            if os.path.exists(action_70_path) and "Action_70.png" not in files_in_path:
                                print(f"DEBUG: [add_starter_cards] ⚠️ PROBLEMA: Action_70.png existe no filesystem mas não retornado por listdir!")
                                files_in_path.append("Action_70.png")  # Força a adição
                        
                        card_files = [os.path.join(path_attempt, f) for f in files_in_path 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        print(f"DEBUG: [add_starter_cards] Arquivos de carta neutros filtrados: {[os.path.basename(f) for f in card_files]}")
                        if card_files:
                            # Para actions e events, filtrar apenas cartas válidas para o jogador
                            # Para challenges, adicionar especificamente o Challenge_8.png solicitado
                            if card_type == "challenges":
                                # Adicionar especificamente apenas Challenge_3.png se estiver disponível
                                target_challenges = ["Challenge_3.png"]
                                valid_cards = []
                                
                                for target_challenge in target_challenges:
                                    for card_file in card_files:
                                        if os.path.basename(card_file) == target_challenge:
                                            valid_cards.append(card_file)
                                            print(f"DEBUG: [add_starter_cards] Challenge específico encontrado: {target_challenge}")
                                            break
                                
                                if not valid_cards:
                                    # Se Challenge_3 não estiver disponível, pegar o primeiro Challenge disponível
                                    valid_cards = card_files[:1] if card_files else []
                                    print(f"DEBUG: [add_starter_cards] Challenge_3 não encontrado, usando primeiro disponível: {[os.path.basename(f) for f in valid_cards]}")
                                
                                card_files = valid_cards
                                print(f"DEBUG: [add_starter_cards] Challenges selecionados para adicionar: {[os.path.basename(f) for f in card_files]}")
                                
                            elif card_type in ["actions", "events"] and hasattr(self, 'card_database') and self.card_database:
                                valid_cards = []
                                player_color = self.player_color.lower()
                                
                                for card_file in card_files:
                                    filename = os.path.basename(card_file)
                                    print(f"DEBUG: [add_starter_cards] Verificando arquivo {card_type}: {filename}")
                                    try:
                                        if card_type == "actions":
                                            # ESPECÍFICO: Incluir Action_70.png e Action_10.png
                                            if filename == "Action_70.png":
                                                valid_cards.append(card_file)
                                                print(f"DEBUG: [add_starter_cards] Action FORÇADA (Action_70): {filename}")
                                            elif filename == "Action_10.png":
                                                valid_cards.append(card_file)
                                                print(f"DEBUG: [add_starter_cards] Action FORÇADA (Action_10): {filename}")
                                            else:
                                                print(f"DEBUG: [add_starter_cards] Action IGNORADA (não é Action_70 nem Action_10): {filename}")
                                        elif card_type == "events":
                                            # Event_1.png -> event_1
                                            match = re.search(r'Event_(\d+)\.', filename)
                                            if match:
                                                # ESPECIAL: Incluir APENAS Event_55 e Event_14
                                                if filename == "Event_55.png":
                                                    valid_cards.append(card_file)
                                                    print(f"DEBUG: [add_starter_cards] Event FORÇADO (teste duration variável): {filename}")
                                                elif filename == "Event_14.png":
                                                    valid_cards.append(card_file)
                                                    print(f"DEBUG: [add_starter_cards] Event FORÇADO (Event_14): {filename}")
                                                else:
                                                    print(f"DEBUG: [add_starter_cards] Event IGNORADO (não é Event_55 nem Event_14): {filename}")
                                    except Exception as e:
                                        print(f"DEBUG: [add_starter_cards] Erro ao processar carta {filename}: {e}")
                                
                                card_files = valid_cards
                                print(f"DEBUG: [add_starter_cards] Cartas filtradas para {card_type}: {len(card_files)} válidas de {len(valid_cards)} totais")
                            
                            # Adicionar cartas ao inventário
                            if card_files:
                                if card_type == "events":
                                    max_cards = min(2, len(card_files))  # Máximo 2 events (Event_55 e Event_14)
                                elif card_type == "actions":
                                    max_cards = min(2, len(card_files))  # Máximo 2 actions (Action_70.png e Action_10.png)
                                elif card_type == "challenges":
                                    max_cards = min(1, len(card_files))  # Máximo 1 Challenge (Challenge_3.png)
                                else:
                                    max_cards = min(3, len(card_files))
                                
                                print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas neutras de {card_type}")
                                for i in range(max_cards):
                                    self.inventario[card_type].append(card_files[i])
                                    print(f"DEBUG: [PlayerDashboard] Carta inicial neutra adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                    
                                    # Se for uma carta Challenge, registrar no sistema de tracking
                                    if card_type == "challenges":
                                        carta_path = card_files[i]
                                        print(f"DEBUG: [add_starter_cards] Challenge adicionado ao inventário: {os.path.basename(carta_path)}")
                                        print(f"DEBUG: [add_starter_cards] ✅ Challenge estará disponível na página Activities/Challenges")
                                    
                                    # Se for uma carta Event, registrar o tracking de duração
                                    elif card_type == "events":
                                        current_turn = getattr(self, '_current_turn', 0)
                                        carta_path = card_files[i]
                                        
                                        # Obter duration_turns da carta
                                        from cards_database import get_event_duration
                                        duration_turns = get_event_duration(carta_path)
                                        print(f"DEBUG: [add_starter_cards] get_event_duration({os.path.basename(carta_path)}) returned: {duration_turns} (type: {type(duration_turns)})")
                                        if duration_turns is not None:
                                            # CORREÇÃO: Verificar se é duração variável
                                            if duration_turns == "variable":
                                                print(f"DEBUG: [add_starter_cards] Event {os.path.basename(carta_path)} detectado como duração VARIÁVEL")
                                                self._event_duration_tracking[carta_path] = {
                                                    'start_turn': current_turn,
                                                    'duration_turns': duration_turns,
                                                    'expires_turn': None  # Será definido após o dado
                                                }
                                                print(f"DEBUG: [add_starter_cards] Event tracking adicionado: {os.path.basename(carta_path)} - turno:{current_turn}, duração:{duration_turns} (variável), expira:A ser determinado")
                                            else:
                                                print(f"DEBUG: [add_starter_cards] Event {os.path.basename(carta_path)} detectado como duração FIXA: {duration_turns}")
                                                self._event_duration_tracking[carta_path] = {
                                                    'start_turn': current_turn,
                                                    'duration_turns': duration_turns,
                                                    'expires_turn': current_turn + duration_turns  # expira após duration_turns turnos
                                                }
                                                print(f"DEBUG: [add_starter_cards] Event tracking adicionado: {os.path.basename(carta_path)} - turno:{current_turn}, duração:{duration_turns}, expira:{current_turn + duration_turns}")
                                        else:
                                            print(f"DEBUG: [add_starter_cards] Duração não encontrada para Event: {os.path.basename(carta_path)}")
                            else:
                                print(f"DEBUG: [add_starter_cards] Nenhuma carta válida encontrada para {card_type} após filtragem")
                            cards_found = True
                            break
                        else:
                            print(f"DEBUG: [add_starter_cards] Nenhum arquivo de carta neutra encontrado em {path_attempt}")
                    except Exception as e:
                        print(f"DEBUG: [PlayerDashboard] Erro ao carregar carta inicial {card_type}: {e}")
                else:
                    print(f"DEBUG: [add_starter_cards] Caminho neutro não existe: {path_attempt}")
            
            if not cards_found:
                print(f"DEBUG: [add_starter_cards] NENHUMA ESTRUTURA NEUTRA FUNCIONOU para {card_type}")
        
        print(f"DEBUG: [PlayerDashboard] Resumo do inventário após cartas iniciais:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")
        
        # Verificar se temos Action_70.png e Action_10.png no inventário
        action_70_present = any("Action_70.png" in carta for carta in self.inventario.get("actions", []))
        action_10_present = any("Action_10.png" in carta for carta in self.inventario.get("actions", []))
        print(f"DEBUG: [PlayerDashboard] Action_70.png presente? {action_70_present}")
        print(f"DEBUG: [PlayerDashboard] Action_10.png presente? {action_10_present}")
        
        if action_70_present or action_10_present:
            print(f"DEBUG: [PlayerDashboard] ✅ Actions específicas encontradas! NÃO adicionando Actions extras")
            # Só garantir que há Events suficientes, mas não Actions extras
            current_actions = len(self.inventario.get("actions", []))
            self.add_more_action_event_cards(min_actions=current_actions, min_events=2)  # Manter actions atuais
        else:
            print(f"DEBUG: [PlayerDashboard] ⚠️ Actions específicas NÃO encontradas, adicionando Actions padrão")
            # Garantir que há cartas suficientes de Actions/Events  
            self.add_more_action_event_cards(min_actions=6, min_events=2)
        
        # Adicionar Equipment_2.png especificamente ao inventário
        base_path = detect_player_inventory_base_dir()
        
        # CORREÇÃO: Incluir a cor do jogador no caminho do Equipment_2.png
        player_color_capitalized = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        equipment_2_path = os.path.join(base_path, "Equipments", "Residential-level", player_color_capitalized, "Equipment_2.png")
        
        print(f"DEBUG: [PlayerDashboard] Tentando adicionar Equipment_2.png para cor {player_color_capitalized}")
        print(f"DEBUG: [PlayerDashboard] Caminho completo: {equipment_2_path}")
        
        # Verificar se o arquivo existe e adicionar ao inventário se não estiver já lá
        equipment_2_final_path = None
        if os.path.exists(equipment_2_path):
            if equipment_2_path not in self.inventario["equipments"]:
                self.inventario["equipments"].append(equipment_2_path)
                print(f"DEBUG: [PlayerDashboard] ✅ Equipment_2.png adicionada ao inventário: {equipment_2_path}")
                equipment_2_final_path = equipment_2_path
            else:
                print(f"DEBUG: [PlayerDashboard] Equipment_2.png já estava no inventário")
                equipment_2_final_path = equipment_2_path
        else:
            print(f"DEBUG: [PlayerDashboard] Equipment_2.png não encontrada em: {equipment_2_path}")
            # Fallback: tentar outros caminhos possíveis incluindo variações de cor
            fallback_paths = [
                os.path.join(base_path, "Equipments", "Residential-level", "Equipment_2.png"),  # Sem cor
                os.path.join(base_path, "equipments", "Residential-level", player_color_capitalized, "Equipment_2.png"),  # Minúscula
                os.path.join(os.path.dirname(__file__), "Equipments", "Residential-level", player_color_capitalized, "Equipment_2.png"),
                os.path.join(os.path.dirname(__file__), "equipments", "Residential-level", player_color_capitalized, "Equipment_2.png")
            ]
            
            for fallback_path in fallback_paths:
                print(f"DEBUG: [PlayerDashboard] Testando fallback: {fallback_path}")
                if os.path.exists(fallback_path):
                    if fallback_path not in self.inventario["equipments"]:
                        self.inventario["equipments"].append(fallback_path)
                        print(f"DEBUG: [PlayerDashboard] ✅ Equipment_2.png adicionada via fallback: {fallback_path}")
                        equipment_2_final_path = fallback_path
                        break
                    else:
                        print(f"DEBUG: [PlayerDashboard] Equipment_2.png já estava no inventário (fallback)")
                        equipment_2_final_path = fallback_path
                        break
        
        # Equipment_2.png adicionada ao inventário mas NÃO ativada automaticamente
        # O jogador deve ativar manualmente para usar REMOVE ROUTER
        if equipment_2_final_path:
            print(f"DEBUG: [PlayerDashboard] ✅ Equipment_2.png adicionada ao inventário: {os.path.basename(equipment_2_final_path)}")
            print(f"DEBUG: [PlayerDashboard] ⚠️ Equipment_2.png deve ser ativada manualmente para usar REMOVE ROUTER")
        else:
            print(f"DEBUG: [PlayerDashboard] ⚠️ Equipment_2.png não foi encontrada - REMOVE ROUTER não funcionará")
    
    def _get_card_message_size(self, carta_path):
        """
        Extrai o message_size de uma carta Activity ou Challenge usando a base de dados
        """
        try:
            if not self.card_database:
                print("DEBUG: Base de dados não está disponível")
                return 0
            
            # Tentar determinar se é Activity ou Challenge pelo nome do arquivo
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: Analisando carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair ID da carta Activity
                # Assumindo formato Activity_X.png onde X é o número
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    # Usar o formato correto da base de dados: activity_X_cor
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        print(f"DEBUG: Found activity {activity_id} with message_size: {activity_card.message_size}")
                        return activity_card.message_size
                    else:
                        print(f"DEBUG: Activity {activity_id} não encontrada na base de dados")
                            
            elif "challenge" in carta_basename:
                # Extrair ID da carta Challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        print(f"DEBUG: Found challenge {challenge_id} with message_size: {challenge_card.message_size}")
                        return challenge_card.message_size
                    else:
                        print(f"DEBUG: Challenge {challenge_id} não encontrada na base de dados")
            
            print(f"DEBUG: Could not find message_size for card: {carta_basename}")
            return 0
            
        except Exception as e:
            print(f"DEBUG: Error getting message_size for {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def _get_card_message_size_from_database(self, carta_path):
        """
        CORREÇÃO 2: Função dedicada para obter message_size sempre da base de dados
        Garante que os valores são sempre obtidos da base de dados integrada
        """
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print("DEBUG: [DATABASE] Base de dados não está disponível")
                return 20  # fallback padrão
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [DATABASE] Analisando carta para message_size: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair número da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [DATABASE] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        message_size = getattr(activity_card, 'message_size', 20)
                        print(f"DEBUG: [DATABASE] Activity {activity_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Activity {activity_id} não encontrada")
            
            elif "challenge" in carta_basename:
                # Extrair número do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [DATABASE] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        message_size = getattr(challenge_card, 'message_size', 25)
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} não encontrado")
            
            print(f"DEBUG: [DATABASE] Usando fallback para carta: {carta_basename}")
            return 20  # fallback padrão
            
        except Exception as e:
            print(f"DEBUG: [DATABASE] Erro ao obter message_size para {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 20  # fallback em caso de erro
    
    def _select_carousel_card(self, card_index, carta_path):
        """
        Seleciona uma carta no carrossel (primeiro clique) ou abre fullscreen (segundo clique)
        """
        print(f"DEBUG: ===== _select_carousel_card CHAMADA =====")
        print(f"DEBUG: card_index={card_index}, carta_path={os.path.basename(carta_path)}")
        
        # CORREÇÃO CRÍTICA: Verificar bloqueio temporário após clique no botão seta
        if getattr(self, '_bloqueio_temporario_carrossel', False):
            print("DEBUG: ❌ Clique bloqueado temporariamente após botão seta - evitando fullscreen acidental")
            return
        
        # CORREÇÃO: Verificar se estamos em Final Phase com gestão de pacotes ativa
        # APENAS bloquear se estivermos em gestão ativa, não em qualquer Final Phase
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        print(f"DEBUG: Estado atual - gestao_pacotes_ativa: {gestao_pacotes_ativa}, final_phase_normal: {final_phase_normal}")
        
        if gestao_pacotes_ativa:
            print("DEBUG: Gestão de pacotes ativa - verificando se carta tem destaque roxo")
            
            # Só permitir clique na carta que tem destaque roxo
            if hasattr(self, '_carta_destacada_posicao') and self._carta_destacada_posicao == card_index:
                print("DEBUG: Clique permitido - carta tem destaque roxo")
                
                # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DO FULLSCREEN
                self._capturar_estado_botoes_imediato()
                
                # Permitir apenas fullscreen da carta destacada
                self.show_card_fullscreen_carrossel(carta_path)
                return
            else:
                print("DEBUG: Clique bloqueado - carta não tem destaque roxo")
                return
        
        # Verificar se é uma carta virada para baixo (não pode ser selecionada)
        if os.path.basename(carta_path).startswith("back_card_"):
            print(f"DEBUG: Carta virada para baixo não pode ser selecionada")
            return
        
        # CORREÇÃO: Permitir cliques normais em Final Phase (quando não está em gestão de pacotes)
        # Só verificar Next Phase se realmente estiver ativo
        if getattr(self, '_next_phase_active', False) and not final_phase_normal:
            if not self._can_access_carousel_position(card_index):
                print(f"DEBUG: Clique bloqueado - sem permissão durante Next Phase para posição {card_index}")
                return
        
        # Verificar se é Activity ou Challenge
        carta_basename = os.path.basename(carta_path).lower()
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: Carta {carta_basename} não é Activity nem Challenge")
            return
        
        # Se clicar na mesma carta já selecionada, abrir fullscreen
        if (self.selected_carousel_index == card_index and 
            self.selected_carousel_card == carta_path):
            print(f"DEBUG: Segundo clique na carta {card_index} - abrindo fullscreen")
            
            # CORREÇÃO CRÍTICA: Detectar estado dos botões IMEDIATAMENTE antes do fullscreen
            print("DEBUG: [ESTADO] === DETECÇÃO IMEDIATA DOS BOTÕES ===")
            estado_imediato = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            # Detectar estado atual dos botões AGORA
            if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                try:
                    if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                        estado_imediato['btn_plus_rxd_visivel'] = True
                        print("DEBUG: [ESTADO] ✅ Botão + Rxd DETECTADO como visível")
                except:
                    pass
            
            if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                try:
                    if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                        estado_imediato['btn_plus_lost_visivel'] = True
                        print("DEBUG: [ESTADO] ✅ Botão + Lost DETECTADO como visível")
                except:
                    pass
            
            if hasattr(self, '_btn_seta') and self._btn_seta:
                try:
                    if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                        estado_imediato['btn_seta_visivel'] = True
                        print("DEBUG: [ESTADO] ✅ Botão seta DETECTADO como visível")
                except:
                    pass
            
            print(f"DEBUG: [ESTADO] RESULTADO DETECÇÃO IMEDIATA:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {estado_imediato['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {estado_imediato['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {estado_imediato['btn_seta_visivel']}")
            
            # Salvar o estado detectado IMEDIATAMENTE
            self._estado_botoes_imediato = estado_imediato
            
            # CORREÇÃO CRÍTICA: Salvar estado da dashboard antes de abrir fullscreen
            self._save_dashboard_state()
            self.show_card_fullscreen_carrossel(carta_path)
            return
        
        # Primeiro clique: selecionar carta
        print(f"DEBUG: Primeiro clique - Selecionando carta {card_index}: {os.path.basename(carta_path)}")
        
        # Atualizar seleção
        self.selected_carousel_card = carta_path
        self.selected_carousel_index = card_index
        
        # Atualizar destaques visuais
        print(f"DEBUG: Atualizando destaques visuais...")
        self._update_carousel_selection_highlights()
        
        # CORREÇÃO: Verificar se há valores preservados para esta carta antes de atualizar barras
        print(f"DEBUG: ===== VERIFICANDO VALORES PRESERVADOS =====")
        carta_index_in_carrossel = card_index
        if carta_index_in_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[carta_index_in_carrossel]
            print(f"DEBUG: Stats preservadas para carta {carta_index_in_carrossel}: {preserved_stats}")
            
            # CORREÇÃO PROBLEMA 1: SEMPRE atualizar barras diretamente da base de dados primeiro
            # Depois aplicar valores preservados apenas se diferentes de zero
            print(f"DEBUG: 🔄 ATUALIZANDO BARRAS DA BASE DE DADOS - ANTES FINAL PHASE")
            self._update_progress_bars_from_card(carta_path)
            
            # NOVA LÓGICA: Aplicar valores preservados apenas se diferentes dos defaults
            message_size = self._get_card_message_size_from_database(carta_path)
            rxd_preservado = preserved_stats.get('Rxd', 0)
            lost_preservado = preserved_stats.get('Lost', 0)
            to_send_preservado = preserved_stats.get('To send', message_size)
            
            # Se valores preservados diferem dos defaults da base de dados, aplicar
            if rxd_preservado > 0 or lost_preservado > 0 or to_send_preservado != message_size:
                print(f"DEBUG: 📊 APLICANDO VALORES PRESERVADOS - ANTES FINAL PHASE")
                self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_path)
            else:
                print(f"DEBUG: ✅ VALORES PRESERVADOS SÃO DEFAULTS - MANTENDO BASE DE DADOS")
        else:
            print(f"DEBUG: ⚠️ Índice {carta_index_in_carrossel} fora do range de card_stats")
            print(f"DEBUG: 🔄 ATUALIZANDO BARRAS DIRETAMENTE DA BASE DE DADOS")
            self._update_progress_bars_from_card(carta_path)
        
        print(f"DEBUG: ===== FIM _select_carousel_card =====\n")
    
    def _update_carousel_selection_highlights(self):
        """
        Atualiza os destaques das cartas no carrossel baseado na seleção atual
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: ⚠️ card_labels não existe ou está vazio - pulando atualização de destaques")
            return
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights INICIADA =====")
        print(f"DEBUG: selected_carousel_index: {getattr(self, 'selected_carousel_index', None)}")
        print(f"DEBUG: _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        print(f"DEBUG: _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        
        # CORREÇÃO CRÍTICA: Verificar se todos os widgets estão válidos ANTES de processar
        widgets_destruidos = 0
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: ⚠️ Widget carta {i} foi destruído, pulando configuração")
                    widgets_destruidos += 1
                    continue
            except tk.TclError:
                print(f"DEBUG: ⚠️ Widget carta {i} não é válido (TclError), pulando configuração")
                widgets_destruidos += 1
                continue
        
        # Se muitos widgets foram destruídos, cancelar atualização
        if widgets_destruidos >= len(self.card_labels) // 2:
            print(f"DEBUG: ⚠️ Muitos widgets destruídos ({widgets_destruidos}/{len(self.card_labels)}) - cancelando atualização")
            print(f"DEBUG: ===== _update_carousel_selection_highlights CANCELADA =====\n")
            return
        
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # CORREÇÃO: Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: ⚠️ Widget carta {i} foi destruído, pulando configuração")
                    continue
            except tk.TclError:
                print(f"DEBUG: ⚠️ Widget carta {i} não é válido (TclError), pulando configuração")
                continue
            
            carta_path = self.cards[i]
            is_back_card = os.path.basename(carta_path).startswith("back_card_")
            next_phase_active = getattr(self, '_next_phase_active', False)
            final_phase_active = getattr(self, '_final_phase_active', False)
            gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            
            # CORREÇÃO: Lógica de destaques mais clara e específica
            highlight_color = "black"
            border_width = 0
            border_color = "black"
            
            # PRIORIDADE 1: Gestão de pacotes (destaque roxo específico) - PRIORIDADE MÁXIMA
            if gestao_pacotes_ativa:
                # CORREÇÃO CRÍTICA: Usar selected_carousel_index como fonte da verdade durante gestão
                # Em vez de confiar apenas em _carta_atual_gestao, usar a posição realmente selecionada
                posicao_gestao_atual = getattr(self, 'selected_carousel_index', None)
                
                # VALIDAÇÃO DUPLA: Verificar também _carta_atual_gestao como backup
                carta_atual_gestao = getattr(self, '_carta_atual_gestao', None)
                
                # Se não temos posição selecionada mas temos gestão ativa, usar a gestão
                if posicao_gestao_atual is None and carta_atual_gestao is not None:
                    if hasattr(self, '_cartas_gestao') and carta_atual_gestao < len(self._cartas_gestao):
                        carta_path_atual = self._cartas_gestao[carta_atual_gestao]
                        # Encontrar posição desta carta no carrossel
                        for idx, carta in enumerate(self.cards):
                            if carta == carta_path_atual:
                                posicao_gestao_atual = idx
                                print(f"DEBUG: Carta gestão encontrada na posição {idx}: {os.path.basename(carta_path_atual)}")
                                break
                
                # APLICAR DESTAQUE: Apenas a posição selecionada/atual deve ter destaque roxo
                if posicao_gestao_atual is not None and i == posicao_gestao_atual:
                    # VERIFICAÇÃO ADICIONAL: Garantir que a carta não é back_card
                    carta_na_posicao = self.cards[i] if i < len(self.cards) else None
                    if carta_na_posicao:
                        carta_basename = os.path.basename(carta_na_posicao).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            highlight_color = "#800080"  # Roxo
                            border_width = 3
                            border_color = "#800080"
                            print(f"DEBUG: Carta {i} - destaque ROXO (gestão de pacotes ativa) - carta atual: {os.path.basename(carta_na_posicao)}")
                        else:
                            highlight_color = "black"
                            border_width = 0
                            border_color = "black"
                            print(f"DEBUG: Carta {i} - sem destaque (gestão ativa mas carta inválida: {carta_basename})")
                    else:
                        highlight_color = "black"
                        border_width = 0
                        border_color = "black"
                        print(f"DEBUG: Carta {i} - sem destaque (gestão ativa mas carta não encontrada)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (gestão de pacotes ativa, não é carta atual)")
            
            # PRIORIDADE 2: Final Phase normal (sem gestão de pacotes)
            elif final_phase_active and not gestao_pacotes_ativa:
                # CORREÇÃO CRÍTICA: Durante Final Phase SEM gestão ativa, NÃO aplicar QUALQUER destaque
                # Após finalizar gestão de pacotes, limpar TODOS os destaques
                # As cartas devem voltar ao estado visual normal (sem destaque)
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - SEM DESTAQUE (Final Phase, gestão finalizada - limpeza completa)")
                
                # CORREÇÃO CRÍTICA: NÃO limpar selected_carousel_index durante Final Phase
                # O índice deve ser preservado para permitir navegação e gestão de pacotes
                # Removida a limpeza automática do selected_carousel_index
            
            # PRIORIDADE 3: Next Phase (cartas viradas para baixo com destaque roxo)
            elif next_phase_active and is_back_card:
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"
                    print(f"DEBUG: Carta {i} - destaque ROXO (Next Phase, pode selecionar)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (Next Phase, não pode selecionar)")
            
            # PRIORIDADE 4: Estado normal (destaque da cor do jogador)
            elif i == self.selected_carousel_index and not is_back_card:
                highlight_color = self.bar_color
                border_width = 3
                border_color = self.player_color.lower()
                print(f"DEBUG: Carta {i} - destaque COR DO JOGADOR (estado normal)")
            
            # PRIORIDADE 5: Sem destaque
            else:
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - sem destaque (estado normal)")
            
            try:
                lbl.config(bg=highlight_color, borderwidth=border_width, relief="solid" if border_width > 0 else "flat",
                          highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
                print(f"DEBUG: ✅ Carta {i} configurada: bg={highlight_color}, border={border_width}")
            except tk.TclError as e:
                print(f"DEBUG: ❌ Widget carta {i} inválido (TclError): {e}")
                continue
            except Exception as e:
                print(f"DEBUG: ❌ Erro ao configurar carta {i}: {e}")
                continue
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights TERMINADA =====\n")
    
    def _update_progress_bars_from_card(self, carta_path):
        """
        Atualiza as barras de progresso com base nos dados da carta selecionada
        CORREÇÃO: Considera valores preservados para comportamento dinâmico correto
        """
        try:
            print(f"DEBUG: ===== 🔄 _update_progress_bars_from_card INICIADA =====")
            print(f"DEBUG: 📋 Carta selecionada: {os.path.basename(carta_path)}")
            print(f"DEBUG: 🎯 CONTEXTO: Atualizando barras ANTES do Final Phase (comportamento dinâmico)")
            
            # Verificar se as barras de progresso estão inicializadas
            print(f"DEBUG: Verificando inicialização...")
            print(f"DEBUG: hasattr(self, 'progress_bars'): {hasattr(self, 'progress_bars')}")
            print(f"DEBUG: hasattr(self, 'progress_labels'): {hasattr(self, 'progress_labels')}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ❌ Barras de progresso não inicializadas")
                return
                
            print(f"DEBUG: ✅ Barras de progresso inicializadas")
            print(f"DEBUG: progress_bars keys: {list(self.progress_bars.keys())}")
            print(f"DEBUG: progress_labels keys: {list(self.progress_labels.keys())}")
                
            # Obter message_size da base de dados
            print(f"DEBUG: Extraindo message_size da base de dados...")
            message_size = self._get_card_message_size_from_database(carta_path)
            print(f"DEBUG: 📊 Message size extraído da base de dados: {message_size}")
            
            # CORREÇÃO CRÍTICA: Verificar se existem valores preservados para esta carta
            carta_idx = None
            if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                carta_idx = self.selected_carousel_index
            elif hasattr(self, 'cards') and self.cards:
                # Procurar o índice da carta no carrossel
                for i, carta_carrossel in enumerate(self.cards):
                    if carta_carrossel and os.path.basename(carta_carrossel) == os.path.basename(carta_path):
                        carta_idx = i
                        break
            
            # Verificar se existem valores preservados
            preserved_stats = None
            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats)):
                preserved_stats = self.card_stats[carta_idx]
                print(f"DEBUG: 📊 VALORES PRESERVADOS ENCONTRADOS para carta {carta_idx}: {preserved_stats}")
            else:
                print(f"DEBUG: 📊 Nenhum valor preservado encontrado - usando valores padrão")
                print(f"DEBUG: 📊 Debug info: carta_idx={carta_idx}, card_stats_len={len(getattr(self, 'card_stats', []))}")
            
            # Verificar se "To send" existe nas barras
            if "To send" not in self.progress_bars:
                print("DEBUG: ❌ 'To send' não encontrado em progress_bars")
                return
                
            if "To send" not in self.progress_labels:
                print("DEBUG: ❌ 'To send' não encontrado em progress_labels")
                return
            
            print(f"DEBUG: ✅ 'To send' encontrado em ambas as estruturas")
            
            # Configurar barra "To send"
            try:
                print(f"DEBUG: Atualizando barras de progresso...")
                
                # CORREÇÃO: Definir o message_size como máximo para TODAS as barras (To send, Rxd, Lost)
                # Isso garante precisão visual - barras com mesmo valor ficarão alinhadas
                for bar_name in ["To send", "Rxd", "Lost"]:
                    if bar_name in self.progress_bars:
                        self.progress_bars[bar_name]["maximum"] = message_size
                        print(f"DEBUG: ✅ Máximo da barra '{bar_name}' definido para {message_size}")
                
                # CORREÇÃO: Usar valores preservados se disponíveis, senão usar valor padrão
                if preserved_stats and 'To send' in preserved_stats:
                    to_send_value = preserved_stats['To send']
                    print(f"DEBUG: 📊 USANDO VALOR PRESERVADO para To send: {to_send_value}")
                else:
                    to_send_value = message_size  # Valor padrão (barra cheia)
                    print(f"DEBUG: 📊 USANDO VALOR PADRÃO para To send: {to_send_value}")
                
                # Configurar valor da barra To send
                self.progress_bars["To send"]["value"] = to_send_value
                self.progress_labels["To send"]["text"] = str(to_send_value)
                
                print(f"DEBUG: ✅ Barra 'To send' configurada:")
                print(f"DEBUG:   - Máximo: {message_size}")
                print(f"DEBUG:   - Valor: {to_send_value}")
                print(f"DEBUG:   - Label: '{to_send_value}'")
                
                # CORREÇÃO: Atualizar todas as outras barras (Rxd e Lost) com mesmo máximo e valores preservados
                for bar_name in ['Rxd', 'Lost']:
                    if bar_name in self.progress_bars and bar_name in self.progress_labels:
                        # IMPORTANTE: As barras já foram configuradas com maximum=message_size acima
                        if preserved_stats and bar_name in preserved_stats:
                            # Usar valor preservado
                            preserved_value = preserved_stats[bar_name]
                            self.progress_bars[bar_name]["value"] = preserved_value
                            self.progress_labels[bar_name]["text"] = str(preserved_value)
                            print(f"DEBUG: ✅ {bar_name} atualizada com valor preservado: {preserved_value} (máx: {message_size})")
                        else:
                            # NOVO: Usar valor padrão (buscar no card_stats se disponível)
                            carta_idx = getattr(self, 'selected_carousel_index', None)
                            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats) and
                                bar_name in self.card_stats[carta_idx]):
                                # Usar valor atual do card_stats se disponível
                                current_value = self.card_stats[carta_idx][bar_name]
                                self.progress_bars[bar_name]["value"] = current_value
                                self.progress_labels[bar_name]["text"] = str(current_value)
                                print(f"DEBUG: ✅ {bar_name} atualizada com valor do card_stats: {current_value} (máx: {message_size})")
                            else:
                                # Último recurso: valor padrão 0
                                self.progress_bars[bar_name]["value"] = 0
                                self.progress_labels[bar_name]["text"] = "0"
                                print(f"DEBUG: ✅ {bar_name} atualizada com valor padrão: 0 (máx: {message_size})")
                
                # Forçar atualização visual
                try:
                    for stat_name in ["To send", "Rxd", "Lost"]:
                        if stat_name in self.progress_bars:
                            widget = self.progress_bars[stat_name]
                            widget.update_idletasks()
                            widget.update()
                        if stat_name in self.progress_labels:
                            widget = self.progress_labels[stat_name]
                            widget.update_idletasks()
                            widget.update()
                    
                    # Forçar atualização da janela principal e master
                    self.update_idletasks()
                    self.update()
                    
                    if hasattr(self, 'master') and self.master:
                        self.master.update_idletasks()
                        self.master.update()
                    
                    self.after_idle(lambda: self._force_visual_refresh())
                    print(f"DEBUG: ✅ Atualização visual completa realizada")
                    
                except Exception as visual_error:
                    print(f"DEBUG: ⚠️ Erro durante atualização visual: {visual_error}")
                
                # Verificação final
                final_value = self.progress_bars["To send"]["value"]
                final_max = self.progress_bars["To send"]["maximum"]
                final_label = self.progress_labels["To send"]["text"]
                print(f"DEBUG: ===== VERIFICAÇÃO FINAL =====")
                print(f"DEBUG: Máximo final da barra: {final_max}")
                print(f"DEBUG: Valor final da barra: {final_value}")
                print(f"DEBUG: Texto final do label: '{final_label}'")
                print(f"DEBUG: Percentagem da barra: {(final_value/final_max)*100:.1f}%")
                print(f"DEBUG: ✅ SUCESSO - Barra configurada com valores {'preservados' if preserved_stats else 'padrão'}!")
                
            except Exception as update_error:
                print(f"DEBUG: ❌ Erro ao configurar progress bar: {update_error}")
                import traceback
                traceback.print_exc()
            
        except Exception as e:
            print(f"DEBUG: ❌ Erro geral ao atualizar barras de progresso: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: ===== _update_progress_bars_from_card TERMINADA =====\n")

    def _force_visual_refresh(self):
        """
        Força um refresh visual adicional das barras de progresso
        """
        try:
            print("DEBUG: 🔄 _force_visual_refresh executando...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if (hasattr(self, 'progress_bars') and stat_name in self.progress_bars and
                    hasattr(self, 'progress_labels') and stat_name in self.progress_labels):
                    
                    # Forçar redesenho dos widgets
                    self.progress_bars[stat_name].update()
                    self.progress_labels[stat_name].update()
            
            self.update()
            print("DEBUG: ✅ _force_visual_refresh concluído")
        except Exception as e:
            print(f"DEBUG: ⚠️ Erro em _force_visual_refresh: {e}")

    def _apply_preserved_stats_to_progress_bars(self, preserved_stats, carta_path=None):
        """
        Aplica estatísticas preservadas diretamente às barras de progresso
        CORREÇÃO FUNDAMENTAL: Sempre usar a carta que está na posição do carrossel
        """
        try:
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars INICIADA =====")
            print(f"DEBUG: Aplicando stats preservadas: {preserved_stats}")
            print(f"DEBUG: Carta parametro: {os.path.basename(carta_path) if carta_path else 'N/A'}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ❌ Barras de progresso não inicializadas")
                return
            
            # CORREÇÃO CRÍTICA: SEMPRE usar a carta que está realmente no carrossel
            carta_real_para_valores = None
            if (hasattr(self, 'selected_carousel_index') and 
                self.selected_carousel_index is not None and 
                hasattr(self, 'cards') and self.cards):
                
                carrossel_index = self.selected_carousel_index
                if carrossel_index < len(self.cards):
                    carta_real_para_valores = self.cards[carrossel_index]
                    carta_nome = os.path.basename(carta_real_para_valores)
                    
                    print(f"DEBUG: ⚠️ IMPORTANTE - Carta REAL no carrossel posição {carrossel_index}: {carta_nome}")
                    print(f"DEBUG: ⚠️ IMPORTANTE - Aplicando valores À CARTA DO CARROSSEL, não à preservada")
                    
                    # Obter message_size da carta que está REALMENTE no carrossel
                    correct_message_size = self._get_card_message_size_from_database(carta_real_para_valores)
                    print(f"DEBUG: Message size da carta REAL do carrossel: {correct_message_size}")
                else:
                    print(f"DEBUG: ⚠️ Índice carrossel inválido: {carrossel_index}")
                    carta_real_para_valores = carta_path
                    correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
            else:
                # Fallback para carta_path se não há carrossel válido
                carta_real_para_valores = carta_path
                correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
                print(f"DEBUG: ⚠️ Sem seleção carrossel válida, usando carta_path fallback")
            
            print(f"DEBUG: DEFINITIVO - Carta para aplicar valores: {os.path.basename(carta_real_para_valores) if carta_real_para_valores else 'N/A'}")
            print(f"DEBUG: DEFINITIVO - Message size: {correct_message_size}")
            
            # CORREÇÃO PROBLEMA 1: Verificar se os valores preservados são zeros inválidos
            to_send_preservado = preserved_stats.get("To send", 0)
            rxd_preservado = preserved_stats.get("Rxd", 0)
            lost_preservado = preserved_stats.get("Lost", 0)
            
            # Se To send preservado é 0, verificar se há message_size válido na barra atual
            if to_send_preservado == 0 and "To send" in self.progress_bars:
                current_max = self.progress_bars["To send"]["maximum"]
                current_value = self.progress_bars["To send"]["value"]
                
                print(f"DEBUG: CORREÇÃO PROBLEMA 1 - To send preservado é 0")
                print(f"DEBUG: Máximo atual da barra: {current_max}, Valor atual: {current_value}")
                
                # Se a barra já tem um valor válido da base de dados, não sobrescrever com zero
                if current_max > 0 and current_value > 0:
                    print(f"DEBUG: ✅ CORREÇÃO - Mantendo valor atual {current_value} em vez de aplicar 0")
                    # Não aplicar o To send=0, manter o valor atual
                    preserved_stats = preserved_stats.copy()
                    preserved_stats["To send"] = current_value
                    print(f"DEBUG: Stats corrigidas: {preserved_stats}")
            
            # Aplicar cada valor preservado (possivelmente corrigido)
            for stat_name, value in preserved_stats.items():
                if stat_name in self.progress_bars and stat_name in self.progress_labels:
                    try:
                        # CORREÇÃO: Para TODAS as barras, usar o message_size correto da carta atual como máximo
                        # Isso garante precisão visual - barras com mesmo valor ficam alinhadas
                        if correct_message_size is not None:
                            # Primeiro definir o máximo correto para TODAS as barras
                            self.progress_bars[stat_name]["maximum"] = correct_message_size
                            print(f"DEBUG: ✅ Máximo da barra '{stat_name}' corrigido para carta REAL: {correct_message_size}")
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, máximo={correct_message_size}")
                        else:
                            # Fallback para máximo atual
                            current_max = self.progress_bars[stat_name]["maximum"]
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, máximo={current_max} (fallback)")
                        
                        # Aplicar valores
                        self.progress_bars[stat_name]["value"] = value
                        self.progress_labels[stat_name]["text"] = str(value)
                        
                        # Forçar atualização
                        self.progress_bars[stat_name].update()
                        self.progress_labels[stat_name].update()
                        
                        print(f"DEBUG: ✅ {stat_name} aplicado com sucesso: {value}")
                    except Exception as e:
                        print(f"DEBUG: ❌ Erro ao aplicar {stat_name}: {e}")
                else:
                    print(f"DEBUG: ⚠️ {stat_name} não encontrado nas barras de progresso")
            
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars TERMINADA =====")
            
            # CORREÇÃO: Forçar atualização visual após aplicar valores preservados
            print(f"DEBUG: Forçando atualização visual após aplicar valores preservados...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    self.progress_bars[stat_name].update_idletasks()
                    self.progress_bars[stat_name].update()
                if stat_name in self.progress_labels:
                    self.progress_labels[stat_name].update_idletasks()
                    self.progress_labels[stat_name].update()
            
            # Forçar atualização da janela principal
            self.update_idletasks()
            print(f"DEBUG: ✅ Atualização visual de valores preservados realizada")
            
        except Exception as e:
            print(f"DEBUG: ❌ Erro geral em _apply_preserved_stats_to_progress_bars: {e}")
            import traceback
            traceback.print_exc()

    def _sync_card_stats_with_progress_bars(self):
        """
        Sincroniza os valores atuais das barras de progresso com card_stats
        Deve ser chamado sempre que as barras são modificadas
        """
        try:
            if (not hasattr(self, 'selected_carousel_index') or 
                self.selected_carousel_index is None or
                not hasattr(self, 'progress_bars') or 
                not hasattr(self, 'progress_labels')):
                return
            
            carta_index = self.selected_carousel_index
            if carta_index >= len(self.card_stats):
                return
            
            print(f"DEBUG: Sincronizando card_stats[{carta_index}] com barras de progresso")
            
            # Capturar valores atuais das barras
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    current_value = self.progress_bars[stat_name]["value"]
                    old_value = self.card_stats[carta_index][stat_name]
                    
                    # Atualizar card_stats
                    self.card_stats[carta_index][stat_name] = current_value
                    
                    print(f"DEBUG: {stat_name}: {old_value} -> {current_value}")
            
            print(f"DEBUG: ✅ card_stats[{carta_index}] sincronizado: {self.card_stats[carta_index]}")
            
        except Exception as e:
            print(f"DEBUG: ❌ Erro ao sincronizar card_stats: {e}")
            import traceback
            traceback.print_exc()

    def decrement_to_send_progress(self, packets_sent=1):
        """
        Decrementa a barra 'To send' quando pacotes são enviados.
        Esta função deve ser chamada pelo sistema de jogo quando pacotes são efetivamente enviados.
        
        Args:
            packets_sent (int): Número de pacotes enviados (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "To send" not in self.progress_bars:
                print("DEBUG: Barra 'To send' não disponível para decremento")
                return
            
            current_value = self.progress_bars["To send"]["value"]
            new_value = max(0, current_value - packets_sent)  # Não pode ser negativo
            
            print(f"DEBUG: Decrementando 'To send': {current_value} - {packets_sent} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["To send"]["value"] = new_value
            self.progress_labels["To send"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["To send"].update()
            self.progress_labels["To send"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            # Verificar se todos os pacotes foram enviados
            if new_value == 0:
                print("DEBUG: ✅ Todos os pacotes da mensagem foram enviados! Barra vazia.")
            else:
                percentage = (new_value / self.progress_bars["To send"]["maximum"]) * 100
                print(f"DEBUG: Restam {new_value} pacotes para enviar ({percentage:.1f}% da barra)")
                
        except Exception as e:
            print(f"DEBUG: Erro ao decrementar barra 'To send': {e}")
            import traceback
            traceback.print_exc()

    def increment_rxd_progress(self, packets_received=1):
        """
        Incrementa a barra 'Rxd' quando pacotes são recebidos.
        
        Args:
            packets_received (int): Número de pacotes recebidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Rxd" not in self.progress_bars:
                print("DEBUG: Barra 'Rxd' não disponível para incremento")
                return
            
            current_value = self.progress_bars["Rxd"]["value"]
            new_value = current_value + packets_received
            
            print(f"DEBUG: Incrementando 'Rxd': {current_value} + {packets_received} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Rxd"]["value"] = new_value
            self.progress_labels["Rxd"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["Rxd"].update()
            self.progress_labels["Rxd"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            print(f"DEBUG: ✅ 'Rxd' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Rxd': {e}")
            import traceback
            traceback.print_exc()

    def increment_lost_progress(self, packets_lost=1):
        """
        Incrementa a barra 'Lost' quando pacotes são perdidos.
        
        Args:
            packets_lost (int): Número de pacotes perdidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Lost" not in self.progress_bars:
                print("DEBUG: Barra 'Lost' não disponível para incremento")
                return
            
            current_value = self.progress_bars["Lost"]["value"]
            new_value = current_value + packets_lost
            
            print(f"DEBUG: Incrementando 'Lost': {current_value} + {packets_lost} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Lost"]["value"] = new_value
            self.progress_labels["Lost"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["Lost"].update()
            self.progress_labels["Lost"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            print(f"DEBUG: ✅ 'Lost' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Lost': {e}")
            import traceback
            traceback.print_exc()

    def _extrair_valor_venda_carta(self, carta_path):
        """
        Extrai o valor de venda da carta usando a base de dados integrada
        Similar ao _extrair_valor_carta do Store_v2.py mas retorna sell_cost
        """
        # CORREÇÃO: Verificação adicional para garantir que Services sempre retornam 0
        path_lower = carta_path.lower()
        nome = os.path.basename(carta_path)
        if "/services/" in path_lower or "service_" in nome.lower():
            print(f"DEBUG: Service detectada - forçando valor de venda 0: {nome}")
            return 0
        
        if not self.card_database:
            print("DEBUG: Base de dados não disponível, usando extração por nome de arquivo")
            return self._extrair_valor_fallback(carta_path)
        
        try:
            # Determinar tipo da carta pelo caminho
            carta_tipo = self._get_card_type_from_path(carta_path)
            if not carta_tipo:
                print(f"DEBUG: Tipo de carta não identificado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Mapear arquivo para ID da base de dados
            card_id = self._map_file_to_card_id(carta_path, carta_tipo)
            if not card_id:
                print(f"DEBUG: ID da carta não mapeado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Obter carta da base de dados
            if carta_tipo == "users":
                card = self.card_database.get_user(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "equipments":
                card = self.card_database.get_equipment(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "services":
                card = self.card_database.get_service(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "activities":
                card = self.card_database.get_activity(card_id)
                valor = card.sell_cost if card else None  # Activities têm sell_cost = 0
            elif carta_tipo == "actions":
                card = self.card_database.get_action(card_id)
                valor = 0 if card else None  # Actions não podem ser vendidas
            else:
                print(f"DEBUG: Tipo de carta não suportado para venda: {carta_tipo}")
                return self._extrair_valor_fallback(carta_path)
            
            if valor is not None:
                print(f"DEBUG: Valor de venda encontrado na base de dados: {valor} para {card_id}")
                return valor
            else:
                print(f"DEBUG: Carta não encontrada na base de dados: {card_id}")
                return self._extrair_valor_fallback(carta_path)
                
        except Exception as e:
            print(f"DEBUG: Erro ao extrair valor da base de dados: {e}")
            return self._extrair_valor_fallback(carta_path)
    
    def _extrair_valor_fallback(self, carta_path):
        """Método fallback para extrair valor do nome do arquivo"""
        try:
            import re
            nome = os.path.basename(carta_path)
            path_lower = carta_path.lower()
            
            # CORREÇÃO: Services sempre têm valor de venda 0, independentemente do fallback
            if "/services/" in path_lower or "service_" in nome.lower():
                print(f"DEBUG: Service detectada no fallback - retornando 0: {nome}")
                return 0
            
            # Para outros tipos, extrair do nome do arquivo
            match = re.search(r'_(\d+)\.', nome)
            if match:
                valor = int(match.group(1))
                print(f"DEBUG: Valor extraído por fallback: {valor}")
                return valor
        except Exception as e:
            print(f"DEBUG: Erro no fallback: {e}")
        return 1  # Valor padrão
    
    def _get_card_type_from_path(self, carta_path):
        """Determina o tipo da carta pelo caminho"""
        path_lower = carta_path.lower()
        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
            return "users"
        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
            return "equipments"
        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
            return "services"
        elif "/activities/" in path_lower or "activity_" in os.path.basename(path_lower):
            return "activities"
        elif "/actions/" in path_lower or "action_" in os.path.basename(path_lower):
            return "actions"
        return None
    
    def _map_file_to_card_id(self, carta_path, carta_tipo):
        """Mapeia arquivo para ID da base de dados"""
        nome = os.path.basename(carta_path)
        cor = self._get_color_from_path(carta_path)
        
        # Fallback para cor se não detectada no caminho
        if not cor:
            cor = self.player_color  # Usar cor do jogador como padrão aqui
        
        if carta_tipo == "users":
            # User_1.png -> contract_red, User_2.png -> 1_red, User_3.png -> 2_red, etc.
            match = re.search(r'User_(\d+)\.', nome)
            if match:
                user_num = int(match.group(1))
                if user_num == 1:  # User_1.png = Residential Contract
                    return f"contract_{cor}"
                elif user_num >= 2:  # User_2.png = user ID 1, User_3.png = user ID 2, etc.
                    return f"{user_num - 1}_{cor}"
        
        elif carta_tipo == "equipments":
            # Equipment_1.png -> small_router_1_red, etc.
            match = re.search(r'Equipment_(\d+)\.', nome)
            if match:
                eq_num = int(match.group(1))
                if 1 <= eq_num <= 3:
                    return f"small_router_{eq_num}_{cor}"
                elif 4 <= eq_num <= 6:
                    return f"medium_router_{eq_num - 3}_{cor}"
                elif 7 <= eq_num <= 9:
                    return f"short_link_{eq_num - 6}_{cor}"
                elif 10 <= eq_num <= 12:
                    return f"long_link_{eq_num - 9}_{cor}"
        
        elif carta_tipo == "services":
            # Service_1.png -> service_bandwidth_1_red
            # Service_2.png -> service_data_volume_1_red  
            # Service_3.png -> service_data_volume_2_red
            # Service_4.png -> service_data_volume_3_red
            # Service_5.png -> service_temporary_1_red
            # Service_6.png -> service_temporary_2_red
            # Service_7.png -> service_temporary_3_red
            match = re.search(r'Service_(\d+)\.', nome)
            if match:
                service_num = int(match.group(1))
                if service_num == 1:
                    return f"service_bandwidth_1_{cor}"
                elif 2 <= service_num <= 4:
                    return f"service_data_volume_{service_num - 1}_{cor}"
                elif 5 <= service_num <= 7:
                    return f"service_temporary_{service_num - 4}_{cor}"
        
        elif carta_tipo == "activities":
            # Activity_1.png -> activity_1_red, etc.
            match = re.search(r'Activity_(\d+)\.', nome)
            if match:
                activity_num = int(match.group(1))
                return f"activity_{activity_num}_{cor}"
        
        elif carta_tipo == "actions":
            # Action_1.png -> action_1, etc.
            match = re.search(r'Action_(\d+)\.', nome)
            if match:
                action_num = int(match.group(1))
                return f"action_{action_num}"
        
        return None
    
    def _extract_event_id_from_path(self, carta_path):
        """Extrai o ID do Event a partir do caminho da carta"""
        try:
            nome = os.path.basename(carta_path)
            # Event_123.png -> event_123
            import re
            match = re.search(r'Event_(\d+)\.', nome)
            if match:
                event_num = int(match.group(1))
                return f"event_{event_num}"
        except Exception as e:
            print(f"DEBUG: [_extract_event_id_from_path] Erro ao extrair ID do Event: {e}")
        return None
    
    def _get_color_from_path(self, carta_path):
        """Extrai a cor do caminho da carta"""
        path_lower = carta_path.lower()
        if "/red/" in path_lower or "-red" in path_lower:
            return "red"
        elif "/blue/" in path_lower or "-blue" in path_lower:
            return "blue"
        elif "/green/" in path_lower or "-green" in path_lower:
            return "green"
        elif "/yellow/" in path_lower or "-yellow" in path_lower:
            return "yellow"
        return self.player_color  # Usar cor do jogador como padrão
        
    # Cargas de cartas usando a nova estrutura: [tipo]/Residential-level/[cor]/
    def load_cards_from_new_structure(self, card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Mapear tipo para nome da pasta
            folder_mapping = {
                "users": "Users",
                "equipments": "Equipments", 
                "services": "Services",
                "activities": "Activities",
                "challenges": "Challenges",
                "actions": "Actions",
                "events": "Events"
            }
            
            folder_name = folder_mapping.get(card_type, card_type)
            
            # Para cartas que têm cores específicas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Tentar encontrar cartas na estrutura: [tipo]/Residential-level/[cor]/
                for color_var in color_variants:
                    path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                                break  # Para no primeiro caminho que funcionar
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar {card_type}: {e}")
            
            return cards

    def animate_typing(self, label, text, delay=50, callback=None):
        def _type(i=0):
            if i <= len(text):
                label.config(text=text[:i])
                label.after(delay, _type, i + 1)
            elif callback:
                callback()
        _type()

    def show_dice_roll_screen(self, player_name, saldo, other_players, screen_width, screen_height):
        # Reset da flag de Action removida - novo turno, cartas podem ficar viradas para cima novamente
        self._action_recently_removed = False
        print("DEBUG: [DICE_ROLL] Flag _action_recently_removed resetada para False - novo turno")
        
        # NOVO: Resetar contadores de processamento por turno
        self._reset_turn_processing_counters()
        
        # Limpa widgets abaixo da barra superior
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), fg="black", bg=self.bar_color)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Saldo (direita)
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
        coin_lbl.image = coin_img
        coin_lbl.place(x=screen_width-100, y=30)
        saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, y=30)

        # Ícones dos outros jogadores (esquerda)
        for idx, p in enumerate(other_players):
            if idx < len(USER_ICONS):
                icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                lbl.image = icon_img  # type: ignore[attr-defined]
                lbl.place(x=5+idx*40, y=20)

        # Frame central para o dado e frases
        center_frame = tk.Frame(self, bg="black")
        center_frame.place(relx=0.5, rely=0.5, anchor="center")

        lbl1 = tk.Label(center_frame, text="", font=("Helvetica", 22, "bold"), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl1.pack(pady=(0, 10))
        lbl2 = tk.Label(center_frame, text="", font=("Helvetica", 18), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl2.pack(pady=(0, 30))

        dice_btn = None
        go_btn = None


        if not hasattr(self, "player_pos"):
            self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        player_pos = self.player_pos

        def after_texts():
            nonlocal dice_btn, go_btn
            blank_img_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
            dice_img = ImageTk.PhotoImage(Image.open(blank_img_path).resize((100,100)))
            dice_btn = tk.Label(center_frame, image=dice_img, bg="black")
            dice_btn.image = dice_img  # type: ignore[attr-defined]
            dice_btn.pack(pady=20)

            go_btn = tk.Button(center_frame, text="Go!", font=("Helvetica", 16, "bold"), bg="#005c75", fg="white")

            def roll_animation():
                go_btn.pack_forget()
                frames = 25
                results = [random.randint(1,6) for _ in range(frames)]
                final = random.randint(1,6)
                results.append(final)

                def animate(i=0,player_color=self.player_color):
                    
                    color_map = {
                    "green": "#70AD47",
                    "yellow": "#F2BA0D",
                    "red": "#EE6F68",
                    "blue": "#43BEF2"
                    }
                    
                    self.bar_color = color_map.get(player_color.lower(), "#AAAAAA")
                    
                    if i < len(results):
                        n = results[i]
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]
                        center_frame.after(100, animate, i+1)
                    else:
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{final}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]

                        # Esconde as frases imediatamente
                        lbl1.pack_forget()
                        lbl2.pack_forget()

                        steps = final
                        old = self.player_pos
                        new_pos = (old + steps) % NUM_CASAS
                        tipo, casa_cor = BOARD[new_pos]
                        self.player_pos = new_pos
                        
                        # Atualizar variáveis da casa atual para o botão Store
                        self.current_casa_tipo = tipo
                        self.current_casa_cor = casa_cor
                        # Verificar se é casa de outro jogador
                        self.current_other_player_house = (casa_cor != self.player_color.lower() and casa_cor != "neutral")

                        # CORREÇÃO CRÍTICA: Limpar estado Challenge se não estivermos numa casa Challenge
                        if tipo != "challenges":
                            print(f"DEBUG: [MOVIMENTO] Mudou para casa {tipo} {casa_cor} - limpando estado Challenge antigo")
                            self.limpar_estado_challenge_pendente(force_clean=True)
                            print("DEBUG: [MOVIMENTO] Estado Challenge limpo pois não estamos numa casa Challenge")

                        # IMPORTANTE: Reativar botão Store se não for casa Actions/Events/Challenges neutra
                        if not (tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                            self.enable_store_button()
                            print(f"DEBUG: Botão Store reativado - mudou para casa {tipo} {casa_cor}")

                        def mostrar_nome_casa(tipo, casa_cor):
                            # Esconde o dado só agora
                            dice_btn.pack_forget()
                            cor_map = {
                                "green": "#70AD47",
                                "yellow": "#F2BA0D",
                                "red": "#EE6F68",
                                "blue": "#43BEF2",
                                "neutral": "#AAAAAA"
                            }
                            cor = cor_map.get(casa_cor, "#FFFFFF")
                            # Corrigir nome 'equipment' para 'EQUIPMENTS'
                            nome_tipo = tipo.upper()
                            if nome_tipo == "EQUIPMENT":
                                nome_tipo = "EQUIPMENTS"
                            nome_lbl = tk.Label(center_frame, text=nome_tipo, font=("Helvetica", 22, "bold"), fg=cor, bg="black")
                            nome_lbl.pack(pady=10)

                            def depois_nome():
                                nome_lbl.pack_forget()
                                
                                # VERIFICAR SE É CASA START - vai diretamente para interface principal
                                if tipo == "start":
                                    print("DEBUG: [depois_nome] Casa START detectada - indo para interface principal do PlayerDashboard")
                                    # Marcar que está numa casa start (sem botão Store e sem vendas)
                                    self.current_casa_tipo = "start"
                                    self.current_casa_cor = "neutral"
                                    self.current_other_player_house = False
                                    
                                    # IMPORTANTE: Reativar botão Store na casa START (não é Actions/Events neutra)
                                    self.enable_store_button()
                                    print("DEBUG: Botão Store reativado - está na casa START")
                                    
                                    # Ir diretamente para a interface principal sem botão Store
                                    center_frame.destroy()
                                    self.playerdashboard_interface(player_name, saldo, self.other_players, show_store_button=False)
                                    return
                                
                                # VERIFICAR se já existe uma Store antes de criar nova
                                if (hasattr(self, 'store_window') and self.store_window and 
                                    hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                    print("DEBUG: [depois_nome] Store já existe, a reutilizar existente")
                                    print(f"DEBUG: [depois_nome] ID da Store existente: {id(self.store_window)}")
                                    print(f"DEBUG: [depois_nome] Estado fullscreen da Store existente: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                                    
                                    # CRÍTICO: Limpar estado obsoleto da Store antes de reutilizar
                                    if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                        self.store_window._limpar_estado_completo_store()
                                        print("DEBUG: [depois_nome] Estado da Store limpo antes da reutilização")
                                    
                                    # CORREÇÃO: Atualizar informações da casa atual na Store
                                    self.store_window.casa_tipo = tipo
                                    self.store_window.casa_cor = casa_cor
                                    print(f"DEBUG: [depois_nome] Casa atualizada na Store: {tipo} {casa_cor}")
                                    
                                    # CORREÇÃO CRÍTICA: Reconstruir interface da Store após limpeza
                                    if hasattr(self.store_window, 'rebuild_store_interface'):
                                        print("DEBUG: [depois_nome] Reconstruindo interface da Store após reutilização")
                                        self.store_window.rebuild_store_interface()
                                    
                                    # Restaurar Store existente em vez de criar nova
                                    self.store_window.deiconify()
                                    self.store_window.state('normal')
                                    self.store_window.lift()
                                    self.store_window.focus_force()
                                    return
                                
                                if casa_cor == self.player_color.lower() or casa_cor == "neutral":
                                    # Casa própria ou neutra - Store normal
                                    print("DEBUG: [depois_nome] Criando nova Store para casa própria/neutra")
                                    self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self)
                                    print(f"DEBUG: [depois_nome] Nova Store criada com ID: {id(self.store_window)}")
                                    if hasattr(self.store_window, '_store_id'):
                                        print(f"DEBUG: [depois_nome] Store ID único: {self.store_window._store_id}")
                                else:
                                    # Casa de outro jogador - mostra mensagem e depois Store apenas para venda
                                    other_player_lbl = tk.Label(center_frame, text="Square of other player", font=("Helvetica", 18, "bold"), fg="white", bg="black")
                                    other_player_lbl.pack(pady=10)
                                    
                                    def abrir_store_outro_jogador():
                                        other_player_lbl.pack_forget()
                                        
                                        # VERIFICAR se já existe uma Store antes de criar nova (também para outro jogador)
                                        if (hasattr(self, 'store_window') and self.store_window and 
                                            hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                            print("DEBUG: [abrir_store_outro_jogador] Store já existe, a reutilizar existente")
                                            
                                            # CRÍTICO: Limpar estado obsoleto da Store antes de reutilizar
                                            if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                                self.store_window._limpar_estado_completo_store()
                                                print("DEBUG: [abrir_store_outro_jogador] Estado da Store limpo antes da reutilização")
                                            
                                            # CORREÇÃO: Atualizar informações da casa atual na Store
                                            self.store_window.casa_tipo = tipo
                                            self.store_window.casa_cor = casa_cor
                                            self.store_window.other_player_house = True
                                            print(f"DEBUG: [abrir_store_outro_jogador] Casa atualizada na Store: {tipo} {casa_cor} (outro jogador)")
                                            
                                            # CORREÇÃO CRÍTICA: Reconstruir interface da Store após limpeza
                                            if hasattr(self.store_window, 'rebuild_store_interface'):
                                                print("DEBUG: [abrir_store_outro_jogador] Reconstruindo interface da Store após reutilização")
                                                self.store_window.rebuild_store_interface()
                                            
                                            # Restaurar Store existente em vez de criar nova
                                            self.store_window.deiconify()
                                            self.store_window.state('normal')
                                            self.store_window.lift()
                                            self.store_window.focus_force()
                                            center_frame.destroy()
                                            return
                                        
                                        # Para casa de outro jogador, sempre abre a Store mas com restrições
                                        print("DEBUG: [abrir_store_outro_jogador] Criando nova Store para casa de outro jogador")
                                        self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self, other_player_house=True)
                                        center_frame.destroy()
                                    
                                    # Espera 2 segundos e depois abre a Store
                                    center_frame.after(2000, abrir_store_outro_jogador)
                            
                            # Espera 2 segundos DEPOIS de mostrar o nome da casa
                            center_frame.after(2000, depois_nome)

                        # Espera 2 segundos ANTES de esconder o dado e mostrar o nome da casa
                        center_frame.after(2000, lambda: mostrar_nome_casa(tipo, casa_cor))

                animate()

            go_btn.config(command=roll_animation)
            go_btn.pack(pady=(0, 5))

        self.animate_typing(lbl1, "It's your turn!", delay=60,
            callback=lambda: self.animate_typing(lbl2, "Roll the dice to start your adventure.", delay=60, callback=after_texts)
        )
        
    def atualizar_carrossel(self):
        # Junta todas as cartas de Activities e Challenges do inventário, sem duplicar
        novas_cartas = []
        for tipo in ["activities", "challenges"]:
            novas_cartas += self.inventario.get(tipo, [])
        # Se não houver cartas, mostra backs
        if not novas_cartas:
            novas_cartas = [CARD_IMG] * 4
        self.cards = novas_cartas
        self.card_idx = 0
        self.selected_card_idx = 0
        
        # NOVA FUNCIONALIDADE: Atualizar flags das cartas baseado no estado atual
        nova_flags = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - flag True (virada para cima)
                nova_flags.append(True)
                print(f"DEBUG: [atualizar_carrossel] Posição {i}: {os.path.basename(carta_path)} -> Flag True (virada para cima)")
            else:
                # Carta back ou vazia - flag False (virada para baixo)
                nova_flags.append(False)
                print(f"DEBUG: [atualizar_carrossel] Posição {i}: back card -> Flag False (virada para baixo)")
        
        # Garantir que temos 4 flags
        while len(nova_flags) < 4:
            nova_flags.append(False)
        
        if not hasattr(self, 'card_face_up_flags'):
            self.card_face_up_flags = [False, False, False, False]
        self.card_face_up_flags = nova_flags[:4]  # Limitar a 4 posições
        print(f"DEBUG: [atualizar_carrossel] card_face_up_flags atualizado: {self.card_face_up_flags}")
        
        # CORREÇÃO CRÍTICA: Inicializar card_stats com valores corretos da base de dados
        print("DEBUG: [atualizar_carrossel] Inicializando card_stats com valores da base de dados...")
        novo_card_stats = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - obter message_size da base de dados
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    carta_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    print(f"DEBUG: [atualizar_carrossel] Carta {i}: {os.path.basename(carta_path)} -> To send: {message_size}")
                except Exception as e:
                    print(f"DEBUG: [atualizar_carrossel] Erro ao obter message_size para {carta_path}: {e}")
                    carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
            else:
                # Carta back ou vazia
                carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
                print(f"DEBUG: [atualizar_carrossel] Carta {i}: back card -> valores 0")
            novo_card_stats.append(carta_stats)
        
        # Garantir que temos 4 posições
        while len(novo_card_stats) < 4:
            novo_card_stats.append({"To send": 0, "Rxd": 0, "Lost": 0})
        
        self.card_stats = novo_card_stats[:4]  # Limitar a 4 posições
        print(f"DEBUG: [atualizar_carrossel] card_stats atualizado: {self.card_stats}")
        
        # CORREÇÃO: Preservar seleção do carrossel se ainda é válida
        # Verificar se a carta selecionada ainda existe no carrossel atualizado
        carta_selecionada_preservada = None
        indice_selecionado_preservado = None
        
        if (hasattr(self, 'selected_carousel_card') and self.selected_carousel_card and 
            self.selected_carousel_card in novas_cartas):
            # A carta ainda existe, preservar seleção
            carta_selecionada_preservada = self.selected_carousel_card
            indice_selecionado_preservado = novas_cartas.index(self.selected_carousel_card)
            print(f"DEBUG: [atualizar_carrossel] Preservando seleção: {os.path.basename(carta_selecionada_preservada)} (índice {indice_selecionado_preservado})")
        else:
            print("DEBUG: [atualizar_carrossel] Carta selecionada não existe mais ou não havia seleção - resetando")
        
        # Limpar seleção do carrossel temporariamente para atualização
        self.selected_carousel_card = carta_selecionada_preservada
        self.selected_carousel_index = indice_selecionado_preservado
        
        # Atualizar destaques
        if hasattr(self, 'card_labels') and self.card_labels:
            self._update_carousel_selection_highlights()

    def disable_store_button(self):
        """Desativa o botão Store permanentemente até ser reativado E esconde o botão Next Phase"""
        self._store_button_disabled = True
        # NOVA FUNCIONALIDADE: Esconder botão Next Phase quando Challenge é aceite
        self._challenge_accepted = True
        print("DEBUG: [PlayerDashboard] Botão Store desativado e Challenge aceite - Next Phase será escondido")

    def enable_store_button(self):
        """Reativa o botão Store e reset da flag Challenge"""
        self._store_button_disabled = False
        self._challenge_accepted = False
        print("DEBUG: [PlayerDashboard] Botão Store reativado e flag Challenge resetada")

    def limpar_estado_challenge_pendente(self, force_clean=False):
        """
        Função auxiliar para limpar completamente o estado Challenge pendente.
        Deve ser chamada quando voltamos de uma carta Challenge via botão Player.
        CORREÇÃO: Não limpa _challenge_accepted se um Challenge foi realmente aceite OU se há Challenge pendente.
        Se force_clean=True, limpa sempre independentemente do contexto.
        """
        print("DEBUG: [limpar_estado_challenge_pendente] Iniciando limpeza de estado Challenge")
        print(f"DEBUG: [limpar_estado_challenge_pendente] force_clean: {force_clean}")
        
        # CORREÇÃO: Verificar se Challenge foi aceite antes de limpar flag
        # Se Challenge foi aceite (store_button_disabled = True), NÃO limpar _challenge_accepted
        challenge_foi_aceite = getattr(self, '_store_button_disabled', False)
        
        # NOVA VERIFICAÇÃO: Verificar se há Challenge pendente na Store (via transferência de estado)
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # Se force_clean=True, sempre limpar tudo
        if force_clean:
            print("DEBUG: [limpar_estado_challenge_pendente] LIMPEZA FORÇADA - removendo todos os estados Challenge")
            self._challenge_accepted = False
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FORÇADO - _store_challenge_carta_path limpo: {old_path} -> None")
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FORÇADO - _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        else:
            # Lógica normal baseada no contexto
            if challenge_foi_aceite:
                print("DEBUG: [limpar_estado_challenge_pendente] Challenge foi aceite - preservando _challenge_accepted = True")
                # Não mexer na flag _challenge_accepted quando Challenge foi aceite
                # IMPORTANTE: Preservar também após substituição Challenge->Activity
            elif challenge_pendente_transferido:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Challenge pendente transferido ({self._store_challenge_carta_path}) - NÃO limpando _challenge_accepted")
                # Também não limpar quando há Challenge pendente transferido via botão Player
            else:
                # CORREÇÃO: Verificar se houve substituição recente Challenge->Activity
                substituicao_recente = getattr(self, '_substituicao_challenge_activity_concluida', False)
                if substituicao_recente:
                    print("DEBUG: [limpar_estado_challenge_pendente] Substituição Challenge->Activity recente - preservando _challenge_accepted = True")
                    # Não resetar _challenge_accepted após substituição Challenge->Activity
                    # Limpar flag de substituição após uso
                    self._substituicao_challenge_activity_concluida = False
                else:
                    # Limpar flag Challenge apenas quando não foi aceite E não há Challenge pendente E não houve substituição
                    self._challenge_accepted = False
                    print("DEBUG: [limpar_estado_challenge_pendente] Nenhum Challenge pendente - limpando _challenge_accepted = False")
            
            # CORREÇÃO CRÍTICA: Sempre limpar variáveis de Challenge pendente para evitar que persistam entre turnos
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_path limpo: {old_path} -> None")
            
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        
        # Verificar e limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar estado fullscreen Challenge na Store
                    if hasattr(self.store_window, 'fullscreen_carta_path'):
                        old_path = self.store_window.fullscreen_carta_path
                        self.store_window.fullscreen_carta_path = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_path limpo: {old_path} -> None")
                    if hasattr(self.store_window, 'fullscreen_carta_tipo'):
                        old_tipo = self.store_window.fullscreen_carta_tipo
                        self.store_window.fullscreen_carta_tipo = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_tipo limpo: {old_tipo} -> None")
                    
                    # Limpar backups adicionais se existirem
                    backup_attrs = ['_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                   '_original_carta_path', '_original_carta_tipo']
                    for attr in backup_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: [limpar_estado_challenge_pendente] Store {attr} limpo")
                else:
                    print("DEBUG: [limpar_estado_challenge_pendente] Store não existe mais")
            except Exception as e:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Erro ao verificar Store: {e}")
        else:
            print("DEBUG: [limpar_estado_challenge_pendente] Nenhuma Store ativa para limpar")
        
        print("DEBUG: [limpar_estado_challenge_pendente] Limpeza de estado Challenge concluída")

    def _criar_botao_next_phase(self):
        """Cria o botão Next Phase com toda a lógica necessária"""
        def next_phase_action():
            # MARCAR: Next Phase foi ativado manualmente pelo jogador
            self._next_phase_manually_activated = True
            # Esconde o botão Store
            if hasattr(self, 'btn_store') and self.btn_store:
                self.btn_store.place_forget()
                print("DEBUG: Botão Store escondido")
            # Ativa flag para desativar vendas nas páginas de inventário
            self._next_phase_active = True
            # Atualiza cache dos User IDs para controlo do carrossel
            self._check_user_inventory_for_carousel_access()
            # Atualiza destaques roxos do carrossel
            self._update_carousel_highlights()
            
            # MANTER BARRAS ATUALIZADAS: Atualizar barras de progresso quando Next Phase é ativado
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                print(f"DEBUG: Next Phase - Atualizando barras para carta selecionada: {os.path.basename(self.selected_carousel_card)}")
                self._update_progress_bars_from_card(self.selected_carousel_card)
            else:
                print("DEBUG: Next Phase - Nenhuma carta selecionada para atualizar barras")
            
            print("DEBUG: Next Phase ativado - Store escondido, vendas desativadas, User IDs verificados, destaques e barras atualizadas")
            
            # Esconder o botão Next Phase e criar o botão Final Phase na mesma posição
            if hasattr(self, 'next_phase_btn') and self.next_phase_btn:
                self.next_phase_btn.place_forget()
                print("DEBUG: Botão Next Phase escondido")
            
            # Criar botão Final Phase diretamente aqui em vez de chamar função externa
            self._criar_botao_final_phase()

        def final_phase_action():
            print("DEBUG: Final Phase ativado")
            
            # NOVA FLAG CRÍTICA: Marcar que Final Phase foi clicado NESTE turno
            self._final_phase_clicked_this_turn = True
            self._final_phase_turn_id = getattr(self, '_current_turn_number', 1)  # Associar ao turno atual
            print(f"DEBUG: [FINAL PHASE] Flag _final_phase_clicked_this_turn definida como True para turno {self._final_phase_turn_id}")
            
            # CORREÇÃO CRÍTICA: PRESERVAR valores atuais das barras ANTES de iniciar gestão
            self._preservar_valores_atuais_barras()
            
            # Ativar flag Final Phase para bloquear todas as ações de cartas
            self._final_phase_active = True
            # NOVA FLAG: Ativar flag para mostrar botão End Turn
            self._show_end_turn_button = True
            print("DEBUG: Final Phase ativado - ativação/desativação de cartas bloqueada")
            
            # CORREÇÃO: Verificar se existem cartas ativas ANTES de aplicar destaque roxo
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            print(f"DEBUG: [FINAL PHASE] Cartas ativas encontradas: {len(cartas_ativas)}")
            
            if cartas_ativas:
                # Se há cartas ativas, aplicar destaque roxo na primeira carta ativa
                print("DEBUG: [FINAL PHASE] Ativando destaque roxo na primeira carta ativa")
                self._final_phase_gestao_ativa = True  # Ativar gestão de pacotes
                self._carta_destacada_posicao = 0      # Destacar posição 0
                self.selected_carousel_index = None    # Limpar seleção da cor do jogador
                
                # Atualizar destaques visuais ANTES de iniciar gestão de pacotes
                self._update_carousel_selection_highlights()
                print("DEBUG: [FINAL PHASE] Destaque roxo aplicado na posição 0")
            else:
                # Se não há cartas ativas, não ativar gestão de pacotes nem destaque roxo
                print("DEBUG: [FINAL PHASE] Nenhuma carta ativa - sem destaque roxo")
                self._final_phase_gestao_ativa = False
                self.selected_carousel_index = None    # Limpar seleção da cor do jogador
                
                # Atualizar destaques visuais (sem destaque roxo)
                self._update_carousel_selection_highlights()
            
            # INICIAR SISTEMA DE GESTÃO DE PACOTES
            print("DEBUG: Final Phase - Iniciando sistema de gestão de pacotes")
            
            # Esconder o botão Final Phase e criar End Turn ANTES de iniciar gestão
            try:
                if hasattr(self, 'final_phase_btn') and self.final_phase_btn:
                    self.final_phase_btn.place_forget()
                    print("DEBUG: Botão Final Phase escondido")
            except Exception as e:
                print(f"DEBUG: Erro ao esconder botão Final Phase: {e}")
            
            # Criar botão End Turn ANTES de iniciar gestão de pacotes
            self._criar_botao_end_turn()
            
            # Agora sim iniciar gestão de pacotes (que pode ativar o botão End Turn se necessário)
            self._iniciar_gestao_pacotes()

        # Armazenar as funções como atributos da classe para acesso posterior
        self._next_phase_action = next_phase_action
        self._final_phase_action = final_phase_action

        self.next_phase_btn = tk.Button(
            self,
            text="Next Phase",
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Cinza
            fg="black",
            command=next_phase_action,
            width=10,
        )
        # Posição igual aos botões Back das páginas de inventário
        self.next_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.next_phase_btn.lift()
        print("DEBUG: Botão Next Phase recriado na interface principal")
    
    def _criar_botao_final_phase(self):
        """Cria o botão Final Phase"""
        self.final_phase_btn = tk.Button(
            self,
            text="Final Phase",
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Mesmo cinza do Next Phase
            fg="black",
            command=self._final_phase_action,
            width=10,
        )
        # Mesma posição do botão Next Phase
        self.final_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.final_phase_btn.lift()
        print("DEBUG: Botão Final Phase criado na mesma posição")
    
    def _gerenciar_botao_end_turn(self, command):
        """Função centralizada para gerenciar criação/atualização do botão End Turn"""
        try:
            # Verificar se botão já existe e está válido
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                try:
                    if self.end_turn_btn.winfo_exists():
                        # Botão existe e é válido, apenas atualizar comando
                        self.end_turn_btn.config(command=command)
                        print("DEBUG: Botão End Turn - comando atualizado")
                        return
                except tk.TclError:
                    # Widget foi destruído, precisamos recriar
                    print("DEBUG: Botão End Turn destruído, recriando...")
                    pass
            
            # Criar novo botão
            self.end_turn_btn = tk.Button(
                self,
                text="End Turn",
                font=("Helvetica", 14, "bold"),
                bg="#808080",
                fg="black",
                command=command,
                width=10,
                state="disabled"  # Sempre começar disabled
            )
            # Mesma posição do botão Final Phase
            self.end_turn_btn.place(relx=0.5, rely=0.98, anchor="s")
            self.end_turn_btn.lift()
            print("DEBUG: Botão End Turn criado com sucesso")
            
        except Exception as e:
            print(f"DEBUG: Erro ao gerenciar botão End Turn: {e}")

    def _criar_botao_end_turn(self):
        """Cria o botão End Turn"""
        def end_turn_action():
            print("DEBUG: End Turn clicado - chamando método self.end_turn() correto")
            
            # CORREÇÃO CRÍTICA: Chamar o método principal end_turn() que faz tudo corretamente
            # incluindo incremento sincronizado de todos os contadores de turno
            self.end_turn()
            
            # Após preservar todos os dados, resetar flags de fase para começar novo turno limpo
            self._next_phase_active = False
            self._final_phase_active = False
            self._final_phase_gestao_ativa = False
            self._challenge_accepted = False
            self._show_end_turn_button = False
            self._next_phase_manually_activated = False
            
            # RESETAR SELEÇÃO: Limpar seleção do carrossel para próximo turno
            self.selected_carousel_index = None
            self.selected_carousel_card = None
            self._carta_destacada_posicao = None
            
            # Chamar a página de lançamento de dado
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            self.show_dice_roll_screen(self.player_name, self.saldo, self.other_players, screen_width, screen_height)

        # Usar função centralizada
        self._gerenciar_botao_end_turn(end_turn_action)

    def playerdashboard_interface(self, player_name, saldo, other_players, show_store_button=None):
        try:
            print(f"DEBUG: [INTERFACE] ===== playerdashboard_interface INÍCIO =====")
            print(f"DEBUG: [INTERFACE] player_name: {player_name}, saldo: {saldo}")
            print(f"DEBUG: [INTERFACE] show_store_button: {show_store_button}")
            print(f"DEBUG: [INTERFACE] self existe? {hasattr(self, 'player_name')}")
            
            # PROTEÇÃO CONTRA LOOP: Limpar flag quando entra na interface principal
            self._inventory_opening = False
            print(f"DEBUG: [INTERFACE] Flag inventory_opening limpa")
            
            # LIMPEZA: Limpar flags de contexto especial quando volta ao dashboard
            if hasattr(self, '_in_remove_router_context'):
                self._in_remove_router_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_remove_router_context limpa")
            
            if hasattr(self, '_in_router_upgrade_context'):
                self._in_router_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_upgrade_context limpa")
            
            if hasattr(self, '_in_link_upgrade_context'):
                self._in_link_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_upgrade_context limpa")
            
            if hasattr(self, '_in_link_downgrade_context'):
                self._in_link_downgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_downgrade_context limpa")
            
            if hasattr(self, '_in_router_selection_page'):
                self._in_router_selection_page = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_selection_page limpa")
            
            # DETECÇÃO AUTOMÁTICA DE FASE: Verificar se o jogador deve estar numa fase avançada
            # com base no estado do jogo (cartas selecionadas, User IDs no inventário, etc.)
            # IMPORTANTE: Apenas aplicar quando NÃO está a vir da página de lançamento de dado
            if not hasattr(self, '_turn_number'):
                self._turn_number = 1
            print(f"DEBUG: [INTERFACE] Turn number inicializado: {self._turn_number}")
            
            # FLUXO CORRETO: Sempre começar com página de dado, independentemente do turno
            # A detecção de fase só deve acontecer quando vem diretamente de uma Store/inventário
            coming_from_dice_page = getattr(self, '_coming_from_dice', False)
            print(f"DEBUG: [INTERFACE] Coming from dice page: {coming_from_dice_page}")
            
            if coming_from_dice_page:
                # Reset da flag para evitar loops
                self._coming_from_dice = False
                print(f"DEBUG: [INTERFACE] Vindo da página de dado - turno {self._turn_number}")
            else:
                # Incrementar turno apenas quando NÃO vem da página de dado
                self._turn_number = getattr(self, '_turn_number', 1) + 1
                print(f"DEBUG: [INTERFACE] Navegação entre páginas - turno {self._turn_number}")
            
            print(f"DEBUG: [INTERFACE] Preparando para limpar widgets...")
            
        except Exception as e:
            print(f"DEBUG: [INTERFACE] ERRO CRÍTICO no início da playerdashboard_interface: {e}")
            import traceback
            print(f"DEBUG: [INTERFACE] Traceback: {traceback.format_exc()}")
            return
            # NOTA: Restauração automática de fase DESATIVADA para permitir controlo manual
            # O jogador deve clicar explicitamente nos botões Next Phase e Final Phase
            print(f"DEBUG: [FASE] Restauração automática desativada - flags controladas manualmente")
        
        # CORREÇÃO: Distinguir entre NOVO TURNO e navegação dentro do mesmo turno
        # IMPORTANTE: Só limpar estado Challenge em NOVOS TURNOS para evitar persistência entre turnos
        # Para navegação dentro do turno (via botão Player), preservar estado Challenge
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # DETECÇÃO DE NOVO TURNO: Verificar se está a vir da página de lançamento de dado
        coming_from_dice_page = getattr(self, '_coming_from_dice', False)
        
        print(f"DEBUG: [INTERFACE] === ANÁLISE DE ESTADO CHALLENGE ===")
        print(f"DEBUG: [INTERFACE] coming_from_dice_page: {coming_from_dice_page}")
        print(f"DEBUG: [INTERFACE] challenge_pendente_transferido: {challenge_pendente_transferido}")
        if challenge_pendente_transferido:
            print(f"DEBUG: [INTERFACE] Challenge path: {getattr(self, '_store_challenge_carta_path', 'None')}")
        
        if coming_from_dice_page:
            # NOVO TURNO: Sempre limpar estado Challenge antigo para evitar persistência entre turnos
            # Isto resolve o problema relatado onde Challenge do turno 1 aparecia no turno 2
            print("DEBUG: [INTERFACE] NOVO TURNO detectado - limpeza automática de estado Challenge antigo")
            self.limpar_estado_challenge_pendente(force_clean=True)
            print("DEBUG: [INTERFACE] Estado Challenge antigo limpo FORÇADAMENTE - início de novo turno")
        elif challenge_pendente_transferido:
            # NAVEGAÇÃO NO MESMO TURNO: Verificar se estamos ainda numa casa Challenge
            casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
            if casa_atual_tipo == "challenges":
                # Preservar estado Challenge transferido via botão Player apenas se ainda estivermos numa casa Challenge
                print(f"DEBUG: [INTERFACE] NAVEGAÇÃO NO TURNO EM CASA CHALLENGE - preservando Challenge transferido: {self._store_challenge_carta_path}")
                print("DEBUG: [INTERFACE] Estado Challenge preservado para permitir voltar à Store")
            else:
                # Se não estivermos numa casa Challenge, limpar o estado
                print(f"DEBUG: [INTERFACE] NAVEGAÇÃO NO TURNO FORA DE CASA CHALLENGE (casa atual: {casa_atual_tipo}) - limpando Challenge transferido")
                self.limpar_estado_challenge_pendente(force_clean=True)
                print("DEBUG: [INTERFACE] Estado Challenge limpo pois não estamos numa casa Challenge")
        else:
            # SEM CHALLENGE PENDENTE: Limpeza normal (equivalente ao comportamento anterior)
            print("DEBUG: [INTERFACE] Sem Challenge pendente - limpeza normal")
            self.limpar_estado_challenge_pendente()
            print("DEBUG: [INTERFACE] Estado Challenge limpo via função auxiliar - limpeza normal")
        
        print(f"DEBUG: [INTERFACE] === FIM ANÁLISE DE ESTADO CHALLENGE ===")
        
        # TESTE: Adicionar User cards para testar o sistema de controlo do carrossel
        # Esta linha pode ser removida em produção
        self._teste_adicionar_user_cards()
        
        # LIMPEZA: Remover cartas Actions/Events que foram incorretamente adicionadas ao inventário
        # (cartas destinadas a outros jogadores que não deveriam ficar no inventário do remetente)
        print("DEBUG: [INTERFACE] Iniciando limpeza de cartas Actions/Events incorretas...")
        self._limpar_cartas_actions_events_incorretas()
        print("DEBUG: [INTERFACE] Limpeza de cartas Actions/Events concluída")
        
        # CORREÇÃO CRÍTICA: Se há Challenge pendente transferido, SEMPRE mostrar botão Store
        # Isto tem prioridade sobre qualquer parâmetro show_store_button
        if challenge_pendente_transferido and hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path:
            show_store_button = True
            print("DEBUG: Challenge pendente detectado - forçando botão Store para permitir voltar")
            # NÃO atualizar _store_button_disabled quando há Challenge pendente
        elif show_store_button is None:
            # Se show_store_button não for especificado, usar o estado atual
            show_store_button = not self._store_button_disabled
        else:
            # Atualizar o estado baseado no parâmetro fornecido APENAS se não há Challenge pendente
            self._store_button_disabled = not show_store_button
            
        self.atualizar_carrossel()
        # Limpar todos os widgets existentes (exceto a barra superior se existir)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue  # Manter a barra superior
            widget.destroy()
        
        # Barra superior com imagem
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)  # Remove barra de título
        self.attributes("-fullscreen", True)  # Garante fullscreen (opcional)
        
        # Criar TopBar se não existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [playerdashboard_interface] Tentando carregar TopBar de: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [playerdashboard_interface] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [playerdashboard_interface] Arquivo TopBar não encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [playerdashboard_interface] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [playerdashboard_interface] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [playerdashboard_interface] TopBar fallback criada após erro!")
        
        # Ícones dos outros jogadores (esquerda)
        for idx, p in enumerate(other_players):
            if idx < len(USER_ICONS):
                icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                lbl.image = icon_img  # type: ignore[attr-defined]
                lbl.place(x=5+idx*40, y=20)

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Botão da Store no canto superior direito para ir à Store (apenas se show_store_button for True)
        self._store_btn_widget = None
        # CORREÇÃO: Não esconder botão Store apenas porque Next Phase foi detectado automaticamente
        # Só esconder se Next Phase foi ativado explicitamente pelo jogador
        next_phase_manually_activated = getattr(self, '_next_phase_manually_activated', False)
        
        # CORREÇÃO CRÍTICA: Se há Challenge pendente, SEMPRE mostrar botão Store
        # Isto tem prioridade sobre qualquer estado de Next Phase
        has_challenge_pendente = (challenge_pendente_transferido and 
                                hasattr(self, '_store_challenge_carta_path') and 
                                self._store_challenge_carta_path)
        
        if show_store_button and (not next_phase_manually_activated or has_challenge_pendente):
            # Debug da decisão
            if has_challenge_pendente:
                print("DEBUG: Botão Store criado devido a Challenge pendente (prioridade sobre Next Phase)")
            elif not next_phase_manually_activated:
                print("DEBUG: Botão Store criado - condições normais atendidas")
            
            def abrir_store():
                """Abre a Store seguindo o mesmo padrão do botão Player"""
                print("DEBUG: Botão Store pressionado - abrindo Store")
                print(f"DEBUG: [abrir_store] Verificando se Store existe...")
                print(f"DEBUG: [abrir_store] hasattr store_window: {hasattr(self, 'store_window')}")
                if hasattr(self, 'store_window'):
                    print(f"DEBUG: [abrir_store] store_window não é None: {self.store_window is not None}")
                    if self.store_window:
                        print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                        print(f"DEBUG: [abrir_store] tem fullscreen_carta_path: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                        if hasattr(self.store_window, 'fullscreen_carta_path'):
                            print(f"DEBUG: [abrir_store] fullscreen_carta_path valor: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                
                try:
                    # CORREÇÃO IMPORTANTE: Só restaurar carta Challenge se estivermos numa casa Challenge
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo):
                        print(f"DEBUG: [abrir_store] Carta Challenge encontrada no PlayerDashboard: {self._store_challenge_carta_path}")
                        print(f"DEBUG: [abrir_store] Casa atual: tipo={casa_tipo}, cor={casa_cor}")
                        
                        # SÓ restaurar Challenge se estivermos numa casa Challenge
                        if casa_tipo == "challenges":
                            print("DEBUG: [abrir_store] Estamos numa casa Challenge - restaurando carta Challenge")
                            
                            # Verificar se Store existe e pode ser restaurada
                            if (hasattr(self, 'store_window') and self.store_window and 
                                hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                print("DEBUG: [abrir_store] Store existente encontrada - transferindo estado Challenge")
                                # Transferir estado de volta para a Store
                                self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._original_carta_path = self._store_challenge_carta_path
                                self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                                
                                # Restaurar Store com carta Challenge
                                self.store_window.voltar_para_store()
                                self.withdraw()
                                
                                # Limpar estado do PlayerDashboard
                                self._store_challenge_carta_path = None
                                self._store_challenge_carta_tipo = None
                                print("DEBUG: [abrir_store] Store restaurada com carta Challenge")
                                return
                            else:
                                print("DEBUG: [abrir_store] Store não existe - criando nova com estado Challenge")
                                # Store não existe, criar nova com estado Challenge já definido
                                # (continua para criação abaixo)
                        else:
                            print(f"DEBUG: [abrir_store] NÃO estamos numa casa Challenge (estamos em {casa_tipo}) - LIMPANDO estado Challenge")
                            # Limpar estado Challenge pois não estamos numa casa Challenge
                            self._store_challenge_carta_path = None
                            self._store_challenge_carta_tipo = None
                            print("DEBUG: [abrir_store] Estado Challenge limpo - continuando criação normal da Store")
                    
                    # Verificar se já existe uma Store com estado de fullscreen guardado
                    elif (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists() and
                        hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print(f"DEBUG: Store existente encontrada com estado fullscreen - restaurando carta: {self.store_window.fullscreen_carta_path}")
                        print(f"DEBUG: [abrir_store] ID da Store existente: {id(self.store_window)}")
                        if hasattr(self.store_window, '_store_id'):
                            print(f"DEBUG: [abrir_store] Store ID único: {self.store_window._store_id}")
                        print(f"DEBUG: [abrir_store] Chamando voltar_para_store() na Store existente...")
                        # Restaurar Store existente com estado de fullscreen
                        self.store_window.voltar_para_store()
                        # Esconder PlayerDashboard enquanto Store está aberta
                        self.withdraw()
                        print("DEBUG: Store existente restaurada com sucesso")
                        return
                    else:
                        # Debug das condições que falharam
                        print("DEBUG: [abrir_store] Condições de Store existente com fullscreen:")
                        print(f"DEBUG: [abrir_store] hasattr(self, 'store_window'): {hasattr(self, 'store_window')}")
                        if hasattr(self, 'store_window'):
                            print(f"DEBUG: [abrir_store] self.store_window is not None: {self.store_window is not None}")
                            if self.store_window:
                                print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                                print(f"DEBUG: [abrir_store] tem fullscreen_carta_path attr: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                                if hasattr(self.store_window, 'fullscreen_carta_path'):
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path value: {self.store_window.fullscreen_carta_path}")
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path is truthy: {bool(self.store_window.fullscreen_carta_path)}")
                        print("DEBUG: [abrir_store] Store existente NÃO tem estado fullscreen válido - criando nova")
                    
                    # Verificar se existe Store sem estado fullscreen
                    if (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                        print("DEBUG: [abrir_store] Store existe mas sem estado fullscreen - reutilizando")
                        self.store_window.voltar_para_store()
                        self.withdraw()
                        return
                    
                    # Importar Store aqui para evitar imports circulares
                    from Store_v2 import StoreWindow
                    # Usar as mesmas informações da casa atual (se disponível)
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    current_other_player_house = getattr(self, 'current_other_player_house', False)
                    
                    print(f"DEBUG: Criando nova Store - casa_tipo: {casa_tipo}, casa_cor: {casa_cor}, other_player_house: {current_other_player_house}")
                    
                    # IMPORTANTE: Reativar botão Store se não estiver numa casa Actions/Events/Challenges neutra
                    if not (casa_tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                        self.enable_store_button()
                        print("DEBUG: Botão Store reativado - não está numa casa Actions/Events/Challenges neutra")
                    
                    # Criar nova janela da Store
                    self.store_window = StoreWindow(
                        self.master,
                        self.player_color,
                        self.player_name,
                        self.saldo,
                        casa_tipo=casa_tipo,
                        casa_cor=casa_cor,
                        inventario=self.inventario,
                        dashboard=self,
                        other_player_house=current_other_player_house
                    )
                    print(f"DEBUG: Nova Store criada via botão Store com ID: {id(self.store_window)}")
                    if hasattr(self.store_window, '_store_id'):
                        print(f"DEBUG: Store ID único (botão Store): {self.store_window._store_id}")
                    
                    # CORREÇÃO: Só transferir carta Challenge se estivermos numa casa Challenge
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo and
                        casa_tipo == "challenges"):
                        print(f"DEBUG: Transferindo estado Challenge para nova Store (casa Challenge): {self._store_challenge_carta_path}")
                        self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._original_carta_path = self._store_challenge_carta_path
                        self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                        
                        # Limpar estado do PlayerDashboard
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                        print("DEBUG: Estado Challenge transferido para nova Store")
                    elif (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                          casa_tipo != "challenges"):
                        print(f"DEBUG: Limpando estado Challenge pois não estamos numa casa Challenge (estamos em {casa_tipo})")
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                    
                    # Esconder PlayerDashboard enquanto Store está aberta
                    self.withdraw()
                    
                    # Se há estado Challenge, restaurar carta imediatamente
                    if (hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print("DEBUG: Restaurando carta Challenge na nova Store")
                        self.store_window.voltar_para_store()  # Vai ativar restaurar_carta_fullscreen_pendente()
                    
                    print("DEBUG: Nova Store criada com sucesso")
                except Exception as e:
                    print(f"DEBUG: Erro ao abrir Store: {e}")
                    import traceback
                    traceback.print_exc()

            try:
                # Carregar ícone da Store
                store_icon_path = os.path.join(IMG_DIR, "Store_button_icon.png")
                store_icon_img = ImageTk.PhotoImage(Image.open(store_icon_path).resize((30, 30)))
                self.btn_store = tk.Button(self, image=store_icon_img, bg=self.bar_color, relief="flat", borderwidth=0, 
                                     command=abrir_store, cursor="hand2", activebackground=self.bar_color,
                                     highlightthickness=0)
                self.btn_store.image = store_icon_img  # Manter referência para evitar garbage collection
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")  # Mesma posição do botão Player na Store
                print("DEBUG: Botão Store criado com ícone Store_button_icon.png")
            except Exception as e:
                print(f"DEBUG: Erro ao carregar Store_button_icon.png: {e}")
                # Fallback para botão de texto se não conseguir carregar a imagem
                self.btn_store = tk.Button(self, text="🏪", font=("Helvetica", 20), bg=self.bar_color, fg="black", 
                                     relief="flat", borderwidth=0, command=abrir_store, cursor="hand2",
                                     activebackground=self.bar_color, activeforeground="black", highlightthickness=0)
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")
                print("DEBUG: Botão Store criado com ícone de fallback")
        else:
            # Debug melhorado para explicar porque não foi criado
            if not show_store_button:
                print(f"DEBUG: Botão Store NÃO criado - show_store_button=False")
            elif next_phase_manually_activated and not has_challenge_pendente:
                print(f"DEBUG: Botão Store NÃO criado - Next Phase ativo e sem Challenge pendente")
            else:
                print(f"DEBUG: Botão Store NÃO criado - razão desconhecida (show_store_button={show_store_button}, next_phase_manually_activated={next_phase_manually_activated}, has_challenge_pendente={has_challenge_pendente})")
            self.btn_store = None  # Inicializar como None quando não é criado

        # --- NOVO LAYOUT ---

        # Espaço extra antes dos botões
        self.after(0, lambda: self.update())  # Garante update do layout antes de calcular altura
        tk.Frame(self, height=5, bg="black").pack()  # reduzido para menos espaço

        # 1. Botões grandes (layout igual ao carrossel)
        btns_frame = tk.Frame(self, bg="black")
        btns_frame.pack(pady=(12, 18))  # Reduz espaço acima, mantém abaixo
        card_width, card_height = 85, 120  # Igual ao carrossel

        btn_info = [
            ("Users", self.bar_color, "users"),
            ("Equip.", self.bar_color, "equipments"),
            ("Services", self.bar_color, "services"),
            ("Actions/\nEvents", self.bar_color, "actions_events")
        ]

        self.action_buttons = []
        for text, color, inv_key in btn_info:
            btn_font = ("Helvetica", 13, "bold")
            if text.startswith("Services"):
                btn_font = ("Helvetica", 12, "bold")  # Fonte menor só para "Services"
            btn = tk.Button(
                btns_frame, text=text, font=btn_font,
                wraplength=70,
                bg=color, fg="black", activebackground="white", activeforeground="black",
                bd=0, highlightthickness=0
            )
            btn.pack(side=tk.LEFT, padx=2, ipady=22, expand=True, fill="both")
            self.action_buttons.append(btn)
            # Associar inventário correto - CORREÇÃO: usar default parameter para evitar closure problem
            if inv_key == "actions_events":
                print(f"DEBUG: Configurando botão '{text}' para Actions/Events")
                def actions_events_handler():
                    print(f"DEBUG: *** BOTÃO ACTIONS/EVENTS CLICADO ***")
                    # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DE IR PARA INVENTÁRIO
                    self._capturar_estado_botoes_imediato()
                    self.show_inventory_matrix(["actions", "events"])
                btn.config(command=actions_events_handler)
            else:
                print(f"DEBUG: Configurando botão '{text}' para tipo '{inv_key}'")
                def handler(tipo_carta=inv_key):
                    print(f"DEBUG: *** BOTÃO {tipo_carta.upper()} CLICADO ***")
                    # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DE IR PARA INVENTÁRIO
                    self._capturar_estado_botoes_imediato()
                    self.show_inventory_matrix([tipo_carta])
                btn.config(command=handler)

        # 2. Carrossel de cartas (agora abaixo dos botões)
        carousel_frame = tk.Frame(self, bg="black")
        carousel_frame.pack(pady=2)
        cards_container = tk.Frame(carousel_frame, bg="black")
        cards_container.pack()

        card_width, card_height = 85, 120  # Certifique-se que está definido antes

        self.card_labels = []
        for i, carta_path in enumerate(self.cards):
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_width, card_height)))
            
            # Durante Next Phase, verificar se esta posição pode ser selecionada
            can_select = True
            highlight_color = "black"  # Cor padrão do fundo
            border_width = 0
            border_color = "black"
            
            if getattr(self, '_next_phase_active', False) and os.path.basename(carta_path).startswith("back_card_"):
                # Durante Next Phase, verificar se tem User ID para esta posição
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"  # Roxo mais claro para a borda
                    print(f"DEBUG: Carta {i} destacada em roxo - pode ser selecionada")
                else:
                    print(f"DEBUG: Carta {i} sem destaque - não pode ser selecionada")
            
            # Determinar cursor: sempre hand2 para cartas viradas para baixo
            if os.path.basename(carta_path).startswith("back_card_"):
                cursor = "hand2"  # Sempre clicável para cartas viradas para baixo
            else:
                cursor = "hand2" if can_select else "arrow"
            
            lbl = tk.Label(cards_container, image=img, bg=highlight_color, cursor=cursor,
                          borderwidth=border_width, relief="solid", highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
            lbl.image = img  # type: ignore[attr-defined]
            lbl.grid(row=0, column=i, padx=2, pady=0)
            
            # Se for carta virada para baixo, abre inventário de Activities/Challenges
            # CORREÇÃO: Sempre permitir clique em cartas viradas para baixo, independentemente de can_select
            if os.path.basename(carta_path).startswith("back_card_"):
                lbl.bind("<Button-1>", lambda e, idx=i: self.abrir_inventario_para_carrossel(idx))
            else:
                # Para Activities/Challenges: SEMPRE criar binding para permitir cliques
                # A lógica de controlo será feita dentro de _select_carousel_card
                lbl.bind("<Button-1>", lambda e, idx=i, path=carta_path: self._select_carousel_card(idx, path))
            # lbl.selected = True  # Removido para linter
            # lbl.selected = False  # Removido para linter
            self.card_labels.append(lbl)
            
                # Frame para as barras de progresso
        self.progress_frame = tk.Frame(self, bg="black")
        self.progress_frame.pack(pady=(10, 0))

        self.progress_bars = {}
        self.progress_labels = {}

        stats = ["To send", "Rxd", "Lost"]
        for i, stat in enumerate(stats):
            row = tk.Frame(self.progress_frame, bg="black")
            row.pack(fill="x", pady=2)
            # Label do nome da stat à esquerda
            stat_lbl = tk.Label(row, text=stat, font=("Helvetica", 12, "bold"), bg="black", fg="white", width=8, anchor="w")
            stat_lbl.pack(side="left")
            # CORREÇÃO: Todas as barras usam o mesmo máximo inicial (será ajustado dinamicamente para message_size)
            # Isso garante precisão visual - barras com mesmo valor ficam alinhadas
            bar = ttk.Progressbar(row, orient="horizontal", length=240, mode="determinate", maximum=10)  # Valor inicial, será ajustado para message_size
            bar.pack(side="left", fill="x", expand=True, padx=(4, 4))
            self.progress_bars[stat] = bar
            # Label do valor à direita da barra
            value_lbl = tk.Label(row, text="0", font=("Helvetica", 12, "bold"), bg="black", fg="white", width=2, anchor="e")
            value_lbl.pack(side="left", padx=(4, 0))
            self.progress_labels[stat] = value_lbl

        #Outra alternativa para mostrar os valores abaixo das cartas
        """ # --- Tabela de valores por baixo das cartas ---
        stats_frame = tk.Frame(self, bg="black")
        stats_frame.pack(pady=(4, 0))

        self.stats_value_labels = []  # <-- Adiciona esta linha ANTES do ciclo

        stats_labels = [("To send", "To\nsend"), ("Rxd", "Rxd"), ("Lost", "Lost")]

        for row, (stat_key, stat_label) in enumerate(stats_labels):
            legend = tk.Label(
                stats_frame,
                text=stat_label,
                font=("Helvetica", 12, "bold"),
                bg="black",
                fg="white",
                width=8,
                height=2 if "\n" in stat_label else 1,
                anchor="w"  # <-- Alinha o texto à esquerda dentro do label
            )
            # Espaçamento extra APÓS "To send"
            if stat_key == "To send":
                pady_val = (0, 6)
            elif stat_key == "Rxd":
                pady_val = (0, 6)
            else:
                pady_val = (0, 0)
            legend.grid(row=row, column=0, padx=(0,0), pady=pady_val, sticky="w")  # <-- Alinha o label à esquerda na célula
            row_labels = []
            for col in range(4):
                value = self.card_stats[col][stat_key]
                # Ajusta o deslocamento horizontal de cada coluna:
                if col == 0:
                    col_padx = (0, 4)   # Mais espaço à direita da primeira coluna
                elif col == 3:
                    col_padx = (6, 2)   # Mais espaço à esquerda da última coluna
                else:
                    col_padx = (4, 4)   # Espaço igual entre colunas intermédias

                val_lbl = tk.Label(
                    stats_frame,
                    text=str(value),
                    font=("Helvetica", 12),
                    bg="black",
                    fg="white",
                    width=card_width//10,
                    anchor="w"
                )
                val_lbl.grid(row=row, column=col+1, padx=col_padx, pady=pady_val, sticky="w")
                row_labels.append(val_lbl)
            self.stats_value_labels.append(row_labels)

        # Ajuste o grid para expandir igualmente
        for col in range(1, 5):
            stats_frame.grid_columnconfigure(col, weight=1)
            cards_container.grid_columnconfigure(col-1, weight=1) """

        # NOTA: Botão End Turn agora é criado dinamicamente apenas quando necessário
        # Não criar botão End Turn aqui para evitar conflitos com o sistema de gestão de pacotes

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Saldo no canto inferior direito (sobre a BelowBar) - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, saldo))

        # Botão Next Phase OU Final Phase (cinza) na parte inferior central - criado no final para ficar visível
        # Verificar qual botão mostrar baseado no estado atual
        if getattr(self, '_next_phase_active', False) and not getattr(self, '_final_phase_active', False):
            # Next Phase já foi ativado mas Final Phase ainda não, mostrar botão Final Phase
            self._criar_botao_final_phase()
        elif getattr(self, '_final_phase_active', False) and getattr(self, '_show_end_turn_button', False):
            # Final Phase já foi ativado E o botão Final Phase já foi clicado, mostrar botão End Turn
            print("DEBUG: Final Phase ativo e botão Final Phase foi clicado - mostrando botão End Turn")
            
            # CORREÇÃO CRÍTICA: Usar o método _criar_botao_end_turn() que chama self.end_turn() corretamente
            # Este método já faz tudo: incrementa contadores, preserva estado, reseta flags
            self._criar_botao_end_turn()
            
            # CORREÇÃO CRÍTICA: Usar o método _criar_botao_end_turn() que chama self.end_turn() corretamente
            # NÃO redefinir end_turn_action aqui - usar a implementação correta
            self._criar_botao_end_turn()
        else:
            # Next Phase ainda não foi ativado, verificar se deve mostrar botão Next Phase
            # LÓGICA CORRETA:
            # - Se Challenge pendente (navegação Player) → NÃO mostrar Next Phase, mostrar Store
            # - Se Challenge aceite (decisão Accept/Reject) → mostrar Next Phase, NÃO mostrar Store  
            # - Se navegação normal → mostrar Next Phase
            
            challenge_foi_aceite = getattr(self, '_challenge_accepted', False)
            store_button_disabled = getattr(self, '_store_button_disabled', False)
            challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                            hasattr(self, '_store_challenge_carta_tipo') and
                                            self._store_challenge_carta_tipo == "challenges")
            
            print(f"DEBUG: [INTERFACE] Verificação para mostrar Next Phase:")
            print(f"DEBUG: [INTERFACE]   _challenge_accepted: {challenge_foi_aceite}")
            print(f"DEBUG: [INTERFACE]   _store_button_disabled: {store_button_disabled}")
            print(f"DEBUG: [INTERFACE]   challenge_pendente_transferido: {challenge_pendente_transferido}")
            
            # LÓGICA CORRIGIDA: 
            # - Se Challenge pendente (Player button) → NÃO mostrar Next Phase
            # - Se Challenge aceite (Accept/Reject) → mostrar Next Phase
            # - Caso contrário → mostrar Next Phase
            if challenge_pendente_transferido:
                print("DEBUG: Challenge pendente via navegação (Player button) - Next Phase NÃO mostrado")
            elif challenge_foi_aceite or store_button_disabled:
                print("DEBUG: Challenge aceite via decisão (Accept/Reject) - Next Phase mostrado")
                # Mostrar Next Phase quando Challenge foi aceite
                self._criar_botao_next_phase()
            else:
                print("DEBUG: Navegação normal - Next Phase mostrado")
                # Mostrar Next Phase em navegação normal
                self._criar_botao_next_phase()

        # NOTA: As listas de cartas ativas (active_challenge, active_users, etc.) 
        # já estão inicializadas no __init__ do PlayerDashboard
        
        # IMPORTANTE: Atualizar destaques do carrossel no final da criação da interface
        # Isso garante que os destaques roxos apareçam corretamente quando Next Phase está ativo
        # CORREÇÃO: Usar delay para garantir que widgets estão completamente criados
        def atualizar_destaques_com_delay():
            if hasattr(self, 'card_labels') and self.card_labels:
                # Verificar se todos os widgets estão válidos antes de atualizar
                widgets_validos = True
                for i, lbl in enumerate(self.card_labels):
                    try:
                        if not lbl.winfo_exists():
                            widgets_validos = False
                            break
                    except tk.TclError:
                        widgets_validos = False
                        break
                
                if widgets_validos:
                    self._update_carousel_highlights()
                    print("DEBUG: Destaques do carrossel atualizados no final da criação da interface")
                else:
                    print("DEBUG: ⚠️ Widgets ainda não estão prontos - pulando atualização de destaques")
            else:
                print("DEBUG: ⚠️ card_labels não existe - pulando atualização de destaques")
        
        # Usar delay pequeno para garantir que widgets estão estabilizados
        self.after(150, atualizar_destaques_com_delay)
        
        # CORREÇÃO: Restaurar barras de progresso se há carta selecionada
        # Isso resolve o problema das barras ficarem zeradas ao voltar de páginas de inventário
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            carta_atual = self.cards[self.selected_carousel_index] 
            carta_index = self.selected_carousel_index
            
            print(f"DEBUG: Restaurando barras para carta REAL do carrossel: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar diferença se existe
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: ⚠️ CORREÇÃO APLICADA:")
                    print(f"DEBUG:   Carta preservada (ERRADA): {carta_preservada}")
                    print(f"DEBUG:   Carta real (CORRETA): {carta_real}")
            
            # CORREÇÃO: Usar índice correto e verificar valores preservados
            if carta_index < len(self.card_stats):
                preserved_stats = self.card_stats[carta_index]
                print(f"DEBUG: Stats disponíveis para carta {carta_index}: {preserved_stats}")
                
                # CORREÇÃO CRÍTICA: Sempre aplicar valores preservados se existirem
                # Em gestão de pacotes, os valores preservados são sempre válidos
                gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
                if gestao_ativa or any(val > 0 for val in preserved_stats.values()):
                    print(f"DEBUG: Aplicando valores preservados para carta {carta_index} (gestão_ativa={gestao_ativa})")
                    self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_atual)
                    
                    # FORÇA refresh visual adicional para garantir que valores aparecem
                    self.after(50, self._force_visual_refresh)
                else:
                    print(f"DEBUG: Valores preservados estão todos a zero - usando base de dados")
                    self._update_progress_bars_from_card(carta_atual)
            else:
                print(f"DEBUG: Índice {carta_index} fora do range de card_stats")
                self._update_progress_bars_from_card(carta_atual)
        else:
            print("DEBUG: Nenhuma carta selecionada no carrossel - barras ficam com valores padrão")
    
    def create_coin_saldo_overlay(self, screen_width, screen_height, saldo):
        """Cria o overlay do coin e saldo por cima de todos os outros elementos"""
        try:
            coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
            coin_lbl.image = coin_img  # type: ignore[attr-defined]
            coin_lbl.place(x=screen_width-100, y=screen_height-45)
            coin_lbl.lift()  # Garante que fica por cima
            
            saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
            saldo_lbl.place(x=screen_width-70, y=screen_height-45)
            saldo_lbl.lift()  # Garante que fica por cima
        except Exception as e:
            print(f"DEBUG: Erro ao criar overlay coin/saldo: {e}")
    
    def update_progress_bars_for_card(self, card_idx):
        """Atualiza as barras de progresso com base nos valores do card_stats"""
        try:
            if not hasattr(self, 'card_stats') or card_idx >= len(self.card_stats):
                print(f"DEBUG: update_progress_bars_for_card - Índice inválido: {card_idx}")
                return
                
            stats = self.card_stats[card_idx]
            print(f"DEBUG: update_progress_bars_for_card - Atualizando carta {card_idx}: {stats}")
            
            # CORREÇÃO: Obter message_size da carta atual e aplicar como máximo para TODAS as barras
            if hasattr(self, 'cards') and card_idx < len(self.cards):
                carta_path = self.cards[card_idx]
                message_size = self._get_card_message_size_from_database(carta_path)
                print(f"DEBUG: update_progress_bars_for_card - Message size: {message_size}")
                
                # Aplicar message_size como máximo para todas as barras (precisão visual)
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        try:
                            # CORREÇÃO CRÍTICA: Verificar se o widget ainda existe antes de configurar
                            if self.progress_bars[stat].winfo_exists():
                                self.progress_bars[stat]["maximum"] = message_size
                                print(f"DEBUG: update_progress_bars_for_card - Máximo da barra '{stat}' definido para {message_size}")
                            else:
                                print(f"DEBUG: update_progress_bars_for_card - Widget progress bar '{stat}' foi destruído, pulando")
                        except tk.TclError as e:
                            print(f"DEBUG: update_progress_bars_for_card - Erro TclError na barra '{stat}': {e}")
                            print(f"DEBUG: update_progress_bars_for_card - Widget foi destruído, cancelando atualização")
                            return
            
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars and stat in self.progress_labels:
                    try:
                        # CORREÇÃO CRÍTICA: Verificar se os widgets ainda existem antes de atualizar
                        if (self.progress_bars[stat].winfo_exists() and 
                            self.progress_labels[stat].winfo_exists()):
                            value = stats[stat]
                            self.progress_bars[stat]["value"] = value
                            self.progress_labels[stat]["text"] = str(value)
                            
                            # Forçar atualização visual
                            self.progress_bars[stat].update_idletasks()
                            self.progress_labels[stat].update_idletasks()
                        else:
                            print(f"DEBUG: update_progress_bars_for_card - Widgets '{stat}' foram destruídos, pulando")
                    except tk.TclError as e:
                        print(f"DEBUG: update_progress_bars_for_card - Erro TclError ao atualizar '{stat}': {e}")
                        print(f"DEBUG: update_progress_bars_for_card - Widgets foram destruídos, cancelando resto da atualização")
                        return
            
            # Forçar atualização da interface principal
            self.update_idletasks()
            print(f"DEBUG: update_progress_bars_for_card - Atualização visual completa")
            
        except Exception as e:
            print(f"DEBUG: Erro em update_progress_bars_for_card: {e}")
            import traceback
            traceback.print_exc()
        

    def update_card_image(self):
        for i, lbl in enumerate(self.card_labels):
            idx = (self.card_idx + i) % len(self.cards)
            img = ImageTk.PhotoImage(Image.open(self.cards[idx]).resize((85,120)))
            lbl.config(image=img)
            lbl.image = img
            # CORREÇÃO: Usar _select_carousel_card em vez de make_card_callback
            # e passar o índice correto do carrossel
            carousel_index = idx
            carta_path = self.cards[idx]
            lbl.bind("<Button-1>", lambda e, ci=carousel_index, cp=carta_path: self._select_carousel_card(ci, cp))

    def prev_card(self):
        self.card_idx = (self.card_idx - 1) % len(self.cards)
        self.update_card_image()

    def next_card(self):
        self.card_idx = (self.card_idx + 1) % len(self.cards)
        self.update_card_image()

    def add_progress_bar(self, parent, label, value):
        fr = tk.Frame(parent, bg="black")
        fr.pack(pady=2, anchor="w", fill="x", expand=True)
        tk.Label(fr, text=label, font=("Helvetica", 14), bg="black", fg="white", width=8, anchor="w").pack(side=tk.LEFT)
        pb = ttk.Progressbar(fr, length=160, maximum=10, value=value)
        pb.pack(side=tk.LEFT, padx=8, fill="x", expand=True)
        value_lbl = tk.Label(fr, text=str(value), font=("Helvetica", 14), bg="black", fg="white", width=2)
        value_lbl.pack(side=tk.LEFT)
        self.progress_bars[label] = pb  # Guarda referência
        if not hasattr(self, "progress_labels"):
            self.progress_labels = {}
        self.progress_labels[label] = value_lbl  # Guarda referência à label do valor

    def try_mostrar_carta(self, path):
        try:
            print("CLICOU!", path)
            idx = self.cards.index(path)
            mostrar_carta_fullscreen_root(self.master, path, selected_card_idx=idx)
        except Exception as ex:
            print("ERRO AO ABRIR FULLSCREEN:", ex)

    def activate_card(self, card_type, card_path):
        # CORREÇÃO: Permitir ativação de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser ativadas antes de Next Phase e permanecem ativas entre turnos
        
        # IMPORTANTE: Não pode ativar cartas após Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de ativar carta {card_type} BLOQUEADA - Final Phase está ativo")
            return
        
        if card_type == "challenge":
            # Só pode haver 1 challenge ativo
            if self.active_challenge:
                self.discard_card(self.active_challenge)
            self.active_challenge = card_path
            self.show_card_active(card_path)
        elif card_type == "user" or card_type == "users":
            # Máximo de 4 users ativos (apenas Users têm limite)
            if card_path not in self.active_users:
                if len(self.active_users) < self.max_users:
                    self.active_users.append(card_path)
                    self.show_card_active(card_path)
                    print(f"DEBUG: User ativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                    # IMPORTANTE: Atualizar destaques do carrossel quando User é ativado
                    self._update_carousel_highlights()
                else:
                    # Opcional: feedback ao jogador que já tem 4 users
                    print("Já tens 4 users ativos!")
        elif card_type == "equipment" or card_type == "equipments":
            # SEM LIMITE para equipments após Next Phase
            if card_path not in self.active_equipments:
                self.active_equipments.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Equipment ativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type == "service" or card_type == "services":
            # SEM LIMITE para services após Next Phase
            if card_path not in self.active_services:
                self.active_services.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Service ativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")
                
                # NOVO: Adicionar tracking para serviços TEMPORARY
                self._register_service_start_turn(card_path)
    
    def is_card_active(self, card_path, card_type):
        """Verifica se uma carta está ativa"""
        if card_type == "challenge":
            return self.active_challenge == card_path
        elif card_type in ["user", "users"]:
            return card_path in self.active_users
        elif card_type in ["equipment", "equipments"]:
            return card_path in self.active_equipments
        elif card_type in ["service", "services"]:
            return card_path in self.active_services
        return False
    
    def deactivate_card(self, card_path, card_type):
        """Desativa uma carta"""
        # CORREÇÃO: Permitir desativação de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser desativadas antes de Next Phase e o estado é preservado entre turnos
        
        # IMPORTANTE: Não pode desativar cartas após Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de desativar carta {card_type} BLOQUEADA - Final Phase está ativo")
            return
        
        if card_type == "challenge":
            if self.active_challenge == card_path:
                self.active_challenge = None
                print(f"DEBUG: Challenge desativado: {os.path.basename(card_path)}")
        elif card_type in ["user", "users"]:
            if card_path in self.active_users:
                self.active_users.remove(card_path)
                print(f"DEBUG: User desativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                # IMPORTANTE: Atualizar destaques do carrossel quando User é desativado
                self._update_carousel_highlights()
        elif card_type in ["equipment", "equipments"]:
            if card_path in self.active_equipments:
                self.active_equipments.remove(card_path)
                print(f"DEBUG: Equipment desativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type in ["service", "services"]:
            if card_path in self.active_services:
                self.active_services.remove(card_path)
                print(f"DEBUG: Service desativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")

    def discard_card(self, card_path):
        # Remove visualmente/desativa o challenge anterior
        pass

    def show_card_active(self, card_path):
        # Atualiza visualmente a carta como ativa
        pass
    
    def _limpar_cartas_actions_events_incorretas(self):
        """
        Remove cartas Actions/Events que foram incorretamente adicionadas ao inventário
        quando deveriam ter sido enviadas para outros jogadores.
        
        Cartas que devem ser removidas:
        - Actions com target diferente do jogador atual
        - Events com target_player diferente do jogador atual (exceto player_choice=True)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [_limpar_cartas_incorretas] Base de dados não disponível - não é possível limpar")
            return
        
        player_color = self.player_color.lower()
        cartas_para_remover = []
        
        # Verificar cartas Actions
        for carta_path in self.inventario.get("actions", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Action_(\d+)\.', filename)
                if match:
                    card_id = f"action_{match.group(1)}"
                    card_data = self.card_database.get_action(card_id)
                    if card_data:
                        target = getattr(card_data, 'target', None)
                        # Se target não é None e não é igual ao jogador atual, remover
                        if target is not None and target != player_color:
                            cartas_para_remover.append(('actions', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Action para remoção: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Action {filename}: {e}")
        
        # Verificar cartas Events
        for carta_path in self.inventario.get("events", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Event_(\d+)\.', filename)
                if match:
                    card_id = f"event_{match.group(1)}"
                    card_data = self.card_database.get_event(card_id)
                    if card_data:
                        target = getattr(card_data, 'target_player', None)
                        player_choice = getattr(card_data, 'player_choice', False)
                        # Se target não é None, não é igual ao jogador atual e player_choice é False, remover
                        if target is not None and target != player_color and not player_choice:
                            cartas_para_remover.append(('events', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Event para remoção: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Event {filename}: {e}")
        
        # Remover cartas identificadas
        cartas_removidas = 0
        for tipo, carta_path, target in cartas_para_remover:
            try:
                self.inventario[tipo].remove(carta_path)
                cartas_removidas += 1
                print(f"DEBUG: [_limpar_cartas_incorretas] ✅ Removida: {os.path.basename(carta_path)} (tipo={tipo}, target={target})")
            except ValueError:
                print(f"DEBUG: [_limpar_cartas_incorretas] ❌ Erro: carta não encontrada no inventário: {os.path.basename(carta_path)}")
        
        if cartas_removidas > 0:
            print(f"DEBUG: [_limpar_cartas_incorretas] Total de cartas removidas: {cartas_removidas}")
        else:
            print(f"DEBUG: [_limpar_cartas_incorretas] Nenhuma carta incorreta encontrada para remoção")

    def adicionar_carta_inventario(self, carta_path, carta_tipo):
        if carta_tipo in self.inventario:
            self.inventario[carta_tipo].append(carta_path)
            # Se for uma carta User, atualizar destaques do carrossel
            if carta_tipo == "users":
                # Aguardar um momento para garantir que a carta foi adicionada
                self.after(100, self._update_carousel_highlights)
            
            # Se for uma carta Event, registrar no tracking mas só ativar se for posição 0
            if carta_tipo == "events":
                current_turn = getattr(self, '_current_turn', 0)
                
                # Obter duration_turns da carta
                from cards_database import get_event_duration
                duration_turns = get_event_duration(carta_path)
                
                if duration_turns is not None:
                    # Verificar se este Event será o primeiro na fila (posição 0)
                    cartas_events = self.inventario.get("events", [])
                    is_first_event = len(cartas_events) == 0  # Se não há Events, este será o primeiro
                    
                    if is_first_event:
                        # Event vai para posição 0 - ativar imediatamente
                        self._event_start_turns[carta_path] = current_turn
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': current_turn,
                            'duration_turns': duration_turns,
                            'expires_turn': current_turn + duration_turns,
                            'is_active': True  # Marcador para indicar que está ativo
                        }
                        print(f"DEBUG: [ADD_EVENT] Event adicionado na posição 0 (ativo): {os.path.basename(carta_path)}")
                    else:
                        # Event vai para fila - não ativar ainda
                        self._event_start_turns[carta_path] = None  # Não ativo ainda
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': None,  # Será definido quando mover para posição 0
                            'duration_turns': duration_turns,
                            'expires_turn': None,  # Será calculado quando ativar
                            'is_active': False  # Em fila, não ativo
                        }
                        print(f"DEBUG: [ADD_EVENT] Event adicionado na fila (inativo): {os.path.basename(carta_path)}")
                        
                self._ensure_active_event_tracking()

    def _ensure_active_event_tracking(self):
        """
        Garante que apenas o Event na posição 0 está ativo e contando tempo.
        Ativa o próximo Event na fila quando necessário.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return
            
        cartas_events = self.inventario.get("events", [])
        if not cartas_events:
            return
            
        current_turn = getattr(self, '_current_turn', 0)
        event_do_topo = cartas_events[0]
        
        # Verificar se o Event do topo está ativo
        if (event_do_topo in self._event_duration_tracking and 
            self._event_duration_tracking[event_do_topo].get('is_active', False) == False):
            
            # Ativar o Event do topo
            duration_turns = self._event_duration_tracking[event_do_topo]['duration_turns']
            
            # CORREÇÃO: Verificar se é duração variável
            if duration_turns == "variable":
                # Para Events com duração variável, não calcular expires_turn ainda
                # Será calculado apenas quando o dado for lançado
                self._event_duration_tracking[event_do_topo].update({
                    'start_turn': current_turn,
                    'expires_turn': None,  # Será definido após o dado
                    'is_active': True
                })
                print(f"DEBUG: [ACTIVATE_EVENT] Event ativado na posição 0: {os.path.basename(event_do_topo)}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Turno início: {current_turn}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Duration: {duration_turns} (será determinada por dado)")
                print(f"DEBUG: [ACTIVATE_EVENT]   Expira no turno: A ser determinado")
            else:
                # Para Events com duração fixa
                self._event_duration_tracking[event_do_topo].update({
                    'start_turn': current_turn,
                    'expires_turn': current_turn + duration_turns,
                    'is_active': True
                })
                print(f"DEBUG: [ACTIVATE_EVENT] Event ativado na posição 0: {os.path.basename(event_do_topo)}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Turno início: {current_turn}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Duration: {duration_turns}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Expira no turno: {current_turn + duration_turns}")
            
            self._event_start_turns[event_do_topo] = current_turn
        
        # Garantir que Events em outras posições permanecem inativos
        for i, carta_path in enumerate(cartas_events[1:], 1):  # Começar do índice 1
            if carta_path in self._event_duration_tracking:
                if self._event_duration_tracking[carta_path].get('is_active', False) == True:
                    # Desativar Events que não estão na posição 0
                    self._event_duration_tracking[carta_path].update({
                        'start_turn': None,
                        'expires_turn': None,
                        'is_active': False
                    })
                    self._event_start_turns[carta_path] = None
                    print(f"DEBUG: [DEACTIVATE_EVENT] Event desativado na posição {i}: {os.path.basename(carta_path)}")

    def _verificar_events_expirados(self):
        """
        Verifica automaticamente Events expirados e remove-os do inventário,
        devolvendo-os à Store.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return
        
        current_turn = getattr(self, '_current_turn', 0)
        events_para_remover = []
        
        print(f"DEBUG: Verificando Events expirados no turno {current_turn}")
        
        # GARANTIR que o tracking está correto antes de verificar expiração
        self._ensure_active_event_tracking()
        
        for carta_path, event_data in self._event_duration_tracking.items():
            is_active = event_data.get('is_active', False)
            start_turn = event_data.get('start_turn')
            duration_turns = event_data.get('duration_turns')
            
            # Só verificar expiração para Events ativos
            if is_active and start_turn is not None and duration_turns is not None:
                expires_turn = start_turn + duration_turns  # expira após duration_turns turnos
                
                print(f"DEBUG: Event {os.path.basename(carta_path)} (ativo) - start: {start_turn}, duration: {duration_turns}, expires: {expires_turn}")
                
                if current_turn >= expires_turn:
                    print(f"DEBUG: Event {os.path.basename(carta_path)} expirou (turno {current_turn} >= {expires_turn})")
                    # NOVO: Mostrar overlay de expiração em vez de processar automaticamente
                    self._mostrar_overlay_event_expirado(carta_path)
                    return  # Sair após mostrar o primeiro overlay (processar um de cada vez)
            else:
                print(f"DEBUG: Event {os.path.basename(carta_path)} (inativo) - ignorando verificação de expiração")
        
        # CÓDIGO LEGADO COMENTADO: Processamento automático removido em favor de overlays
        # O processamento agora é feito através do overlay mostrado acima
        """
        # Remover Events expirados
        for carta_path in events_para_remover:
            try:
                # Remover da lista de Events no inventário
                if carta_path in self.inventario.get("events", []):
                    self.inventario["events"].remove(carta_path)
                    print(f"DEBUG: Event {os.path.basename(carta_path)} removido do inventário")
                
                # Remover do tracking
                if carta_path in self._event_duration_tracking:
                    del self._event_duration_tracking[carta_path]
                if carta_path in self._event_start_turns:
                    del self._event_start_turns[carta_path]
                
                # Adicionar de volta à Store usando Store_v2
                try:
                    from Store_v2 import adicionar_carta_store
                    adicionar_carta_store(carta_path, "events")
                    print(f"DEBUG: Event {os.path.basename(carta_path)} devolvido à Store automaticamente")
                except ImportError:
                    print("DEBUG: Erro - Store_v2 não encontrado para devolução automática")
                except Exception as e:
                    print(f"DEBUG: Erro ao devolver Event à Store automaticamente: {e}")
                    
            except Exception as e:
                print(f"DEBUG: Erro ao processar Event expirado {carta_path}: {e}")
        
        # ATIVAR próximo Event na fila após remoções
        if events_para_remover:
            self._ensure_active_event_tracking()
            print(f"DEBUG: {len(events_para_remover)} Events expirados removidos automaticamente")
        else:
            print("DEBUG: Nenhum Event expirado encontrado")
        """
        
        print("DEBUG: Verificação de Events expirados concluída (usando overlay quando necessário)")

    def show_inventory_page(self, carta_tipo):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        screen_width = self.winfo_screenwidth()
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"),
                         fg="black", bg=self.bar_color)
        title.place(relx=0.5, y=65, anchor="n")

        # Mostra as cartas desse tipo
        cartas = self.inventario.get(carta_tipo, [])
        if cartas:
            carta_path = cartas[-1]  # Mostra a última carta tirada
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((180, 260)))
            carta_lbl = tk.Label(self, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.place(relx=0.5, rely=0.4, anchor="center")

            def abrir_fullscreen(event=None):
                self.show_card_fullscreen(carta_path, carta_tipo)
            carta_lbl.bind("<Button-1>", abrir_fullscreen)
        else:
            tk.Label(self, text="Sem cartas!", font=("Helvetica", 16), bg="black", fg="white").place(relx=0.5, rely=0.5, anchor="center")

        # Botão seta para voltar (usando X_button.png como fallback para arrow_left.png)
        try:
            # Tentar carregar arrow_left.png primeiro
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((48, 48)))
        except FileNotFoundError:
            # Fallback para X_button.png se arrow_left.png não existir
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "X_button.png")).resize((48, 48)))
        seta_btn = tk.Button(
            self,
            image=seta_img,
            bg="black",
            borderwidth=0,
            command=lambda: self.show_dice_roll_screen(
                self.player_name,
                self.saldo,
                self.other_players,
                self.screen_width,
                self.screen_height
            )
        )
        seta_btn.image = seta_img  # type: ignore[attr-defined]
        seta_btn.place(x=10, rely=0.9*self.winfo_screenheight(), anchor="sw")

        # Se Next Phase estiver ativo, desabilitar vendas nesta página
        if getattr(self, '_next_phase_active', False):
            self._disable_inventory_sales()
    def _disable_inventory_sales(self):
        """Desativa botões ou funcionalidades de venda nas páginas de inventário."""
        # Aqui você pode implementar a lógica para desabilitar/remover botões de venda
        # Exemplo: desabilitar todos os botões de venda se existirem
        for widget in self.winfo_children():
            if isinstance(widget, tk.Button) and getattr(widget, 'is_sell_button', False):
                widget.config(state='disabled')

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((self.screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada na página de inventário")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png na página de inventário: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

    def show_card_fullscreen(self, carta_path, carta_tipo):
        print("DEBUG: PlayerDashboard.show_card_fullscreen chamado")
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black")
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

        # Botão X para fechar
        x_img_path = os.path.join(IMG_DIR, "X_button.png")
        x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
        x_btn = tk.Label(self, image=x_img, bg="black", cursor="hand2")
        x_btn.image = x_img  # type: ignore[attr-defined]
        x_btn.place(relx=0.98, rely=0.02, anchor="ne")

        def fechar():
            # Limpa tudo menos a barra superior
            for widget in self.winfo_children():
                if widget == self.topbar_label:
                    continue
                widget.destroy()
            # Redesenha a interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

        x_btn.bind("<Button-1>", lambda e: fechar())

        # Verificar se é uma carta Event expirada durante Next Phase
        if (carta_tipo == "events" and 
            getattr(self, '_next_phase_active', False) and 
            carta_path in self._event_duration_tracking):
            
            current_turn = getattr(self, '_current_turn', 0)
            event_data = self._event_duration_tracking[carta_path]
            
            # Se a carta expirou (current_turn >= expires_turn)
            if current_turn >= event_data['expires_turn']:
                # Botão certo vermelho para devolver à Store (mesmo formato que botão de desativação)
                red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def devolver_event_para_store():
                    print(f"DEBUG: Devolvendo Event {carta_path} para a Store")
                    
                    # Remover da lista de Events no inventário
                    if carta_path in self.inventario.get("events", []):
                        self.inventario["events"].remove(carta_path)
                    
                    # Remover do tracking
                    if carta_path in self._event_duration_tracking:
                        del self._event_duration_tracking[carta_path]
                    if carta_path in self._event_start_turns:
                        del self._event_start_turns[carta_path]
                    
                    # Adicionar de volta à Store usando Store_v2
                    try:
                        from Store_v2 import adicionar_carta_store
                        adicionar_carta_store(carta_path, "events")
                        print(f"DEBUG: Event {carta_path} devolvido à Store com sucesso")
                    except ImportError:
                        print("DEBUG: Erro - Store_v2 não encontrado")
                    except Exception as e:
                        print(f"DEBUG: Erro ao devolver Event à Store: {e}")
                    
                    # Fechar fullscreen e voltar ao inventário
                    fechar()
                
                red_check_btn.config(command=devolver_event_para_store)

        # Verificar se é uma carta Service expirada
        print(f"DEBUG: [FULLSCREEN_SERVICE] Verificando expiração para carta tipo '{carta_tipo}' - {os.path.basename(carta_path)}")
        if carta_tipo == "services":
            print(f"DEBUG: [FULLSCREEN_SERVICE] É uma carta Service - verificando se está expirada...")
            is_expired = self._is_service_expired(carta_path)
            print(f"DEBUG: [FULLSCREEN_SERVICE] Resultado da verificação de expiração: {is_expired}")
            
            if is_expired:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service EXPIRADO - criando botão vermelho de expiração")
                # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def mostrar_overlay_expiracao():
                    print(f"DEBUG: Mostrando overlay de expiração para Service {carta_path}")
                    self._mostrar_overlay_service_expirado(carta_path)
                
                red_check_btn.config(command=mostrar_overlay_expiracao)
                return  # Não criar outros botões se o Service expirou
            else:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service NÃO expirado - continuando com lógica normal")

    # ===============================
    # SISTEMA DE GESTÃO DE PACOTES
    # ===============================
    
    def _preservar_valores_atuais_barras(self):
        """
        CORREÇÃO CRÍTICA: Preserva os valores atuais das barras de progresso
        antes de iniciar o Final Phase. Este método preserva os valores
        específicos de cada carta individual, não apenas da carta selecionada.
        """
        print("DEBUG: ===== PRESERVANDO VALORES ATUAIS DAS BARRAS =====")
        
        if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
            print("DEBUG: ⚠️ Barras de progresso não encontradas para preservação")
            return
        
        if not hasattr(self, 'card_stats'):
            print("DEBUG: ⚠️ card_stats não existe, criando...")
            self.card_stats = [
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
            ]
        
        # CORREÇÃO CRÍTICA: Preservar valores únicos para cada carta ativa
        print("DEBUG: INICIANDO preservação individual de cada carta...")
        
        try:
            # ETAPA 1: Capturar valores da carta atualmente selecionada/visível
            carta_selecionada_idx = getattr(self, 'selected_carousel_index', None)
            
            if carta_selecionada_idx is not None:
                # CORREÇÃO PROBLEMA 1: Verificar se barras estão válidas antes de capturar
                try:
                    to_send_selecionada = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_selecionada = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_selecionada = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # CORREÇÃO PROBLEMA 1: Se valores são zeros no primeiro turno, obter da base de dados
                    if to_send_selecionada == 0 and rxd_selecionada == 0 and lost_selecionada == 0:
                        carta_path = self.cards[carta_selecionada_idx]
                        message_size = self._get_card_message_size_from_database(carta_path)
                        to_send_selecionada = message_size
                        print(f"DEBUG: CORREÇÃO PROBLEMA 1 - Carta {carta_selecionada_idx} valores zero detectados")
                        print(f"DEBUG: Usando message_size da base de dados: {message_size}")
                    
                    # Preservar para a carta selecionada
                    if carta_selecionada_idx < len(self.card_stats):
                        self.card_stats[carta_selecionada_idx] = {
                            "To send": to_send_selecionada,
                            "Rxd": rxd_selecionada,
                            "Lost": lost_selecionada
                        }
                        print(f"DEBUG: ✅ Carta selecionada {carta_selecionada_idx} preservada:")
                        print(f"DEBUG:   To send: {to_send_selecionada}, Rxd: {rxd_selecionada}, Lost: {lost_selecionada}")
                except Exception as e:
                    print(f"DEBUG: ⚠️ Erro ao capturar valores da carta selecionada: {e}")
            
            # ETAPA 2: Para cartas não selecionadas, preservar valores existentes ou calcular padrões
            print("DEBUG: Verificando outras cartas do carrossel...")
            
            for i, carta_path in enumerate(self.cards):
                if i < len(self.card_stats):
                    carta_basename = os.path.basename(carta_path)
                    
                    # Pular cartas viradas para baixo
                    if carta_basename.startswith("back_card_"):
                        continue
                    
                    # Se esta carta não é a selecionada e ainda não tem valores preservados
                    if i != carta_selecionada_idx:
                        stats_atuais = self.card_stats[i]
                        
                        # CORREÇÃO PROBLEMA 1: Se esta carta ainda não tem valores válidos, calcular da base de dados
                        if (stats_atuais["To send"] == 0 and 
                            stats_atuais["Rxd"] == 0 and 
                            stats_atuais["Lost"] == 0):
                            
                            message_size = self._get_card_message_size_from_database(carta_path)
                            
                            # Valores padrão: carta não processada ainda
                            self.card_stats[i] = {
                                "To send": message_size,  # CORREÇÃO: Usar message_size correto
                                "Rxd": 0,
                                "Lost": 0
                            }
                            print(f"DEBUG: ✅ Carta {i} inicializada com valores padrão da base de dados:")
                            print(f"DEBUG:   To send: {message_size}, Rxd: 0, Lost: 0")
                        else:
                            print(f"DEBUG: ✅ Carta {i} já tem valores preservados:")
                            print(f"DEBUG:   To send: {stats_atuais['To send']}, Rxd: {stats_atuais['Rxd']}, Lost: {stats_atuais['Lost']}")
            
            print("DEBUG: ===== PRESERVAÇÃO INDIVIDUAL CONCLUÍDA =====")
            print(f"DEBUG: Estado final do card_stats:")
            for i, stats in enumerate(self.card_stats):
                carta_nome = os.path.basename(self.cards[i]) if i < len(self.cards) else "N/A"
                print(f"DEBUG:   Carta {i} ({carta_nome}): {stats}")
                
        except Exception as e:
            print(f"DEBUG: ❌ Erro ao preservar valores das barras: {e}")
            import traceback
            traceback.print_exc()
    
    def _iniciar_gestao_pacotes(self):
        """Inicia o sistema de gestão de pacotes no Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Iniciando sistema de gestão de pacotes")
        
        # Encontrar cartas ativas no carrossel
        cartas_ativas = self._obter_cartas_ativas_carrossel()
        print(f"DEBUG: [GESTÃO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        
        if not cartas_ativas:
            print("DEBUG: [GESTÃO_PACOTES] Nenhuma carta ativa encontrada no carrossel")
            # CORREÇÃO: Garantir que gestão de pacotes não é ativada
            self._final_phase_gestao_ativa = False
            print("DEBUG: [GESTÃO_PACOTES] Flag _final_phase_gestao_ativa definida como False")
            # Se não há cartas ativas, ativar botão End Turn imediatamente
            self._ativar_botao_end_turn()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] {len(cartas_ativas)} cartas ativas encontradas")
        
        # IMPORTANTE: Só ativar gestão se realmente há cartas ativas
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GESTÃO_PACOTES] Flag _final_phase_gestao_ativa ativada (cartas encontradas)")
        
        # Inicializar variáveis de controle
        self._cartas_gestao = cartas_ativas
        self._carta_atual_gestao = 0
        self._valores_pacotes = {}  # Armazenar valores enviados/perdidos por carta
        
        # Inicializar valores para cada carta
        for i, carta_path in enumerate(cartas_ativas):
            self._valores_pacotes[i] = {'enviados': 0, 'perdidos': 0}
        
        # Mostrar destaque na primeira carta e controles de gestão
        self._mostrar_gestao_carta_atual()
        
        # NOVO: Remover destaques da cor do jogador e bloquear interações
        self._bloquear_interacoes_carrossel()
    
    def _bloquear_interacoes_carrossel(self):
        """Remove destaques da cor do jogador e bloqueia cliques durante Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Bloqueando interações do carrossel")
        
        # CORREÇÃO 1: Garantir que o destaque roxo seja preservado
        # Verificar qual carta tem destaque roxo antes de remover outros destaques
        carta_roxo_posicao = getattr(self, '_carta_destacada_posicao', None)
        print(f"DEBUG: [GESTÃO_PACOTES] Preservando destaque roxo na posição: {carta_roxo_posicao}")
        
        # Remover TODOS os destaques da cor do jogador das cartas
        # EXCETO a carta que tem destaque roxo (carta de gestão atual)
        if hasattr(self, 'card_labels') and self.card_labels:
            for i, lbl in enumerate(self.card_labels):
                if lbl and lbl.winfo_exists():
                    # Verificar se esta carta é a que tem destaque roxo
                    carta_tem_destaque_roxo = (carta_roxo_posicao is not None and i == carta_roxo_posicao)
                    
                    if not carta_tem_destaque_roxo:
                        # Remover TODOS os tipos de destaque da cor do jogador
                        lbl.config(
                            highlightthickness=0,
                            highlightbackground="black",
                            highlightcolor="black",
                            bg="black",
                            borderwidth=0,
                            relief="flat"
                        )
                        print(f"DEBUG: [GESTÃO_PACOTES] Destaque removido da carta posição {i}")
                    else:
                        print(f"DEBUG: [GESTÃO_PACOTES] Preservando destaque roxo na carta posição {i}")
        
        # Também forçar atualização dos destaques através da função normal
        # que agora já considera o Final Phase
        self._update_carousel_selection_highlights()
        
        # Marcar que estamos em modo Final Phase (para bloquear cliques)
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GESTÃO_PACOTES] Interações do carrossel bloqueadas")
    
    def _desbloquear_interacoes_carrossel(self):
        """Restaura o comportamento normal do carrossel após Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Desbloqueando interações do carrossel")
        
        # Desmarcar flag de Final Phase
        self._final_phase_gestao_ativa = False
        
        # Remover destaque roxo se existir
        if hasattr(self, '_carta_destacada_posicao'):
            delattr(self, '_carta_destacada_posicao')
        
        # Restaurar destaques normais das cartas se necessário
        # (Será feito automaticamente quando o usuário navegar no carrossel)
        
        print("DEBUG: [GESTÃO_PACOTES] Interações do carrossel desbloqueadas")
    
    def _restaurar_controles_gestao_apos_fullscreen(self, carta_destacada_posicao):
        """Restaura os controles de gestão após voltar do fullscreen"""
        print(f"DEBUG: [FULLSCREEN] Restaurando controles de gestão após fullscreen")
        
        # Verificar se ainda estamos em gestão ativa
        if not getattr(self, '_final_phase_gestao_ativa', False):
            print(f"DEBUG: [FULLSCREEN] Gestão não está mais ativa - não restaurar controles")
            return
        
        # Verificar se temos dados válidos
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [FULLSCREEN] Dados de gestão inválidos - não restaurar controles")
            return
        
        # Restaurar destaque roxo na posição correta
        if carta_destacada_posicao is not None:
            print(f"DEBUG: [FULLSCREEN] Restaurando destaque roxo na posição {carta_destacada_posicao}")
            self._adicionar_destaque_roxo(carta_destacada_posicao)
        else:
            # Se não temos posição preservada, usar carta atual da gestão
            print(f"DEBUG: [FULLSCREEN] Usando carta atual da gestão para destaque")
            self._mostrar_gestao_carta_atual()
            return
        
        # NOVO: Restaurar valores das barras de progresso antes de mostrar controles
        self._atualizar_barras_gestao_carta_atual()
        
        # CORREÇÃO PROBLEMA 3: Usar estado preservado dos botões + em vez de verificar estado atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        rate_carta = self._obter_rate_carta(carta_atual)
        
        print(f"DEBUG: [FULLSCREEN] Verificando estado preservado dos botões +")
        
        # Verificar se temos estado preservado dos botões + e seta
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        botao_seta_estado = getattr(self, '_botao_seta_estado_preservado', False)
        print(f"DEBUG: [FULLSCREEN] Estado preservado botões +: {botoes_plus_estado}")
        print(f"DEBUG: [FULLSCREEN] Estado preservado botão seta: {botao_seta_estado}")
        
        # CORREÇÃO CRÍTICA: Usar valores específicos dos botões individuais
        btn_rxd_estava_visivel = botoes_plus_estado.get('rxd_visivel', False)
        btn_lost_estava_visivel = botoes_plus_estado.get('lost_visivel', False)
        
        # Se qualquer botão + estava visível antes do fullscreen, restaurá-los especificamente
        if btn_rxd_estava_visivel or btn_lost_estava_visivel:
            print(f"DEBUG: [FULLSCREEN] Botões + estavam visíveis - restaurar controles específicos")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Rxd: {btn_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Lost: {btn_lost_estava_visivel}")
            
            # NOVA FUNÇÃO: Restaurar apenas os botões específicos que estavam visíveis
            self._mostrar_controles_gestao_especificos(rate_carta, 
                                                     mostrar_rxd=btn_rxd_estava_visivel,
                                                     mostrar_lost=btn_lost_estava_visivel)
            print(f"DEBUG: [FULLSCREEN] Botões + específicos restaurados")
        else:
            print(f"DEBUG: [FULLSCREEN] Botões + não estavam visíveis - verificar se botão seta estava visível")
            # Se botão seta estava visível antes do fullscreen, restaurá-lo
            if botao_seta_estado:
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível - restaurar apenas botão seta")
                self._mostrar_botao_seta()
            else:
                print(f"DEBUG: [FULLSCREEN] Nem botões + nem botão seta estavam visíveis - não restaurar controles")
            
        # Limpar estado preservado após usar
        if hasattr(self, '_botoes_plus_estado_preservado'):
            delattr(self, '_botoes_plus_estado_preservado')
        if hasattr(self, '_botao_seta_estado_preservado'):
            delattr(self, '_botao_seta_estado_preservado')
        
        print(f"DEBUG: [FULLSCREEN] Restauração de controles de gestão concluída")
    
    def _obter_cartas_ativas_carrossel(self):
        """Obtém lista de cartas ativas (viradas para cima) no carrossel"""
        cartas_ativas = []
        
        # Verificar cada posição do carrossel usando self.cards
        for i in range(len(self.cards)):
            carta_path = self.cards[i]
            
            # Verificar se não é uma carta virada para baixo (back_card)
            if carta_path and "back_card" not in carta_path:
                carta_basename = os.path.basename(carta_path).lower()
                
                # CORREÇÃO: Para Activities e Challenges no carrossel, considerar ativas se estão viradas para cima
                # Para outros tipos de cartas, verificar as listas de cartas ativas
                carta_esta_ativa = False
                
                if "activity" in carta_basename or "challenge" in carta_basename:
                    # Activities e Challenges no carrossel são consideradas ativas se estão viradas para cima
                    carta_esta_ativa = True
                    print(f"DEBUG: [GESTÃO_PACOTES] Activity/Challenge virada para cima posição {i}: {os.path.basename(carta_path)}")
                else:
                    # Para outros tipos (Users, Equipments, Services), verificar listas de cartas ativas
                    if (carta_path in getattr(self, 'active_users', []) or
                        carta_path in getattr(self, 'active_equipments', []) or 
                        carta_path in getattr(self, 'active_services', []) or
                        carta_path == getattr(self, 'active_challenge', None)):
                        carta_esta_ativa = True
                        print(f"DEBUG: [GESTÃO_PACOTES] Carta ativa nas listas posição {i}: {os.path.basename(carta_path)}")
                
                # Só adicionar se estiver ativa E o jogador puder acessar a posição
                if carta_esta_ativa and self._can_access_carousel_position(i):
                    cartas_ativas.append(carta_path)
                    print(f"DEBUG: [GESTÃO_PACOTES] ✅ Carta ATIVA posição {i}: {os.path.basename(carta_path)}")
                elif carta_esta_ativa:
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta ativa mas sem acesso à posição {i}: {os.path.basename(carta_path)}")
                else:
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta na posição {i} não está ativa: {os.path.basename(carta_path)}")
        
        print(f"DEBUG: [GESTÃO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        return cartas_ativas
    
    def _mostrar_gestao_carta_atual(self):
        """Mostra destaque roxo na carta atual e controles de gestão"""
        
        print(f"DEBUG: [GESTÃO_PACOTES] === INICIANDO _mostrar_gestao_carta_atual ===")
        
        # VERIFICAÇÃO ADICIONAL: Se não há cartas em gestão, finalizar imediatamente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Lista de cartas gestão vazia ou inexistente")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Estado atual da gestão:")
        print(f"DEBUG: [GESTÃO_PACOTES]   _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
        print(f"DEBUG: [GESTÃO_PACOTES]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [GESTÃO_PACOTES]   _cartas_gestao: {[os.path.basename(c) if c else 'None' for c in self._cartas_gestao]}")
        
        # CORREÇÃO CRÍTICA: Verificar se índice atual está dentro dos limites
        if not hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ _carta_atual_gestao não existia, inicializado como 0")
            
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            # NOVA FUNCIONALIDADE: Todas as cartas foram processadas - enable End Turn
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Todas as cartas processadas - habilitando End Turn")
            print(f"DEBUG: [GESTÃO_PACOTES] Índice atual ({self._carta_atual_gestao}) >= tamanho da lista ({len(self._cartas_gestao)})")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando gestão para carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)}")
        
        # Encontrar posição da carta atual no carrossel
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        posicao_carta = None
        
        # VERIFICAÇÃO ADICIONAL: Se a carta atual é None ou vazia
        if not carta_atual:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Carta atual na gestão é None ou vazia")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA: Se a carta atual é um back_card, todas as cartas foram processadas
        carta_basename = os.path.basename(carta_atual).lower()
        if carta_basename.startswith("back_card_"):
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Carta atual é back_card: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ Isto indica que todas as cartas ativas foram removidas")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA ADICIONAL: Se a carta não é Activity ou Challenge, finalizar
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Carta atual não é Activity nem Challenge: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA ADICIONAL: Se carta não existe no carrossel atual, finalizar
        if hasattr(self, 'cards') and carta_atual not in self.cards:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Carta atual não existe no carrossel atual: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Procurando carta atual no carrossel: {os.path.basename(carta_atual)}")
        
        # NOVA FUNCIONALIDADE: Verificar flags de estado das cartas
        if hasattr(self, 'card_face_up_flags'):
            print(f"DEBUG: [GESTÃO_PACOTES] Estados das cartas (flags): {self.card_face_up_flags}")
        
        for i in range(len(self.cards)):
            if self.cards[i] == carta_atual:
                posicao_carta = i
                print(f"DEBUG: [GESTÃO_PACOTES] Carta encontrada na posição {i} do carrossel")
                
                # NOVA FUNCIONALIDADE: Verificar se a carta está virada para cima usando flags
                if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                    is_face_up = self.card_face_up_flags[i]
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta na posição {i} virada para cima: {is_face_up}")
                    
                    if not is_face_up:
                        print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Carta na posição {i} está virada para baixo")
                        print(f"DEBUG: [GESTÃO_PACOTES] ❌ Isto indica que a carta foi completada e removida")
                        print(f"DEBUG: [GESTÃO_PACOTES] ✅ Removendo carta inválida da gestão e continuando")
                        
                        # Remover carta inválida da lista de gestão
                        self._cartas_gestao.remove(carta_atual)
                        
                        # Se não há mais cartas, finalizar
                        if not self._cartas_gestao:
                            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão - nenhuma carta válida restante")
                            self._finalizar_gestao_pacotes()
                        else:
                            # Ajustar índice se necessário e continuar com próxima carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                self._carta_atual_gestao = 0
                            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Continuando com próxima carta válida")
                            self._mostrar_gestao_carta_atual()
                        return
                break
        
        if posicao_carta is None:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Carta {os.path.basename(carta_atual)} não encontrada no carrossel")
            print(f"DEBUG: [GESTÃO_PACOTES] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Removendo carta inválida da gestão e continuando")
            
            # Remover carta inválida da lista de gestão
            self._cartas_gestao.remove(carta_atual)
            
            # Se não há mais cartas, finalizar
            if not self._cartas_gestao:
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão - nenhuma carta válida restante")
                self._finalizar_gestao_pacotes()
                return
            
            # Tentar próxima carta
            self._mostrar_gestao_carta_atual()
            return
        
        # CORREÇÃO CRÍTICA: Verificar se a carta atual é uma carta virada para baixo
        if posicao_carta is not None and carta_atual:
            carta_basename = os.path.basename(carta_atual).lower()
            if carta_basename.startswith("back_card_"):
                print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO CRÍTICO: Tentativa de aplicar gestão à carta virada para baixo: {carta_basename}")
                print(f"DEBUG: [GESTÃO_PACOTES] ❌ Isto indica que todas as cartas ativas foram processadas")
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Finalizando gestão de pacotes automaticamente")
                self._finalizar_gestao_pacotes()
                return
        
        # NOVA FUNCIONALIDADE: Garantir que End Turn permanece disabled enquanto há cartas para processar
        print(f"DEBUG: [GESTÃO_PACOTES] Ainda há cartas para processar - mantendo End Turn disabled")
        self._manter_end_turn_disabled()
        
        # Remover destaque anterior
        self._remover_destaque_roxo()
        
        if posicao_carta is not None:
            # CORREÇÃO 1: Adicionar destaque roxo ANTES de qualquer outra operação
            self._adicionar_destaque_roxo(posicao_carta)
            
            # CORREÇÃO CRÍTICA: Ajustar selected_carousel_index para corresponder à carta com destaque roxo
            # Isso garante que ao voltar do fullscreen, a seleção esteja correta
            print(f"DEBUG: [GESTÃO_PACOTES] Ajustando selected_carousel_index para posição {posicao_carta}")
            self.selected_carousel_index = posicao_carta
            self.selected_carousel_card = carta_atual
            
            # CORREÇÃO CRÍTICA: Forçar atualização dos destaques após ajustar índice
            print(f"DEBUG: [GESTÃO_PACOTES] Forçando atualização de destaques para carta {posicao_carta}")
            self._update_carousel_selection_highlights()
            
            # Obter dados da carta para determinar rate
            rate_carta = self._obter_rate_carta(carta_atual)
            
            # NOVO: Atualizar barras de progresso com valores salvos da carta atual
            self._atualizar_barras_gestao_carta_atual()
            
            # Mostrar controles de gestão
            self._mostrar_controles_gestao(rate_carta)
            
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Gestão configurada para carta {os.path.basename(carta_atual)} na posição {posicao_carta}")
            
            # CORREÇÃO: Botão seta só aparece quando há controles de gestão visíveis
            # (será mostrado dentro de _mostrar_controles_gestao se necessário)
    
    def _adicionar_destaque_roxo(self, posicao):
        """Adiciona destaque roxo à volta da carta especificada"""
        print(f"DEBUG: [GESTÃO_PACOTES] Adicionando destaque roxo à carta posição {posicao}")
        
        # Remover destaque anterior se existir
        self._remover_destaque_roxo()
        
        # Verificar se temos card_labels e se a posição é válida
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: [GESTÃO_PACOTES] card_labels não disponível para destaque")
            return
        
        if posicao >= len(self.card_labels):
            print(f"DEBUG: [GESTÃO_PACOTES] Posição {posicao} inválida (máx: {len(self.card_labels)-1})")
            return
        
        # Obter widget da carta
        carta_widget = self.card_labels[posicao]
        
        if carta_widget and carta_widget.winfo_exists():
            # CORREÇÃO CRÍTICA: Aplicar destaque roxo diretamente
            carta_widget.config(
                bg="#800080",  # Fundo roxo
                highlightbackground="#800080",  # Cor roxa da borda
                highlightcolor="#800080",
                highlightthickness=3  # Espessura da borda
            )
            
            # Guardar referência para remoção posterior
            self._carta_destacada = carta_widget
            # CORREÇÃO: Guardar também a posição para verificação de clique
            self._carta_destacada_posicao = posicao
            
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Destaque roxo aplicado à carta {posicao}")
            print(f"DEBUG: [GESTÃO_PACOTES] Widget configurado: bg='{carta_widget.cget('bg')}', highlightthickness={carta_widget.cget('highlightthickness')}")
        else:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ Widget da carta {posicao} não disponível")
    
    def _remover_destaque_roxo(self):
        """Remove o destaque roxo atual"""
        print("DEBUG: [GESTÃO_PACOTES] === REMOVENDO DESTAQUE ROXO ===")
        
        if hasattr(self, '_carta_destacada') and self._carta_destacada:
            try:
                # Remover destaque roxo da carta
                self._carta_destacada.config(
                    bg="black",  # Voltar ao fundo preto
                    highlightbackground="black",  # Remover borda
                    highlightcolor="black",
                    highlightthickness=0  # Remover espessura da borda
                )
                print("DEBUG: [GESTÃO_PACOTES] ✅ Destaque roxo removido da carta específica")
                self._carta_destacada = None
            except Exception as e:
                print(f"DEBUG: [GESTÃO_PACOTES] ❌ Erro ao remover destaque roxo: {e}")
        
        # CORREÇÃO: Limpar também a posição destacada
        if hasattr(self, '_carta_destacada_posicao'):
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ Limpando posição destacada: {self._carta_destacada_posicao}")
            self._carta_destacada_posicao = None
        
        # Limpar frame_destaque se ainda existir (fallback)
        if hasattr(self, '_frame_destaque') and self._frame_destaque:
            try:
                self._frame_destaque.destroy()
                self._frame_destaque = None
                print("DEBUG: [GESTÃO_PACOTES] ✅ frame_destaque removido")
            except:
                pass
        
        # CORREÇÃO ADICIONAL: Remover destaque roxo de TODAS as cartas do carrossel
        # para garantir que não fica nenhum destaque residual
        if hasattr(self, 'card_labels') and self.card_labels:
            print("DEBUG: [GESTÃO_PACOTES] ✅ Limpando destaque roxo de todas as cartas do carrossel")
            for i, lbl in enumerate(self.card_labels):
                if lbl and hasattr(lbl, 'winfo_exists'):
                    try:
                        if lbl.winfo_exists():
                            # Verificar se tem destaque roxo e remover
                            current_bg = lbl.cget('bg')
                            current_thickness = lbl.cget('highlightthickness')
                            
                            if current_bg == "#800080" or current_thickness == 3:
                                lbl.config(
                                    bg="black",
                                    highlightbackground="black",
                                    highlightcolor="black", 
                                    highlightthickness=0
                                )
                                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Destaque roxo removido da carta {i}")
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ Erro ao limpar carta {i}: {e}")
        
        print("DEBUG: [GESTÃO_PACOTES] === DESTAQUE ROXO COMPLETAMENTE REMOVIDO ===")
    
    def _obter_dados_carta(self, carta_path):
        """Obtém dados da carta (rate e drops_allowed) da base de dados"""
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print(f"DEBUG: [GESTÃO_PACOTES] Database não disponível, usando fallback")
                return {
                    'rate': 20, 
                    'rate_options': list(range(21)), 
                    'drops_allowed': True,
                    'message_size': 20,
                    'message_received': 50
                }
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [GESTÃO_PACOTES] Obtendo dados para carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair número da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [GESTÃO_PACOTES] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        # Obter rate e rate_options
                        if hasattr(activity_card, 'rate'):
                            if isinstance(activity_card.rate, list):
                                rate_max = max(activity_card.rate)
                                rate_options = activity_card.rate
                            else:
                                rate_max = activity_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 20
                            rate_options = list(range(21))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(activity_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se botão Lost deve aparecer
                        penalty_per_packet = getattr(activity_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_received para completion
                        message_size = getattr(activity_card, 'message_size', rate_max)
                        message_received = getattr(activity_card, 'message_received', 0)
                        
                        # CORREÇÃO: Obter parâmetros de recompensa para Activities
                        reward_per_packet = getattr(activity_card, 'reward_per_packet', 0)
                        min_packets_bonus = getattr(activity_card, 'min_packets_bonus', 0)
                        lost_penalty_per_packet = getattr(activity_card, 'lost_penalty_per_packet', 0)
                        
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity reward_per_packet: {reward_per_packet}, min_packets_bonus: {min_packets_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity lost_penalty_per_packet: {lost_penalty_per_packet}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'reward_per_packet': reward_per_packet,
                            'min_packets_bonus': min_packets_bonus,
                            'lost_penalty_per_packet': lost_penalty_per_packet
                        }
            
            elif "challenge" in carta_basename:
                # Extrair número do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [GESTÃO_PACOTES] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        # Obter rate e rate_options
                        if hasattr(challenge_card, 'rate'):
                            if isinstance(challenge_card.rate, list):
                                rate_max = max(challenge_card.rate)
                                rate_options = challenge_card.rate
                            else:
                                rate_max = challenge_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 25
                            rate_options = list(range(26))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(challenge_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se botão Lost deve aparecer (Challenges geralmente não têm)
                        penalty_per_packet = getattr(challenge_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_bonus para completion
                        message_size = getattr(challenge_card, 'message_size', rate_max)
                        
                        # CORREÇÃO: Obter parâmetros corretos da base de dados
                        n_turns = getattr(challenge_card, 'n_turns', 0)  # CORREÇÃO: Adicionar n_turns
                        time_limit = getattr(challenge_card, 'time_limit', 0)
                        time_limit_bonus = getattr(challenge_card, 'time_limit_bonus', 0)
                        message_received = getattr(challenge_card, 'message_bonus', 0)  # Field correto
                        reward_per_packet = getattr(challenge_card, 'reward_per_packet', 0)
                        message_received_bonus = getattr(challenge_card, 'message_received_bonus', 0)  # CORREÇÃO: Field correto para JACKPOT
                        
                        # CORREÇÃO: Obter challenge_quit_fee
                        challenge_quit_fee = getattr(challenge_card, 'challenge_quit_fee', 0)
                        
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge n_turns: {n_turns}")  # CORREÇÃO: Debug n_turns
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge time_limit: {time_limit}, time_limit_bonus: {time_limit_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge reward_per_packet: {reward_per_packet}, message_received_bonus: {message_received_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge challenge_quit_fee: {challenge_quit_fee}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'n_turns': n_turns,  # CORREÇÃO: Adicionar n_turns ao retorno
                            'time_limit': time_limit,
                            'time_limit_bonus': time_limit_bonus,
                            'reward_per_packet': reward_per_packet,
                            'message_received_bonus': message_received_bonus,
                            'challenge_quit_fee': challenge_quit_fee
                        }
            
            # Fallback baseado no tipo de carta
            if "activity" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Activity_', '').replace('.png', '')
                try:
                    rate_fallback = max(10, int(num) % 30 + 10)
                    print(f"DEBUG: [GESTÃO_PACOTES] Fallback Activity rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 50
                    }
                except:
                    print(f"DEBUG: [GESTÃO_PACOTES] Erro no fallback Activity, usando 20")
                    return {
                        'rate': 20, 
                        'rate_options': list(range(21)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 20,
                        'message_received': 50
                    }
                    
            elif "challenge" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Challenge_', '').replace('.png', '')
                try:
                    rate_fallback = max(15, int(num) % 40 + 15)
                    print(f"DEBUG: [GESTÃO_PACOTES] Fallback Challenge rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 100
                    }
                except:
                    print(f"DEBUG: [GESTÃO_PACOTES] Erro no fallback Challenge, usando 25")
                    return {
                        'rate': 25, 
                        'rate_options': list(range(26)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 25,
                        'message_received': 100
                    }
            
            # Fallback final
            print(f"DEBUG: [GESTÃO_PACOTES] Fallback final: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }
            
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] Erro ao obter dados da carta: {e}")
            print(f"DEBUG: [GESTÃO_PACOTES] Fallback de emergência: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }

    def _obter_rate_carta(self, carta_path):
        """Obtém o rate máximo da carta (Activities/Challenges)"""
        print(f"DEBUG: [GESTÃO_PACOTES] === OBTENDO RATE DA CARTA ===")
        print(f"DEBUG: [GESTÃO_PACOTES] Carta: {os.path.basename(carta_path)}")
        
        # Usar a nova função que obtém dados completos
        dados = self._obter_dados_carta(carta_path)
        return dados['rate']
    
    def _mostrar_controles_gestao(self, rate_max):
        """Mostra controles + para Rxd e Lost posicionados entre labels e barras"""
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando controles para rate máximo: {rate_max}")
        
        # Limpar controles anteriores
        self._remover_controles_gestao()
        
        # Obter valores atuais
        valores_atuais = self._valores_pacotes[self._carta_atual_gestao]
        
        # Obter dados da carta atual para verificar drops_allowed e penalty_per_packet
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        drops_allowed = dados_carta['drops_allowed']
        penalty_per_packet = dados_carta.get('penalty_per_packet', None)
        rate_options = dados_carta['rate_options']
        
        # CORREÇÃO: Determinar tipo da carta para aplicar lógica específica
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        print(f"DEBUG: [GESTÃO_PACOTES] Carta: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [GESTÃO_PACOTES] Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [GESTÃO_PACOTES] Drops allowed: {drops_allowed}")
        print(f"DEBUG: [GESTÃO_PACOTES] Penalty per packet: {penalty_per_packet}")
        print(f"DEBUG: [GESTÃO_PACOTES] Rate options: {rate_options}")
        
        # CORREÇÃO CRÍTICA: Regras específicas para Challenges vs Activities
        if is_challenge:
            # Para Challenges: Lost é permitido se há penalty_per_packet OU drops_allowed=True
            mostrar_botao_lost = drops_allowed or (penalty_per_packet is not None)
            print(f"DEBUG: [GESTÃO_PACOTES] Challenge - Mostrar botão Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   - drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
        else:
            # Para Activities: Lost é permitido apenas se há penalty_per_packet específico
            mostrar_botao_lost = (penalty_per_packet is not None)
            print(f"DEBUG: [GESTÃO_PACOTES] Activity - Mostrar botão Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   - penalty_per_packet existe: {penalty_per_packet is not None}")
        
        print(f"DEBUG: [GESTÃO_PACOTES] DECISÃO FINAL - Mostrar botão Lost: {mostrar_botao_lost}")
        
        # Encontrar as barras de progresso Rxd e Lost
        if not hasattr(self, 'progress_bars'):
            print("DEBUG: [GESTÃO_PACOTES] Barras de progresso não encontradas")
            return
        
        # CORREÇÃO CRÍTICA: Remover explicitamente o botão seta quando criamos botões +
        # Isso garante que quando há botões +, não há botão seta visível
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta antes de criar botões +")
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # CORREÇÃO: Sempre criar botões + independentemente dos valores atuais
        # Os botões + devem aparecer sempre para permitir modificações
        
        # Criar botão + para Rxd (sempre disponível)
        if "Rxd" in self.progress_bars:
            rxd_bar = self.progress_bars["Rxd"]
            
            # Posicionar botão + à esquerda da barra Rxd
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            
            # Posicionar o botão entre o label Rxd e a barra
            # Assumindo que a barra está em rely=0.77 e o label um pouco acima
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [GESTÃO_PACOTES] Botão + Rxd criado")
        else:
            self._btn_plus_rxd = None
            
        # Criar botão + para Lost baseado na nova regra
        if mostrar_botao_lost and "Lost" in self.progress_bars:
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            
            # Posicionar o botão entre o label Lost e sua barra
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            
            print("DEBUG: [GESTÃO_PACOTES] Botão + Lost criado")
        else:
            self._btn_plus_lost = None
            if not mostrar_botao_lost:
                print("DEBUG: [GESTÃO_PACOTES] Botão + Lost NÃO criado - condições não atendidas (drops_allowed=False e penalty_per_packet=None)")
            else:
                print("DEBUG: [GESTÃO_PACOTES] Botão + Lost deveria ter sido criado mas não foi encontrada barra Lost")
        
        # CORREÇÃO: Confirmar que botão seta foi removido quando botões + são criados
        print("DEBUG: [GESTÃO_PACOTES] Botões + criados - botão seta removido para evitar conflito")
    
    def _mostrar_controles_gestao_sem_seta(self, rate_max):
        """Versão especial para restauração após fullscreen - cria botões + sem mexer no botão seta"""
        print(f"DEBUG: [FULLSCREEN] Criando botões + sem afetar botão seta (rate máximo: {rate_max})")
        
        # IMPORTANTE: NÃO chamar _remover_controles_gestao para evitar criar botão seta
        
        # Remover apenas os botões + se existirem (sem afetar seta)
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORREÇÃO: Usar estado preservado para decidir quais botões + recriar
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        print(f"DEBUG: [FULLSCREEN] Estado preservado dos botões +: {botoes_plus_estado}")
        
        # Obter dados da carta atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        rate_options = dados_carta['rate_options']
        
        # Recriar APENAS os botões + que estavam visíveis antes do fullscreen
        if botoes_plus_estado.get('rxd_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando botão + Rxd (estava visível)")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [FULLSCREEN] Botão + Rxd recriado")
        else:
            print("DEBUG: [FULLSCREEN] Botão + Rxd NÃO recriado - não estava visível")
        
        # Recriar botão + Lost apenas se estava visível
        if botoes_plus_estado.get('lost_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando botão + Lost (estava visível)")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            print("DEBUG: [FULLSCREEN] Botão + Lost recriado")
        else:
            print("DEBUG: [FULLSCREEN] Botão + Lost NÃO recriado - não estava visível")
        
        # IMPORTANTE: Garantir que o botão seta é removido se existe
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                self._btn_seta.destroy()
                self._btn_seta = None
                print("DEBUG: [FULLSCREEN] Botão seta removido após criar botões +")
            except Exception as e:
                print(f"DEBUG: [FULLSCREEN] Erro ao remover botão seta: {e}")
        
        print("DEBUG: [FULLSCREEN] Botões + recriados baseado no estado preservado")
    
    def _mostrar_controles_gestao_especificos(self, rate_max, mostrar_rxd=False, mostrar_lost=False):
        """Nova função para restaurar controles específicos baseado nas flags salvas"""
        print(f"DEBUG: [ESTADO] Criando controles específicos: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
        
        # Remover controles existentes
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
            
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Obter dados da carta atual
        if (hasattr(self, 'cards') and self.cards and 
            self._carta_atual_gestao < len(self.cards)):
            carta_atual = self.cards[self._carta_atual_gestao]
            dados_carta = self._obter_dados_carta(carta_atual)
            rate_options = dados_carta['rate_options']
        else:
            rate_options = [1, 2, 5, 10]  # valores padrão
        
        # Criar APENAS os botões solicitados
        if mostrar_rxd:
            print("DEBUG: [ESTADO] Criando botão + Rxd")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
        
        if mostrar_lost:
            print("DEBUG: [ESTADO] Criando botão + Lost")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
        
        print(f"DEBUG: [ESTADO] Controles específicos criados: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
    
    def _verificar_e_mostrar_botao_seta_se_necessario(self):
        """
        Verifica se todos os botões + foram removidos e se deve mostrar o botão seta
        CORREÇÃO: Agora verifica se os widgets existem E estão visíveis, não apenas se os atributos existem
        """
        print("DEBUG: [GESTÃO_PACOTES] === VERIFICAÇÃO AUTOMÁTICA DO BOTÃO SETA ===")
        
        # CORREÇÃO: Verificar se os botões existem E estão visíveis na interface
        def botao_esta_visivel(botao):
            try:
                return (botao is not None and 
                        hasattr(botao, 'winfo_exists') and 
                        botao.winfo_exists() and 
                        hasattr(botao, 'winfo_ismapped') and 
                        botao.winfo_ismapped())
            except (tk.TclError, AttributeError):
                return False
        
        btn_rxd_visivel = (hasattr(self, '_btn_plus_rxd') and 
                          botao_esta_visivel(self._btn_plus_rxd))
        btn_lost_visivel = (hasattr(self, '_btn_plus_lost') and 
                           botao_esta_visivel(self._btn_plus_lost))
        btn_seta_visivel = (hasattr(self, '_btn_seta') and 
                           botao_esta_visivel(self._btn_seta))
        
        print(f"DEBUG: [GESTÃO_PACOTES] Estado atual dos botões (visibilidade real):")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão + Rxd visível: {btn_rxd_visivel}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão + Lost visível: {btn_lost_visivel}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão seta visível: {btn_seta_visivel}")
        
        # REGRA CORRIGIDA: Só mostrar botão seta se NENHUM botão + está visível E não há botão seta visível
        if not btn_rxd_visivel and not btn_lost_visivel and not btn_seta_visivel:
            print("DEBUG: [GESTÃO_PACOTES] ✅ Condição atendida - criando botão seta automaticamente")
            self._mostrar_botao_seta()
        elif btn_seta_visivel:
            print("DEBUG: [GESTÃO_PACOTES] ✅ Botão seta já visível - nada a fazer")
        elif btn_rxd_visivel or btn_lost_visivel:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ BLOQUEADO - ainda há botões + visíveis na interface")
            # CORREÇÃO CRÍTICA: Se há botões + visíveis mas há botão seta, remover o botão seta
            if btn_seta_visivel:
                print("DEBUG: [GESTÃO_PACOTES] ⚠️ Removendo botão seta incorretamente visível")
                try:
                    self._btn_seta.destroy()
                    self._btn_seta = None
                except:
                    pass
        else:
            print(f"DEBUG: [GESTÃO_PACOTES] ⚪ Estado indeterminado - mantendo como está")
        
        print("DEBUG: [GESTÃO_PACOTES] === FIM VERIFICAÇÃO AUTOMÁTICA DO BOTÃO SETA ===")
    
    
    
    def _mostrar_overlay_entrada(self, tipo, rate_options):
        """Mostra overlay com botões baseados nas opções de rate da carta"""
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando overlay para {tipo} com rate_options {rate_options}")
        
        # Criar overlay semi-transparente
        self._overlay_entrada = tk.Toplevel(self)
        self._overlay_entrada.title("")
        self._overlay_entrada.configure(bg="black")
        self._overlay_entrada.overrideredirect(True)
        self._overlay_entrada.attributes("-alpha", 0.9)
        
        # Centralizar overlay
        overlay_width = 300
        overlay_height = 200
        x = (self.screen_width - overlay_width) // 2
        y = (self.screen_height - overlay_height) // 2
        self._overlay_entrada.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal do overlay
        main_frame = tk.Frame(self._overlay_entrada, bg="black", highlightbackground="#8B5CF6", highlightthickness=3)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Título
        titulo_tipo = "Rxd" if tipo == "enviados" else "Lost"
        titulo_label = tk.Label(
            main_frame,
            text=f"Inserir {titulo_tipo}:",
            fg="white",
            bg="black",
            font=("Helvetica", 14, "bold")
        )
        titulo_label.pack(pady=10)
        
        # Frame para botões
        botoes_frame = tk.Frame(main_frame, bg="black")
        botoes_frame.pack(pady=20)
        
        # Determinar quais botões mostrar baseado nas opções de rate da carta
        # Use os valores específicos da base de dados ou o range completo se for uma lista simples
        if isinstance(rate_options, list) and len(rate_options) > 0:
            # Se temos uma lista específica de valores, usar essa lista
            botoes_values = sorted(rate_options)
            # CORREÇÃO: Para Lost (perdidos), sempre garantir que 0 está incluído
            if tipo == "perdidos" and 0 not in botoes_values:
                botoes_values = [0] + botoes_values
        else:
            # Fallback: criar range de 0 até o valor máximo
            rate_max = max(rate_options) if isinstance(rate_options, list) else rate_options
            botoes_values = list(range(rate_max + 1))
        
        print(f"DEBUG: [GESTÃO_PACOTES] Valores dos botões: {botoes_values}")
        
        for valor in botoes_values:
            btn = tk.Button(
                botoes_frame,
                text=str(valor),
                bg="#8B5CF6",
                fg="white",
                font=("Helvetica", 12, "bold"),
                width=4,
                height=2,
                command=lambda v=valor: self._aplicar_valor_e_fechar_overlay(tipo, v)
            )
            btn.pack(side="left", padx=5)
        
        # Botão Cancelar
        btn_cancelar = tk.Button(
            main_frame,
            text="Cancelar",
            bg="#666666",
            fg="white",
            font=("Helvetica", 10),
            command=self._fechar_overlay_entrada
        )
        btn_cancelar.pack(pady=10)
    
    def _aplicar_valor_entrada(self, tipo, valor):
        """
        CORREÇÃO: Aplica o valor selecionado sincronizando com card_stats
        E AUTOMATICAMENTE atualiza To send quando Rxd ou Lost mudam
        NOVA FUNCIONALIDADE: Remove o botão + correspondente após aplicar valor
        CORREÇÃO PROBLEMA 2: Garantir que valores selecionados são aplicados corretamente
        """
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor {valor} para {tipo}")
        
        # CORREÇÃO FUNDAMENTAL: Usar carta selecionada diretamente do carrossel
        # Evita problemas de sincronização após restauração de fullscreen
        if not hasattr(self, 'selected_carousel_index') or self.selected_carousel_index is None:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Nenhuma carta selecionada no carrossel!")
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ hasattr(selected_carousel_index): {hasattr(self, 'selected_carousel_index')}")
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ selected_carousel_index value: {getattr(self, 'selected_carousel_index', 'NOT_SET')}")
            return
        
        posicao_carrossel = self.selected_carousel_index
        
        # CORREÇÃO CRÍTICA: Obter carta_atual diretamente da posição no carrossel, não da variável cached
        if not hasattr(self, 'cards') or posicao_carrossel >= len(self.cards):
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Posição inválida no carrossel!")
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ posicao_carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ len(cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
            return
        
        carta_atual = self.cards[posicao_carrossel]
        
        # DIAGNÓSTICO DETALHADO APÓS OBTER CARTA
        print(f"DEBUG: [GESTÃO_PACOTES] === DIAGNÓSTICO DETALHADO ===")
        print(f"DEBUG: [GESTÃO_PACOTES] posicao_carrossel: {posicao_carrossel}")
        print(f"DEBUG: [GESTÃO_PACOTES] carta_atual: {os.path.basename(carta_atual) if carta_atual else 'None'}")
        print(f"DEBUG: [GESTÃO_PACOTES] len(self.cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
        print(f"DEBUG: [GESTÃO_PACOTES] ✅ Carta atual obtida do carrossel com sucesso!")
        
        if not carta_atual:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Carta atual é None!")
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor na posição {posicao_carrossel} do carrossel")
        
        # CORREÇÃO: Obter message_size da base de dados
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # CORREÇÃO: Sincronizar com card_stats usando posição correta do carrossel
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            # Obter valores preservados atuais
            stats_atuais = self.card_stats[posicao_carrossel]
            to_send_anterior = stats_atuais.get('To send', message_size)
            rxd_anterior = stats_atuais.get('Rxd', 0)
            lost_anterior = stats_atuais.get('Lost', 0)
            
            print(f"DEBUG: [GESTÃO_PACOTES] Valores anteriores preservados:")
            print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Message size: {message_size}")
            
            # CORREÇÃO PROBLEMA 2: Aplicar o valor selecionado como INCREMENTO
            # O valor selecionado é ADICIONADO ao valor atual
            if tipo == 'enviados':
                # CORREÇÃO: Valor selecionado é ADICIONADO ao Rxd atual
                novo_rxd = rxd_anterior + valor  # Incrementa o valor existente
                novo_lost = lost_anterior  # Lost mantém-se igual
                self.card_stats[posicao_carrossel]['Rxd'] = novo_rxd
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ CORREÇÃO - Rxd incrementado: {rxd_anterior} + {valor} = {novo_rxd}")
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ card_stats[{posicao_carrossel}]['Rxd'] = {novo_rxd}")
                
                # NOVO: Incrementar contador de processamento por turno
                # CORREÇÃO: Sempre incrementar em 1 (independente do valor selecionado)
                # Isto garante que o botão + desaparece após ser usado, mesmo com valor 0
                self._increment_processed_this_turn(carta_atual, 'rxd', 1)
                
                # NOVA FUNCIONALIDADE: Remover botão + de Rxd após aplicar valor
                if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                    try:
                        self._btn_plus_rxd.destroy()
                        self._btn_plus_rxd = None
                        print(f"DEBUG: [GESTÃO_PACOTES] ✅ Botão + Rxd removido após incrementar +{valor}")
                        
                        # CORREÇÃO: Atualizar estado preservado para refletir que botão não está mais visível
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['rxd_visivel'] = False
                            print("DEBUG: [GESTÃO_PACOTES] Estado preservado atualizado: rxd_visivel = False")
                        
                        # CORREÇÃO ADICIONAL: Verificar imediatamente se deve mostrar botão seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ Erro ao remover botão + Rxd: {e}")
                    
            elif tipo == 'perdidos':
                # CORREÇÃO: Valor selecionado é ADICIONADO ao Lost atual
                novo_rxd = rxd_anterior  # Rxd mantém-se igual
                novo_lost = lost_anterior + valor  # Incrementa o valor existente
                self.card_stats[posicao_carrossel]['Lost'] = novo_lost
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ CORREÇÃO - Lost incrementado: {lost_anterior} + {valor} = {novo_lost}")
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ card_stats[{posicao_carrossel}]['Lost'] = {novo_lost}")
                
                # NOVO: Incrementar contador de processamento por turno
                # CORREÇÃO: Sempre incrementar em 1 (independente do valor selecionado)
                # Isto garante que o botão + desaparece após ser usado, mesmo com valor 0
                self._increment_processed_this_turn(carta_atual, 'lost', 1)
                
                # NOVA FUNCIONALIDADE: Remover botão + de Lost após aplicar valor
                if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                    try:
                        self._btn_plus_lost.destroy()
                        self._btn_plus_lost = None
                        print(f"DEBUG: [GESTÃO_PACOTES] ✅ Botão + Lost removido após incrementar +{valor}")
                        
                        # CORREÇÃO: Atualizar estado preservado para refletir que botão não está mais visível
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['lost_visivel'] = False
                            print("DEBUG: [GESTÃO_PACOTES] Estado preservado atualizado: lost_visivel = False")
                        
                        # CORREÇÃO ADICIONAL: Verificar imediatamente se deve mostrar botão seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ Erro ao remover botão + Lost: {e}")
                    
            else:
                novo_rxd = rxd_anterior
                novo_lost = lost_anterior
            
            # CORREÇÃO CRÍTICA: Calcular To send automaticamente
            # To send = message_size - Rxd (apenas pacotes recebidos reduzem To send)
            # Lost = pacotes perdidos (não afetam To send)
            novo_to_send = max(message_size - novo_rxd, 0)
            
            # Atualizar To send nos card_stats
            self.card_stats[posicao_carrossel]['To send'] = novo_to_send
            
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ APLICAÇÃO DE VALOR COMPLETA:")
            print(f"DEBUG: [GESTÃO_PACOTES]   Valor selecionado: {valor}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Aplicado a: {tipo}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO Rxd total: {novo_rxd}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO Lost total: {novo_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO To send: {novo_to_send} (= {message_size} - {novo_rxd})")
            print(f"DEBUG: [GESTÃO_PACOTES]   ⚠️ Lost packets ({novo_lost}) não afetam To send")
            
            # CORREÇÃO: Atualizar TODAS as barras visualmente
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Atualizar To send
                if "To send" in self.progress_bars and "To send" in self.progress_labels:
                    self.progress_bars["To send"].config(value=novo_to_send, maximum=message_size)
                    self.progress_labels["To send"].config(text=str(novo_to_send))
                    print(f"DEBUG: [GESTÃO_PACOTES] ✅ Barra To send atualizada visualmente: {novo_to_send}/{message_size}")
                
                # Atualizar Rxd
                if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                    self.progress_bars["Rxd"].config(value=novo_rxd, maximum=message_size)
                    self.progress_labels["Rxd"].config(text=str(novo_rxd))
                    print(f"DEBUG: [GESTÃO_PACOTES] ✅ Barra Rxd atualizada visualmente: {novo_rxd}")
                
                # Atualizar Lost
                if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                    self.progress_bars["Lost"].config(value=novo_lost, maximum=message_size)
                    self.progress_labels["Lost"].config(text=str(novo_lost))
                    print(f"DEBUG: [GESTÃO_PACOTES] ✅ Barra Lost atualizada visualmente: {novo_lost}")
        
        # CORREÇÃO: Sincronizar com card_stats após aplicar valores
        try:
            self._sync_card_stats_with_progress_bars()
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ card_stats sincronizado com barras após aplicar valor")
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ Erro ao sincronizar card_stats: {e}")
        
        # NOVA CORREÇÃO: Verificar se deve mostrar botão seta após remover botões +
        self._verificar_e_mostrar_botao_seta_se_necessario()
        
        # Manter compatibilidade com sistema antigo (se existir)
        if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
        
        # Fechar overlay
        self._fechar_overlay_entrada()
    
    def _fechar_overlay_entrada(self):
        """Fecha o overlay de entrada"""
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
    
    def _aplicar_valor_e_fechar_overlay(self, tipo, valor):
        """Aplica o valor selecionado e fecha o overlay"""
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor {valor} para {tipo} e fechando overlay")
        
        # Aplicar o valor
        self._aplicar_valor_entrada(tipo, valor)
        
        # Fechar o overlay
        self._fechar_overlay_entrada()
    
    def _incrementar_valor(self, tipo, message_size):
        """
        Incrementa valor respeitando o message_size máximo da carta.
        CORREÇÃO: Usar message_size como limite, não rate_max.
        rate_max é para pacotes por turno, message_size é o limite total da mensagem.
        NOVO: Incrementa também o contador de processamento por turno.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor_atual = int(entry.get())
            
            # Obter carta atual
            carta_path = self._cartas_gestao[self._carta_atual_gestao]
            
            # Obter rate_max para verificar limite por turno
            rate_max = self._obter_rate_carta(carta_path)
            
            # Verificar contadores de processamento por turno
            tipo_contador = 'rxd' if tipo == 'enviados' else 'lost'
            processed_this_turn = self._get_processed_this_turn(carta_path, tipo_contador)
            
            print(f"DEBUG: [INCREMENTAR] {tipo}: atual={valor_atual}, processed_this_turn={processed_this_turn}")
            print(f"DEBUG: [INCREMENTAR] Limites: message_size={message_size}, rate_max={rate_max}")
            
            # NOVA VERIFICAÇÃO: Ambos os limites devem ser respeitados
            pode_incrementar = (valor_atual < message_size) and (processed_this_turn < rate_max)
            
            if pode_incrementar:
                novo_valor = valor_atual + 1
                entry.delete(0, tk.END)
                entry.insert(0, str(novo_valor))
                
                # Atualizar valores armazenados
                self._valores_pacotes[self._carta_atual_gestao][tipo] = novo_valor
                
                # NOVO: Incrementar contador de processamento por turno
                self._increment_processed_this_turn(carta_path, tipo_contador, 1)
                
                # Atualizar barra "To send"
                self._atualizar_barra_to_send()
                
                print(f"DEBUG: [INCREMENTAR] ✅ {tipo} incrementado para {novo_valor}")
                print(f"DEBUG: [INCREMENTAR] Novo processed_this_turn: {self._get_processed_this_turn(carta_path, tipo_contador)}")
            else:
                if valor_atual >= message_size:
                    print(f"DEBUG: [INCREMENTAR] ❌ Limite de message_size atingido ({message_size})")
                if processed_this_turn >= rate_max:
                    print(f"DEBUG: [INCREMENTAR] ❌ Limite de rate_max por turno atingido ({rate_max})")
                
        except ValueError:
            print("DEBUG: [INCREMENTAR] Valor inválido no campo")
    
    def _validar_entrada(self, tipo, message_size):
        """
        Valida entrada manual respeitando message_size máximo.
        CORREÇÃO: Usar message_size como limite, não rate_max.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor = int(entry.get())
            if valor < 0:
                valor = 0
                entry.delete(0, tk.END)
                entry.insert(0, "0")
            
            # CORREÇÃO: Verificar limite individual por message_size
            if valor > message_size:
                valor = message_size
                entry.delete(0, tk.END)
                entry.insert(0, str(valor))
            
            # Atualizar valores armazenados
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
            
            # Atualizar barra "To send"
            self._atualizar_barra_to_send()
            
            print(f"DEBUG: [GESTÃO_PACOTES] {tipo} validado para {valor} (limite: {message_size})")
            
        except ValueError:
            # Se valor inválido, resetar para 0
            entry.delete(0, tk.END)
            entry.insert(0, "0")
            self._valores_pacotes[self._carta_atual_gestao][tipo] = 0
    
    def _atualizar_barra_to_send(self):
        """Atualiza a barra 'To send' com base nos valores inseridos"""
        valores = self._valores_pacotes[self._carta_atual_gestao]
        
        # CORREÇÃO: "To send" = message_size(DB) - enviados - perdidos
        # Obter message_size da base de dados para a carta atual (coerente com pré-Final Phase)
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # Calcular quanto ainda resta para enviar
        total_processado = valores['enviados'] + valores['perdidos']
        to_send_restante = max(message_size - total_processado, 0)
        
        print(f"DEBUG: [GESTÃO_PACOTES] Cálculo 'To send':")
        print(f"DEBUG: [GESTÃO_PACOTES]   Message size (DB): {message_size}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Enviados (Rxd): {valores['enviados']}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Perdidos (Lost): {valores['perdidos']}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Total processado: {total_processado}")
        print(f"DEBUG: [GESTÃO_PACOTES]   To send restante: {to_send_restante}")
        
        # Atualizar a barra de progresso "To send" usando o widget diretamente
        if hasattr(self, 'progress_bars') and "To send" in self.progress_bars:
            # Usar configuração do widget Progressbar do tkinter (máximo coerente com DB)
            self.progress_bars["To send"].config(value=to_send_restante, maximum=message_size)
            print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'To send' atualizada para {to_send_restante}/{message_size}")
            
        # Atualizar label do valor usando o widget diretamente
        if hasattr(self, 'progress_labels') and "To send" in self.progress_labels:
            self.progress_labels["To send"].config(text=str(to_send_restante))
            print(f"DEBUG: [GESTÃO_PACOTES] Progress label 'To send' atualizada para {to_send_restante}")
        
        # NOVO: Atualizar também as barras Rxd e Lost para refletir os valores atuais
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=valores['enviados'])
                self.progress_labels["Rxd"].config(text=str(valores['enviados']))
                print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'Rxd' atualizada para {valores['enviados']}")
                
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=valores['perdidos'])
                self.progress_labels["Lost"].config(text=str(valores['perdidos']))
                print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'Lost' atualizada para {valores['perdidos']}")
        
        # REMOVIDO: Não verificar completion automaticamente - só no botão seta da última carta
        # self._verificar_completion_activity()
    
    def _verificar_completion_activity(self):
        """
        Verifica se uma Activity/Challenge foi completada:
        - To send = 0 (todos os pacotes da mensagem foram enviados)
        - drops_allowed = False
        
        NOTA: Uma Activity/Challenge é completada quando todos os pacotes da mensagem
        (message_size) foram enviados ao longo de múltiplos turnos, não apenas
        quando o rate de um turno foi atingido.
        """
        if not hasattr(self, '_valores_pacotes') or self._carta_atual_gestao not in self._valores_pacotes:
            return
        
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        
        # Obter dados da carta da database
        dados_carta = self._obter_dados_carta(carta_atual)
        if not dados_carta:
            print(f"DEBUG: [COMPLETION] Não foi possível obter dados da carta {os.path.basename(carta_atual)}")
            return
        
        # CORREÇÃO: Para Challenges, verificar completion mesmo com drops_allowed=True
        # As regras de completion são diferentes para Activities vs Challenges
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        drops_allowed = dados_carta.get('drops_allowed', True)
        
        # NOVA LÓGICA: Challenges sempre verificam completion, Activities só se drops_allowed=False
        if is_activity and drops_allowed:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=True, não verifica completion")
            return
        elif is_challenge:
            print(f"DEBUG: [COMPLETION] Challenge {os.path.basename(carta_atual)} - sempre verifica completion")
        else:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=False - verifica completion")
        
        # Obter dados da carta para verificar completion
        message_size = dados_carta.get('message_size', 0)
        
        # Verificar se a carta tem dados de progresso acumulados
        if not hasattr(self, 'card_stats'):
            print(f"DEBUG: [COMPLETION] Dados de progresso não encontrados")
            return
            
        # CORREÇÃO: Encontrar o índice real da carta no carrossel
        carta_idx = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                carta_idx = i
                break
        
        if carta_idx is None or carta_idx >= len(self.card_stats):
            print(f"DEBUG: [COMPLETION] Carta não encontrada no carrossel ou índice inválido")
            return
            
        stats = self.card_stats[carta_idx]
        to_send_atual = stats['To send']
        rxd_acumulado = stats['Rxd']
        
        print(f"DEBUG: [COMPLETION] Verificando completion para {os.path.basename(carta_atual)}:")
        print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [COMPLETION]   Message size: {message_size}")
        print(f"DEBUG: [COMPLETION]   To send atual: {to_send_atual}")
        print(f"DEBUG: [COMPLETION]   Rxd acumulado: {rxd_acumulado}")
        print(f"DEBUG: [COMPLETION]   Drops allowed: {drops_allowed}")
        
        # CORREÇÃO: Condições de completion mais flexíveis
        # Para Challenges: To send = 0 OU Rxd >= message_size
        # Para Activities: To send = 0 E Rxd >= message_size
        completion_achieved = False
        
        if is_challenge:
            # Challenges: mais flexível - ou todos enviados ou todos recebidos
            completion_achieved = (to_send_atual == 0) or (rxd_acumulado >= message_size)
            completion_reason = "todos enviados" if to_send_atual == 0 else f"todos recebidos ({rxd_acumulado}/{message_size})"
        else:
            # Activities: mais restritivo - todos enviados E todos recebidos
            completion_achieved = (to_send_atual == 0) and (rxd_acumulado >= message_size)
            completion_reason = f"todos enviados e recebidos ({rxd_acumulado}/{message_size})"
        
        if completion_achieved:
            print(f"DEBUG: [COMPLETION] *** {'Challenge' if is_challenge else 'Activity'} COMPLETADA! ***")
            print(f"DEBUG: [COMPLETION] Carta: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [COMPLETION] Motivo: {completion_reason}")
            
            # Mostrar overlay de congratulações
            self._mostrar_overlay_completion(carta_atual, dados_carta)
        else:
            print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_atual)} ainda não completada:")
            print(f"DEBUG: [COMPLETION]   To send: {to_send_atual} (deve ser 0)")
            print(f"DEBUG: [COMPLETION]   Rxd: {rxd_acumulado} (deve ser >= {message_size})")
            print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge (flexível)' if is_challenge else 'Activity (restritivo)'}")
    
    def _mostrar_overlay_completion(self, carta_path, dados_carta, is_sequential=False, carta_index=None):
        """
        Mostra overlay de congratulações quando Activity/Challenge é completada
        
        Args:
            carta_path: Caminho da carta completada
            dados_carta: Dados da carta da base de dados
            is_sequential: Se True, este overlay faz parte de uma sequência (múltiplas cartas completadas)
            carta_index: Índice específico da carta no carrossel (para cálculo correto de reward)
        """
        print(f"DEBUG: [COMPLETION] Mostrando overlay de congratulações")
        print(f"DEBUG: [COMPLETION] Sequencial: {is_sequential}")
        
        # CORREÇÃO: Limpar controles de gestão antes de mostrar overlay
        # Isso evita que o botão roxo apareça por baixo do overlay
        if hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa:
            print(f"DEBUG: [COMPLETION] Removendo controles de gestão antes do overlay")
            self._remover_controles_gestao_silencioso()
        
        # Determinar tipo da carta (Activity ou Challenge)
        carta_basename = os.path.basename(carta_path).lower()
        if "activity" in carta_basename:
            card_type = "Activity"
        elif "challenge" in carta_basename:
            card_type = "Challenge"
        else:
            card_type = "Activity"  # fallback
        
        print(f"DEBUG: [COMPLETION] Tipo de carta detectado: {card_type}")
        
        # Calcular reward baseado no tipo de carta e regras específicas usando índice correto
        reward_value = self._calcular_reward_completion(carta_path, dados_carta, card_type, carta_index)
        print(f"DEBUG: [COMPLETION] Reward calculado: {reward_value} picoins")
        
        # NOVO FORMATO: Overlay fullscreen igual ao de ativação
        # Limpar TODOS os widgets para criar overlay fullscreen
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (igual ao overlay de ativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à ativação)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à ativação)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [COMPLETION] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de congratulações (centro da tela) - fundo preto com letras coloridas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de ativação
        completion_frame = tk.Frame(self, bg="black")
        completion_frame.pack(expand=True)
        
        # NOVO: Se é sequencial, mostrar informação sobre progresso (APENAS para Challenges)
        if (is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays') and
            card_type == "Challenge"):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            
            progress_lbl = tk.Label(
                completion_frame,
                text=f"Carta {current_index + 1} de {total_overlays} completadas",
                font=("Helvetica", 14),
                fg="#888888",
                bg="black"
            )
            progress_lbl.pack(pady=(5, 0))
            
            # Nome da carta atual
            carta_name = os.path.basename(carta_path).replace('.png', '')
            carta_name_lbl = tk.Label(
                completion_frame,
                text=carta_name,
                font=("Helvetica", 16, "bold"),
                fg="#8000FF",
                bg="black"
            )
            carta_name_lbl.pack(pady=(0, 10))
        
        # Título "Congratulations!" em roxo (centralizado)
        title_lbl = tk.Label(
            completion_frame,
            text="   Congratulations!   ",
            font=("Helvetica", 20, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(10, 10), anchor="center")
        
        # Frame para "You've won" + valor + picoin
        won_frame = tk.Frame(completion_frame, bg="black")
        won_frame.pack(pady=(0, 30), anchor="center")
        
        # Texto "You've won"
        won_text_lbl = tk.Label(won_frame, text="You've won", 
                               font=("Helvetica", 14, "bold"), 
                               fg="white", bg="black")
        won_text_lbl.pack(side="left", padx=(0, 10))
        
        # Valor da reward
        valor_lbl = tk.Label(won_frame, text=str(reward_value), 
                            font=("Helvetica", 14, "bold"), 
                            fg="#FFD700", bg="black")
        valor_lbl.pack(side="left", padx=(0, 5))
        
        # Ícone do picoin
        try:
            coin_img_path = os.path.join(os.path.dirname(__file__), "img", "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path).resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                coin_lbl = tk.Label(won_frame, image=coin_img, bg="black")
                coin_lbl.image = coin_img  # type: ignore[attr-defined]
                coin_lbl.pack(side="left")
            else:
                # Fallback para emoji
                coin_lbl = tk.Label(won_frame, text="🪙", 
                                   font=("Helvetica", 14), 
                                   fg="#FFD700", bg="black")
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar ícone picoin: {e}")
            # Fallback para emoji
            coin_lbl = tk.Label(won_frame, text="🪙", 
                               font=("Helvetica", 14), 
                               fg="#FFD700", bg="black")
            coin_lbl.pack(side="left")
        
        # CORREÇÃO: Botão para fechar o overlay (sempre presente)
        def fechar_e_continuar():
            print(f"DEBUG: [COMPLETION] Fechando overlay e continuando...")
            
            # CRÍTICO: Verificar se já foi processado para evitar duplicação
            if hasattr(self, '_completion_processed') and self._completion_processed:
                print(f"DEBUG: [COMPLETION] AVISO: Completion já processado, ignorando")
                return
                
            # Marcar como processado
            self._completion_processed = True
            
            # Atualizar saldo do jogador
            self.saldo += reward_value
            print(f"DEBUG: [COMPLETION] Saldo atualizado: +{reward_value}, novo saldo: {self.saldo}")
            
            # AGORA remover carta do carrossel e devolver para store
            self._devolver_carta_para_store(carta_path, card_type)
            
            # Resetar flag para próximo overlay
            self._completion_processed = False
            
            # NOVO: Se é sequencial, mostrar próximo overlay
            if is_sequential and hasattr(self, '_next_completion_overlays') and hasattr(self, '_current_completion_index'):
                next_index = self._current_completion_index + 1
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                self._mostrar_overlays_completion_sequencial(self._next_completion_overlays, next_index)
            else:
                print(f"DEBUG: [COMPLETION] Todos os overlays de completion foram mostrados")
                
                # AGORA verificar se ainda há cartas válidas para processar
                cartas_reais_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for i, carta in enumerate(self.cards):
                        carta_basename = os.path.basename(carta).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            # NOVA FUNCIONALIDADE: Verificar flag da carta
                            is_face_up = True  # Default para compatibilidade
                            if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                                is_face_up = self.card_face_up_flags[i]
                            
                            if is_face_up:
                                cartas_reais_no_carrossel += 1
                
                # Verificar se ainda há cartas na lista de gestão VÁLIDAS (já foi atualizada acima)
                cartas_gestao_restantes = 0
                cartas_validas_gestao = []
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    # NOVA FUNCIONALIDADE: Primeiro limpar cartas inválidas (viradas para baixo) da gestão
                    cartas_para_remover = []
                    for carta in self._cartas_gestao:
                        if carta and hasattr(self, 'cards') and carta in self.cards:
                            carta_index = self.cards.index(carta)
                            if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                if not self.card_face_up_flags[carta_index]:
                                    cartas_para_remover.append(carta)
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} virada para baixo - será removida da gestão")
                    
                    # Remover cartas inválidas
                    for carta in cartas_para_remover:
                        carta_index_gestao = self._cartas_gestao.index(carta)
                        self._cartas_gestao.remove(carta)
                        # Ajustar índice se necessário
                        if carta_index_gestao <= self._carta_atual_gestao and self._carta_atual_gestao > 0:
                            self._carta_atual_gestao -= 1
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} removida da gestão")
                    
                    # CORREÇÃO: Verificar apenas se há cartas VÁLIDAS restantes na lista de gestão
                    # NÃO verificar se podem processar - isso será feito dentro da gestão
                    for i, carta in enumerate(self._cartas_gestao):
                        if carta:
                            carta_basename = os.path.basename(carta).lower()
                            # Carta deve ser Activity ou Challenge E existir no carrossel E estar virada para cima
                            if (not carta_basename.startswith("back_card_") and 
                                ("activity" in carta_basename or "challenge" in carta_basename) and
                                hasattr(self, 'cards') and carta in self.cards):
                                
                                # NOVA FUNCIONALIDADE: Verificar flag da carta
                                carta_index = self.cards.index(carta)
                                is_face_up = True  # Default para compatibilidade
                                if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                    is_face_up = self.card_face_up_flags[carta_index]
                                
                                if is_face_up:
                                    print(f"DEBUG: [COMPLETION] Carta válida encontrada: {os.path.basename(carta)} - gestão deve continuar")
                                    cartas_gestao_restantes += 1
                                    cartas_validas_gestao.append(carta)
                                else:
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} está virada para baixo - será ignorada")
                    
                    # ADICIONAL: Se há cartas na lista mas _carta_atual_gestao está fora de range, ajustar
                    if cartas_gestao_restantes > 0 and hasattr(self, '_carta_atual_gestao'):
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            print(f"DEBUG: [COMPLETION] ⚠️ _carta_atual_gestao ({self._carta_atual_gestao}) fora de range - ajustando para 0")
                            self._carta_atual_gestao = 0
                
                # VERIFICAÇÃO CRÍTICA: Se gestão está ativa mas não há cartas para processar, finalizar imediatamente
                gestao_esta_ativa = (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa)
                
                # NOVA LÓGICA: A gestão deve continuar APENAS se há cartas VÁLIDAS na lista de gestão
                gestao_deve_continuar = gestao_esta_ativa and cartas_gestao_restantes > 0
                
                print(f"DEBUG: [COMPLETION] ===== DECISÃO DE CONTINUAÇÃO DA GESTÃO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] cartas_reais_no_carrossel: {cartas_reais_no_carrossel}")
                print(f"DEBUG: [COMPLETION] cartas_gestao_restantes: {cartas_gestao_restantes}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                print(f"DEBUG: [COMPLETION] cartas_validas_gestao: {[os.path.basename(c) for c in cartas_validas_gestao]}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                
                # CORREÇÃO CRÍTICA: PRIMEIRO remover carta da LISTA DE GESTÃO, não do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA DA LISTA DE GESTÃO ===")
                if (hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao') and
                    self._cartas_gestao and carta_path in self._cartas_gestao):
                    
                    # Encontrar e remover carta da lista de gestão
                    try:
                        carta_gestao_idx = self._cartas_gestao.index(carta_path)
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_path)} está na posição {carta_gestao_idx} da lista de gestão")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao antes da remoção: {self._carta_atual_gestao}")
                        
                        # Remover carta da lista
                        self._cartas_gestao.remove(carta_path)
                        
                        # CORREÇÃO CRÍTICA: Ajustar _carta_atual_gestao baseado na posição da carta removida
                        if carta_gestao_idx < self._carta_atual_gestao:
                            # Carta removida estava antes da carta atual, decrementar índice
                            self._carta_atual_gestao -= 1
                            print(f"DEBUG: [COMPLETION] Carta removida antes da atual - índice decrementado para: {self._carta_atual_gestao}")
                        elif carta_gestao_idx == self._carta_atual_gestao:
                            # A carta atual foi removida
                            print(f"DEBUG: [COMPLETION] Carta atual foi removida - mantendo índice {self._carta_atual_gestao}")
                            # NOVA LÓGICA: Se removemos a carta atual, o índice fica apontando para a próxima carta
                            # Se o índice ficou >= tamanho da lista, significa que removemos a última carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                if len(self._cartas_gestao) > 0:
                                    # Há cartas restantes, voltar ao início
                                    self._carta_atual_gestao = 0
                                    print(f"DEBUG: [COMPLETION] Última carta removida - voltando ao início: {self._carta_atual_gestao}")
                                else:
                                    # Não há cartas restantes
                                    print(f"DEBUG: [COMPLETION] Nenhuma carta restante na gestão")
                        # Se carta_gestao_idx > self._carta_atual_gestao, não precisa ajustar
                        
                        print(f"DEBUG: [COMPLETION] Lista gestão após remoção: {len(self._cartas_gestao)} cartas")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao após remoção: {self._carta_atual_gestao}")
                        print(f"DEBUG: [COMPLETION] Cartas restantes: {[os.path.basename(c) for c in self._cartas_gestao]}")
                        
                    except ValueError:
                        print(f"DEBUG: [COMPLETION] AVISO: Carta não estava na lista de gestão")
                
                # SEGUNDO: AGORA remover carta do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA COMPLETADA DO CARROSSEL ===")
                self._remover_carta_do_carrossel(carta_path)
                
                # TERCEIRO: Determinar se gestão deve continuar baseado nas cartas restantes NA LISTA DE GESTÃO
                gestao_deve_continuar = False
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    print(f"DEBUG: [COMPLETION] ✅ Há {len(self._cartas_gestao)} cartas restantes na lista de gestão - gestão deve continuar")
                    gestao_deve_continuar = True
                    
                    # Garantir que _carta_atual_gestao está dentro dos limites
                    if self._carta_atual_gestao >= len(self._cartas_gestao):
                        self._carta_atual_gestao = 0
                    
                    proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                    print(f"DEBUG: [COMPLETION] ✅ Próxima carta será: {os.path.basename(proxima_carta)} (posição gestão: {self._carta_atual_gestao})")
                else:
                    print(f"DEBUG: [COMPLETION] ❌ Lista de gestão vazia - finalizando gestão")
                    gestao_deve_continuar = False
                
                # TERCEIRO: Ajustar índice se está fora de range
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                    if self._carta_atual_gestao >= len(self._cartas_gestao):
                        self._carta_atual_gestao = len(self._cartas_gestao) - 1
                        print(f"DEBUG: [COMPLETION] Ajustado _carta_atual_gestao para {self._carta_atual_gestao}")
                
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                
                print(f"DEBUG: [COMPLETION] ===== DECISÃO DE CONTINUAÇÃO DA GESTÃO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                
                # QUARTO: Tomar decisão final sobre continuação da gestão
                if gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] ✅ Continuando gestão de pacotes")
                    
                    # CORREÇÃO CRÍTICA: Determinar corretamente a próxima carta válida na lista de gestão
                    if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                        # NOVA LÓGICA: Quando uma carta é removida no meio da lista, o índice atual já aponta para a próxima carta
                        # Se a carta removida estava na posição atual, não incrementamos - a próxima já está na mesma posição
                        # Se a carta removida estava antes da atual, já decrementámos o índice
                        
                        # Verificar se o índice atual ainda está válido
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            # Se o índice ficou inválido, significa que removemos a última carta
                            # Voltar ao início da lista para continuar com a primeira carta restante
                            self._carta_atual_gestao = 0
                            print(f"DEBUG: [COMPLETION] Índice ajustado para início da lista: {self._carta_atual_gestao}")
                        
                        proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                        print(f"DEBUG: [COMPLETION] ✅ Próxima carta determinada: {os.path.basename(proxima_carta)} (posição gestão: {self._carta_atual_gestao})")
                        
                        # Encontrar a posição desta carta no carrossel ATUALIZADO (após remoção)
                        proxima_posicao = None
                        if hasattr(self, 'cards'):
                            for i, carta in enumerate(self.cards):
                                if carta == proxima_carta:
                                    proxima_posicao = i
                                    print(f"DEBUG: [COMPLETION] ✅ Próxima carta encontrada no carrossel posição {i}")
                                    break
                        
                        if proxima_posicao is not None:
                            print(f"DEBUG: [COMPLETION] ✅ Atualizando seleção para próxima carta válida:")
                            print(f"DEBUG: [COMPLETION]   Carta: {os.path.basename(proxima_carta)}")
                            print(f"DEBUG: [COMPLETION]   Posição carrossel: {proxima_posicao}")
                            print(f"DEBUG: [COMPLETION]   Posição gestão: {self._carta_atual_gestao}")
                            
                            # ATUALIZAR seleção do carrossel para a próxima carta CORRETA
                            self.selected_carousel_card = proxima_carta
                            self.selected_carousel_index = proxima_posicao
                            
                        else:
                            print(f"DEBUG: [COMPLETION] ❌ ERRO: Próxima carta {os.path.basename(proxima_carta)} não encontrada no carrossel")
                            print(f"DEBUG: [COMPLETION] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
                            gestao_deve_continuar = False
                    
                    if gestao_deve_continuar:
                        print(f"DEBUG: [COMPLETION] Reconstruindo dashboard e continuando gestão...")
                        
                        # RECONSTRUIR DASHBOARD antes de continuar gestão
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                        # Depois de reconstruir, continuar gestão na carta correta
                        self.after(100, lambda: self._mostrar_gestao_carta_atual())
                        return
                
                if not gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] ✅ Gestão de pacotes finalizada - não há mais cartas para processar")
                    print(f"DEBUG: [COMPLETION] Voltando ao dashboard normal com End Turn habilitado")
                    
                    # CORREÇÃO CRÍTICA: Finalizar gestão mas MANTER Final Phase ativo para End Turn
                    self._final_phase_gestao_ativa = False
                    # NÃO limpar _final_phase_active - o jogador ainda está em Final Phase!
                    
                    # CORREÇÃO: Ativar End Turn quando gestão termina por completion
                    self._show_end_turn_button = True
                    
                    if hasattr(self, '_cartas_gestao'):
                        self._cartas_gestao = []
                    if hasattr(self, '_carta_atual_gestao'):
                        self._carta_atual_gestao = 0
                    
                    # CORREÇÃO CRÍTICA: Voltar ao dashboard MANTENDO Final Phase ativo
                    print(f"DEBUG: [COMPLETION] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    # CORREÇÃO CRÍTICA: Ativar o botão End Turn APÓS reconstruir a interface
                    self.after(100, self._ativar_botao_end_turn)
                    
                    # CORREÇÃO NOVA: Forçar atualização dos destaques para garantir que carta restante fique destacada
                    self.after(200, lambda: self._update_carousel_selection_highlights())
        
        # Texto do botão baseado no tipo de carta
        if card_type == "Activity":
            btn_text = "OK"
        elif is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays'):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            if current_index < total_overlays - 1:
                btn_text = "Próxima →"
            else:
                btn_text = "Finalizar"
        else:
            btn_text = "OK"
        
        # Botão OK roxo (inferior central)
        print(f"DEBUG: [COMPLETION] Criando botão OK...")
        ok_btn = tk.Button(
            completion_frame,
            text=btn_text,
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="#8000FF",  # Roxo
            bd=2,
            relief="raised",
            width=12,
            height=1,
            command=fechar_e_continuar
        )
        ok_btn.pack(pady=(20, 20), anchor="center")  # Centralizar o botão
        print(f"DEBUG: [COMPLETION] Botão OK criado e posicionado")
        
        print(f"DEBUG: [COMPLETION] Overlay de congratulações criado com botão '{btn_text}'")
        
        # Armazenar dados da recompensa e tipo de carta para quando fechar o overlay
        self._completion_reward = reward_value
        self._completed_card_path = carta_path
        self._completed_card_type = card_type
        
        # Forçar update da janela principal para garantir que tudo é renderizado
        self.update_idletasks()
        self.deiconify()  # Garantir que está visível
        self.lift()       # Trazer para a frente
        self.focus_force()  # Forçar foco
        
        print(f"DEBUG: [COMPLETION] Overlay criado, tipo: {card_type}, recompensa: {reward_value} picoins")
        print(f"DEBUG: [COMPLETION] Widgets criados no overlay: {len(completion_frame.winfo_children())} widgets")
        print(f"DEBUG: [COMPLETION] Botão OK widget: {ok_btn}")
        print(f"DEBUG: [COMPLETION] Botão OK visível: {ok_btn.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal geometry: {self.geometry()}")
        print(f"DEBUG: [COMPLETION] Janela principal viewable: {self.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal ismapped: {self.winfo_ismapped()}")
    
    def _calcular_reward_completion(self, carta_path, dados_carta, card_type, carta_index=None):
        """
        Calcula o reward de completion baseado nas regras específicas do arquivo Reward_Activity e Reward_Challenge
        """
        print(f"DEBUG: [REWARD_CALC] Calculando reward para {card_type}: {os.path.basename(carta_path)}")
        
        # CORREÇÃO: Usar índice específico da carta se fornecido, senão usar selected_card_idx
        card_idx = carta_index if carta_index is not None else getattr(self, 'selected_card_idx', 0)
        
        # Obter valores atuais das barras de progresso usando o índice correto
        rxd_atual = self._obter_valor_barra_atual_by_index("Rxd", card_idx)
        lost_atual = self._obter_valor_barra_atual_by_index("Lost", card_idx)
        
        print(f"DEBUG: [REWARD_CALC] Valores atuais (carta índice {card_idx}) - Rxd: {rxd_atual}, Lost: {lost_atual}")
        print(f"DEBUG: [REWARD_CALC] Dados da carta: {dados_carta}")
        
        if card_type == "Activity":
            return self._calcular_reward_activity(carta_path, dados_carta, rxd_atual, lost_atual)
        elif card_type == "Challenge":
            return self._calcular_reward_challenge(carta_path, dados_carta, rxd_atual, lost_atual)
        else:
            # Fallback para valor message_received
            return dados_carta.get('message_received', 0)
    
    def _calcular_reward_activity(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Activity baseado nas regras do arquivo Reward_Activity
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necessários da carta
        reward_per_packet = dados_carta.get('reward_per_packet', 0)
        packet_bonus = dados_carta.get('packet_bonus', 0)
        bonus_condition = dados_carta.get('bonus_condition', 0)
        message_received = dados_carta.get('message_received', 0)
        message_size = dados_carta.get('message_size', 0)
        penalty_per_packet = dados_carta.get('penalty_per_packet', 0)
        penalty_condition = dados_carta.get('penalty_condition', 0)
        
        print(f"DEBUG: [REWARD_CALC] Activity data:")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  packet_bonus: {packet_bonus}")
        print(f"  bonus_condition: {bonus_condition}")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  penalty_per_packet: {penalty_per_packet}")
        print(f"  penalty_condition: {penalty_condition}")
        
        # Identificar qual Activity é baseado no nome do arquivo
        if "activity_1" in carta_basename:
            # Activity_1 (Home Surveillance): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_1: {n_rxd} × {reward_per_packet} = {reward}")
            
        elif "activity_2" in carta_basename or "activity_3" in carta_basename:
            # Activity_2-3 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [n_Rxd x packet_bonus (se n_Rxd >= bonus_condition)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (n_rxd * packet_bonus) if n_rxd >= bonus_condition else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_2-3: {n_rxd}×{reward_per_packet} + bonus({n_rxd}×{packet_bonus} se {n_rxd}>={bonus_condition}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_4" in carta_basename:
            # Activity_4 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [message_received (se bonus_condition == n_Lost)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if bonus_condition == n_lost else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_4: {n_rxd}×{reward_per_packet} + message_received({message_received} se {bonus_condition}=={n_lost}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_5" in carta_basename:
            # Activity_5 (Home Safety): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_5: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_6" in carta_basename or "activity_7" in carta_basename:
            # Activity_6-7 (Home Safety): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost <= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost <= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # Não pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_6-7: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}×{penalty_per_packet} se {n_lost}<={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_8" in carta_basename:
            # Activity_8 (Short Message): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_8: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_9" in carta_basename:
            # Activity_9 (Short Message): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost >= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost >= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # Não pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_9: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}×{penalty_per_packet} se {n_lost}>={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_10" in carta_basename:
            # Activity_10 (Gaming): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_10: {n_rxd} × {reward_per_packet} = {reward}")
            
        elif "activity_11" in carta_basename:
            # Activity_11 (Gaming): Reward = [n_Rxd x reward_per_packet] + [message_received (se n_Rxd == message_size)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if n_rxd == message_size else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_11: {n_rxd}×{reward_per_packet} + message_received({message_received} se {n_rxd}=={message_size}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_12" in carta_basename:
            # Activity_12 (File Transfer): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_12: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        else:
            # Fallback para Activities não reconhecidas
            reward = message_received
            print(f"DEBUG: [REWARD_CALC] Activity não reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que não é negativo
    
    def _calcular_reward_challenge(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Challenge baseado nas regras do arquivo Reward_Challenge
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necessários da carta
        message_received = dados_carta.get('message_received', 0) or 0
        message_size = dados_carta.get('message_size', 0) or 0
        reward_per_packet = dados_carta.get('reward_per_packet', 0) or 0
        time_limit_bonus = dados_carta.get('time_limit_bonus', 0) or 0
        message_received_bonus = dados_carta.get('message_received_bonus', 0) or 0
        
        # CORREÇÃO: Usar valor passado por parâmetro em vez de obter da barra atual
        # (que pode estar apontando para carta errada)
        to_send_atual = message_size - n_rxd  # Calcular To send baseado nos valores corretos
        
        print(f"DEBUG: [REWARD_CALC] Challenge data:")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  time_limit_bonus: {time_limit_bonus}")
        print(f"  message_received_bonus: {message_received_bonus}")
        print(f"  to_send_calculado: {to_send_atual}")
        
        # Verificar condições de completion (To send = 0 e Rxd = message_size)
        completion_achieved = (to_send_atual == 0 and n_rxd == message_size)
        print(f"DEBUG: [REWARD_CALC] Completion achieved: {completion_achieved} (to_send={to_send_atual}, rxd={n_rxd}, message_size={message_size})")
        
        # Identificar qual Challenge é baseado no nome do arquivo
        if any(f"challenge_{i}." in carta_basename for i in range(1, 5)):
            # Challenge_1-4 (Message Mission): Reward = message_received (se completion achieved)
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge_1-4: message_received({message_received} se completion) = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(5, 8)):
            # Challenge_5-7 (Message Sprint): Reward = time_limit_bonus + message_received (se completion achieved E dentro do time_limit)
            time_limit = dados_carta.get('time_limit', 0) or 0
            
            # Verificar se carta foi iniciada e calcular turnos decorridos
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            within_time_limit = turns_elapsed <= time_limit if time_limit > 0 else True
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7 timing:")
            print(f"  time_limit: {time_limit} turnos")
            print(f"  turns_elapsed: {turns_elapsed} turnos")
            print(f"  within_time_limit: {within_time_limit}")
            
            # Time bonus só é dado se completion achieved E dentro do limite de tempo
            time_bonus = (time_limit_bonus or 0) if (completion_achieved and within_time_limit) else 0
            # Message received só é dado se completion achieved (independente do tempo)
            message_bonus = (message_received or 0) if completion_achieved else 0
            reward = time_bonus + message_bonus
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7: time_limit_bonus({time_limit_bonus} se completion E time_limit) + message_received({message_received} se completion) = {time_bonus} + {message_bonus} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(8, 11)):
            # Challenge_8-10 (Jackpot): Reward = [n_Rxd x reward_per_packet] + [message_received_bonus (se completion achieved)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (message_received_bonus or 0) if completion_achieved else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Challenge_8-10: {n_rxd}×{reward_per_packet} + message_received_bonus({message_received_bonus} se completion) = {base_reward} + {bonus_reward} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(11, 15)):
            # Challenge_11-14 (Packet Race): Reward = n_Rxd x reward_per_packet (SEM verificação de completion)
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Challenge_11-14: {n_rxd} × {reward_per_packet} = {reward}")
            
        else:
            # Fallback para Challenges não reconhecidas
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge não reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que não é negativo
    
    def _get_turns_elapsed_for_challenge(self, carta_path):
        """
        Calcula quantos turnos se passaram desde que a carta Challenge foi aceite
        CORREÇÃO: Detecção automática de Challenges sem registo baseada no turno atual e n_turns
        """
        # VERIFICAÇÃO DE SINCRONIZAÇÃO DOS CONTADORES
        print(f"DEBUG: [TIME_TRACKING] === VERIFICAÇÃO DE SINCRONIZAÇÃO ===")
        print(f"DEBUG: [TIME_TRACKING] _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING] _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING] _current_turn_id (Processing): {self._current_turn_id}")
        
        if carta_path in self._challenge_start_turns:
            start_turn = self._challenge_start_turns[carta_path]
            turns_elapsed = self._current_turn_number - start_turn + 1  # +1 porque o turno atual conta
            print(f"DEBUG: [TIME_TRACKING] Challenge {os.path.basename(carta_path)}:")
            print(f"  Turno de início: {start_turn}")
            print(f"  Turno atual: {self._current_turn_number} (USANDO CONTADOR CORRETO)")
            print(f"  Turnos decorridos: {turns_elapsed}")
            return turns_elapsed
        else:
            # CORREÇÃO AUTOMÁTICA: Se não há registo mas o turno atual é maior que n_turns da carta,
            # calcular automaticamente o turno de início provável
            print(f"DEBUG: [TIME_TRACKING] Challenge {os.path.basename(carta_path)} sem registo de início")
            
            # Tentar obter n_turns da carta para correção automática
            try:
                dados_carta = self._obter_dados_carta(carta_path)
                n_turns = dados_carta.get('n_turns', 1) if dados_carta else 1
                
                print(f"DEBUG: [TIME_TRACKING] n_turns detectado: {n_turns}")
                print(f"DEBUG: [TIME_TRACKING] Turno atual: {self._current_turn_number} (CONTADOR SINCRONIZADO)")
                
                # Se o turno atual for maior que n_turns, calcular turno de início
                if self._current_turn_number > n_turns:
                    # Calcular turno de início baseado na suposição de que o Challenge deve estar na Final Phase
                    calculated_start_turn = self._current_turn_number - n_turns
                    turns_elapsed = self._current_turn_number - calculated_start_turn + 1
                    
                    print(f"DEBUG: [TIME_TRACKING] ✅ CORREÇÃO AUTOMÁTICA APLICADA:")
                    print(f"  Turno início calculado: {calculated_start_turn}")
                    print(f"  Turnos decorridos: {turns_elapsed}")
                    print(f"  Challenge deve estar na Final Phase: {turns_elapsed >= n_turns}")
                    
                    # Registar o turno de início calculado para futuras verificações
                    self._challenge_start_turns[carta_path] = calculated_start_turn
                    
                    return turns_elapsed
                else:
                    # Se o turno atual for <= n_turns, assumir que foi aceite no turno 1
                    print(f"DEBUG: [TIME_TRACKING] Turno atual <= n_turns, assumindo início no turno 1")
                    turns_elapsed = self._current_turn_number
                    
                    # Registar o turno 1 como início
                    self._challenge_start_turns[carta_path] = 1
                    
                    return turns_elapsed
                    
            except Exception as e:
                print(f"DEBUG: [TIME_TRACKING] ⚠️ Erro ao obter dados da carta: {e}")
                # Fallback: assumir que foi aceite no turno atual (1 turno decorrido)
                print(f"DEBUG: [TIME_TRACKING] Fallback: assumindo turno atual")
                return 1
    
    def _register_challenge_start_turn(self, carta_path):
        """
        Regista o turno em que uma carta Challenge foi aceite
        """
        self._challenge_start_turns[carta_path] = self._current_turn_number
        print(f"DEBUG: [TIME_TRACKING] Challenge {os.path.basename(carta_path)} registado no turno {self._current_turn_number}")
    
    def _verificar_challenges_tempo_limite(self):
        """
        Verifica se alguma carta Challenge atingiu o limite de n_turns e força completion obrigatório
        Chamado automaticamente no end_turn()
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] === VERIFICANDO CHALLENGES COM TEMPO LIMITE ===")
        
        cartas_para_completion_obrigatorio = []
        
        # Verificar todas as cartas no carrossel
        for i, carta_path in enumerate(self.cards):
            if not carta_path or carta_path == os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"):
                continue
                
            # Verificar se é uma carta Challenge
            carta_basename = os.path.basename(carta_path).lower()
            if not carta_basename.startswith('challenge_'):
                continue
                
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Verificando Challenge: {os.path.basename(carta_path)}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Dados não encontrados para {os.path.basename(carta_path)}")
                continue
                
            n_turns = dados_carta.get('n_turns', 0)
            if n_turns <= 0:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge sem limite de turnos válido: n_turns={n_turns}")
                continue
                
            # Verificar quantos turnos passaram desde que foi ativada
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge {os.path.basename(carta_path)}:")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   n_turns limite: {n_turns}")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   turnos decorridos: {turns_elapsed}")
            
            # Se atingiu o limite, adicionar à lista para completion obrigatório
            if turns_elapsed >= n_turns:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] ⚠️  LIMITE ATINGIDO! Challenge deve ser completado obrigatoriamente")
                cartas_para_completion_obrigatorio.append({
                    'carta_path': carta_path,
                    'carta_index': i,
                    'dados_carta': dados_carta,
                    'turns_elapsed': turns_elapsed,
                    'n_turns': n_turns
                })
            else:
                turnos_restantes = n_turns - turns_elapsed
                print(f"DEBUG: [CHALLENGE_TIMEOUT] ✅ Ainda tem {turnos_restantes} turno(s) restante(s)")
        
        # Processar cartas que atingiram o limite
        if cartas_para_completion_obrigatorio:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] === {len(cartas_para_completion_obrigatorio)} CHALLENGE(S) ATINGIRAM LIMITE ===")
            self._processar_challenges_tempo_limite_atingido(cartas_para_completion_obrigatorio)
        else:
            print("DEBUG: [CHALLENGE_TIMEOUT] ✅ Nenhuma carta Challenge atingiu limite de turnos")
    
    def _processar_challenges_tempo_limite_atingido(self, cartas_lista):
        """
        Processa cartas Challenge que atingiram o limite de n_turns
        Força completion obrigatório com os valores atuais das barras de progresso
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] === PROCESSANDO COMPLETION OBRIGATÓRIO ===")
        
        # Mostrar mensagem informativa ao jogador
        import tkinter.messagebox
        nomes_cartas = [os.path.basename(carta['carta_path']) for carta in cartas_lista]
        mensagem = f"As seguintes cartas Challenge atingiram o limite de turnos e devem ser completadas obrigatoriamente:\n\n"
        mensagem += "\n".join([f"• {nome}" for nome in nomes_cartas])
        mensagem += f"\n\nAs cartas serão processadas automaticamente com os valores atuais das barras de progresso."
        
        tkinter.messagebox.showwarning("Challenge - Tempo Limite Atingido", mensagem)
        
        # Processar cada carta individualmente
        for carta_info in cartas_lista:
            carta_path = carta_info['carta_path']
            carta_index = carta_info['carta_index']
            dados_carta = carta_info['dados_carta']
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Processando completion obrigatório para: {os.path.basename(carta_path)}")
            
            # Obter valores atuais das barras de progresso para esta carta
            stats = self.card_stats[carta_index] if carta_index < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Valores finais da carta:")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   To send: {stats['To send']}")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   Rxd: {stats['Rxd']}")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   Lost: {stats['Lost']}")
            
            # Calcular reward com os valores atuais
            n_rxd = stats['Rxd']
            n_lost = stats['Lost']
            reward = self._calcular_reward_challenge(carta_path, dados_carta, n_rxd, n_lost)
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Reward calculado: {reward} picoins")
            
            # Atualizar saldo
            self.saldo += reward
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Saldo atualizado: {self.saldo} picoins")
            
            # Mostrar overlay de completion
            self._mostrar_overlay_completion_tempo_limite(carta_path, dados_carta, carta_info, reward)
            
            # Remover carta do carrossel e limpar tracking
            self._remover_carta_do_carrossel(carta_path)
            self._cleanup_completed_challenge_tracking(carta_path)
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] ✅ Challenge {os.path.basename(carta_path)} processado e removido")
    
    def _mostrar_overlay_completion_tempo_limite(self, carta_path, dados_carta, carta_info, reward):
        """
        Mostra overlay específico para completion por tempo limite
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] Mostrando overlay de completion por tempo limite")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Título do overlay
        title_label = tk.Label(
            overlay, 
            text="CHALLENGE - TEMPO LIMITE ATINGIDO!", 
            font=("Helvetica", 28, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.place(relx=0.5, rely=0.15, anchor="center")
        
        # Informações da carta
        carta_nome = os.path.basename(carta_path)
        info_text = f"Carta: {carta_nome}\n"
        info_text += f"Limite de turnos: {carta_info['n_turns']}\n"
        info_text += f"Turnos decorridos: {carta_info['turns_elapsed']}\n\n"
        info_text += f"Valores finais:\n"
        
        carta_index = carta_info['carta_index']
        if carta_index < len(self.card_stats):
            stats = self.card_stats[carta_index]
            info_text += f"Packets Received: {stats['Rxd']}\n"
            info_text += f"Packets Lost: {stats['Lost']}\n"
        
        info_text += f"\nReward obtido: {reward} picoins"
        
        info_label = tk.Label(
            overlay,
            text=info_text,
            font=("Helvetica", 18),
            bg="black",
            fg="white",
            justify="center"
        )
        info_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Botão OK
        ok_button = tk.Button(
            overlay,
            text="OK",
            font=("Helvetica", 16, "bold"),
            bg=self.bar_color,
            fg="black",
            width=10,
            command=overlay.destroy
        )
        ok_button.place(relx=0.5, rely=0.8, anchor="center")
        
        print("DEBUG: [CHALLENGE_TIMEOUT] Overlay de completion por tempo limite criado")

    def _increment_turn_counter(self):
        """
        Incrementa TODOS os contadores de turnos (chamado no end_turn)
        CORREÇÃO CRÍTICA: Sincronizar todos os sistemas de contagem
        """
        # 1. Contador principal para Challenges
        old_turn_challenges = self._current_turn_number
        self._current_turn_number += 1
        
        # 2. Contador para Events
        old_turn_events = self._current_turn
        self._current_turn += 1
        
        # 3. O _current_turn_id já é incrementado no _reset_turn_processing_counters
        # mas vamos garantir que está sincronizado
        expected_turn_id = self._current_turn_number
        if self._current_turn_id != expected_turn_id:
            print(f"DEBUG: [TIME_TRACKING] ⚠️ DESSINCRONIZAÇÃO DETECTADA!")
            print(f"DEBUG: [TIME_TRACKING] _current_turn_id: {self._current_turn_id} ≠ expected: {expected_turn_id}")
            self._current_turn_id = expected_turn_id
            print(f"DEBUG: [TIME_TRACKING] ✅ _current_turn_id corrigido para: {self._current_turn_id}")
        
        print(f"DEBUG: [TIME_TRACKING] ✅ CONTADORES SINCRONIZADOS:")
        print(f"DEBUG: [TIME_TRACKING]   Challenges: {old_turn_challenges} → {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING]   Events: {old_turn_events} → {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING]   Processing ID: {self._current_turn_id}")
        print(f"DEBUG: [TIME_TRACKING] ✅ TODOS OS SISTEMAS AGORA NO TURNO {self._current_turn_number}")
    
    def _cleanup_completed_challenge_tracking(self, carta_path):
        """
        Remove tracking de uma carta Challenge que foi completada
        """
        if carta_path in self._challenge_start_turns:
            del self._challenge_start_turns[carta_path]
            print(f"DEBUG: [TIME_TRACKING] Tracking removido para Challenge completado: {os.path.basename(carta_path)}")
    
    # ===============================
    # SISTEMA DE TRACKING DE SERVIÇOS TEMPORARY
    # ===============================
    
    def _register_service_start_turn(self, carta_path):
        """
        Regista o turno em que uma carta Service TEMPORARY foi ativada
        """
        # Verificar se é um serviço TEMPORARY usando a base de dados
        try:
            service_data = self._get_service_data_from_path(carta_path)
            if service_data and service_data.service_type.value == 'temporary' and service_data.service_turns:
                self._service_start_turns[carta_path] = self._current_turn_number
                self._service_duration_tracking[carta_path] = {
                    'duration_turns': service_data.service_turns,
                    'start_turn': self._current_turn_number
                }
                print(f"DEBUG: [SERVICE_TRACKING] Service TEMPORARY {os.path.basename(carta_path)} registado no turno {self._current_turn_number} (duração: {service_data.service_turns} turnos)")
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} não é TEMPORARY - tracking ignorado")
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] ERRO ao registar service: {e}")
    
    def _get_service_data_from_path(self, carta_path):
        """
        Obtém dados de um serviço usando a base de dados a partir do caminho
        """
        try:
            # Extrair ID do serviço do caminho (ex: Service_5.png -> service_temporary_5_red)
            filename = os.path.basename(carta_path)
            if not filename.startswith('Service_'):
                return None
                
            # Extrair número do serviço
            import re
            match = re.match(r'Service_(\d+)', filename)
            if not match:
                return None
                
            service_number = int(match.group(1))
            
            # Obter todos os serviços e mapear pelo número
            all_services = self.card_database.get_all_services()
            if service_number <= len(all_services):
                return all_services[service_number - 1]
                
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] Erro ao obter dados do serviço: {e}")
            
        return None
    
    def _verificar_services_expirados(self):
        """
        Verifica se algum serviço TEMPORARY expirou baseado no número de turnos
        Chamado automaticamente no end_turn()
        """
        print("DEBUG: [SERVICE_EXPIRY] === VERIFICANDO SERVIÇOS EXPIRADOS ===")
        
        services_expirados = []
        
        # Verificar todos os serviços ativos
        for carta_path in self.active_services[:]:  # Cópia para evitar modificação durante iteração
            if carta_path in self._service_duration_tracking:
                tracking_data = self._service_duration_tracking[carta_path]
                duration_turns = tracking_data['duration_turns']
                start_turn = tracking_data['start_turn']
                
                # Calcular turnos decorridos
                turnos_decorridos = self._current_turn_number - start_turn
                
                print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)}:")
                print(f"DEBUG: [SERVICE_EXPIRY]   Início: turno {start_turn}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Duração: {duration_turns} turnos")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turno atual: {self._current_turn_number}")
                
                # Verificar se expirou (turnos decorridos >= duração)
                if turnos_decorridos >= duration_turns:
                    print(f"DEBUG: [SERVICE_EXPIRY] ⏰ Service {os.path.basename(carta_path)} EXPIROU!")
                    services_expirados.append(carta_path)
        
        if services_expirados:
            print(f"DEBUG: [SERVICE_EXPIRY] {len(services_expirados)} serviços expiraram neste turno")
            # A expiração será tratada quando o usuário clicar na carta
        else:
            print("DEBUG: [SERVICE_EXPIRY] Nenhum serviço expirou neste turno")
    
    def _is_service_expired(self, carta_path):
        """
        Verifica se um serviço específico expirou
        """
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Verificando se Service expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Services com tracking: {list(self._service_duration_tracking.keys())}")
        
        if carta_path not in self._service_duration_tracking:
            print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)} NÃO está no tracking - considerado não expirado")
            # CORREÇÃO: Verificar se o Service está ativo mas sem tracking - recriar tracking se necessário
            if self.is_card_active(carta_path, "services"):
                print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service está ATIVO mas sem tracking - tentando recriar...")
                self._register_service_start_turn(carta_path)
                # Após recriar, verificar novamente se agora está no tracking
                if carta_path in self._service_duration_tracking:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Tracking recriado com sucesso - continuando verificação...")
                else:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Falhou ao recriar tracking - Service considerado não expirado")
                    return False
            else:
                return False
            
        tracking_data = self._service_duration_tracking[carta_path]
        duration_turns = tracking_data['duration_turns']
        start_turn = tracking_data['start_turn']
        
        turnos_decorridos = self._current_turn_number - start_turn
        expirou = turnos_decorridos >= duration_turns
        
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)}:")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno início: {start_turn}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        return expirou
    
    def _is_event_expired(self, carta_path):
        """
        Verifica se um event específico expirou
        """
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Verificando se Event expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Turno atual: {self._current_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Events com tracking: {list(self._event_duration_tracking.keys())}")
        
        if carta_path not in self._event_duration_tracking:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)} NÃO está no tracking - considerado não expirado")
            return False
            
        tracking_data = self._event_duration_tracking[carta_path]
        duration_turns = tracking_data.get('duration_turns')
        start_turn = tracking_data.get('start_turn')
        is_active = tracking_data.get('is_active', False)
        
        # Só verificar expiração se o Event estiver ativo
        if not is_active:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)} está INATIVO - considerado não expirado")
            return False
        
        if duration_turns is None or start_turn is None:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK] Dados de tracking incompletos para Event {os.path.basename(carta_path)} - considerado não expirado")
            return False
        
        turnos_decorridos = self._current_turn - start_turn
        expirou = turnos_decorridos >= duration_turns
        
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)}:")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turno início: {start_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Ativo: {is_active}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        return expirou
    
    def _cleanup_expired_service_tracking(self, carta_path):
        """
        Remove tracking de um serviço que expirou
        """
        if carta_path in self._service_start_turns:
            del self._service_start_turns[carta_path]
        if carta_path in self._service_duration_tracking:
            del self._service_duration_tracking[carta_path]
        print(f"DEBUG: [SERVICE_TRACKING] Tracking removido para Service expirado: {os.path.basename(carta_path)}")
    
    def _mostrar_overlay_service_expirado(self, carta_path):
        """
        Mostra overlay de serviço expirado com a carta em fullscreen de fundo
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Mostrando overlay de expiração para {os.path.basename(carta_path)}")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conteúdo do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # Título "Expired Service" em vermelho
        title_label = tk.Label(
            content_frame, 
            text="   Expired Service    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto "Service_x has expired"
        service_name = os.path.basename(carta_path).replace('.png', '')
        message_text = f"{service_name} has expired"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 18),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Botão OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#4CAF50",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_service_expirado(overlay, carta_path)
        )
        ok_button.pack(pady=20)
    
    def _processar_service_expirado(self, overlay, carta_path):
        """
        Processa a expiração do serviço: remove das cartas ativas, do inventário do jogador e devolve para a Store
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Processando expiração de {os.path.basename(carta_path)}")
        
        # Remover da lista de serviços ativos
        if carta_path in self.active_services:
            self.active_services.remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service removido da lista ativa")
        
        # CORREÇÃO CRÍTICA: Remover carta do inventário do jogador
        if carta_path in self.inventario.get("services", []):
            self.inventario["services"].remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} removido do inventário do jogador")
        else:
            print(f"DEBUG: [SERVICE_EXPIRY] AVISO: Service {os.path.basename(carta_path)} não encontrado no inventário do jogador")
        
        # CORREÇÃO CRÍTICA: Devolver carta para a Store
        try:
            self._devolver_carta_para_store(carta_path, "services")
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} devolvido para a Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao devolver carta para Store: {e}")
        
        # Limpar tracking
        self._cleanup_expired_service_tracking(carta_path)
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de inventário de Services do jogador (interface completa)
        print(f"DEBUG: [SERVICE_EXPIRY] Abrindo matriz de inventário de Services do jogador")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de inventário de Services (interface completa e formatada)
            self.show_inventory_matrix(["services"], page=0)
            print(f"DEBUG: [SERVICE_EXPIRY] Matriz de inventário de Services aberta com sucesso")
            print(f"DEBUG: [SERVICE_EXPIRY] Processo de expiração completo - carta removida do jogador e devolvida à Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao abrir matriz de inventário de Services: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [SERVICE_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [SERVICE_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [SERVICE_EXPIRY] Serviço {os.path.basename(carta_path)} retornou para o inventário da Store")
    
    def _mostrar_overlay_event_expirado(self, carta_path):
        """
        Mostra overlay de event expirado com a carta em fullscreen de fundo (similar ao Service)
        """
        print(f"DEBUG: [EVENT_EXPIRY] Mostrando overlay de expiração para {os.path.basename(carta_path)}")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conteúdo do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # Título "Expired Event" em vermelho
        title_label = tk.Label(
            content_frame, 
            text="   Expired Event    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto "Event_x has expired"
        event_name = os.path.basename(carta_path).replace('.png', '')
        message_text = f"{event_name} has expired"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 18),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Botão OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#4CAF50",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_event_expirado(overlay, carta_path)
        )
        ok_button.pack(pady=20)
    
    def _processar_event_expirado(self, overlay, carta_path):
        """
        Processa a expiração do event: remove do inventário do jogador
        """
        print(f"DEBUG: [EVENT_EXPIRY] Processando expiração de {os.path.basename(carta_path)}")
        
        # CORREÇÃO CRÍTICA: Remover carta do inventário do jogador
        if carta_path in self.inventario.get("events", []):
            self.inventario["events"].remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do inventário do jogador")
        else:
            print(f"DEBUG: [EVENT_EXPIRY] AVISO: Event {os.path.basename(carta_path)} não encontrado no inventário do jogador")
        
        # Limpar tracking
        if hasattr(self, '_event_start_turns') and carta_path in self._event_start_turns:
            del self._event_start_turns[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de turno removido para {os.path.basename(carta_path)}")
        
        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
            del self._event_duration_tracking[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de duração removido para {os.path.basename(carta_path)}")
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de inventário de Actions/Events (interface completa)
        print(f"DEBUG: [EVENT_EXPIRY] Voltando para matriz de inventário de Actions/Events")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de inventário de Actions/Events (interface completa e formatada)
            self.show_inventory_matrix(["actions", "events"], page=0)
            print(f"DEBUG: [EVENT_EXPIRY] Matriz de inventário de Actions/Events aberta com sucesso")
            print(f"DEBUG: [EVENT_EXPIRY] Processo de expiração completo - carta removida do jogador")
        except Exception as e:
            print(f"DEBUG: [EVENT_EXPIRY] Erro ao abrir matriz de inventário de Actions/Events: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [EVENT_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [EVENT_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do inventário")
    
    
    def _obter_valor_barra_atual(self, tipo_barra):
        """
        Obtém o valor atual de uma barra de progresso específica
        """
        return self._obter_valor_barra_atual_by_index(tipo_barra, getattr(self, 'selected_card_idx', 0))
    
    def _obter_valor_barra_atual_by_index(self, tipo_barra, card_idx):
        """
        Obtém o valor atual de uma barra de progresso específica para um índice de carta específico
        """
        try:
            # Verificar se existe dados de estatísticas e índice válido
            if hasattr(self, 'card_stats') and card_idx < len(self.card_stats):
                valor = self.card_stats[card_idx].get(tipo_barra, 0)
                print(f"DEBUG: [REWARD_CALC] Valor da barra {tipo_barra} (carta {card_idx}): {valor}")
                return valor
            
            print(f"DEBUG: [REWARD_CALC] Não foi possível obter valor da barra {tipo_barra} para carta {card_idx}, retornando 0")
            return 0
        except Exception as e:
            print(f"DEBUG: [REWARD_CALC] Erro ao obter valor da barra {tipo_barra} para carta {card_idx}: {e}")
            return 0
    
    def _fechar_overlay_completion(self):
        """
        Fecha overlay de completion - MÉTODO LEGADO
        O processamento principal agora é feito em fechar_e_continuar()
        """
        if hasattr(self, '_overlay_completion') and self._overlay_completion:
            print(f"DEBUG: [COMPLETION] Fechando overlay (método legado)")
            
            # Apenas fechar overlay - processamento já foi feito
            self._overlay_completion.destroy()
            self._overlay_completion = None
            
            print(f"DEBUG: [COMPLETION] Overlay fechado")
    
    def _devolver_carta_para_store(self, carta_path, card_type):
        """
        Devolve carta completada para a Store conforme o tipo:
        - Challenge: volta para o baralho da Store
        - Activity: volta para o inventário Activity da Store
        - Services: volta para o inventário Services da Store
        """
        try:
            print(f"DEBUG: [DEVOLVER_STORE] Devolvendo {card_type}: {os.path.basename(carta_path)}")
            
            # CORREÇÃO CRÍTICA: Primeiro remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # CORREÇÃO: Normalizar tipo para maiúsculo para comparação
            card_type_normalized = card_type.capitalize() if isinstance(card_type, str) else str(card_type).capitalize()
            
            if card_type_normalized == "Challenge":
                # Challenge volta para o baralho da Store
                self._devolver_challenge_para_baralho(carta_path)
            elif card_type_normalized == "Activity":
                # Activity volta para o inventário Activity da Store
                self._devolver_activity_para_inventario(carta_path)
            elif card_type_normalized == "Services":
                # Services volta para o inventário Services da Store
                self._devolver_service_para_inventario_store(carta_path)
            else:
                print(f"DEBUG: [DEVOLVER_STORE] AVISO: Tipo de carta desconhecido: {card_type} (normalizado: {card_type_normalized})")
                # CORREÇÃO ADICIONAL: Tentar detectar tipo pelo nome do arquivo
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Activity pelo nome do arquivo - devolvendo como Activity")
                    self._devolver_activity_para_inventario(carta_path)
                elif "challenge" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Challenge pelo nome do arquivo - devolvendo como Challenge")
                    self._devolver_challenge_para_baralho(carta_path)
                elif "service" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Service pelo nome do arquivo - devolvendo como Service")
                    self._devolver_service_para_inventario_store(carta_path)
                else:
                    print(f"DEBUG: [DEVOLVER_STORE] ERRO: Não foi possível determinar tipo da carta")
                
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_STORE] ERRO ao devolver carta à Store: {e}")
            import traceback
            traceback.print_exc()
    
    def _devolver_challenge_para_baralho(self, carta_path):
        """
        Devolve Challenge completado para o baralho da Store
        """
        try:
            # Determinar cor da carta (geralmente neutral para Challenges)
            cor_carta = self._get_color_from_path(carta_path) or "neutral"
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "challenges", cor_carta)
                    print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store_v2 import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "challenges" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["challenges"] = []
                
                # Adicionar no início do baralho (topo)
                baralhos[cor_carta]["challenges"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho global challenges/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO: Não foi possível importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO ao devolver Challenge: {e}")
    
    def _devolver_activity_para_inventario(self, carta_path):
        """
        Devolve Activity completada para o inventário Activity da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "activities", cor_carta)
                    print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao inventário da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store_v2 import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "activities" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["activities"] = []
                
                # Adicionar no início do baralho (topo)
                baralhos[cor_carta]["activities"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao baralho global activities/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO: Não foi possível importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO ao devolver Activity: {e}")
    
    def _devolver_service_para_inventario_store(self, carta_path):
        """
        Devolve Service expirado para o inventário Services da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "services", cor_carta)
                    print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao inventário da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais da Store
            try:
                from Store_v2 import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "services" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["services"] = []
                
                # Adicionar no início do baralho (topo) para ficar disponível imediatamente
                baralhos[cor_carta]["services"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao baralho global services/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_SERVICE] ERRO: Não foi possível importar baralhos da Store: {e}")
                # Fallback adicional: tentar diretamente através de Store_v2
                try:
                    from Store_v2 import StoreWindow
                    # Criar instância temporária da Store para adicionar carta
                    # Nota: Isto é um fallback extremo, normalmente a store_window deve estar disponível
                    print(f"DEBUG: [DEVOLVER_SERVICE] Tentando fallback via StoreWindow direto")
                except Exception as e2:
                    print(f"DEBUG: [DEVOLVER_SERVICE] ERRO no fallback StoreWindow: {e2}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_SERVICE] ERRO ao devolver Service: {e}")
    
    def _remover_carta_do_carrossel(self, carta_path):
        """
        Remove carta completada do carrossel e volta ao estado vazio
        """
        try:
            # Encontrar posição da carta no carrossel
            carta_removida_idx = None
            for i, card_path in enumerate(self.cards):
                if card_path == carta_path:
                    carta_removida_idx = i
                    break
            
            if carta_removida_idx is not None:
                print(f"DEBUG: [COMPLETION] Removendo carta da posição {carta_removida_idx} do carrossel")
                
                # Voltar para carta de costas padrão
                default_card = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                self.cards[carta_removida_idx] = default_card
                
                # NOVA FUNCIONALIDADE: Atualizar flag da carta para False (virada para baixo)
                if hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags[carta_removida_idx] = False
                    print(f"DEBUG: [COMPLETION] Flag da posição {carta_removida_idx} atualizada para False (virada para baixo)")
                    print(f"DEBUG: [COMPLETION] Estados das cartas: {self.card_face_up_flags}")
                
                # Resetar estatísticas da carta
                self.card_stats[carta_removida_idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # NOTA: NÃO removemos da lista de gestão aqui - isso é feito antes na função de completion
                # Apenas removemos visualmente do carrossel
                
                # Atualizar carrossel visual
                self.atualizar_carrossel()
                
                # Se a carta removida era a carta atual, atualizar barras de progresso
                if carta_removida_idx == self.selected_card_idx:
                    self.update_progress_bars_for_card(carta_removida_idx)
                
                print(f"DEBUG: [COMPLETION] Carta removida com sucesso da posição {carta_removida_idx}")
            else:
                print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta_path)} não encontrada no carrossel")
        
        except Exception as e:
            print(f"DEBUG: [COMPLETION] ERRO ao remover carta do carrossel: {e}")
            import traceback
            traceback.print_exc()
    
    def _atualizar_display_saldo(self):
        """
        Atualiza o display do saldo na interface (se existir)
        """
        # Procurar por widgets de saldo na interface principal
        for widget in self.winfo_children():
            if isinstance(widget, tk.Label):
                # Tentar encontrar label do saldo pelo texto numérico
                try:
                    texto = widget.cget("text")
                    if texto.isdigit():
                        widget.config(text=str(self.saldo))
                        print(f"DEBUG: [COMPLETION] Display do saldo atualizado para {self.saldo}")
                        break
                except:
                    continue
    
    def _carta_pode_processar_pacotes(self, carta_path):
        """
        Verifica se uma carta ainda tem capacidade de processamento restante.
        Uma carta NÃO pode processar mais se:
        1. Para Activities: Rxd >= message_size E To send <= 0
        2. Para Activities: Já processou rate_max pacotes neste turno
        3. Para Challenges: Similar mas com regras específicas
        
        Returns:
            bool: True se a carta pode processar mais pacotes, False caso contrário
        """
        try:
            carta_basename = os.path.basename(carta_path).lower()
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem dados - NÃO pode processar")
                return False
            
            rate_max = dados_carta.get('rate', 1)
            message_size = dados_carta.get('message_size', 20)
            
            # Encontrar posição da carta no carrossel para obter valores atuais
            posicao_carrossel = None
            if hasattr(self, 'cards') and carta_path in self.cards:
                posicao_carrossel = self.cards.index(carta_path)
            
            if posicao_carrossel is None:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: não encontrada no carrossel - NÃO pode processar")
                return False
            
            # Obter valores atuais das barras
            if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                stats = self.card_stats[posicao_carrossel]
                to_send_atual = stats.get('To send', 0)
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem stats - NÃO pode processar")
                return False
            
            # Verificar quantos pacotes foram processados NESTE turno
            rxd_processado_turno = self._get_processed_this_turn(carta_path, 'rxd')
            lost_processado_turno = self._get_processed_this_turn(carta_path, 'lost')
            total_processado_turno = rxd_processado_turno + lost_processado_turno
            
            print(f"DEBUG: [PODE_PROCESSAR] === VERIFICAÇÃO CARTA {os.path.basename(carta_path)} ===")
            print(f"DEBUG: [PODE_PROCESSAR] Valores atuais: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            print(f"DEBUG: [PODE_PROCESSAR] Rate máximo por turno: {rate_max}")
            print(f"DEBUG: [PODE_PROCESSAR] Message size (limite total): {message_size}")
            print(f"DEBUG: [PODE_PROCESSAR] Processado neste turno: Rxd={rxd_processado_turno}, Lost={lost_processado_turno}, Total={total_processado_turno}")
            
            # REGRA 1: Verificar limite por turno (rate_max)
            if total_processado_turno >= rate_max:
                print(f"DEBUG: [PODE_PROCESSAR] ❌ Limite por turno atingido ({total_processado_turno}/{rate_max})")
                return False
            
            # REGRA 2: Para Activities - verificar completion
            if "activity" in carta_basename:
                # Activity completa quando: To send = 0 E Rxd >= message_size
                if to_send_atual <= 0 and rxd_atual >= message_size:
                    print(f"DEBUG: [PODE_PROCESSAR] ❌ Activity completada (To send={to_send_atual}, Rxd={rxd_atual}/{message_size})")
                    return False
                
                # Verificar se ainda pode incrementar Rxd ou Lost
                pode_incrementar_rxd = (rxd_atual < message_size and rxd_processado_turno < rate_max)
                
                # Para Lost: verificar se drops são permitidos
                drops_allowed = dados_carta.get('drops_allowed', False)
                penalty_per_packet = dados_carta.get('penalty_per_packet')
                lost_permitido = drops_allowed or penalty_per_packet is not None
                pode_incrementar_lost = (lost_permitido and lost_atual < message_size and lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Activity pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            # REGRA 3: Para Challenges - similar mas com regras específicas
            elif "challenge" in carta_basename:
                # Challenge pode processar enquanto não atingir rate_max neste turno
                pode_incrementar_rxd = (rxd_processado_turno < rate_max)
                pode_incrementar_lost = (lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Challenge pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            print(f"DEBUG: [PODE_PROCESSAR] ❌ Tipo de carta não reconhecido: {carta_basename}")
            return False
            
        except Exception as e:
            print(f"DEBUG: [PODE_PROCESSAR] ❌ ERRO ao verificar carta {os.path.basename(carta_path)}: {e}")
            return False
    
    def _atualizar_barras_gestao_carta_atual(self):
        """
        CORREÇÃO CRÍTICA: Atualiza barras usando sempre a carta REAL do carrossel
        e não a carta preservada que pode estar incorreta
        """
        print(f"DEBUG: [GESTÃO_PACOTES] === ATUALIZAÇÃO BARRAS CARTA SELECIONADA ===")
        
        # CORREÇÃO FUNDAMENTAL: SEMPRE usar a carta que está REALMENTE no carrossel
        # em vez de confiar na carta preservada que pode estar desatualizada
        carta_atual = None
        posicao_carrossel = None
        
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            posicao_carrossel = self.selected_carousel_index
            carta_atual = self.cards[posicao_carrossel]
            
            print(f"DEBUG: [GESTÃO_PACOTES]   ✅ USANDO CARTA REAL DO CARROSSEL:")
            print(f"DEBUG: [GESTÃO_PACOTES]   Posição no carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Carta REAL: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar se há diferença entre carta real e preservada
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: [GESTÃO_PACOTES]   ⚠️ DIFERENÇA DETECTADA:")
                    print(f"DEBUG: [GESTÃO_PACOTES]   Carta preservada: {carta_preservada}")
                    print(f"DEBUG: [GESTÃO_PACOTES]   Carta real: {carta_real}")
                    print(f"DEBUG: [GESTÃO_PACOTES]   ✅ USANDO A CARTA REAL!")
            
        else:
            # Fallback: usar sistema antigo se não há carrossel válido
            if hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao'):
                carta_atual = self._cartas_gestao[self._carta_atual_gestao]
                carta_basename = os.path.basename(carta_atual)
                
                print(f"DEBUG: [GESTÃO_PACOTES] === FALLBACK - CARTA ATUAL (SISTEMA ANTIGO) ===")
                print(f"DEBUG: [GESTÃO_PACOTES]   Carta: {carta_basename}")
                print(f"DEBUG: [GESTÃO_PACOTES]   Índice gestão: {self._carta_atual_gestao}")
                
                # Encontrar a posição real no carrossel (self.cards)
                posicao_carrossel = None
                if hasattr(self, 'cards'):
                    for i, card_path in enumerate(self.cards):
                        if card_path == carta_atual:
                            posicao_carrossel = i
                            break
                
                if posicao_carrossel is None:
                    print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Carta não encontrada no carrossel!")
                    return
                
                print(f"DEBUG: [GESTÃO_PACOTES]   Posição real no carrossel: {posicao_carrossel}")
            else:
                print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO: Não há informação de cartas!")
                return
        
        # CORREÇÃO: Verificar se há valores preservados para esta carta primeiro
        preserved_stats = None
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[posicao_carrossel]
            print(f"DEBUG: [GESTÃO_PACOTES] Stats preservadas encontradas: {preserved_stats}")
        
        # CORREÇÃO: Se há stats preservadas, usar essas; senão buscar da base de dados
        if preserved_stats:
            # Usar valores preservados do turno atual
            to_send_atual = preserved_stats.get('To send', 0)
            rxd_atual = preserved_stats.get('Rxd', 0) 
            lost_atual = preserved_stats.get('Lost', 0)
            
            # Obter message_size da base de dados para máximo das barras
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            print(f"DEBUG: [GESTÃO_PACOTES] ✅ USANDO VALORES PRESERVADOS:")
            print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Message size (máximo): {message_size}")
            
        else:
            # Fallback: usar base de dados se não há valores preservados
            print(f"DEBUG: [GESTÃO_PACOTES] ⚠️ Sem valores preservados - usando base de dados")
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            # Verificar se há valores nos _valores_pacotes (antigo sistema)
            if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
                valores = self._valores_pacotes[self._carta_atual_gestao]
                total_processado = valores['enviados'] + valores['perdidos']
                to_send_atual = max(message_size - total_processado, 0)
                rxd_atual = valores['enviados']
                lost_atual = valores['perdidos']
            else:
                # Reset completo se não há dados
                to_send_atual = message_size
                rxd_atual = 0
                lost_atual = 0
        
        # Atualizar todas as barras com os valores corretos
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            # Atualizar To send
            if "To send" in self.progress_bars and "To send" in self.progress_labels:
                self.progress_bars["To send"].config(value=to_send_atual, maximum=message_size)
                self.progress_labels["To send"].config(text=str(to_send_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ To send atualizada: {to_send_atual}/{message_size}")
            
            # Atualizar Rxd
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=rxd_atual, maximum=message_size)
                self.progress_labels["Rxd"].config(text=str(rxd_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Rxd atualizada: {rxd_atual}")
            
            # Atualizar Lost
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=lost_atual, maximum=message_size)
                self.progress_labels["Lost"].config(text=str(lost_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Lost atualizada: {lost_atual}")
                
            # IMPORTANTE: Sincronizar os valores preservados com o que está nas barras
            if preserved_stats is None and hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                self.card_stats[posicao_carrossel] = {
                    'To send': to_send_atual,
                    'Rxd': rxd_atual,
                    'Lost': lost_atual
                }
                print(f"DEBUG: [GESTÃO_PACOTES] ✅ Stats sincronizadas na posição {posicao_carrossel}")
        else:
            print("DEBUG: [GESTÃO_PACOTES] ❌ Barras de progresso não encontradas para atualização")
    
    def _mostrar_botao_seta(self):
        """Mostra botão seta (→) na mesma altura do End Turn com cor roxa"""
        print("DEBUG: [GESTÃO_PACOTES] === INICIANDO CRIAÇÃO DO BOTÃO SETA ===")
        
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta existente...")
                self._btn_seta.destroy()
            except (tk.TclError, AttributeError):
                print("DEBUG: [GESTÃO_PACOTES] Erro ao remover botão seta existente")
                pass
        
        try:
            self._btn_seta = tk.Button(
                self,
                text="→",
                font=("Helvetica", 16, "bold"),
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                command=self._proxima_carta_gestao,
                width=3,
                height=1
            )
            
            # Posicionar na mesma altura (rely) que o End Turn (aproximadamente)
            # End Turn está em rely=0.945, então usamos uma posição ligeiramente diferente
            self._btn_seta.place(relx=0.05, rely=0.945, anchor="w")
            
            # Forçar o botão a aparecer por cima de todos os outros elementos
            self._btn_seta.lift()
            
            # Atualizar a interface para garantir que o botão aparece
            self.update_idletasks()
            
            print("DEBUG: [GESTÃO_PACOTES] ✅ Botão seta criado com sucesso!")
            print(f"DEBUG: [GESTÃO_PACOTES] Posição: relx=0.05, rely=0.945")
            print(f"DEBUG: [GESTÃO_PACOTES] Widget existe: {hasattr(self, '_btn_seta') and self._btn_seta}")
            
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ ERRO ao criar botão seta: {e}")
            self._btn_seta = None
    
    def _proxima_carta_gestao(self):
        """
        NOVA FUNCIONALIDADE: 
        1. Verificar PRIMEIRO se é Challenge na Final Phase (independente da posição)
        2. Se for Challenge na Final Phase, mostrar overlay completion
        3. Caso contrário, continuar gestão normal
        """
        print(f"DEBUG: [SETA_COMPLETION] ===== BOTÃO SETA CLICADO =====")
        print(f"DEBUG: [SETA_COMPLETION] Carta atual (índice): {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION] Total de cartas gestão: {len(self._cartas_gestao)}")
        
        # CORREÇÃO CRÍTICA: Bloquear temporariamente cliques no carrossel por 500ms
        # para evitar fullscreen acidental após clique no botão seta
        self._bloqueio_temporario_carrossel = True
        self.after(500, lambda: setattr(self, '_bloqueio_temporario_carrossel', False))
        print(f"DEBUG: [SETA_COMPLETION] ✅ Bloqueio temporário do carrossel ativado por 500ms")
        
        # CORREÇÃO CRÍTICA: Validar índices antes de acessar as listas
        print(f"DEBUG: [SETA_COMPLETION] Validação inicial:")
        print(f"DEBUG: [SETA_COMPLETION]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [SETA_COMPLETION]   _cartas_gestao: {[os.path.basename(c) for c in self._cartas_gestao]}")
        
        # CORREÇÃO FUNDAMENTAL: Verificar se o índice é válido antes de acessar
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO: Índice gestão ({self._carta_atual_gestao}) >= tamanho lista ({len(self._cartas_gestao)})")
            print(f"DEBUG: [SETA_COMPLETION] ✅ CORREÇÃO: Usando carta selecionada do carrossel como referência")
            selected_carta = getattr(self, 'selected_carousel_card', None)
            if selected_carta:
                carta_atual = selected_carta
                print(f"DEBUG: [SETA_COMPLETION] ✅ Carta corrigida para: {os.path.basename(carta_atual)}")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO CRÍTICO: Sem carta selecionada no carrossel")
                return
        else:
            # CORREÇÃO CRÍTICA: Garantir que estamos a processar a carta CORRETA
            # A carta atual da gestão deve corresponder à carta selecionada no carrossel
            carta_atual = self._cartas_gestao[self._carta_atual_gestao]
            selected_carta = getattr(self, 'selected_carousel_card', None)
        
        print(f"DEBUG: [SETA_COMPLETION] Carta gestão atual: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [SETA_COMPLETION] Carta selecionada carrossel: {os.path.basename(selected_carta) if selected_carta else 'None'}")
        
        # CORREÇÃO FUNDAMENTAL: Se há discrepância E a gestão tem cartas válidas, usar a carta selecionada do carrossel
        # que é a que está destacada em roxo e visível ao utilizador
        if (selected_carta and 
            len(self._cartas_gestao) > 0 and 
            self._carta_atual_gestao < len(self._cartas_gestao) and 
            selected_carta != carta_atual):
            print(f"DEBUG: [SETA_COMPLETION] ⚠️ DISCREPÂNCIA DETECTADA!")
            print(f"DEBUG: [SETA_COMPLETION] Gestão: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [SETA_COMPLETION] Carrossel: {os.path.basename(selected_carta)}")
            print(f"DEBUG: [SETA_COMPLETION] ✅ CORRIGINDO - Usando carta do carrossel como referência")
            carta_atual = selected_carta
            
            # Atualizar a posição da gestão para corresponder à carta correta
            try:
                nova_posicao_gestao = self._cartas_gestao.index(carta_atual)
                self._carta_atual_gestao = nova_posicao_gestao
                print(f"DEBUG: [SETA_COMPLETION] ✅ Posição gestão corrigida para: {nova_posicao_gestao}")
            except ValueError:
                print(f"DEBUG: [SETA_COMPLETION] ❌ AVISO: Carta selecionada não está na lista de gestão")
                print(f"DEBUG: [SETA_COMPLETION] Lista gestão: {[os.path.basename(c) for c in self._cartas_gestao]}")
                print(f"DEBUG: [SETA_COMPLETION] ✅ Continuando com carta selecionada do carrossel")
        elif selected_carta and len(self._cartas_gestao) == 0:
            print(f"DEBUG: [SETA_COMPLETION] ⚠️ Lista gestão vazia - usando carta selecionada do carrossel")
            carta_atual = selected_carta
        
        carta_basename = os.path.basename(carta_atual).lower()
        
        print(f"DEBUG: [SETA_COMPLETION] Carta final a processar: {carta_basename}")
        
        # CORREÇÃO: Verificar PRIMEIRO se é Challenge na Final Phase, independente da posição
        is_challenge_card = "challenge" in carta_basename
        
        if is_challenge_card:
            print(f"DEBUG: [SETA_COMPLETION] ✅ Challenge detectado - verificando Final Phase")
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_atual)
            
            if dados_carta and 'n_turns' in dados_carta:
                n_turns = dados_carta['n_turns']
                turns_elapsed = self._get_turns_elapsed_for_challenge(carta_atual)
                
                # CORREÇÃO CRÍTICA: Verificar também se já foi completado através das barras
                message_size = dados_carta.get('message_size', 0)
                
                # Obter valores atuais das barras (posição atual do carrossel)
                current_to_send = 0
                current_rxd = 0
                
                try:
                    if hasattr(self, 'progress_labels'):
                        current_to_send = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                        current_rxd = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                except:
                    current_to_send = 0
                    current_rxd = 0
                
                # CORREÇÃO: Challenge só mostra completion se:
                # 1. Tempo limite atingido (turns_elapsed >= n_turns) OU
                # 2. Recebeu todos os pacotes necessários (current_rxd >= message_size)
                tempo_limite_atingido = (turns_elapsed >= n_turns) and (turns_elapsed > 1)
                pacotes_completos = (current_rxd >= message_size) and (message_size > 0)
                
                challenge_na_final_phase = tempo_limite_atingido or pacotes_completos
                
                print(f"DEBUG: [SETA_COMPLETION] Challenge dados completos:")
                print(f"DEBUG: [SETA_COMPLETION]   n_turns (da DB): {n_turns}")
                print(f"DEBUG: [SETA_COMPLETION]   turns_elapsed (calculado): {turns_elapsed}")
                print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                print(f"DEBUG: [SETA_COMPLETION]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [SETA_COMPLETION]   Condição 1 (tempo limite): {tempo_limite_atingido}")
                print(f"DEBUG: [SETA_COMPLETION]   Condição 2 (pacotes completos): {pacotes_completos}")
                print(f"DEBUG: [SETA_COMPLETION]   challenge_na_final_phase: {challenge_na_final_phase}")
                
                if challenge_na_final_phase:
                    print(f"DEBUG: [SETA_COMPLETION] ✅ Challenge pode ser completado - mostrar overlay")
                    
                    # Preservar valores antes de mostrar completion
                    self._preservar_valores_atuais_barras()
                    
                    # CORREÇÃO: Usar o índice correto da carta no carrossel, não o índice na gestão
                    # O índice no carrossel é selected_carousel_index, não _carta_atual_gestao
                    carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                    
                    # CORREÇÃO ADICIONAL: Se não há selected_carousel_index, procurar a carta no carrossel
                    if carta_index_carrossel is None:
                        for i, carta_carrossel in enumerate(self.cards):
                            if carta_carrossel == carta_atual:
                                carta_index_carrossel = i
                                print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posição: {i}")
                                break
                    
                    if carta_index_carrossel is None:
                        print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO: Não foi possível encontrar carta no carrossel")
                        return
                    
                    print(f"DEBUG: [SETA_COMPLETION] Usando índice do carrossel: {carta_index_carrossel} (gestão: {self._carta_atual_gestao})")
                    
                    # Mostrar overlay de completion diretamente
                    self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                    
                    print(f"DEBUG: [SETA_COMPLETION] ✅ Overlay de completion mostrado para Challenge")
                    return
                else:
                    print(f"DEBUG: [SETA_COMPLETION] ❌ Challenge não pode ser completado ainda - continuar gestão normal")
                    print(f"DEBUG: [SETA_COMPLETION]   Razão: tempo_limite={tempo_limite_atingido}, pacotes_completos={pacotes_completos}")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ❌ Dados da carta não encontrados")
        else:
            print(f"DEBUG: [SETA_COMPLETION] ❌ Não é Challenge - verificando se é Activity...")
            
            # CORREÇÃO CRÍTICA: Adicionar verificação de completion para Activities
            is_activity_card = "activity" in carta_basename
            
            if is_activity_card:
                print(f"DEBUG: [SETA_COMPLETION] ✅ Activity detectado - verificando completion")
                
                # Obter dados da carta
                dados_carta = self._obter_dados_carta(carta_atual)
                
                if dados_carta:
                    message_size = dados_carta.get('message_size', 0)
                    drops_allowed = dados_carta.get('drops_allowed', True)
                    
                    # Obter valores atuais das barras (posição atual do carrossel)
                    current_to_send = 0
                    current_rxd = 0
                    
                    try:
                        if hasattr(self, 'progress_labels'):
                            current_to_send = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                            current_rxd = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    except:
                        current_to_send = 0
                        current_rxd = 0
                    
                    print(f"DEBUG: [SETA_COMPLETION] Activity dados completos:")
                    print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                    print(f"DEBUG: [SETA_COMPLETION]   drops_allowed: {drops_allowed}")
                    
                    # CONDIÇÕES DE COMPLETION PARA ACTIVITIES:
                    # 1. To send = 0 (todos os pacotes foram enviados) E
                    # 2. Rxd >= message_size (todos os pacotes foram recebidos) E
                    # 3. (drops_allowed = False OU completion forçada no botão seta)
                    
                    pacotes_todos_enviados = (current_to_send == 0)
                    pacotes_todos_recebidos = (current_rxd >= message_size) and (message_size > 0)
                    
                    # Activity é completada se TODOS os pacotes foram enviados E recebidos
                    activity_completada = pacotes_todos_enviados and pacotes_todos_recebidos
                    
                    print(f"DEBUG: [SETA_COMPLETION]   Condição 1 (todos enviados): {pacotes_todos_enviados}")
                    print(f"DEBUG: [SETA_COMPLETION]   Condição 2 (todos recebidos): {pacotes_todos_recebidos}")
                    print(f"DEBUG: [SETA_COMPLETION]   activity_completada: {activity_completada}")
                    
                    if activity_completada:
                        print(f"DEBUG: [SETA_COMPLETION] ✅ Activity pode ser completada - mostrar overlay")
                        
                        # Preservar valores antes de mostrar completion
                        self._preservar_valores_atuais_barras()
                        
                        # CORREÇÃO: Usar o índice correto da carta no carrossel, não o índice na gestão
                        carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                        
                        # CORREÇÃO ADICIONAL: Se não há selected_carousel_index, procurar a carta no carrossel
                        if carta_index_carrossel is None:
                            for i, carta_carrossel in enumerate(self.cards):
                                if carta_carrossel == carta_atual:
                                    carta_index_carrossel = i
                                    print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posição: {i}")
                                    break
                        
                        if carta_index_carrossel is None:
                            print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO: Não foi possível encontrar carta no carrossel")
                            return
                        
                        print(f"DEBUG: [SETA_COMPLETION] Usando índice do carrossel: {carta_index_carrossel} (gestão: {self._carta_atual_gestao})")
                        
                        # Mostrar overlay de completion diretamente
                        self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                        
                        print(f"DEBUG: [SETA_COMPLETION] ✅ Overlay de completion mostrado para Activity")
                        return
                    else:
                        print(f"DEBUG: [SETA_COMPLETION] ❌ Activity não pode ser completada ainda - continuar gestão normal")
                        print(f"DEBUG: [SETA_COMPLETION]   Razão: enviados={pacotes_todos_enviados}, recebidos={pacotes_todos_recebidos}")
                else:
                    print(f"DEBUG: [SETA_COMPLETION] ❌ Dados da Activity não encontrados")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ❌ Não é nem Challenge nem Activity - continuar gestão normal")
        
        print(f"DEBUG: [SETA_COMPLETION] ❌ Condições para completion não atendidas - continuar gestão normal")
        
        # FLUXO ORIGINAL: PRESERVAR VALORES DA CARTA ATUAL ANTES DE AVANÇAR
        
        # Encontrar posição real no carrossel
        posicao_carrossel_atual = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                posicao_carrossel_atual = i
                break
        
        if posicao_carrossel_atual is not None:
            # Capturar valores atuais das barras visíveis
            try:
                if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # IMPORTANTE: Preservar na posição correta do carrossel
                    if hasattr(self, 'card_stats') and posicao_carrossel_atual < len(self.card_stats):
                        self.card_stats[posicao_carrossel_atual] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual, 
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [GESTÃO_PACOTES] ✅ VALORES PRESERVADOS antes de avançar:")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Posição carrossel: {posicao_carrossel_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   card_stats[{posicao_carrossel_atual}] = {self.card_stats[posicao_carrossel_atual]}")
                    
            except Exception as e:
                print(f"DEBUG: [GESTÃO_PACOTES] ❌ Erro ao preservar valores: {e}")
        
        # CORREÇÃO 2: Salvar também no sistema antigo (compatibilidade)
        if hasattr(self, '_entry_rxd') and hasattr(self, '_entry_lost'):
            try:
                enviados = int(self._entry_rxd.get()) if hasattr(self._entry_rxd, 'get') else rxd_atual
                perdidos = int(self._entry_lost.get()) if hasattr(self._entry_lost, 'get') else lost_atual
                
                if not hasattr(self, '_valores_pacotes'):
                    self._valores_pacotes = {}
                    
                self._valores_pacotes[self._carta_atual_gestao] = {
                    'enviados': enviados,
                    'perdidos': perdidos
                }
                print(f"DEBUG: [GESTÃO_PACOTES] Valores salvos no sistema antigo - Enviados: {enviados}, Perdidos: {perdidos}")
            except (ValueError, AttributeError):
                print("DEBUG: [GESTÃO_PACOTES] Sistema antigo não disponível")
        
        # Remover controles atuais
        self._remover_controles_gestao()
        
        # CORREÇÃO 3: Avançar para próxima carta
        self._carta_atual_gestao += 1
        print(f"DEBUG: [GESTÃO_PACOTES] Nova carta atual (índice): {self._carta_atual_gestao}")
        
        # VERIFICAÇÃO CRÍTICA: Antes de continuar, verificar se ainda há cartas válidas
        cartas_validas_restantes = 0
        if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
            for i, carta in enumerate(self._cartas_gestao):
                if (i >= self._carta_atual_gestao and carta and hasattr(self, 'cards') and 
                    carta in self.cards):
                    carta_basename = os.path.basename(carta).lower()
                    if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                        cartas_validas_restantes += 1
        
        print(f"DEBUG: [GESTÃO_PACOTES] Cartas válidas restantes para processar: {cartas_validas_restantes}")
        print(f"DEBUG: [GESTÃO_PACOTES] Índice atual: {self._carta_atual_gestao}, Total cartas: {len(getattr(self, '_cartas_gestao', []))}")
        
        # Se não há mais cartas válidas, finalizar gestão automaticamente
        if cartas_validas_restantes == 0 or self._carta_atual_gestao >= len(getattr(self, '_cartas_gestao', [])):
            print("DEBUG: [GESTÃO_PACOTES] ❌ Não há mais cartas válidas para processar")
            print("DEBUG: [GESTÃO_PACOTES] ✅ FINALIZANDO GESTÃO DE PACOTES AUTOMATICAMENTE")
            
            # CORREÇÃO CRÍTICA: Finalizar gestão mas MANTER Final Phase ativo para End Turn
            # A gestão termina mas o jogador ainda está em Final Phase
            self._final_phase_gestao_ativa = False
            # NÃO limpar _final_phase_active - o jogador ainda está em Final Phase!
            # self._final_phase_active = False  # ❌ REMOVIDO - Final Phase deve continuar ativo
            
            # CORREÇÃO: Ativar End Turn quando gestão termina automaticamente
            self._show_end_turn_button = True
            
            if hasattr(self, '_cartas_gestao'):
                self._cartas_gestao = []
            if hasattr(self, '_carta_atual_gestao'):
                self._carta_atual_gestao = 0
            
            # Remover controles silenciosamente
            self._remover_controles_gestao_silencioso()
            
            # CORREÇÃO CRÍTICA: Reconstruir dashboard MANTENDO Final Phase ativo
            print("DEBUG: [GESTÃO_PACOTES] Voltando ao dashboard com Final Phase ativo e End Turn enabled...")
            print(f"DEBUG: [GESTÃO_PACOTES] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # CORREÇÃO CRÍTICA: Ativar o botão End Turn APÓS reconstruir a interface
            self.after(100, self._ativar_botao_end_turn)
            
            # CORREÇÃO NOVA: Forçar atualização dos destaques para garantir que carta restante fique destacada
            self.after(200, lambda: self._update_carousel_selection_highlights())
            return
        
        # CORREÇÃO 4: Mostrar gestão da próxima carta ou finalizar
        self._mostrar_gestao_carta_atual()
        
        print(f"DEBUG: [GESTÃO_PACOTES] ===== AVANÇO CONCLUÍDO =====")
    
    def _remover_controles_gestao_silencioso(self):
        """Remove controles de gestão SEM criar automaticamente o botão seta"""
        print("DEBUG: [GESTÃO_PACOTES] Removendo controles de gestão silenciosamente...")
        
        # Remover frame de controles (versão antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover botões + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # Remover botão seta se existir
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GESTÃO_PACOTES] Controles removidos silenciosamente")

    def _remover_controles_gestao(self):
        """Remove controles de gestão atuais"""
        print("DEBUG: [GESTÃO_PACOTES] Removendo controles de gestão...")
        
        # Verificar se há botões + para remover
        tinha_botoes_plus = False
        if ((hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd) or 
            (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost)):
            tinha_botoes_plus = True
        
        # Remover frame de controles (versão antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover botões + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORREÇÃO: Mostrar botão seta APÓS remover os botões +
        if tinha_botoes_plus:
            print("DEBUG: [GESTÃO_PACOTES] Botões + foram removidos - agora mostrar botão seta")
            self._mostrar_botao_seta()
        
        # NÃO remover botão seta aqui, pois ele deve aparecer quando os botões + desaparecem
        # O botão seta será removido apenas quando a gestão de pacotes terminar completamente
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GESTÃO_PACOTES] Controles removidos")
    
    def _finalizar_gestao_pacotes(self):
        """Finaliza gestão de pacotes e ativa botão End Turn"""
        print("DEBUG: [GESTÃO_PACOTES] === FINALIZANDO GESTÃO DE PACOTES ===")
        
        # CORREÇÃO CRÍTICA: Desativar gestão de pacotes PRIMEIRO
        self._final_phase_gestao_ativa = False
        print("DEBUG: [GESTÃO_PACOTES] ✅ _final_phase_gestao_ativa = False")
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles (incluindo botão seta)
        self._remover_controles_gestao()
        
        # CORREÇÃO: Remover botão seta quando gestão termina completamente
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta - gestão de pacotes finalizada")
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # CORREÇÃO: Limpar todas as variáveis de gestão
        if hasattr(self, '_cartas_gestao'):
            self._cartas_gestao = []
            print("DEBUG: [GESTÃO_PACOTES] ✅ _cartas_gestao limpa")
        
        if hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print("DEBUG: [GESTÃO_PACOTES] ✅ _carta_atual_gestao resetado")
        
        if hasattr(self, '_carta_destacada'):
            self._carta_destacada = None
            print("DEBUG: [GESTÃO_PACOTES] ✅ _carta_destacada limpa")
        
        if hasattr(self, '_carta_destacada_posicao'):
            self._carta_destacada_posicao = None
            print("DEBUG: [GESTÃO_PACOTES] ✅ _carta_destacada_posicao limpa")
        
        # CORREÇÃO CRÍTICA: Limpar seleção do carrossel para evitar destaques residuais
        self.selected_carousel_card = None
        self.selected_carousel_index = None
        print("DEBUG: [GESTÃO_PACOTES] ✅ Seleção do carrossel limpa")
        
        # Aplicar valores finais a todas as cartas
        self._aplicar_valores_finais()
        
        # CORREÇÃO CRÍTICA: Forçar limpeza completa de todos os destaques
        print("DEBUG: [GESTÃO_PACOTES] ✅ Forçando limpeza completa de destaques")
        if hasattr(self, 'card_labels') and self.card_labels:
            for lbl in self.card_labels:
                try:
                    lbl.config(highlightthickness=0)
                except tk.TclError:
                    pass
        
        # Atualização em múltiplas etapas para garantir limpeza
        self.after(25, lambda: self._update_carousel_selection_highlights())
        self.after(50, lambda: self._update_carousel_selection_highlights())
        
        # CORREÇÃO: Ativar botão End Turn com delay para garantir que interface está pronta
        self.after(75, self._ativar_botao_end_turn)
        
        print("DEBUG: [GESTÃO_PACOTES] === GESTÃO FINALIZADA COM SUCESSO ===")
    
    def _aplicar_valores_finais(self):
        """
        CORREÇÃO: Verifica completion de TODAS as cartas após gestão de pacotes
        Antes só verificava uma carta por vez, agora verifica todas
        """
        print("DEBUG: [GESTÃO_PACOTES] === VERIFICAÇÃO FINAL DE COMPLETION DE TODAS AS CARTAS ===")
        
        cartas_completadas = []
        
        for i, carta_path in enumerate(self._cartas_gestao):
            valores = self._valores_pacotes[i]
            print(f"DEBUG: [GESTÃO_PACOTES] Verificando carta {i+1}/{len(self._cartas_gestao)}: {os.path.basename(carta_path)}")
            print(f"DEBUG: [GESTÃO_PACOTES] Valores aplicados: Enviados={valores['enviados']}, Perdidos={valores['perdidos']}")
            
            # Encontrar a posição da carta no carrossel para verificar completion
            carta_name = os.path.basename(carta_path)
            carta_idx = None
            
            for card_idx, card_path in enumerate(self.cards):
                if card_path and os.path.basename(card_path) == carta_name:
                    carta_idx = card_idx
                    break
            
            if carta_idx is not None and carta_idx < len(self.card_stats):
                stats = self.card_stats[carta_idx]
                
                print(f"DEBUG: [GESTÃO_PACOTES] Estado final da carta {carta_idx}:")
                print(f"DEBUG: [GESTÃO_PACOTES]   To send: {stats['To send']}")
                print(f"DEBUG: [GESTÃO_PACOTES]   Rxd total: {stats['Rxd']}")
                print(f"DEBUG: [GESTÃO_PACOTES]   Lost total: {stats['Lost']}")
                
                # NOVA FUNCIONALIDADE: Verificar completion para cada carta
                dados_carta = self._obter_dados_carta(carta_path)
                if dados_carta:
                    message_size = dados_carta.get('message_size', 0)
                    drops_allowed = dados_carta.get('drops_allowed', True)
                    
                    # Determinar tipo da carta
                    carta_basename = os.path.basename(carta_path).lower()
                    is_challenge = "challenge" in carta_basename
                    is_activity = "activity" in carta_basename
                    
                    # Aplicar regras de completion
                    completion_achieved = False
                    completion_reason = ""
                    
                    # Para Activities: só verificar se drops_allowed=False
                    # Para Challenges: sempre verificar
                    should_check_completion = is_challenge or (is_activity and not drops_allowed)
                    
                    if should_check_completion:
                        to_send = stats['To send']
                        rxd = stats['Rxd']
                        
                        if is_challenge:
                            # Challenges: mais flexível
                            completion_achieved = (to_send == 0) or (rxd >= message_size)
                            if to_send == 0:
                                completion_reason = "todos os pacotes foram enviados"
                            elif rxd >= message_size:
                                completion_reason = f"todos os pacotes foram recebidos ({rxd}/{message_size})"
                        else:
                            # Activities: mais restritivo
                            completion_achieved = (to_send == 0) and (rxd >= message_size)
                            if completion_achieved:
                                completion_reason = f"todos os pacotes foram enviados e recebidos ({rxd}/{message_size})"
                        
                        if completion_achieved:
                            print(f"DEBUG: [COMPLETION_FINAL] *** {'Challenge' if is_challenge else 'Activity'} {carta_name} COMPLETADA! ***")
                            print(f"DEBUG: [COMPLETION_FINAL] Motivo: {completion_reason}")
                            cartas_completadas.append({
                                'path': carta_path,
                                'name': carta_name,
                                'type': 'Challenge' if is_challenge else 'Activity',
                                'reason': completion_reason,
                                'dados': dados_carta,
                                'index': carta_idx  # CORREÇÃO: Adicionar índice da carta
                            })
                        else:
                            print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} não completada:")
                            print(f"DEBUG: [COMPLETION_FINAL]   To send: {to_send}, Rxd: {rxd}, Message size: {message_size}")
                    else:
                        print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} não verifica completion (Activity com drops_allowed=True)")
        
        # NOVA FUNCIONALIDADE: Mostrar overlays para TODAS as cartas completadas
        if cartas_completadas:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: {len(cartas_completadas)} CARTAS COMPLETADAS ===")
            for carta_info in cartas_completadas:
                print(f"DEBUG: [COMPLETION_FINAL] - {carta_info['type']}: {carta_info['name']} ({carta_info['reason']})")
            
            # Mostrar overlays sequencialmente (com delay entre elas)
            self._mostrar_overlays_completion_sequencial(cartas_completadas)
        else:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: NENHUMA CARTA COMPLETADA ===")
    
    def _mostrar_overlays_completion_sequencial(self, cartas_completadas, index=0):
        """
        Mostra overlays de completion para múltiplas cartas de forma sequencial
        """
        if index >= len(cartas_completadas):
            print("DEBUG: [COMPLETION_FINAL] ✅ Todos os overlays de completion foram mostrados")
            return
        
        carta_info = cartas_completadas[index]
        print(f"DEBUG: [COMPLETION_FINAL] Mostrando overlay {index+1}/{len(cartas_completadas)} para {carta_info['name']}")
        
        # Armazenar informações para o próximo overlay
        self._next_completion_overlays = cartas_completadas
        self._current_completion_index = index
        
        # Mostrar overlay atual (será fechado automaticamente ou pelo usuário)
        self._mostrar_overlay_completion(carta_info['path'], carta_info['dados'], is_sequential=True, carta_index=carta_info.get('index'))
    
    def _mostrar_overlay_quit_challenge(self, carta_path):
        """
        Mostra overlay de confirmação para quit challenge
        """
        print(f"DEBUG: [QUIT_CHALLENGE] Criando overlay de confirmação para: {os.path.basename(carta_path)}")
        
        # Obter dados da carta para challenge_quit_fee
        dados_carta = self._obter_dados_carta(carta_path)
        challenge_quit_fee = dados_carta.get('challenge_quit_fee', 0)
        
        print(f"DEBUG: [QUIT_CHALLENGE] Challenge quit fee: {challenge_quit_fee}")
        
        # Criar overlay
        if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
            self._overlay_quit_challenge.destroy()
        
        self._overlay_quit_challenge = tk.Toplevel(self)
        self._overlay_quit_challenge.title("")
        self._overlay_quit_challenge.configure(bg="black")
        self._overlay_quit_challenge.overrideredirect(True)
        self._overlay_quit_challenge.attributes("-topmost", True)
        
        # Centralizar na tela com altura reduzida
        overlay_width, overlay_height = 400, 220  # Reduzido de 300 para 220
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_quit_challenge.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com padding reduzido
        main_frame = tk.Frame(self._overlay_quit_challenge, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=5)  # Reduzido pady de 10 para 5
        
        # Título "Are you sure you want to quit?" em roxo (centralizado) com padding reduzido
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to quit?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(15, 15))  # Reduzido de (20, 20) para (15, 15)
        
        # Frame para "You'll lost" + valor + moeda com padding reduzido
        lost_frame = tk.Frame(main_frame, bg="black")
        lost_frame.pack(pady=(5, 15))  # Reduzido de (10, 20) para (5, 15)
        
        # Texto "You'll lost " em branco
        lost_text_lbl = tk.Label(
            lost_frame,
            text="You'll lost ",
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        lost_text_lbl.pack(side="left")
        
        # Valor da taxa em branco
        fee_value_lbl = tk.Label(
            lost_frame,
            text=str(challenge_quit_fee),
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        fee_value_lbl.pack(side="left", padx=(0, 5))
        
        # Símbolo da piccoin
        try:
            coin_img_path = os.path.join(IMG_DIR, "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path)
                coin_pil = coin_pil.resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                
                coin_lbl = tk.Label(
                    lost_frame,
                    image=coin_img,
                    bg="black"
                )
                coin_lbl.image = coin_img  # manter referência
                coin_lbl.pack(side="left")
            else:
                # Fallback se imagem não existir
                coin_lbl = tk.Label(
                    lost_frame,
                    text="🪙",
                    font=("Helvetica", 14),
                    fg="gold",
                    bg="black"
                )
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: [QUIT_CHALLENGE] Erro ao carregar imagem da moeda: {e}")
            # Fallback emoji
            coin_lbl = tk.Label(
                lost_frame,
                text="🪙",
                font=("Helvetica", 14),
                fg="gold",
                bg="black"
            )
            coin_lbl.pack(side="left")
        
        # Frame para botões com padding reduzido
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(15, 5))  # Reduzido de (20, 10) para (15, 5)
        
        # Função para fechar overlay sem quit
        def fechar_sem_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador cancelou quit challenge")
            if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
                self._overlay_quit_challenge.destroy()
                self._overlay_quit_challenge = None
        
        # Função para confirmar quit
        def confirmar_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador confirmou quit challenge")
            
            # Verificar se jogador tem saldo suficiente
            if self.saldo < challenge_quit_fee:
                print(f"DEBUG: [QUIT_CHALLENGE] ❌ Saldo insuficiente: {self.saldo} < {challenge_quit_fee}")
                # Talvez mostrar mensagem de erro aqui
                fechar_sem_quit()
                return
            
            # Decrementar saldo
            self.saldo -= challenge_quit_fee
            print(f"DEBUG: [QUIT_CHALLENGE] Saldo decrementado: -{challenge_quit_fee}, novo saldo: {self.saldo}")
            self._atualizar_display_saldo()
            
            # CORREÇÃO: Remover carta do inventário do jogador ANTES de devolver ao baralho
            if 'challenges' in self.inventario and carta_path in self.inventario['challenges']:
                self.inventario['challenges'].remove(carta_path)
                print(f"DEBUG: [QUIT_CHALLENGE] ✅ Carta {os.path.basename(carta_path)} removida do inventário challenges do jogador")
            else:
                print(f"DEBUG: [QUIT_CHALLENGE] ⚠️ Carta {os.path.basename(carta_path)} não encontrada no inventário challenges do jogador")
            
            # Remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # Devolver carta para baralho da Store (challenges)
            self._devolver_challenge_para_baralho(carta_path)
            
            # Fechar overlay
            fechar_sem_quit()
            
            # Voltar para interface principal
            print(f"DEBUG: [QUIT_CHALLENGE] Voltando para interface principal após quit")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Botão "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_quit
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Botão "Yes" verde (lado direito)
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",
            fg="white",
            width=8,
            height=1,
            command=confirmar_quit
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [QUIT_CHALLENGE] Overlay de quit challenge criado")
    
    def _mostrar_overlay_confirmacao_troca(self, carta_path, tipos, page=0):
        """
        Mostra overlay de confirmação para troca de carta com warning sobre perda de progresso
        """
        print(f"DEBUG: [SWITCH_CONFIRM] Criando overlay de confirmação de troca para: {os.path.basename(carta_path)}")
        
        # Criar overlay
        if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
            self._overlay_switch_confirm.destroy()
        
        self._overlay_switch_confirm = tk.Toplevel(self)
        self._overlay_switch_confirm.title("")
        self._overlay_switch_confirm.configure(bg="black")
        self._overlay_switch_confirm.overrideredirect(True)
        self._overlay_switch_confirm.attributes("-topmost", True)
        
        # Centralizar na tela 
        overlay_width, overlay_height = 400, 200
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_switch_confirm.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com borda
        main_frame = tk.Frame(self._overlay_switch_confirm, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Título "Are you sure you want to switch?" em roxo (centralizado)
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to switch?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",  # Roxo
            bg="black"
        )
        title_lbl.pack(pady=(20, 10))
        
        # Subtítulo "All progress will be lost" em branco
        subtitle_lbl = tk.Label(
            main_frame,
            text="All progress will be lost",
            font=("Helvetica", 12),
            fg="white",
            bg="black"
        )
        subtitle_lbl.pack(pady=(0, 20))
        
        # Frame para botões
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(10, 0))
        
        # Função para fechar overlay sem confirmar troca
        def fechar_sem_trocar():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador cancelou a troca")
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
        
        # Função para confirmar troca (executar troca e voltar ao dashboard)
        def confirmar_troca():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador confirmou a troca")
            
            # Fechar overlay
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
            
            # CORREÇÃO CRÍTICA: Executar a troca diretamente
            print(f"DEBUG: [SWITCH_CONFIRM] Executando troca da carta: {os.path.basename(carta_path)}")
            
            # Chama diretamente aceitar_carta_carrossel que faz a troca completa
            self.aceitar_carta_carrossel(carta_path, tipos, page)
        
        # Botão "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",  # Vermelho
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_trocar
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Botão "Yes" verde (lado direito)  
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",  # Verde
            fg="white",
            width=8,
            height=1,
            command=confirmar_troca
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [SWITCH_CONFIRM] Overlay de confirmação de troca criado")
    
    def _ativar_botao_end_turn(self):
        """Ativa o botão End Turn e muda sua aparência"""
        print("DEBUG: [END_TURN] === TENTANDO ATIVAR BOTÃO END TURN ===")
        try:
            # CORREÇÃO: Procurar por botão End Turn em toda a interface se necessário
            end_turn_button = None
            
            # 1. Verificar se temos referência válida
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                if hasattr(self.end_turn_btn, 'winfo_exists') and self.end_turn_btn.winfo_exists():
                    end_turn_button = self.end_turn_btn
                    print("DEBUG: [END_TURN] ✅ Botão encontrado via referência self.end_turn_btn")
                else:
                    print("DEBUG: [END_TURN] ❌ Referência self.end_turn_btn inválida")
                    self.end_turn_btn = None
            
            # 2. Se não encontrou, procurar em toda a interface
            if not end_turn_button:
                print("DEBUG: [END_TURN] Procurando botão End Turn em toda a interface...")
                end_turn_button = self._procurar_botao_end_turn_na_interface()
                if end_turn_button:
                    self.end_turn_btn = end_turn_button
                    print("DEBUG: [END_TURN] ✅ Botão End Turn encontrado na interface")
            
            # 3. Se encontrou o botão, ativar
            if end_turn_button:
                end_turn_button.config(
                    state="normal",
                    bg="#808080",
                    fg="black"
                )
                print("DEBUG: [END_TURN] ✅ Botão End Turn ATIVADO com sucesso")
            else:
                print("DEBUG: [END_TURN] ❌ Botão End Turn não encontrado")
                # CORREÇÃO: Tentar recriar o botão se não existir
                self._tentar_recriar_end_turn_button()
                
        except tk.TclError as e:
            print(f"DEBUG: [END_TURN] ❌ Erro TclError ao ativar End Turn: {e}")
            # Limpar referência inválida e tentar recriar
            self.end_turn_btn = None
            self._tentar_recriar_end_turn_button()
        except Exception as e:
            print(f"DEBUG: [END_TURN] ❌ Erro inesperado ao ativar End Turn: {e}")
    
    def _procurar_botao_end_turn_na_interface(self):
        """Procura o botão End Turn em toda a interface atual"""
        try:
            # Procurar em todos os widgets filhos
            for widget in self.winfo_children():
                if hasattr(widget, 'winfo_children'):
                    for sub_widget in widget.winfo_children():
                        # Verificar se é um botão com texto "End Turn"
                        if (hasattr(sub_widget, 'cget') and 
                            hasattr(sub_widget, 'config') and
                            hasattr(sub_widget, 'state')):
                            try:
                                text = sub_widget.cget('text')
                                if text and 'End Turn' in str(text):
                                    print(f"DEBUG: [END_TURN] ✅ Botão End Turn encontrado: {text}")
                                    return sub_widget
                            except:
                                continue
            
            print("DEBUG: [END_TURN] ❌ Botão End Turn não encontrado na interface")
            return None
        except Exception as e:
            print(f"DEBUG: [END_TURN] ❌ Erro ao procurar botão: {e}")
            return None
    
    def _tentar_recriar_end_turn_button(self):
        """Tenta recriar o botão End Turn se não existir"""
        try:
            print("DEBUG: [END_TURN] Tentando recriar botão End Turn...")
            # Verificar se há um container válido para o botão
            if hasattr(self, 'winfo_children') and self.winfo_children():
                # CORREÇÃO: Usar método seguro para criar End Turn
                print("DEBUG: [END_TURN] ✅ Container válido encontrado - tentando recriar...")
                self.after(100, lambda: self._criar_botao_end_turn_seguro())
            else:
                print("DEBUG: [END_TURN] ❌ Não há container válido para recriar End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ❌ Erro ao tentar recriar End Turn: {e}")
    
    def _criar_botao_end_turn_seguro(self):
        """Cria botão End Turn de forma segura"""
        try:
            if not hasattr(self, 'end_turn_btn') or not self.end_turn_btn:
                # Verificar se já existe na interface atual
                existing_button = self._procurar_botao_end_turn_na_interface()
                if existing_button:
                    self.end_turn_btn = existing_button
                    print("DEBUG: [END_TURN] ✅ Botão End Turn existente encontrado e vinculado")
                    
                    # Ativar imediatamente
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] ✅ Botão End Turn ativado")
                    return
                
                # Se não existe, tentar criar novo
                print("DEBUG: [END_TURN] Tentando criar novo botão End Turn...")
                self._criar_botao_end_turn()
                
                # Se criado com sucesso, ativar imediatamente
                if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] ✅ Botão End Turn recriado e ativado")
                else:
                    print("DEBUG: [END_TURN] ❌ Falha ao criar novo botão End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ❌ Erro ao criar End Turn seguro: {e}")
    
    def _manter_end_turn_disabled(self):
        """Mantém o botão End Turn disabled enquanto há cartas para processar"""
        try:
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn and self.end_turn_btn.winfo_exists():
                self.end_turn_btn.config(
                    state="disabled",
                    bg="#666666",  # Cor mais escura para indicar disabled
                    fg="#999999"   # Texto mais claro para indicar disabled
                )
                print(f"DEBUG: [GESTÃO_PACOTES] Botão End Turn mantido DISABLED - carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)} em processamento")
            else:
                print("DEBUG: [GESTÃO_PACOTES] ❌ Botão End Turn não encontrado para manter disabled")
        except tk.TclError as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ❌ Erro ao manter End Turn disabled: {e}")
            # Limpar referência inválida
            self.end_turn_btn = None
    
    def _limpar_gestao_pacotes(self):
        """Limpa todas as variáveis e widgets do sistema de gestão de pacotes"""
        print("DEBUG: [GESTÃO_PACOTES] Limpando sistema de gestão de pacotes")
        
        # Desbloquear interações do carrossel
        self._desbloquear_interacoes_carrossel()
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles
        self._remover_controles_gestao()
        
        # Limpar variáveis
        if hasattr(self, '_cartas_gestao'):
            delattr(self, '_cartas_gestao')
        
        if hasattr(self, '_carta_atual_gestao'):
            delattr(self, '_carta_atual_gestao')
        
        if hasattr(self, '_valores_pacotes'):
            delattr(self, '_valores_pacotes')
        
        print("DEBUG: [GESTÃO_PACOTES] Sistema de gestão de pacotes limpo")

    def end_turn(self):
        # CORREÇÃO CRÍTICA: Preservar estatísticas das cartas antes de terminar turno
        print("DEBUG: End Turn clicado - preservando estatísticas das cartas")
        
        # Salvar estatísticas atuais das cartas para preservação entre turnos
        if hasattr(self, 'card_stats') and hasattr(self, 'cards'):
            # Salvar no root para que persista quando PlayerDashboard for recriado
            root = self.master
            root._backup_card_stats = []
            root._backup_cards = []
            
            for i, stats in enumerate(self.card_stats):
                # Criar cópia profunda das estatísticas
                backup_stats = {
                    'To send': stats['To send'],
                    'Rxd': stats['Rxd'], 
                    'Lost': stats['Lost']
                }
                root._backup_card_stats.append(backup_stats)
                print(f"DEBUG: [END_TURN] Carta {i} estatísticas salvas: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # Salvar também os caminhos das cartas
            for i, card_path in enumerate(self.cards):
                root._backup_cards.append(card_path)
                print(f"DEBUG: [END_TURN] Carta {i} path salvo: {os.path.basename(card_path) if card_path else 'None'}")
        
        # CORREÇÃO CRÍTICA: Preservar mapeamento de Activities com valores preservados
        if hasattr(self, '_activity_preserved_stats'):
            root = self.master
            root._activity_preserved_stats = self._activity_preserved_stats.copy()
            print(f"DEBUG: [END_TURN] Mapeamento de Activities preservadas salvo: {len(self._activity_preserved_stats)} entries")
            for activity_path, stats in self._activity_preserved_stats.items():
                print(f"DEBUG: [END_TURN] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
        
        # CORREÇÃO CRÍTICA: Incrementar primeiro, depois salvar os contadores corretos
        print(f"DEBUG: [END_TURN] ======= INCREMENTANDO CONTADORES DE TURNO =======")
        print(f"DEBUG: [END_TURN] Contadores ANTES do incremento:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # INCREMENTO TEMPORAL: Incrementar contador de turnos para tracking de Challenge time_limit
        self._increment_turn_counter()
        
        print(f"DEBUG: [END_TURN] Contadores APÓS incremento:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # CRÍTICO: SALVAR OS CONTADORES JÁ INCREMENTADOS para preservação
        root = self.master
        root._backup_turn_counters = {
            '_current_turn_number': self._current_turn_number,
            '_current_turn': self._current_turn,
            '_current_turn_id': self._current_turn_id
        }
        print(f"DEBUG: [END_TURN] ======= CONTADORES PRESERVADOS =======")
        print(f"DEBUG: [END_TURN] Root object: {root}")
        print(f"DEBUG: [END_TURN] Backup salvo (INCREMENTADOS): {root._backup_turn_counters}")
        print(f"DEBUG: [END_TURN] ✅ PRÓXIMO TURNO TERÁ OS VALORES CORRETOS!")
        print(f"DEBUG: [END_TURN] ======= FIM PRESERVAÇÃO CONTADORES =======")
        
        # TEMPORARIAMENTE DESABILITADO: Verificar cartas Challenge que atingiram n_turns obrigatoriamente
        # FIXME: Problema com messagebox durante destruição da interface
        # self._verificar_challenges_tempo_limite()
        print("DEBUG: [END_TURN] ✅ Verificação de tempo limite desabilitada temporariamente")
        
        # NOVO: Verificar serviços TEMPORARY que expiraram
        self._verificar_services_expirados()
        
        # NOVO: Verificar events que expiraram
        self._verificar_events_expirados()
        
        # NOVA CORREÇÃO: Resetar flag Final Phase clicked para o próximo turno
        self._final_phase_clicked_this_turn = False
        self._final_phase_turn_id = None
        print("DEBUG: [END_TURN] Flags Final Phase resetadas para próximo turno - gestão não será restaurada automaticamente")
        
        # CORREÇÃO CRÍTICA: Limpar completamente estado Challenge no final do turno
        # Isto garante que cartas Challenge não persistem para o próximo turno
        print("DEBUG: End Turn clicado - limpando estado Challenge antes de terminar turno")
        
        # Limpar variáveis Challenge do PlayerDashboard
        if hasattr(self, '_store_challenge_carta_path'):
            self._store_challenge_carta_path = None
            print("DEBUG: _store_challenge_carta_path limpo no End Turn")
        
        if hasattr(self, '_store_challenge_carta_tipo'):
            self._store_challenge_carta_tipo = None
            print("DEBUG: _store_challenge_carta_tipo limpo no End Turn")
        
        # Limpar também flags de Challenge
        self._challenge_accepted = False
        print("DEBUG: _challenge_accepted resetado para False no End Turn")
        
        # CORREÇÃO: Reabilitar botão Store no final do turno
        # Isto permite que o jogador use casas Challenge novamente no próximo turno
        self.enable_store_button()
        print("DEBUG: Botão Store reabilitado no End Turn - permite novas interações Challenge")
        
        # Limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar todas as variáveis relacionadas com Challenge na Store
                    challenge_attrs = ['fullscreen_carta_path', 'fullscreen_carta_tipo', 
                                     '_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                     '_original_carta_path', '_original_carta_tipo']
                    for attr in challenge_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: Store {attr} limpo no End Turn")
            except Exception as e:
                print(f"DEBUG: Erro ao limpar Store no End Turn: {e}")
        
        print("DEBUG: Estado Challenge completamente limpo no End Turn")
        
        # LIMPEZA ADICIONAL: Limpar estados salvos para evitar restaurações incorretas no próximo turno
        if hasattr(self, '_saved_dashboard_state'):
            self._saved_dashboard_state = None
            print("DEBUG: [END_TURN] Estado salvo do dashboard limpo")
        if hasattr(self, '_estado_botoes_imediato'):
            self._estado_botoes_imediato = None
            print("DEBUG: [END_TURN] Estado imediato dos botões limpo")
        
        # PLACEHOLDER comentado para não bloquear a transição para próximo turno
        # Placeholder: lógica para terminar o turno e passar ao próximo jogador
        # Aqui pode-se implementar a lógica de alternância de jogador
        # import tkinter.messagebox
        # tkinter.messagebox.showinfo("End Turn", "Turno terminado! Próximo jogador...")
        # Exemplo: pode-se limpar a interface ou chamar uma função para o próximo jogador
        print("DEBUG: [END_TURN] ✅ Método end_turn() terminado com sucesso - retornando controle para _criar_botao_end_turn()")

    def _aplicar_router_upgrade(self, router_id):
        """
        Aplica o efeito ROUTER UPGRADE baseado no router_id.
        Verifica se existe Small Router ativo correspondente e abre inventário para upgrade.
        """
        print(f"DEBUG: [ROUTER_UPGRADE] Aplicando Router Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID é None - não aplicando upgrade")
            return
        
        # Mapeamento: Small Router -> Medium Router
        equipment_mapping = {
            1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
            2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
            3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID {router_id} não suportado")
            return
        
        small_router, medium_router = equipment_mapping[router_id]
        
        # Verificar se existe o Small Router correspondente ATIVO (virado para cima)
        target_small_router = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == small_router:
                target_small_router = equipment_path
                break
        
        if target_small_router:
            print(f"DEBUG: [ROUTER_UPGRADE] Small Router {small_router} ativo encontrado - procedendo com inventário")
            print(f"DEBUG: [ROUTER_UPGRADE] Router ativo: {os.path.basename(target_small_router)}")
            
            # Verificar se o jogador já tem o Medium Router correspondente no inventário
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
            
            if medium_router_exists:
                print(f"DEBUG: [ROUTER_UPGRADE] ❌ {medium_router} já existe no inventário - upgrade não aplicado")
                return
            
            # Definir contexto de ROUTER UPGRADE e router_id
            self._in_router_upgrade_context = True
            self._router_upgrade_target_id = router_id
            
            # Abrir inventário de equipamentos para seleção
            self._show_equipment_inventory_for_router_upgrade()
            print("DEBUG: [ROUTER_UPGRADE] ✅ Inventário de equipamentos aberto para upgrade")
        else:
            print(f"DEBUG: [ROUTER_UPGRADE] Nenhum Small Router {small_router} ativo encontrado - não é possível fazer upgrade")
            print(f"DEBUG: [ROUTER_UPGRADE] ROUTER UPGRADE só funciona se houver {small_router} ativo (virado para cima)")
            print(f"DEBUG: [ROUTER_UPGRADE] Equipamentos ativos encontrados:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_UPGRADE]   - {os.path.basename(equipment_path)}")

    def _show_equipment_inventory_for_router_upgrade(self):
        """Abre inventário de equipamentos especificamente para ROUTER UPGRADE"""
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] Criando inventário específico para ROUTER UPGRADE")
        
        # Definir contexto específico
        self._in_router_upgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] ✅ Inventário específico para ROUTER UPGRADE criado")

    def _show_equipment_inventory_for_router_downgrade(self):
        """Abre inventário de equipamentos especificamente para ROUTER DOWNGRADE"""
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Criando inventário específico para ROUTER DOWNGRADE")
        
        # Definir contexto específico
        self._in_router_downgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] ✅ Inventário específico para ROUTER DOWNGRADE criado")

    def _aplicar_router_downgrade(self, router_id):
        """
        Inicia o processo ROUTER DOWNGRADE baseado no router_id.
        Verifica se o medium router está ativo antes de mostrar overlay de confirmação.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Iniciando Router Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID é None - não aplicando downgrade")
            return
        
        # Validar router_id suportado
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID {router_id} não suportado")
            return
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORREÇÃO CRÍTICA: Verificar se o medium router está ATIVO antes de mostrar overlay
        medium_router_ativo = any(
            os.path.basename(equipment_path) == medium_router 
            for equipment_path in self.active_equipments
        )
        
        print(f"DEBUG: [ROUTER_DOWNGRADE] Verificando se {medium_router} está ativo...")
        print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
        print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} ativo: {medium_router_ativo}")
        
        if not medium_router_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ❌ {medium_router} não está ativo - ROUTER DOWNGRADE não pode ser aplicado")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Action_32 foi consumida mas o efeito não se aplica")
            return
        
        # Medium router está ativo - ir DIRETAMENTE para inventário de Equipments
        print(f"DEBUG: [ROUTER_DOWNGRADE] ✅ {medium_router} está ativo - indo para inventário Equipments")
        
        # Armazenar contexto para o fullscreen da carta Equipment
        self._in_router_downgrade_context = True
        self._router_downgrade_target_id = router_id
        
        # Ir diretamente para inventário de Equipments (SEM overlay)
        self._show_equipment_inventory_for_router_downgrade()
        
    def _processar_router_downgrade(self, router_id):
        """
        Processa efetivamente o ROUTER DOWNGRADE baseado no router_id.
        Troca Medium Router ativo por Small Router correspondente.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Processando Router Downgrade para Router ID: {router_id}")
        
        # Mapeamento: Medium Router -> Small Router
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORREÇÃO: Encontrar e remover medium router dos equipments ativos
        medium_router_path_ativo = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == medium_router:
                medium_router_path_ativo = equipment_path
                break
        
        if medium_router_path_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Encontrado {medium_router} nos equipments ativos")
            
            # Remover Medium Router dos equipments ativos
            self.active_equipments.remove(medium_router_path_ativo)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido dos equipments ativos")
            
            # Remover Medium Router do inventário também
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_inventory = None
            for equipment_path in equipments_inventory:
                if os.path.basename(equipment_path) == medium_router:
                    medium_router_inventory = equipment_path
                    break
            
            if medium_router_inventory:
                self.inventario["equipments"].remove(medium_router_inventory)
                print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido do inventário")
            
            # Construir caminho para Small Router (usar mesma estrutura de diretório)
            base_dir = os.path.dirname(medium_router_path_ativo)
            small_router_path = os.path.join(base_dir, small_router)
            
            # Adicionar Small Router ao inventário (fica inativo por padrão)
            self.inventario["equipments"].append(small_router_path)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {small_router} adicionado ao inventário (inativo)")
            print(f"DEBUG: [ROUTER_DOWNGRADE] ✅ Router Downgrade aplicado com sucesso!")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ❌ {medium_router} não encontrado nos equipments ativos")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_DOWNGRADE]   - {os.path.basename(equipment_path)}")

    def _aplicar_link_upgrade(self, router_id):
        """
        Aplica o efeito LINK UPGRADE baseado no router_id.
        Verifica se existe Long Link correspondente e abre inventário para upgrade.
        """
        print(f"DEBUG: [LINK_UPGRADE] Aplicando Link Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_UPGRADE] Router ID é None - não aplicando upgrade")
            return
        
        # Mapeamento: Long Link -> Short Link
        equipment_mapping = {
            1: ("Equipment_10.png", "Equipment_7.png"),  # Long Link 1 -> Short Link 1
            2: ("Equipment_11.png", "Equipment_8.png"),  # Long Link 2 -> Short Link 2
            3: ("Equipment_12.png", "Equipment_9.png"),  # Long Link 3 -> Short Link 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [LINK_UPGRADE] Router ID {router_id} não suportado")
            return
        
        long_link, short_link = equipment_mapping[router_id]
        
        # Verificar se o jogador tem o Long Link correspondente no inventário
        equipments_inventory = self.inventario.get("equipments", [])
        long_link_found = None
        
        for equipment_path in equipments_inventory:
            if os.path.basename(equipment_path) == long_link:
                long_link_found = equipment_path
                break
        
        if long_link_found:
            print(f"DEBUG: [LINK_UPGRADE] Long Link {long_link} encontrado - procedendo com inventário")
            print(f"DEBUG: [LINK_UPGRADE] Long Link encontrado: {os.path.basename(long_link_found)}")
            
            # Verificar se o jogador já tem o Short Link correspondente no inventário
            short_link_exists = any(os.path.basename(eq) == short_link for eq in equipments_inventory)
            
            if short_link_exists:
                print(f"DEBUG: [LINK_UPGRADE] ❌ {short_link} já existe no inventário - upgrade não aplicado")
                return
            
            # Definir contexto de LINK UPGRADE e router_id
            self._in_link_upgrade_context = True
            self._link_upgrade_target_id = router_id
            
            # Abrir inventário de equipamentos para seleção
            self._show_equipment_inventory_for_link_upgrade()
            print("DEBUG: [LINK_UPGRADE] ✅ Inventário de equipamentos aberto para upgrade")
        else:
            print(f"DEBUG: [LINK_UPGRADE] Nenhum Long Link {long_link} encontrado no inventário - não é possível fazer upgrade")
            print(f"DEBUG: [LINK_UPGRADE] LINK UPGRADE só funciona se houver {long_link} disponível no inventário")
            print(f"DEBUG: [LINK_UPGRADE] Equipamentos disponíveis:")
            for equipment_path in equipments_inventory:
                print(f"DEBUG: [LINK_UPGRADE]   - {os.path.basename(equipment_path)}")

    def _show_equipment_inventory_for_link_upgrade(self):
        """Abre inventário de equipamentos especificamente para LINK UPGRADE"""
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Criando inventário específico para LINK UPGRADE")
        
        # Definir contexto específico
        self._in_link_upgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_UPGRADE_INVENTORY] ✅ Inventário específico para LINK UPGRADE criado")

    def _aplicar_link_downgrade(self, router_id):
        """
        Aplica o efeito LINK DOWNGRADE baseado no router_id.
        Verifica se existe Short Link correspondente e abre inventário para downgrade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE] Aplicando Link Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_DOWNGRADE] Router ID é None - não aplicando downgrade")
            return
        
        # Mapeamento: Short Link -> Long Link
        equipment_mapping = {
            1: ("Equipment_7.png", "Equipment_10.png"),  # Short Link 1 -> Long Link 1
            2: ("Equipment_8.png", "Equipment_11.png"),  # Short Link 2 -> Long Link 2
            3: ("Equipment_9.png", "Equipment_12.png"),  # Short Link 3 -> Long Link 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [LINK_DOWNGRADE] Router ID {router_id} não suportado")
            return
        
        short_link, long_link = equipment_mapping[router_id]
        
        # Verificar se o jogador tem o Short Link correspondente no inventário
        equipments_inventory = self.inventario.get("equipments", [])
        short_link_found = None
        
        for equipment_path in equipments_inventory:
            if os.path.basename(equipment_path) == short_link:
                short_link_found = equipment_path
                break
        
        if short_link_found:
            print(f"DEBUG: [LINK_DOWNGRADE] Short Link {short_link} encontrado - procedendo com inventário")
            print(f"DEBUG: [LINK_DOWNGRADE] Short Link encontrado: {os.path.basename(short_link_found)}")
            
            # Verificar se o jogador já tem o Long Link correspondente no inventário
            long_link_exists = any(os.path.basename(eq) == long_link for eq in equipments_inventory)
            
            if long_link_exists:
                print(f"DEBUG: [LINK_DOWNGRADE] ❌ {long_link} já existe no inventário - downgrade não aplicado")
                return
            
            # Definir contexto de LINK DOWNGRADE e router_id
            self._in_link_downgrade_context = True
            self._link_downgrade_target_id = router_id
            
            # Abrir inventário de equipamentos para seleção
            self._show_equipment_inventory_for_link_downgrade()
            print("DEBUG: [LINK_DOWNGRADE] ✅ Inventário de equipamentos aberto para downgrade")
        else:
            print(f"DEBUG: [LINK_DOWNGRADE] Nenhum Short Link {short_link} encontrado no inventário - não é possível fazer downgrade")
            print(f"DEBUG: [LINK_DOWNGRADE] LINK DOWNGRADE só funciona se houver {short_link} disponível no inventário")
            print(f"DEBUG: [LINK_DOWNGRADE] Equipamentos disponíveis:")
            for equipment_path in equipments_inventory:
                print(f"DEBUG: [LINK_DOWNGRADE]   - {os.path.basename(equipment_path)}")

    def _show_equipment_inventory_for_link_downgrade(self):
        """Abre inventário de equipamentos especificamente para LINK DOWNGRADE"""
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Criando inventário específico para LINK DOWNGRADE")
        
        # Definir contexto específico
        self._in_link_downgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] ✅ Inventário específico para LINK DOWNGRADE criado")

    def _aplicar_add_router(self):
        """Abre página para escolher router gratuito (Equipment_1, Equipment_2, ou Equipment_3) da Store"""
        print("DEBUG: [ADD_ROUTER] Iniciando página de seleção de router")
        try:
            self._criar_router_selection_page()
            print("DEBUG: [ADD_ROUTER] ✅ Página de seleção criada com sucesso")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] ❌ Erro ao criar página de seleção: {e}")
            import traceback
            print(f"DEBUG: [ADD_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def _aplicar_remove_router(self):
        """Abre página de inventário de equipamentos para o jogador escolher qual router remover"""
        print("DEBUG: [REMOVE_ROUTER] Abrindo inventário de equipamentos")
        try:
            # Verificar se há equipamentos no inventário
            equipments_inventory = self.inventario.get("equipments", [])
            if not equipments_inventory:
                print("DEBUG: [REMOVE_ROUTER] Inventário de equipamentos vazio")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            # CORREÇÃO: Verificar se há Small Routers (Equipment_1, Equipment_2, Equipment_3) ATIVOS
            # Apenas permite remoção se houver Small Routers virados para cima (ativos)
            small_routers_active = []
            for equipment_path in equipments_inventory:
                equipment_filename = os.path.basename(equipment_path)
                # Verificar se é Small Router (Equipment_1, Equipment_2 ou Equipment_3)
                if any(router_name in equipment_filename for router_name in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]):
                    # Verificar se está ativo (virado para cima)
                    if self.is_card_active(equipment_path, "equipments"):
                        small_routers_active.append(equipment_path)
            
            if not small_routers_active:
                print("DEBUG: [REMOVE_ROUTER] Nenhum Small Router ativo encontrado - não é possível remover routers")
                print("DEBUG: [REMOVE_ROUTER] REMOVE ROUTER só funciona se houver Equipment_1, Equipment_2 ou Equipment_3 ativos (virados para cima)")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            print(f"DEBUG: [REMOVE_ROUTER] {len(small_routers_active)} Small Router(s) ativo(s) encontrado(s) - procedendo com inventário")
            for router in small_routers_active:
                print(f"DEBUG: [REMOVE_ROUTER] Small Router ativo: {os.path.basename(router)}")
            
            # Mostrar inventário de equipamentos com callback específico para voltar a Actions/Events
            self._show_equipment_inventory_for_remove_router()
            print("DEBUG: [REMOVE_ROUTER] ✅ Inventário de equipamentos aberto com sucesso")
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER] ❌ Erro ao abrir inventário: {e}")
            import traceback
            print(f"DEBUG: [REMOVE_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _show_equipment_inventory_for_remove_router(self):
        """Mostra inventário de equipamentos específico para REMOVE ROUTER com callback correto"""
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] Criando inventário específico para REMOVE ROUTER")
        
        # Definir flag para indicar que estamos no contexto REMOVE ROUTER
        self._in_remove_router_context = True
        
        # CORREÇÃO: Usar o método padrão de inventory matrix em vez de criar interface customizada
        # Isto garante consistência com o resto do sistema e permite o botão "Go!" funcionar
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] Chamando show_card_fullscreen_inventory para equipments")
        self.show_inventory_matrix(["equipments"], page=0)
        
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] ✅ Inventário específico para REMOVE ROUTER criado")
    
    def _criar_router_selection_page(self):
        """Cria página completa para seleção de router da Store (padrão igual Store_v2.py)"""
        print("DEBUG: [ADD_ROUTER] ======= INICIANDO CRIAÇÃO DA PÁGINA =======")
        print("DEBUG: [ADD_ROUTER] Criando página de seleção de router")
        
        # PROTEÇÃO: Marcar que estamos numa página especial (impede callbacks automáticos)
        self._in_router_selection_page = True
        print("DEBUG: [ADD_ROUTER] Flag _in_router_selection_page = True")
        
        # VERIFICAÇÃO DE SEGURANÇA: Garantir que esta função só é chamada em contexto válido
        if not hasattr(self, 'cards') or not self.cards:
            print("DEBUG: [ADD_ROUTER] ERRO - Cards não disponíveis, abortando")
            return
        
        # FORÇA ATUALIZAÇÃO DA INTERFACE (crítico para Raspberry Pi)
        self.update_idletasks()
        self.update()
        
        # Limpar interface atual (IGUAL STORE_V2.PY)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        print("DEBUG: [ADD_ROUTER] Interface limpa e fundo preto definido")
        
        # FORÇA SEGUNDA ATUALIZAÇÃO APÓS LIMPEZA
        self.update_idletasks()
        self.update()
        
        # Barra superior com Store_awning_v3.png (como pedido)
        try:
            # Usar Store_awning_v3.png como especificado
            awning_path = os.path.join(os.path.dirname(__file__), "img", "Store_awning_v3.png")
            if os.path.exists(awning_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_path).resize((self.winfo_screenwidth(), 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                print("DEBUG: [ADD_ROUTER] Header com Store_awning_v3.png criado")
            else:
                raise FileNotFoundError("Store_awning_v3.png não encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar Store_awning_v3.png: {e} - usando fallback")
            # Fallback simples
            header_frame = tk.Frame(self, bg="#4CAF50", height=50)
            header_frame.pack(fill="x", pady=(0, 10))
            header_label = tk.Label(header_frame, text="NetMaster", font=("Helvetica", 18, "bold"), 
                                  fg="white", bg="#4CAF50")
            header_label.pack(expand=True)

        # Label pequeno à esquerda do logo (como na Store)
        left_label = tk.Label(self, text="••••", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        left_label.place(relx=0.46, y=10, anchor="center")
        
        # Logo NetMaster posicionado independentemente (igual Store_v2.py)
        try:
            # Tentar carregar o logo do diretório img
            logo_img_path = os.path.join(os.path.dirname(__file__), "img", "logo_netmaster_store.png")
            if not os.path.exists(logo_img_path):
                # Fallback para Raspberry Pi
                logo_img_path = "/home/joao_rebolo/netmaster_menu/img/logo_netmaster_store.png"
            
            if os.path.exists(logo_img_path):
                logo_img = ImageTk.PhotoImage(Image.open(logo_img_path).resize((20, 20)))
                logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                logo_lbl.image = logo_img
                logo_lbl.place(relx=0.5, y=10, anchor="center")
                print("DEBUG: [ADD_ROUTER] Logo NetMaster adicionado com sucesso")
            else:
                print("DEBUG: [ADD_ROUTER] Logo não encontrado em nenhum diretório")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar logo: {e}")
        
        # Label largo à direita do logo para cobrir área amarela (ajustado)
        right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_logo_label.place(relx=0.52, y=10, anchor="w")
        
        # Label adicional para garantir cobertura completa (reduzido)
        extra_cover_label = tk.Label(self, text="  ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
        extra_cover_label.place(relx=0.54, y=10, anchor="w")
        
        # Texto "Store" posicionado independentemente (como na Store)
        title_lbl = tk.Label(self, text="Store", 
                            font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        title_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno à direita do título (igual Store original)
        right_title_label = tk.Label(self, text="•", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_title_label.place(relx=0.6, y=30, anchor="center")

        # Tamanho das cartas - igual ao da Store (75x110)
        card_w, card_h = 75, 110

        # Obter equipamentos disponíveis sincronizados com o inventário
        routers_disponiveis = self._obter_equipments_sincronizados()
        
        print(f"DEBUG: [ADD_ROUTER] Routers disponíveis sincronizados: {len(routers_disponiveis)}")
        
        # Paginação (igual Store_v2.py, mesmo que só tenhamos 3 routers)
        cards_per_page = 4  # Igual à Store_v2.py
        total_pages = max(1, (len(routers_disponiveis) + cards_per_page - 1) // cards_per_page)
        page = 0  # Sempre página 0 para routers
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        routers_page = routers_disponiveis[start_idx:end_idx]
        
        # Frame para os routers (centralizado, movido mais para cima)
        self.matriz_frame = tk.Frame(self, bg="black")
        self.matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        n_col = 2  # 2 colunas para layout 2xn como solicitado
        card_w, card_h = 75, 110  # Tamanho das cartas de router
        
        # Variáveis para seleção
        self.router_selection = None
        self.router_buttons = []
        
        # Callback para seleção de router
        def make_router_selection_callback(router_path, router_idx):
            def callback(event=None):
                print(f"DEBUG: [ADD_ROUTER] Router selecionado: {os.path.basename(router_path)}")
                self._selecionar_router_page(router_path, router_idx)
            return callback
        
        # Criar grid de routers em layout 2xn
        for i, router_path in enumerate(routers_page):
            row = i // n_col
            col = i % n_col
            
            # Frame para router + label
            router_frame = tk.Frame(self.matriz_frame, bg="black")
            router_frame.grid(row=row, column=col, padx=15, pady=8)
            
            # Carregar imagem do router
            try:
                # Verificar se é placeholder ou arquivo real
                if router_path.startswith("PLACEHOLDER_"):
                    # Criar imagem placeholder
                    placeholder_img = Image.new('RGB', (card_w, card_h), color='#4A4A4A')
                    router_img = ImageTk.PhotoImage(placeholder_img)
                    print(f"DEBUG: [ADD_ROUTER] Placeholder criado para {router_path}")
                else:
                    # Carregar imagem real
                    img = ImageTk.PhotoImage(Image.open(router_path).resize((card_w, card_h)))
                    router_img = img
                    print(f"DEBUG: [ADD_ROUTER] Imagem carregada: {os.path.basename(router_path)}")
            except Exception as e:
                print(f"DEBUG: [ADD_ROUTER] Erro ao carregar {router_path}: {e}")
                # Fallback: criar imagem simples
                placeholder_img = Image.new('RGB', (card_w, card_h), color='#666666')
                router_img = ImageTk.PhotoImage(placeholder_img)
            
            # Criar botão do router igual à Store_v2.py
            router_btn = tk.Button(router_frame, image=router_img, bg="black", cursor="hand2",
                                  borderwidth=3, relief="raised")
            router_btn.image = router_img  # Manter referência
            router_btn.pack()
            router_btn.bind("<Button-1>", make_router_selection_callback(router_path, i))
            
            # Label com nome do router por baixo
            filename = os.path.basename(router_path)
            router_id = filename.replace("Equipment_", "").replace(".png", "")
            
            router_name_lbl = tk.Label(router_frame, text=f"Router {router_id}", 
                                     font=("Helvetica", 12, "bold"), fg="white", bg="black")
            router_name_lbl.pack(pady=(5, 0))
            
            # Status label (disponível)
            status_lbl = tk.Label(router_frame, text="Available", 
                                font=("Helvetica", 10), fg="#00FF00", bg="black")
            status_lbl.pack()
            
            self.router_buttons.append(router_btn)
        
        # Botões de ação na parte inferior com BelowBar_store.png (como pedido)
        # Barra inferior com BelowBar_store.png
        try:
            belowbar_path = os.path.join(os.path.dirname(__file__), "img", "BelowBar_store.png")
            if os.path.exists(belowbar_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_path).resize((self.winfo_screenwidth(), 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print("DEBUG: [ADD_ROUTER] Footer com BelowBar_store.png criado")
            else:
                raise FileNotFoundError("BelowBar_store.png não encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar BelowBar_store.png: {e} - usando fallback")
            footer_frame = tk.Frame(self, bg="#4CAF50", height=50)
            footer_frame.pack(side="bottom", fill="x")
        
        # Botões de ação sobrepostos ao footer (igual Store_v2.py)
        buttons_frame = tk.Frame(self, bg="black")
        buttons_frame.place(relx=0.5, rely=0.95, anchor="center")
        
        # Apenas o botão Confirm (sem Cancel button como solicitado)
        self.confirm_button = tk.Button(buttons_frame, text="Confirm", 
                                       font=("Helvetica", 14, "bold"), fg="white", 
                                       bg="#555555", relief="flat", width=10, height=1,
                                       state="disabled", command=self._confirmar_router_selection_page)
        self.confirm_button.pack()
        
        print("DEBUG: [ADD_ROUTER] ✅ Página de seleção de router criada (padrão Store_v2.py)")
        
        # FORÇA ATUALIZAÇÃO FINAL DA INTERFACE
        self.update_idletasks()
        self.update()
        
        # VERIFICAÇÃO FINAL: Confirmar que a página foi criada E está visível
        def verificar_pagina_final():
            if hasattr(self, '_in_router_selection_page') and self._in_router_selection_page:
                widgets_count = len(self.winfo_children())
                print(f"DEBUG: [ADD_ROUTER] ✅ Página ativa com {widgets_count} widgets após verificação final")
                
                # FORÇAR REFRESH VISUAL ADICIONAL
                self.lift()  # Traz a janela para frente
                self.focus_force()  # Força foco
                self.update_idletasks()
                print("DEBUG: [ADD_ROUTER] ✅ Interface forçada para frente e atualizada")
            else:
                print("DEBUG: [ADD_ROUTER] ⚠️ Flag de página perdida após verificação final")
        
        # Verificação imediata + verificação com delay
        verificar_pagina_final()
        self.after(100, verificar_pagina_final)
        
        print("DEBUG: [ADD_ROUTER] ======= PÁGINA CRIADA COM SUCESSO =======")
    
    def _obter_equipments_da_store(self):
        """Obtém lista de equipamentos disponíveis na Store"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos disponíveis...")
        
        # Lista dos 3 routers sempre disponíveis para ADD ROUTER
        routers_add_router = ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]
        equipments_encontrados = []
        
        # DETECÇÃO INTELIGENTE DE CAMINHOS
        possivel_bases = []
        
        # Detectar se estamos no Raspberry Pi
        is_raspberry = os.path.exists("/home/joao_rebolo")
        print(f"DEBUG: [ADD_ROUTER] Ambiente Raspberry Pi detectado: {is_raspberry}")
        
        if is_raspberry:
            # Raspberry Pi - testar múltiplos locais possíveis
            possivel_bases = [
                "/home/joao_rebolo/netmaster_menu/img/cartas",  # Caminho correto mostrado pelo usuário
                "/home/joao_rebolo/netmaster_menu",
                "/home/joao_rebolo/NetMaster", 
                "/home/joao_rebolo/Desktop/NetMaster"
            ]
        else:
            # Desenvolvimento local
            possivel_bases = [
                os.getcwd(),  # Diretório atual
                os.path.dirname(__file__)  # Diretório do script
            ]
        
        print(f"DEBUG: [ADD_ROUTER] Bases a testar: {possivel_bases}")
        
        # Para cada base possível, testar se tem estrutura Equipments
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                print(f"DEBUG: [ADD_ROUTER] ❌ Base não existe: {base_path}")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] ✅ Testando base: {base_path}")
            
            # Verificar se tem diretório Equipments (teste múltiplas variações)
            # CORREÇÃO: Testar tanto "Equipments" quanto "equipments" para Raspberry Pi
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (minúscula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (maiúscula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [ADD_ROUTER] ✅ Encontrou Equipments: {equipments_base}")
                    break
                else:
                    print(f"DEBUG: [ADD_ROUTER] ❌ Sem Equipments: {variation}")
            
            if not equipments_base:
                print(f"DEBUG: [ADD_ROUTER] ❌ Nenhuma variação de Equipments encontrada")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] ✅ Encontrou Equipments: {equipments_base}")
            
            # Testar cada cor para encontrar os routers
            for cor in ["Red", "Blue", "Green", "Yellow"]:
                cor_dir = os.path.join(equipments_base, cor)
                if not os.path.exists(cor_dir):
                    print(f"DEBUG: [ADD_ROUTER] ❌ Cor {cor} não existe: {cor_dir}")
                    continue
                    
                print(f"DEBUG: [ADD_ROUTER] ✅ Testando cor {cor}: {cor_dir}")
                
                # Verificar se tem todos os 3 routers nesta cor
                routers_nesta_cor = []
                for router_filename in routers_add_router:
                    router_path = os.path.join(cor_dir, router_filename)
                    if os.path.exists(router_path):
                        routers_nesta_cor.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] ✅ Router encontrado: {router_path}")
                    else:
                        print(f"DEBUG: [ADD_ROUTER] ❌ Router missing: {router_path}")
                
                # Se encontramos todos os 3, usar esta cor
                if len(routers_nesta_cor) == 3:
                    equipments_encontrados = routers_nesta_cor
                    print(f"DEBUG: [ADD_ROUTER] 🎉 SUCESSO! Todos os 3 routers encontrados em {cor_dir}")
                    break
            
            # Se encontramos, parar de procurar outras bases
            if equipments_encontrados:
                break
        
        # FALLBACK: Se ainda não encontramos, criar placeholders visuais
        if not equipments_encontrados:
            print("DEBUG: [ADD_ROUTER] ⚠️ NENHUM ROUTER ENCONTRADO - Usando placeholders")
            
            # Usar imagens de placeholder ou criar caminhos virtuais
            placeholder_base = "/tmp" if is_raspberry else os.getcwd()
            for i, router_filename in enumerate(routers_add_router, 1):
                placeholder_path = f"PLACEHOLDER_ROUTER_{i}"
                equipments_encontrados.append(placeholder_path)
                print(f"DEBUG: [ADD_ROUTER] 📝 Placeholder criado: {placeholder_path}")
        
        print(f"DEBUG: [ADD_ROUTER] 🏁 RESULTADO FINAL:")
        print(f"DEBUG: [ADD_ROUTER]   Routers para ADD ROUTER: {len(equipments_encontrados)}")
        for i, router in enumerate(equipments_encontrados, 1):
            print(f"DEBUG: [ADD_ROUTER]   {i}. {router}")
        
        return equipments_encontrados
    
    def _obter_equipments_sincronizados(self):
        """Obtém lista de equipamentos disponíveis sincronizados com o inventário (igual à Store)"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos sincronizados com inventário...")
        
        # Primeiro obter todos os equipments disponíveis
        all_equipments = self._obter_equipments_da_store()
        
        # Filtrar apenas Equipment_1, Equipment_2, Equipment_3
        routers_base = []
        for equipment_path in all_equipments:
            filename = os.path.basename(equipment_path)
            if filename in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]:
                routers_base.append(equipment_path)
        
        print(f"DEBUG: [ADD_ROUTER] Routers base encontrados: {len(routers_base)}")
        
        # Aplicar sincronização com inventário (igual Store_v2.py)
        routers_sincronizados = routers_base.copy()  # Começar com todos
        
        if hasattr(self, 'inventario') and self.inventario:
            print(f"DEBUG: [ADD_ROUTER] Aplicando sincronização com inventário...")
            
            # Verificar equipments no inventário
            equipments_inventario = self.inventario.get("equipments", [])
            if equipments_inventario:
                print(f"DEBUG: [ADD_ROUTER] Equipments no inventário: {len(equipments_inventario)}")
                
                # Remover equipments que já estão no inventário
                routers_filtrados = []
                for router_path in routers_sincronizados:
                    router_filename = os.path.basename(router_path)
                    
                    # Verificar se este equipment está no inventário
                    equipment_no_inventario = False
                    for inv_path in equipments_inventario:
                        if os.path.basename(inv_path) == router_filename:
                            equipment_no_inventario = True
                            print(f"DEBUG: [ADD_ROUTER] Removendo {router_filename} (já no inventário)")
                            break
                    
                    # Se não está no inventário, manter disponível
                    if not equipment_no_inventario:
                        routers_filtrados.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] Mantendo {router_filename} (disponível)")
                
                routers_sincronizados = routers_filtrados
            else:
                print(f"DEBUG: [ADD_ROUTER] Nenhum equipment no inventário")
        else:
            print(f"DEBUG: [ADD_ROUTER] Sem inventário para sincronizar")
        
        print(f"DEBUG: [ADD_ROUTER] Resultado sincronização:")
        print(f"DEBUG: [ADD_ROUTER]   Routers disponíveis: {len(routers_sincronizados)}")
        for router in routers_sincronizados:
            print(f"DEBUG: [ADD_ROUTER]   - {os.path.basename(router)}")
        
        return routers_sincronizados
    
    def _selecionar_router_page(self, router_path, button_index):
        """Seleciona router na página e atualiza visual dos botões"""
        print(f"DEBUG: [ADD_ROUTER] Router selecionado: {router_path}")
        
        self.router_selection = router_path
        
        # Resetar todos os botões para cor normal
        for btn in self.router_buttons:
            btn.configure(bg="#4A4A4A", relief="raised", borderwidth=3)
        
        # Destacar botão selecionado em roxo
        if button_index < len(self.router_buttons):
            self.router_buttons[button_index].configure(bg="#8A2BE2", relief="sunken", borderwidth=4)
        
        # Ativar botão Confirm e deixar roxo
        self.confirm_button.configure(state="normal", bg="#8A2BE2", cursor="hand2")
    
    def _cancelar_router_selection(self):
        """Cancela seleção e volta ao PlayerDashboard"""
        print("DEBUG: [ADD_ROUTER] Cancelando seleção de router")
        
        # RESETAR FLAG DE PROTEÇÃO
        self._in_router_selection_page = False
        
        # Limpar seleção
        self.router_selection = None
        
        # Restaurar interface do PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _confirmar_router_selection_page(self):
        """Confirma seleção na página e adiciona router gratuito ao inventário do jogador"""
        if not self.router_selection:
            return
            
        print(f"DEBUG: [ADD_ROUTER] Confirmando seleção: {self.router_selection}")
        
        # RESETAR FLAG DE PROTEÇÃO
        self._in_router_selection_page = False
        
        # Preparar caminho do router para adicionar ao inventário
        router_para_inventario = self.router_selection
        
        # Se é placeholder, criar um caminho de equipamento válido baseado no ID
        if router_para_inventario.startswith("PLACEHOLDER_"):
            # Extrair ID do placeholder (ex: PLACEHOLDER_ROUTER_1 -> Equipment_1.png)
            placeholder_id = router_para_inventario.split("_")[-1]  # Pega último número
            router_filename = f"Equipment_{placeholder_id}.png"
            
            # Criar caminho final baseado na cor do jogador
            base_equipments = detect_player_inventory_base_dir()
            color_mapping = {
                "red": "Red",
                "blue": "Blue", 
                "green": "Green",
                "yellow": "Yellow"
            }
            player_color_title = color_mapping.get(self.player_color.lower(), "Red")
            
            router_para_inventario = os.path.join(
                base_equipments, 
                "Equipments", 
                "Residential-level", 
                player_color_title, 
                router_filename
            )
            
            print(f"DEBUG: [ADD_ROUTER] Placeholder convertido para: {router_para_inventario}")
        
        # Adicionar router ao inventário do jogador
        if "equipments" not in self.inventario:
            self.inventario["equipments"] = []
            
        self.inventario["equipments"].append(router_para_inventario)
        print(f"DEBUG: [ADD_ROUTER] ✅ Router adicionado gratuitamente ao inventário!")
        print(f"DEBUG: [ADD_ROUTER] Inventário equipments agora tem: {len(self.inventario['equipments'])} itens")
        
        # Voltar ao PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _voltar_playerdashboard_apos_router_selection(self):
        """Volta ao PlayerDashboard após seleção/cancelamento de router"""
        print("DEBUG: [ADD_ROUTER] Voltando ao PlayerDashboard")
        
        # RESETAR FLAG DE PROTEÇÃO (garantia adicional)
        self._in_router_selection_page = False
        
        # Limpar a página atual
        for widget in self.winfo_children():
            widget.destroy()
        
        # Restaurar o PlayerDashboard completo
        # Preservar estado atual
        current_saldo = getattr(self, 'saldo', 1000)
        current_color = getattr(self, 'player_color', 'red')
        current_others = getattr(self, 'other_players', ['green', 'blue', 'yellow'])
        current_name = getattr(self, 'player_name', 'Player')
        current_card_idx = getattr(self, 'selected_card_idx', 0)
        
        # Recriar interface do PlayerDashboard
        self.playerdashboard_interface(
            current_name, 
            current_saldo, 
            current_others,
            show_store_button=True
        )


    def show_inventory_matrix(self, tipos, page=0, back_callback=None):
        # PROTEÇÃO CONTRA LOOP: Marcar que estamos a abrir inventário
        self._inventory_opening = True
        
        # CORREÇÃO CRÍTICA: Salvar estado da interface ANTES de destruir widgets
        print("DEBUG: [show_inventory_matrix] *** SALVANDO ESTADO ANTES DE LIMPAR WIDGETS ***")
        self._save_dashboard_state()
        
        print(f"DEBUG: [show_inventory_matrix] *** FUNÇÃO CHAMADA ***")
        print(f"DEBUG: [show_inventory_matrix] Tipos solicitados: {tipos}")
        print(f"DEBUG: [show_inventory_matrix] Page solicitada: {page}")
        print(f"DEBUG: [show_inventory_matrix] Estado COMPLETO do inventário:")
        total_cartas = 0
        for tipo, cartas_list in self.inventario.items():
            print(f"DEBUG: [show_inventory_matrix]   {tipo}: {len(cartas_list)} cartas")
            total_cartas += len(cartas_list)
            if cartas_list:
                for i, carta in enumerate(cartas_list[:5]):  # Mostrar primeiras 5 para debug
                    print(f"DEBUG: [show_inventory_matrix]     {i+1}. {os.path.basename(carta)}")
        print(f"DEBUG: [show_inventory_matrix] Total de cartas no inventário: {total_cartas}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se não existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [show_inventory_matrix] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [show_inventory_matrix] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [show_inventory_matrix] Arquivo TopBar não encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [show_inventory_matrix] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [show_inventory_matrix] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [show_inventory_matrix] TopBar fallback criada após erro!")
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        # Título
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        elif set(tipos) == set(["actions", "events"]):
            title_str = "Actions / Events"
        elif set(tipos) == set(["activities", "challenges"]):
            title_str = "Activities / Challenges"
        else:
            # Para outros casos, mostrar os tipos separados por /
            title_str = " / ".join([t.capitalize() for t in tipos])
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        # Verificar se é Actions/Events ou Activities/Challenges para organização especial em colunas
        if set(tipos) == set(["actions", "events"]):
            # Organização especial: Actions na coluna esquerda, Events na coluna direita
            # CORREÇÃO: Mostrar TODAS as cartas do inventário, não apenas as filtradas
            # Cartas inválidas (que não passam no filtro) aparecem viradas para baixo
            cartas_actions_raw = self.inventario.get("actions", [])
            cartas_events_raw = self.inventario.get("events", [])
            
            # NOVA ABORDAGEM: Não filtrar - mostrar todas as cartas, mas marcar quais são válidas
            cartas_actions_filtered = self._filter_action_event_cards(cartas_actions_raw, "actions")
            cartas_events_filtered = self._filter_action_event_cards(cartas_events_raw, "events")
            
            # Criar listas de status (True = válida/virada para cima, False = inválida/virada para baixo)
            actions_status = [carta in cartas_actions_filtered for carta in cartas_actions_raw]
            events_status = [carta in cartas_events_filtered for carta in cartas_events_raw]
            
            print(f"DEBUG: [show_inventory_matrix] Cartas Actions (total no inventário): {len(cartas_actions_raw)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Actions (válidas): {len(cartas_actions_filtered)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Events (total no inventário): {len(cartas_events_raw)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Events (válidas): {len(cartas_events_filtered)}")
            
            # Usar todas as cartas do inventário para paginação, não apenas as filtradas
            cartas_actions = cartas_actions_raw
            cartas_events = cartas_events_raw
            
            # Calcular total de cartas para paginação (2 linhas, 1 carta de cada tipo por linha)
            max_cards = max(len(cartas_actions), len(cartas_events))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            # Para cada página, decidir quais cartas mostrar:
            # - Página 0: primeira carta de cada tipo (virada para cima) + segunda carta (virada para baixo)
            # - Página 1: terceira carta (virada para baixo) + quarta carta (virada para baixo), etc.
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid para manter estrutura 2x2
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Actions
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Events
            
            # Colocar Actions na coluna da esquerda (col=0)
            actions_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_actions))):
                actions_to_show.append((i, cartas_actions[i], actions_status[i]))
            
            # Determinar posições das cartas Actions baseado no número de cartas a mostrar
            actions_row_counter = 0
            for original_idx, carta_path, is_valid in actions_to_show:
                try:
                    # Lógica para decidir se carta fica virada para cima ou para baixo:
                    # 1. Primeira carta válida (original_idx == 0 E is_valid == True) sempre virada para cima
                    #    EXCETO se uma Action foi removida recentemente (_action_recently_removed == True)
                    # 2. Outras cartas válidas (is_valid == True) viradas para baixo mas clicáveis
                    # 3. Cartas inválidas (is_valid == False) viradas para baixo e marcadas como inválidas
                    
                    # Verificar se carta deveria ficar virada para baixo mesmo sendo primeira
                    carta_deve_ficar_virada_baixo = (original_idx == 0 and 
                                                   getattr(self, '_action_recently_removed', False))
                    
                    if original_idx == 0 and is_valid and not carta_deve_ficar_virada_baixo:
                        # Primeira carta válida: virada para cima, clicável (comportamento normal)
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Usar função auxiliar para corrigir closure problem
                        def make_click_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_click_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Action do topo (virada para cima): {os.path.basename(carta_path)}")
                    elif carta_deve_ficar_virada_baixo and is_valid:
                        # Primeira carta mas removeu Action recentemente: virada para baixo até próximo turno
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Ainda permitir clique para ver a carta
                        def make_facedown_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_facedown_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Action do topo (virada para BAIXO após remoção): {os.path.basename(carta_path)}")
                    elif is_valid:
                        # Cartas válidas restantes: viradas para baixo, mas clicáveis para visualização
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Usar função auxiliar para corrigir closure problem (visualização apenas)
                        def make_view_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_view_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Action válida virada para baixo (posição {original_idx}): {os.path.basename(carta_path)}")
                    else:
                        # Cartas inválidas: viradas para baixo, ainda clicáveis mas marcadas como inválidas
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Ainda permitir visualização de cartas inválidas
                        def make_invalid_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_invalid_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Action INVÁLIDA virada para baixo (posição {original_idx}): {os.path.basename(carta_path)} - target não corresponde")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=actions_row_counter, column=0, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Action colocada na linha {actions_row_counter}, coluna 0")
                    actions_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Action: {e}")
                    continue
            
            # Colocar Events na coluna da direita (col=1)
            events_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_events))):
                events_to_show.append((i, cartas_events[i], events_status[i]))
            
            # Determinar posições das cartas Events baseado no número de cartas a mostrar
            events_row_counter = 0
            for original_idx, carta_path, is_valid in events_to_show:
                try:
                    # Lógica igual às Actions: primeira carta válida virada para cima, resto virado para baixo
                    if original_idx == 0 and is_valid:
                        # Primeira carta válida: virada para cima, clicável
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Usar função auxiliar para corrigir closure problem
                        def make_click_handler_events(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_click_handler_events(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Event do topo (virada para cima): {os.path.basename(carta_path)}")
                    elif is_valid:
                        # Cartas válidas restantes: viradas para baixo, mas clicáveis para visualização
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Usar função auxiliar para corrigir closure problem (visualização apenas)
                        def make_view_handler_events(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_view_handler_events(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Event válido virado para baixo (posição {original_idx}): {os.path.basename(carta_path)}")
                    else:
                        # Cartas inválidas: viradas para baixo, ainda clicáveis mas marcadas como inválidas
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        # Ainda permitir visualização de cartas inválidas
                        def make_invalid_handler_events(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_invalid_handler_events(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Event INVÁLIDO virado para baixo (posição {original_idx}): {os.path.basename(carta_path)} - target não corresponde")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=events_row_counter, column=1, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Event colocado na linha {events_row_counter}, coluna 1")
                    events_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Event: {e}")
                    continue
        elif set(tipos) == set(["activities", "challenges"]):
            # Organização especial: Activities na coluna esquerda, Challenges na coluna direita
            # Estrutura igual ao Actions/Events
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            
            print(f"DEBUG: [show_inventory_matrix] Cartas Activities: {len(cartas_activities)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Challenges: {len(cartas_challenges)}")
            
            # DEBUG: Verificar se as cartas estão nos inventários corretos
            print("DEBUG: [show_inventory_matrix] === VERIFICAÇÃO DE INVENTÁRIOS ===")
            for i, carta in enumerate(cartas_activities[:3]):  # Mostrar primeiras 3 Activities
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Activities[{i}]: {basename}")
                # Verificar se realmente é uma Activity
                if "activity" not in basename.lower() and "activities" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} NÃO parece ser uma Activity! ***")
            
            for i, carta in enumerate(cartas_challenges[:3]):  # Mostrar primeiras 3 Challenges
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Challenges[{i}]: {basename}")
                # Verificar se realmente é uma Challenge
                if "challenge" not in basename.lower() and "challenges" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} NÃO parece ser uma Challenge! ***")
            print("DEBUG: [show_inventory_matrix] === FIM VERIFICAÇÃO ===")
            
            # Calcular total de cartas para paginação (2 linhas, 1 carta de cada tipo por linha)
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid para manter estrutura 2x2
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna da esquerda (col=0)
            activities_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                activities_to_show.append((i, cartas_activities[i]))
            
            # Determinar posições das cartas Activities baseado no número de cartas a mostrar
            activities_row_counter = 0
            for original_idx, carta_path in activities_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar função auxiliar para corrigir closure problem
                    def make_click_handler_activities(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_activities(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Activity COLUNA ESQUERDA (col=0): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row_counter, column=0, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Activity colocada na linha {activities_row_counter}, coluna 0 (ESQUERDA)")
                    activities_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Activity: {e}")
                    continue
            
            # Colocar Challenges na coluna da direita (col=1)
            challenges_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                challenges_to_show.append((i, cartas_challenges[i]))
            
            # Determinar posições das cartas Challenges baseado no número de cartas a mostrar
            challenges_row_counter = 0
            for original_idx, carta_path in challenges_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar função auxiliar para corrigir closure problem
                    def make_click_handler_challenges(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_challenges(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Challenge COLUNA DIREITA (col=1): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row_counter, column=1, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Challenge colocado na linha {challenges_row_counter}, coluna 1 (DIREITA)")
                    challenges_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Challenge: {e}")
                    continue
        else:
            # Organização normal para outros tipos
            cartas = []
            for t in tipos:
                cartas_tipo = self.inventario.get(t, [])
                print(f"DEBUG: [show_inventory_matrix] Cartas de {t}: {len(cartas_tipo)}")
                cartas += cartas_tipo
            
            print(f"DEBUG: [show_inventory_matrix] Total de cartas a mostrar: {len(cartas)}")
            # Paginação igual ao Activities/Challenges
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Igual ao Activities/Challenges
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    # Determinar o tipo da carta para verificar se está ativa
                    carta_tipo = None
                    if len(tipos) == 1:
                        carta_tipo = tipos[0]
                    else:
                        # Se são múltiplos tipos, tentar determinar pelo caminho da carta
                        path_lower = carta_path.lower()
                        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
                            carta_tipo = "users"
                        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
                            carta_tipo = "equipments"
                        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
                            carta_tipo = "services"
                    
                    # Verificar se a carta está ativa para Users/Equipments/Services
                    # CORREÇÃO: Sempre verificar estado ativo, independentemente de Next Phase
                    # As cartas que foram ativadas em turnos anteriores devem aparecer viradas para cima
                    is_active = False
                    if carta_tipo in ["users", "equipments", "services"]:
                        is_active = self.is_card_active(carta_path, carta_tipo)
                    
                    # Escolher imagem baseada no estado da carta
                    if carta_tipo in ["users", "equipments", "services"]:
                        # Verificar se é User_1.png - sempre virada para cima
                        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                        
                        if is_user_1:
                            # User_1.png sempre virada para cima
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] User_1.png SEMPRE virada para cima: {os.path.basename(carta_path)}")
                        elif is_active:
                            # Carta ativa: mostrar virada para cima (independentemente de Next Phase)
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} ATIVA (virada para cima): {os.path.basename(carta_path)}")
                        else:
                            # Carta inativa: mostrar virada para baixo usando imagem específica da cor do jogador
                            back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                            img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} INATIVA (virada para baixo com cor {self.player_color}): {os.path.basename(carta_path)}")
                    else:
                        # Para outros tipos (activities, etc), mostrar normalmente
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} normal: {os.path.basename(carta_path)}")
                        
                except Exception:
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_inventory(p, t, pg))
        # Setas de navegação à direita
        if total_pages > 1:
            seta_x = 0.90
            if page > 0:
                seta_cima = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page-1, back_callback))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page+1, back_callback))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((self.screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Botão Back centrado na parte inferior - criado após a barra para ficar por cima
        # NOVA FUNCIONALIDADE: Desabilitar botão Back durante ROUTER UPGRADE, ROUTER DOWNGRADE ou LINK UPGRADE
        is_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
        is_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
        is_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
        
        if back_callback:
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_callback)
        else:
            def back_to_dashboard():
                # PROTEÇÃO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
                self._inventory_opening = False
                # CORREÇÃO CRÍTICA: Restaurar estado ANTES de recriar interface
                # Isto garante que o estado é preservado corretamente
                saved_state = getattr(self, '_saved_dashboard_state', None)
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                # Restaurar estado imediatamente após recriar interface
                if saved_state:
                    self._saved_dashboard_state = saved_state
                    self._restore_dashboard_state()
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard)
        
        # Desabilitar botão se estivermos em contexto ROUTER UPGRADE, ROUTER DOWNGRADE, LINK UPGRADE ou LINK DOWNGRADE
        if is_router_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_UPGRADE] Botão Back DESABILITADO durante contexto ROUTER UPGRADE")
        elif is_router_downgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Botão Back DESABILITADO durante contexto ROUTER DOWNGRADE")
        elif is_link_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_UPGRADE] Botão Back DESABILITADO durante contexto LINK UPGRADE")
        elif getattr(self, '_in_link_downgrade_context', False):
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_DOWNGRADE] Botão Back DESABILITADO durante contexto LINK DOWNGRADE")
        else:
            back_btn.config(state='normal')
            print(f"DEBUG: [INVENTORY] Botão Back HABILITADO (não em contexto ROUTER/LINK)")
            
        back_btn.place(relx=0.5, rely=0.98, anchor="s")
        
        # Salvar referência do botão Back para poder reabilitar posteriormente
        self._back_button = back_btn

        # Saldo no canto inferior direito - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))

    def show_card_fullscreen_inventory(self, carta_path, tipos, page=0):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Botão X para fechar
        def voltar_inventario():
            # Se for inventário de Activities/Challenges, volta para show_inventory_matrix_carrossel
            if set(tipos) == set(["activities", "challenges"]):
                self.show_inventory_matrix_carrossel(tipos, page)
            else:
                self.show_inventory_matrix(tipos, page)
        # Botão X para fechar - movido para canto superior esquerdo
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Se for Users, Equipments, Services, Activities ou Challenges, mostrar botão de venda APENAS se estiver numa casa do tipo correspondente
        # Para Activities/Challenges: podem ser vendidas quando estás numa casa Activities
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # Determinar o tipo da carta atual PRIMEIRO
        carta_tipo = None
        if len(tipos) == 1:
            carta_tipo = tipos[0]
        elif set(tipos) == set(["activities", "challenges"]):
            # Se é uma página Activities/Challenges, determinar tipo pela carta específica
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo = "challenges"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "activities" in carta_dirname:
                    carta_tipo = "activities"
                elif "challenges" in carta_dirname:
                    carta_tipo = "challenges"
        elif set(tipos) == set(["actions", "events"]):
            # Se é uma página Actions/Events, determinar tipo pela carta específica
            carta_basename = os.path.basename(carta_path).lower()
            if "action" in carta_basename or "actions" in carta_basename:
                carta_tipo = "actions"
            elif "event" in carta_basename or "events" in carta_basename:
                carta_tipo = "events"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "actions" in carta_dirname:
                    carta_tipo = "actions"
                elif "events" in carta_dirname:
                    carta_tipo = "events"
        
        print(f"DEBUG: [FULLSCREEN] Carta tipo determinado: '{carta_tipo}' para carta: {os.path.basename(carta_path)} com tipos: {tipos}")
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do inventário - Next Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se Final Phase estiver ativo, NÃO pode vender nenhuma carta
        elif getattr(self, '_final_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do inventário - Final Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se está numa casa START, NÃO pode vender nenhuma carta
        elif casa_atual_tipo == "start":
            print(f"DEBUG: NÃO pode vender carta do inventário - está numa casa START (nenhuma venda permitida)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            print(f"DEBUG: Verificando possibilidade de venda no inventário - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # CORREÇÃO: Verificar se pode vender considerando casas de outros jogadores
            current_other_player_house = getattr(self, 'current_other_player_house', False)
            print(f"DEBUG: current_other_player_house = {current_other_player_house}")
            
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo OU numa casa de outro jogador do mesmo tipo
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                # Incluindo casas de outros jogadores
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
        
        # NOVA FUNCIONALIDADE: Botão verde ✓ para equipment no contexto REMOVE ROUTER
        # PRIORIDADE MÁXIMA: Este botão deve aparecer ANTES de qualquer outro
        # Condições: estamos no contexto REMOVE ROUTER, carta é equipment
        if (carta_tipo == "equipments" and 
            getattr(self, '_in_remove_router_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto REMOVE ROUTER detectado: {os.path.basename(carta_path)}")
            
            def processar_remove_router():
                """Remove o router selecionado e volta à interface principal"""
                print(f"DEBUG: [REMOVE_ROUTER_GO] Processando remoção do router: {os.path.basename(carta_path)}")
                
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Router removido do inventário")
                    
                    # Devolver carta ao baralho da Store (se há referência)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Router devolvido ao baralho da Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Erro ao devolver router à Store: {e}")
                    
                    # Limpar flag do contexto REMOVE ROUTER
                    self._in_remove_router_context = False
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Flag de contexto REMOVE ROUTER limpa")
                    
                    # Voltar à interface principal
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Voltando à interface principal")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_GO] ERRO: Router não encontrado no inventário")
            
            # Botão verde ✓ no canto superior direito para processar remoção
            btn_remove_router = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#4CAF50", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                command=processar_remove_router, 
                cursor="hand2", 
                activebackground="#43d17a"
            )
            btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
            print(f"DEBUG: [FULLSCREEN] Botão ✓ verde configurado para remoção do router")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto ROUTER UPGRADE
        # PRIORIDADE: Este botão deve aparecer ANTES de qualquer outro (exceto REMOVE ROUTER)
        # Condições: estamos no contexto ROUTER UPGRADE, carta é equipment do tipo Small Router correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Small Router correto para o router_id da Action
            router_upgrade_target_id = getattr(self, '_router_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Router upgrade target ID: {router_upgrade_target_id}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # MODIFICAÇÃO: Para ROUTER UPGRADE, verificar se é o router correto E está ativo (virado para cima)
            # Conforme solicitado pelo usuário: "O botão certo vermelho só aparece na carta virada para cima"
            is_target_router = (equipment_id == router_upgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] NOVA REGRA: Router upgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # CORREÇÃO SOLICITADA: Apenas mostrar botão se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_UPGRADE] Small Router correto E ATIVO encontrado para upgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar upgrade
                btn_router_upgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para upgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router não é o target correto - não mostrando botão")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router correto mas INATIVO (virado para baixo) - não mostrando botão conforme solicitado")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto ROUTER DOWNGRADE
        # Condições: estamos no contexto ROUTER DOWNGRADE, carta é equipment do tipo Medium Router correspondente e ATIVO
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Medium Router correto para o router_id da Action
            router_downgrade_target_id = getattr(self, '_router_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade target ID: {router_downgrade_target_id}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Verificar se é o router correto E está ativo (virado para cima)
            is_target_router = (equipment_id == router_downgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # Apenas mostrar botão se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_DOWNGRADE] Medium Router correto E ATIVO encontrado para downgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar downgrade
                btn_router_downgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_downgrade_confirmation(router_downgrade_target_id), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para downgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router não é o target correto - não mostrando botão")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router correto mas INATIVO (virado para baixo) - não mostrando botão")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto LINK UPGRADE
        # Condições: estamos no contexto LINK UPGRADE, carta é equipment do tipo Long Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Long Link correto para o router_id da Action
            link_upgrade_target_id = getattr(self, '_link_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Link upgrade target ID: {link_upgrade_target_id}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK UPGRADE, verificar se é o link correto (Long Link)
            is_target_link = (equipment_id == link_upgrade_target_id)
            
            # Mapear equipment_id para nomes de Long Links
            long_link_mapping = {
                1: "Equipment_10.png",  # Long Link 1
                2: "Equipment_11.png",  # Long Link 2
                3: "Equipment_12.png",  # Long Link 3
            }
            
            expected_long_link = long_link_mapping.get(link_upgrade_target_id)
            is_long_link = (os.path.basename(carta_path) == expected_long_link) if expected_long_link else False
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Expected long link: {expected_long_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is long link: {is_long_link}")
            
            # Apenas mostrar botão se link correto
            if is_target_link and is_long_link:
                print(f"DEBUG: [LINK_UPGRADE] Long Link correto encontrado para upgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar upgrade
                btn_link_upgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para upgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_UPGRADE] Link não é o target correto - não mostrando botão")
                elif not is_long_link:
                    print(f"DEBUG: [LINK_UPGRADE] Equipment não é Long Link - não mostrando botão")
                else:
                    print(f"DEBUG: [LINK_UPGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto LINK DOWNGRADE
        # Condições: estamos no contexto LINK DOWNGRADE, carta é equipment do tipo Short Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Short Link correto para o router_id da Action
            link_downgrade_target_id = getattr(self, '_link_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Link downgrade target ID: {link_downgrade_target_id}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK DOWNGRADE, verificar se é o link correto (Short Link)
            is_target_link = (equipment_id == link_downgrade_target_id)
            
            # Mapear equipment_id para nomes de Short Links
            short_link_mapping = {
                1: "Equipment_7.png",   # Short Link 1
                2: "Equipment_8.png",   # Short Link 2
                3: "Equipment_9.png",   # Short Link 3
            }
            
            expected_short_link = short_link_mapping.get(link_downgrade_target_id)
            is_short_link = (os.path.basename(carta_path) == expected_short_link) if expected_short_link else False
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Expected short link: {expected_short_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is short link: {is_short_link}")
            
            # Apenas mostrar botão se link correto
            if is_target_link and is_short_link:
                print(f"DEBUG: [LINK_DOWNGRADE] Short Link correto encontrado para downgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar downgrade
                btn_link_downgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_downgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para downgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Link não é o target correto - não mostrando botão")
                elif not is_short_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Equipment não é Short Link - não mostrando botão")
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE] Condições não atendidas - não mostrando botão")
        
        # Botão de venda com checkmark no canto superior direito (substitui o botão verde picoin)
        # APENAS se NÃO for uma carta Activities/Challenges, porque essas têm layout especial
        # IMPORTANTE: User_1.png nunca pode ser vendida
        # IMPORTANTE: Cartas ATIVAS (Users/Equipments/Services viradas para cima) nunca podem ser vendidas
        # IMPORTANTE: NÃO mostrar se já estamos no contexto REMOVE ROUTER
        elif (carta_tipo not in ["activities", "challenges"] and 
              not getattr(self, '_in_remove_router_context', False)):
            
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # NOVA VERIFICAÇÃO: Cartas ativas não podem ser vendidas
            is_carta_ativa = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_carta_ativa = self.is_card_active(carta_path, carta_tipo)
            
            if pode_vender and not is_user_1 and not is_carta_ativa:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo}")
                def abrir_confirm():
                    # Guardar informações para navegação correta
                    self._origem_venda = "inventario"
                    self._tipos_venda = None
                    self._page_venda = 0
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Botão com checkmark (✓) no canto superior direito
                btn_sell = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
                btn_sell.place(relx=0.98, rely=0, anchor="ne")
            elif is_user_1:
                print(f"DEBUG: User_1.png NÃO pode ser vendida")
            elif is_carta_ativa:
                print(f"DEBUG: Carta {carta_tipo} ATIVA (virada para cima) NÃO pode ser vendida - apenas cartas inativas podem ser vendidas")
            elif not pode_vender:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: activities (para Activities/Challenges) ou {carta_tipo} (para outros tipos)")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para remover Actions ativas após Next Phase
        # Condições: Next Phase ativo, antes de Final Phase, carta Action ativa, página Actions/Events
        # CORREÇÃO PROBLEMA 1: Verificar se a carta não está virada para baixo
        print(f"DEBUG: [FULLSCREEN] Verificando condições para botão vermelho ✓:")
        print(f"DEBUG: [FULLSCREEN]   carta_tipo: '{carta_tipo}'")
        print(f"DEBUG: [FULLSCREEN]   tipos: {tipos}")
        print(f"DEBUG: [FULLSCREEN]   set(tipos) == set(['actions', 'events']): {set(tipos) == set(['actions', 'events'])}")
        print(f"DEBUG: [FULLSCREEN]   _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # CORREÇÃO PROBLEMA 1: Verificar se a carta está virada para baixo
        carta_basename = os.path.basename(carta_path).lower()
        is_carta_virada_para_baixo = carta_basename.startswith("back_card_")
        
        # CORREÇÃO CRÍTICA: Para cartas Actions, verificar também a lógica do sistema
        if carta_tipo == "actions" and not is_carta_virada_para_baixo:
            # Verificar se é a primeira carta Action e se uma Action foi removida recentemente
            cartas_actions = self.inventario.get("actions", [])
            if cartas_actions and carta_path == cartas_actions[0] and getattr(self, '_action_recently_removed', False):
                is_carta_virada_para_baixo = True
                print(f"DEBUG: [FULLSCREEN] Carta Action detectada como virada para baixo pela lógica do sistema (Action removida recentemente)")
        
        print(f"DEBUG: [FULLSCREEN]   is_carta_virada_para_baixo: {is_carta_virada_para_baixo}")
        
        # CORREÇÃO PROBLEMA 1: Durante gestão de pacotes, permitir botão vermelho
        # A gestão de pacotes acontece quando _final_phase_gestao_ativa é True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        print(f"DEBUG: [FULLSCREEN]   gestao_pacotes_ativa: {gestao_pacotes_ativa}")
        print(f"DEBUG: [FULLSCREEN]   final_phase_normal: {final_phase_normal}")
        
        # CORREÇÃO PROBLEMA 1: Durante gestão de pacotes, permitir botão vermelho
        # A gestão de pacotes acontece quando _final_phase_gestao_ativa é True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        if (carta_tipo == "actions" and 
            set(tipos) == set(["actions", "events"]) and
            getattr(self, '_next_phase_active', False) and 
            not final_phase_normal and  # CORREÇÃO: Permite durante gestão de pacotes
            not is_carta_virada_para_baixo):  # CORREÇÃO: NÃO mostrar botão se carta está virada para baixo
            
            # Verificar se a carta Action está ativa (primeira carta Action no inventário)
            cartas_actions = self.inventario.get("actions", [])
            is_action_ativa = (cartas_actions and carta_path == cartas_actions[0])
            
            if is_action_ativa:
                print(f"DEBUG: [FULLSCREEN] Action ativa detectada após Next Phase: {os.path.basename(carta_path)}")
                
                def mostrar_action_info_overlay():
                    """Mostra overlay com informações da carta Action usando estilo similar ao overlay de Event"""
                    import re
                    import os
                    
                    print(f"DEBUG: [ACTION_INFO] Mostrando informações da Action: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Action da base de dados
                    action_title = "Action Information"
                    action_description = "Description not available"
                    action_target_router = "N/A"
                    action_effect = "Effect description not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Action_43" -> "action_43")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Action_(\d+)', filename)
                            
                            if match:
                                action_id = f"action_{match.group(1)}"
                                action_card = self.card_database.get_action(action_id)
                                
                                if action_card:
                                    action_title = action_card.title
                                    action_description = action_card.description
                                    action_effect = action_card.effect_description
                                    # Determinar o target baseado no router_id e tipo de ação
                                    if action_card.router_id:
                                        action_target_router = str(action_card.router_id)
                                    elif ActionType and action_card.action_type in [ActionType.ADD_ROUTER, ActionType.REMOVE_ROUTER]:
                                        # Para ADD/REMOVE ROUTER, mostrar texto específico
                                        action_target_router = "New Router" if action_card.action_type == ActionType.ADD_ROUTER else "Last router added"
                                    elif action_card.title in ["ADD ROUTER", "REMOVE ROUTER"]:
                                        # Fallback usando o título quando ActionType não está disponível
                                        action_target_router = "New Router" if action_card.title == "ADD ROUTER" else "Last router added"
                                    else:
                                        action_target_router = "N/A"
                                    
                                    print(f"DEBUG: [ACTION_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [ACTION_INFO]   Title: {action_title}")
                                    print(f"DEBUG: [ACTION_INFO]   Description: {action_description}")
                                    print(f"DEBUG: [ACTION_INFO]   Router ID: {action_target_router}")
                                    print(f"DEBUG: [ACTION_INFO]   Action Type: {action_card.action_type}")
                                    print(f"DEBUG: [ACTION_INFO]   Effect: {action_effect}")
                                else:
                                    print(f"DEBUG: [ACTION_INFO] Action não encontrada na base de dados: {action_id}")
                            else:
                                print(f"DEBUG: [ACTION_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [ACTION_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de Event)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o máximo possível da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter referência
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # Título (valor do campo title da carta Action)
                    print(f"DEBUG: [ACTION_INFO] Criando título com texto: {repr(action_title)}")
                    title_label = tk.Label(info_frame, text=action_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descrição da Action (texto branco)
                    print(f"DEBUG: [ACTION_INFO] Criando descrição com texto: {repr(action_description)}")
                    desc_label = tk.Label(info_frame, text=action_description, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target: Mostrar informação apropriada dependendo do tipo de Action
                    print(f"DEBUG: [ACTION_INFO] Criando target com router ID: {repr(action_target_router)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    # Determinar texto do target baseado no tipo de router_id
                    if action_target_router in ["New Router", "Any Router", "Last router added"]:
                        target_text = action_target_router
                    else:
                        target_text = f"Residential Router {action_target_router}"
                    
                    target_label_value = tk.Label(target_frame, text=target_text, 
                                                font=("Helvetica", 13, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Effect description (texto roxo)
                    print(f"DEBUG: [ACTION_INFO] Criando efeito com texto: {repr(action_effect)}")
                    effect_label = tk.Label(info_frame, text=action_effect, 
                                         font=("Helvetica", 12, "bold"), fg="#9966CC", bg="black",
                                         wraplength=600, justify="center")
                    effect_label.pack(pady=(0, 30))
                    
                    # Frame para o botão
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def remover_action_do_inventario():
                        """Remove a carta Action do inventário e aplica seus efeitos (ROUTER UPGRADE/DOWNGRADE)"""
                        print(f"DEBUG: [REMOVE_ACTION] Removendo Action do inventário: {os.path.basename(carta_path)}")
                        
                        # NOVA FUNCIONALIDADE: Aplicar efeitos da carta Action antes de removê-la
                        try:
                            if self.card_database:
                                # Extrair ID da carta Action
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Action_(\d+)', filename)
                                
                                if match:
                                    action_id = f"action_{match.group(1)}"
                                    action_card = self.card_database.get_action(action_id)
                                    
                                    if action_card:
                                        print(f"DEBUG: [ACTION_EFFECT] Aplicando efeito da Action {action_card.title}")
                                        print(f"DEBUG: [ACTION_EFFECT] Action Type: {action_card.action_type}")
                                        print(f"DEBUG: [ACTION_EFFECT] Router ID: {action_card.router_id}")
                                        
                                        # Aplicar efeitos específicos baseados no tipo de Action
                                        if ActionType and action_card.action_type == ActionType.ROUTER_UPGRADE:
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ROUTER_DOWNGRADE:
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_UPGRADE:
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_DOWNGRADE:
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ADD_ROUTER:
                                            self._aplicar_add_router()
                                        elif ActionType and action_card.action_type == ActionType.REMOVE_ROUTER:
                                            self._aplicar_remove_router()
                                        elif action_card.title == "ROUTER UPGRADE":  # Fallback usando título
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif action_card.title == "ROUTER DOWNGRADE":  # Fallback usando título
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif action_card.title == "LINK UPGRADE":  # Fallback usando título
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif action_card.title == "LINK DOWNGRADE":  # Fallback usando título
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif action_card.title == "ADD ROUTER":  # Fallback usando título
                                            self._aplicar_add_router()
                                        elif action_card.title == "REMOVE ROUTER":  # Fallback usando título
                                            self._aplicar_remove_router()
                                        else:
                                            print(f"DEBUG: [ACTION_EFFECT] Action tipo {action_card.action_type} não implementado ainda")
                                    else:
                                        print(f"DEBUG: [ACTION_EFFECT] Action não encontrada na base de dados: {action_id}")
                                else:
                                    print(f"DEBUG: [ACTION_EFFECT] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [ACTION_EFFECT] Erro ao aplicar efeito da Action: {e}")
                        
                        # Remover carta do inventário
                        if "actions" in self.inventario and carta_path in self.inventario["actions"]:
                            self.inventario["actions"].remove(carta_path)
                            print(f"DEBUG: [REMOVE_ACTION] Carta removida do inventário do jogador")
                            
                            # Marcar que uma Action foi removida para a próxima carta ficar virada para baixo
                            self._action_recently_removed = True
                            print(f"DEBUG: [REMOVE_ACTION] Flag _action_recently_removed definida para True")
                            
                            # Devolver carta ao baralho da Store (se há referência)
                            if hasattr(self, 'store_window') and self.store_window:
                                try:
                                    self.store_window.adicionar_carta_ao_baralho(carta_path, "actions", "neutral")
                                    print(f"DEBUG: [REMOVE_ACTION] Carta devolvida ao baralho da Store")
                                except Exception as e:
                                    print(f"DEBUG: [REMOVE_ACTION] Erro ao devolver carta à Store: {e}")
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ADD ROUTER abriu página de seleção
                            if getattr(self, '_in_router_selection_page', False):
                                print(f"DEBUG: [REMOVE_ACTION] ADD ROUTER ativo - mantendo página de seleção de routers")
                                return  # Interrompe aqui, não volta ao inventário
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se REMOVE ROUTER abriu página de inventário de equipments
                            if getattr(self, '_in_remove_router_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] REMOVE ROUTER ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ROUTER UPGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_router_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER UPGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ROUTER DOWNGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_router_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER DOWNGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se LINK UPGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_link_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK UPGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se LINK DOWNGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_link_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK DOWNGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # Voltar para a página de inventário Actions/Events
                            print(f"DEBUG: [REMOVE_ACTION] Voltando para inventário Actions/Events")
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir página de inventário Actions/Events
                            self.show_inventory_matrix(['actions', 'events'], page)
                        else:
                            print(f"DEBUG: [REMOVE_ACTION] ERRO: Carta não encontrada no inventário Actions")
                    
                    # Botão Go! (roxo para remover a action)
                    ok_button = tk.Button(btn_frame, text="Go!", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=remover_action_do_inventario)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [ACTION_INFO] Overlay de informações da Action criado e exibido")
                
                # Botão verde ✓ no canto superior direito
                btn_remove = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#4CAF50", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_action_info_overlay, 
                    cursor="hand2", 
                    activebackground="#43d17a"
                )
                btn_remove.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ verde configurado para mostrar overlay de informações da Action")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para remover Events expirados
        # Condições: carta Event expirada, página Actions/Events (INDEPENDENTE de Next Phase)
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not final_phase_normal and  # CORREÇÃO: Permite durante gestão de pacotes
              not is_carta_virada_para_baixo):  # CORREÇÃO: NÃO mostrar botão se carta está virada para baixo
            
            # Verificar se a carta Event está expirada (primeira carta Event no inventário + duration_turns)
            cartas_events = self.inventario.get("events", [])
            is_event_do_topo = (cartas_events and carta_path == cartas_events[0])
            
            if is_event_do_topo:
                # Verificar se o Event expirou
                current_turn = getattr(self, '_current_turn', 0)
                is_event_expirado = False
                
                # GARANTIR que o Event do topo está ativo
                self._ensure_active_event_tracking()
                
                # CORREÇÃO: Verificar expiração apenas se Event está ativo
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    
                    event_data = self._event_duration_tracking[carta_path]
                    is_active = event_data.get('is_active', False)
                    start_turn = event_data.get('start_turn')
                    duration_turns = event_data.get('duration_turns')
                    
                    print(f"DEBUG: [FULLSCREEN] Verificando expiração Event {os.path.basename(carta_path)}:")
                    print(f"DEBUG: [FULLSCREEN]   É ativo? {is_active}")
                    print(f"DEBUG: [FULLSCREEN]   Turno atual: {current_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Turno início: {start_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Duration: {duration_turns}")
                    
                    # Só verificar expiração se Event está ativo e tem start_turn válido
                    if is_active and start_turn is not None and duration_turns is not None:
                        # CORREÇÃO: Verificar se é duração variável
                        if duration_turns == "variable":
                            print(f"DEBUG: [FULLSCREEN]   Event com duração variável - ainda não expirou")
                            print(f"DEBUG: [FULLSCREEN]   Aguardando lançamento do dado para determinar duração")
                            is_event_expirado = False
                        else:
                            turns_elapsed = current_turn - start_turn
                            print(f"DEBUG: [FULLSCREEN]   Turnos decorridos: {turns_elapsed}")
                            print(f"DEBUG: [FULLSCREEN]   Expira neste turno? {turns_elapsed >= duration_turns}")
                            
                            # CORREÇÃO: No turno de expiração, mostrar botão ✓ para remoção
                            is_event_expirado = (turns_elapsed >= duration_turns)
                    else:
                        print(f"DEBUG: [FULLSCREEN]   Event não está ativo - não calcular expiração")
                        is_event_expirado = False
                else:
                    # CORREÇÃO: Se não há tracking, tentar obter dados da base de dados
                    print(f"DEBUG: [FULLSCREEN] Event sem tracking - verificando base de dados: {os.path.basename(carta_path)}")
                    
                    # Tentar obter duration da base de dados
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            event_id = self._extract_event_id_from_path(carta_path)
                            if event_id:
                                event_data = self.card_database.get_event(event_id)
                                if event_data:
                                    duration_turns = event_data.duration_turns
                                    
                                    # CORREÇÃO: Verificar se é duração variável
                                    if duration_turns == "variable":
                                        print(f"DEBUG: [FULLSCREEN] Event com duração variável da BD - ainda não expirou")
                                        is_event_expirado = False
                                    else:
                                        # Assumir que começou no turno 1 se não há tracking
                                        start_turn = 1
                                        turns_elapsed = current_turn - start_turn
                                        is_event_expirado = (turns_elapsed >= duration_turns)
                                        
                                        print(f"DEBUG: [FULLSCREEN] Event sem tracking - dados obtidos da BD:")
                                        print(f"DEBUG: [FULLSCREEN]   Duration: {duration_turns}")
                                        print(f"DEBUG: [FULLSCREEN]   Turnos decorridos estimados: {turns_elapsed}")
                                        print(f"DEBUG: [FULLSCREEN]   Expira neste turno? {is_event_expirado}")
                        except Exception as e:
                            print(f"DEBUG: [FULLSCREEN] Erro ao obter dados do Event da BD: {e}")
                
                if is_event_expirado:
                    print(f"DEBUG: [FULLSCREEN] Event no turno de expiração detectado: {os.path.basename(carta_path)}")
                    
                    def mostrar_overlay_expiracao():
                        """Mostra overlay de confirmação para Event expirado"""
                        print(f"DEBUG: [OVERLAY_EVENT] Mostrando overlay de expiração para: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_event_expirado(carta_path)
                    
                    # Botão vermelho ✓ no canto superior direito (aparece no turno de expiração)
                    btn_remove_event = tk.Button(
                        self, 
                        text="✓", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF4444", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_overlay_expiracao, 
                        cursor="hand2", 
                        activebackground="#CC3333"
                    )
                    btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para mostrar overlay de Event que expira neste turno")
                else:
                    print(f"DEBUG: [FULLSCREEN] Event do topo ainda não expirou: {os.path.basename(carta_path)}")
                    
                    # FUNCIONALIDADE: Botão ⓘ para mostrar informações do Event não expirado
                    def mostrar_info_event():
                        """Mostra overlay com informações do Event ativo usando o estilo do overlay de ativação"""
                        import re
                        import os
                        
                        print(f"DEBUG: [EVENT_INFO] Mostrando informações do Event: {os.path.basename(carta_path)}")
                        
                        # Obter dados da carta Event da base de dados
                        event_title = "Event Information"
                        event_effect = "Effect description not available"
                        event_target = "Target not available"
                        
                        try:
                            if self.card_database:
                                # Extrair ID da carta (ex: "Event_367" -> "event_367")
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Event_(\d+)', filename)
                                
                                if match:
                                    event_id = f"event_{match.group(1)}"
                                    event_card = self.card_database.get_event(event_id)
                                    
                                    if event_card:
                                        event_title = event_card.title
                                        event_effect = event_card.effect_description
                                        # Determinar o target baseado nos campos target_link e target_queue
                                        if event_card.target_link:
                                            event_target = event_card.target_link
                                        elif event_card.target_queue:
                                            event_target = event_card.target_queue
                                        else:
                                            event_target = "Target not specified"
                                        
                                        print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                        print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                        print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                        print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                    else:
                                        print(f"DEBUG: [EVENT_INFO] Event não encontrado na base de dados: {event_id}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                        
                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativação)
                        for widget in self.winfo_children():
                            widget.destroy()
                        
                        # Definir fundo preto para a janela
                        self.config(bg="black")
                        
                        # Carregar a imagem da carta como fundo
                        try:
                            carta_img = Image.open(carta_path)
                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                            
                            # Calcular o ratio para ocupar o máximo possível da tela
                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                            carta_photo = ImageTk.PhotoImage(carta_resized)
                            
                            # Label com a imagem da carta como fundo
                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                            carta_label.image = carta_photo  # Manter referência
                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                            
                        except Exception as e:
                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                            self.config(bg="black")
                        
                        # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                        info_frame = tk.Frame(self, bg="black")
                        info_frame.pack(expand=True)
                        
                        # Título (roxo)
                        print(f"DEBUG: [EVENT_INFO] Criando título com texto: {repr(event_title)}")
                        title_label = tk.Label(info_frame, text=event_title, 
                                font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                                wraplength=650, justify="center")
                        title_label.pack(pady=(40, 20))
                        
                        # Descrição do Event
                        print(f"DEBUG: [EVENT_INFO] Criando descrição com texto: {repr(event_effect)}")
                        desc_label = tk.Label(info_frame, text=event_effect, 
                                           font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                           wraplength=600, justify="center")
                        desc_label.pack(pady=(0, 20))
                        
                        # Target do Event
                        print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                        target_frame = tk.Frame(info_frame, bg="black")
                        target_frame.pack(pady=(0, 20))
                        
                        target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                     font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                        target_label_prefix.pack(side="left")
                        
                        target_label_value = tk.Label(target_frame, text=event_target, 
                                                    font=("Helvetica", 13, "bold"), fg="white", bg="black")
                        target_label_value.pack(side="left")
                        
                        # Frame para o botão
                        btn_frame = tk.Frame(info_frame, bg="black")
                        btn_frame.pack(pady=30)
                        
                        def fechar_overlay():
                            print(f"DEBUG: [EVENT_INFO] Fechando overlay de informações")
                            # Ir para a página de inventário Actions/Events
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir página de inventário Actions/Events
                            self.show_inventory_matrix(['actions', 'events'])
                        
                        # Botão OK (roxo para combinar com o tema do Event)
                        ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                           bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                        ok_button.pack(pady=10)
                        
                        print(f"DEBUG: [EVENT_INFO] Overlay de informações criado e exibido")
                    
                    # Botão i laranja no canto superior direito (apenas quando Event ainda não expirou)
                    btn_info_event = tk.Button(
                        self, 
                        text="i", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF9800", 
                        fg="black", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_info_event, 
                        cursor="hand2", 
                        activebackground="#E68900"
                    )
                    btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Botão i roxo configurado para informações do Event ativo")
                    
                    # NOVA FUNCIONALIDADE: Verificar se Event do topo tem duration_turns variável
                    # Se sim, mostrar botão "?" para determinar duração com dado
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            import re
                            # Extrair ID da carta Event
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card and event_card.duration_turns == "variable":
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com duração variável detectado: {os.path.basename(carta_path)}")
                                    
                                    def mostrar_overlay_dado_duration():
                                        """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar duração")
                                        
                                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informação)
                                        for widget in self.winfo_children():
                                            widget.destroy()
                                        
                                        # Definir fundo preto para a janela
                                        self.config(bg="black")
                                        
                                        # Carregar a imagem da carta como fundo (igual ao overlay do botão "i")
                                        try:
                                            carta_img = Image.open(carta_path)
                                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                            
                                            # Calcular o ratio para ocupar o máximo possível da tela
                                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                            carta_photo = ImageTk.PhotoImage(carta_resized)
                                            
                                            # Label com a imagem da carta como fundo
                                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                            carta_label.image = carta_photo  # Manter referência
                                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                            
                                        except Exception as e:
                                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                            self.config(bg="black")
                                        
                                        # Frame central para o overlay (usar pack(expand=True) para dimensionamento dinâmico)
                                        overlay_frame = tk.Frame(self, bg="black")
                                        overlay_frame.pack(expand=True)
                                        
                                        # Título roxo
                                        title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                             font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                        title_label.pack(pady=(40, 30))
                                        
                                        # Dado (inicialmente em branco)
                                        blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                        dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                        dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                        dice_label.image = dice_img
                                        dice_label.pack(pady=20)
                                        
                                        # Botão Go!
                                        go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                            bg="#005c75", fg="white", width=8)
                                        go_button.pack(pady=20)
                                        
                                        def iniciar_animacao_dado():
                                            """Inicia a animação do dado e define a duração"""
                                            print(f"DEBUG: [VARIABLE_DURATION] Iniciando animação do dado")
                                            
                                            # Esconder botão Go!
                                            go_button.pack_forget()
                                            
                                            # Animação do dado (25 frames + resultado final)
                                            frames = 25
                                            results = [random.randint(1, 6) for _ in range(frames)]
                                            final_result = random.randint(1, 6)
                                            results.append(final_result)
                                            
                                            def animar_frame(frame_index=0):
                                                if frame_index < len(results):
                                                    n = results[frame_index]
                                                    dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                    
                                                    try:
                                                        new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                        dice_label.config(image=new_dice_img)
                                                        dice_label.image = new_dice_img
                                                    except Exception as e:
                                                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                    
                                                    # Próximo frame após 100ms
                                                    overlay_frame.after(100, animar_frame, frame_index + 1)
                                                else:
                                                    # Animação terminou - aplicar resultado
                                                    print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                    
                                                    # Atualizar duration_turns na base de dados (temporariamente na instância)
                                                    if event_card:
                                                        event_card.duration_turns = final_result
                                                        print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                    
                                                    # Atualizar tracking de duração se Event já está ativo
                                                    if (hasattr(self, '_event_duration_tracking') and 
                                                        carta_path in self._event_duration_tracking):
                                                        self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                        print(f"DEBUG: [VARIABLE_DURATION] Tracking de duração atualizado")
                                                    
                                                    # Aguardar 2 segundos antes de fechar
                                                    def fechar_overlay():
                                                        print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay após definir duração")
                                                        # Voltar para inventário Actions/Events
                                                        for widget in self.winfo_children():
                                                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                                continue
                                                            widget.destroy()
                                                        self.show_inventory_matrix(['actions', 'events'], page)
                                                    
                                                    overlay_frame.after(2000, fechar_overlay)
                                            
                                            animar_frame()
                                        
                                        go_button.config(command=iniciar_animacao_dado)
                                    
                                    # Botão "?" na mesma posição do botão Player dos Challenges
                                    # (canto inferior direito)
                                    btn_variable_duration = tk.Button(
                                        self, 
                                        text="?", 
                                        font=("Helvetica", 24, "bold"), 
                                        bg="#9966CC", 
                                        fg="white", 
                                        width=2, 
                                        height=1, 
                                        borderwidth=0, 
                                        highlightthickness=0, 
                                        command=mostrar_overlay_dado_duration, 
                                        cursor="hand2", 
                                        activebackground="#7744AA"
                                    )
                                    btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                    print(f"DEBUG: [VARIABLE_DURATION] Botão ? roxo criado para Event do topo com duração variável")
                                else:
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com duração fixa: {event_card.duration_turns if event_card else 'N/A'}")
                        except Exception as e:
                            print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar duração variável do Event do topo: {e}")
            else:
                print(f"DEBUG: [FULLSCREEN] Event não é do topo da lista - botão não mostrado")
        
        # NOVA FUNCIONALIDADE: Para Events não expirados em qualquer posição (não só do topo)
        # Botão ⓘ para mostrar informações do Event
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not is_carta_virada_para_baixo):
            
            print(f"DEBUG: [FULLSCREEN] Verificando Event não-do-topo para botão ⓘ: {os.path.basename(carta_path)}")
            
            # Verificar se o Event ainda está ativo (não expirado)
            current_turn = getattr(self, '_current_turn', 0)
            is_event_ativo = True  # Por padrão, assume que está ativo
            
            if (hasattr(self, '_event_duration_tracking') and 
                carta_path in self._event_duration_tracking):
                
                event_data = self._event_duration_tracking[carta_path]
                start_turn = event_data['start_turn']
                duration_turns = event_data['duration_turns']
                turns_elapsed = current_turn - start_turn
                is_event_ativo = (turns_elapsed < duration_turns)
                
                print(f"DEBUG: [FULLSCREEN] Event tracking - Ativo? {is_event_ativo} (turnos: {turns_elapsed}/{duration_turns})")
            
            if is_event_ativo:
                print(f"DEBUG: [FULLSCREEN] Event ativo detectado - criando botão ?")
                
                def mostrar_info_event_geral():
                    """Mostra overlay com informações do Event ativo usando o estilo do overlay de ativação"""
                    import re
                    import os
                    
                    print(f"DEBUG: [EVENT_INFO] Mostrando informações do Event: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Event da base de dados
                    event_title = "Event Information"
                    event_effect = "Effect description not available"
                    event_target = "Target not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Event_367" -> "event_367")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card:
                                    event_title = event_card.title
                                    event_effect = event_card.effect_description
                                    # Determinar o target baseado nos campos target_link e target_queue
                                    if event_card.target_link:
                                        event_target = event_card.target_link
                                    elif event_card.target_queue:
                                        event_target = event_card.target_queue
                                    else:
                                        event_target = "Target not specified"
                                    
                                    print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                    print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                    print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Event não encontrado na base de dados: {event_id}")
                            else:
                                print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativação)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o máximo possível da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter referência
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # Título (roxo)
                    print(f"DEBUG: [EVENT_INFO] Criando título com texto: {repr(event_title)}")
                    title_label = tk.Label(info_frame, text=event_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descrição do Event
                    print(f"DEBUG: [EVENT_INFO] Criando descrição com texto: {repr(event_effect)}")
                    desc_label = tk.Label(info_frame, text=event_effect, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target do Event
                    print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 14, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    target_label_value = tk.Label(target_frame, text=event_target, 
                                                font=("Helvetica", 14, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Frame para o botão
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def fechar_overlay():
                        print(f"DEBUG: [EVENT_INFO] Fechando overlay de informações")
                        # Ir para a página de inventário Actions/Events
                        # Limpa tudo menos a barra superior
                        for widget in self.winfo_children():
                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                continue
                            widget.destroy()
                        # Abrir página de inventário Actions/Events
                        self.show_inventory_matrix(['actions', 'events'])
                    
                    # Botão OK (roxo para combinar com o tema do Event)
                    ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [EVENT_INFO] Overlay de informações criado e exibido")
                
                # Botão i laranja no canto superior direito (Events não do topo da lista)
                btn_info_event = tk.Button(
                    self, 
                    text="i", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF9800", 
                    fg="black", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_info_event_geral, 
                    cursor="hand2", 
                    activebackground="#E68900"
                )
                btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão i roxo configurado para informações do Event ativo")
                
                # NOVA FUNCIONALIDADE: Verificar se Event tem duration_turns variável
                # Se sim, mostrar botão "?" para determinar duração com dado
                if hasattr(self, 'card_database') and self.card_database:
                    try:
                        import re
                        # Extrair ID da carta Event
                        filename = os.path.basename(carta_path)
                        match = re.match(r'Event_(\d+)', filename)
                        
                        if match:
                            event_id = f"event_{match.group(1)}"
                            event_card = self.card_database.get_event(event_id)
                            
                            if event_card and event_card.duration_turns == "variable":
                                print(f"DEBUG: [VARIABLE_DURATION] Event com duração variável detectado: {os.path.basename(carta_path)}")
                                
                                def mostrar_overlay_dado_duration():
                                    """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                    print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar duração")
                                    
                                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informação)
                                    for widget in self.winfo_children():
                                        widget.destroy()
                                    
                                    # Definir fundo preto para a janela
                                    self.config(bg="black")
                                    
                                    # Carregar a imagem da carta como fundo (igual ao overlay do botão "i")
                                    try:
                                        carta_img = Image.open(carta_path)
                                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                        
                                        # Calcular o ratio para ocupar o máximo possível da tela
                                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                        carta_photo = ImageTk.PhotoImage(carta_resized)
                                        
                                        # Label com a imagem da carta como fundo
                                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                        carta_label.image = carta_photo  # Manter referência
                                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                        
                                    except Exception as e:
                                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                        self.config(bg="black")
                                    
                                    # Frame central para o overlay (usar pack(expand=True) para dimensionamento dinâmico)
                                    overlay_frame = tk.Frame(self, bg="black")
                                    overlay_frame.pack(expand=True)
                                    
                                    # Título roxo
                                    title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                         font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                    title_label.pack(pady=(40, 30))
                                    
                                    # Dado (inicialmente em branco)
                                    blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                    dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                    dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                    dice_label.image = dice_img
                                    dice_label.pack(pady=20)
                                    
                                    # Botão Go!
                                    go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                        bg="#005c75", fg="white", width=8)
                                    go_button.pack(pady=20)
                                    
                                    def iniciar_animacao_dado():
                                        """Inicia a animação do dado e define a duração"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando animação do dado")
                                        
                                        # Esconder botão Go!
                                        go_button.pack_forget()
                                        
                                        # Animação do dado (25 frames + resultado final)
                                        frames = 25
                                        results = [random.randint(1, 6) for _ in range(frames)]
                                        final_result = random.randint(1, 6)
                                        results.append(final_result)
                                        
                                        def animar_frame(frame_index=0):
                                            if frame_index < len(results):
                                                n = results[frame_index]
                                                dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                
                                                try:
                                                    new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                    dice_label.config(image=new_dice_img)
                                                    dice_label.image = new_dice_img
                                                except Exception as e:
                                                    print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                
                                                # Próximo frame após 100ms
                                                overlay_frame.after(100, animar_frame, frame_index + 1)
                                            else:
                                                # Animação terminou - aplicar resultado
                                                print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                
                                                # Atualizar duration_turns na base de dados (temporariamente na instância)
                                                if event_card:
                                                    event_card.duration_turns = final_result
                                                    print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                
                                                # Atualizar tracking de duração se Event já está ativo
                                                if (hasattr(self, '_event_duration_tracking') and 
                                                    carta_path in self._event_duration_tracking):
                                                    self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                    print(f"DEBUG: [VARIABLE_DURATION] Tracking de duração atualizado")
                                                
                                                # Aguardar 2 segundos antes de fechar
                                                def fechar_overlay():
                                                    print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay após definir duração")
                                                    # Voltar para inventário Actions/Events
                                                    for widget in self.winfo_children():
                                                        if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                            continue
                                                        widget.destroy()
                                                    self.show_inventory_matrix(['actions', 'events'], page)
                                                
                                                overlay_frame.after(2000, fechar_overlay)
                                        
                                        animar_frame()
                                    
                                    go_button.config(command=iniciar_animacao_dado)
                                
                                # Botão "?" na mesma posição do botão Player dos Challenges
                                # (canto inferior direito)
                                btn_variable_duration = tk.Button(
                                    self, 
                                    text="?", 
                                    font=("Helvetica", 24, "bold"), 
                                    bg="#9966CC", 
                                    fg="white", 
                                    width=2, 
                                    height=1, 
                                    borderwidth=0, 
                                    highlightthickness=0, 
                                    command=mostrar_overlay_dado_duration, 
                                    cursor="hand2", 
                                    activebackground="#7744AA"
                                )
                                btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                print(f"DEBUG: [VARIABLE_DURATION] Botão ? roxo criado para Event com duração variável")
                            else:
                                print(f"DEBUG: [VARIABLE_DURATION] Event com duração fixa: {event_card.duration_turns if event_card else 'N/A'}")
                    except Exception as e:
                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar duração variável: {e}")
            else:
                # Event expirado - mostrar botão ✓ vermelho para remoção
                print(f"DEBUG: [FULLSCREEN] Event expirado detectado - criando botão ✓ vermelho")
                
                def remover_event_expirado():
                    """Remove a carta Event expirada do inventário e retorna para o baralho da Store"""
                    print(f"DEBUG: [REMOVE_EVENT] Removendo Event expirado do inventário: {os.path.basename(carta_path)}")
                    
                    # Remover carta do inventário
                    if "events" in self.inventario and carta_path in self.inventario["events"]:
                        self.inventario["events"].remove(carta_path)
                        print(f"DEBUG: [REMOVE_EVENT] Carta removida do inventário do jogador")
                        
                        # Remover do tracking de duração
                        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
                            del self._event_duration_tracking[carta_path]
                            print(f"DEBUG: [REMOVE_EVENT] Event removido do tracking de duração")
                        
                        # Devolver carta ao baralho da Store (se há referência)
                        if hasattr(self, 'store_window') and self.store_window:
                            try:
                                self.store_window.adicionar_carta_ao_baralho(carta_path, "events", "neutral")
                                print(f"DEBUG: [REMOVE_EVENT] Carta devolvida ao baralho da Store")
                            except Exception as e:
                                print(f"DEBUG: [REMOVE_EVENT] Erro ao devolver carta à Store: {e}")
                        
                        # Voltar para a página de inventário Actions/Events
                        print(f"DEBUG: [REMOVE_EVENT] Voltando para inventário Actions/Events")
                        # Obter a página atual se disponível
                        current_page = getattr(self, '_current_inventory_page', 0)
                        self.show_inventory_matrix(["actions", "events"], current_page)
                    else:
                        print(f"DEBUG: [REMOVE_EVENT] ERRO: Carta não encontrada no inventário Events")
                
                # Botão vermelho ✓ no canto superior direito (aparece quando Event está expirado)
                btn_remove_event = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF4444", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=remover_event_expirado, 
                    cursor="hand2", 
                    activebackground="#CC3333"
                )
                btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para remoção de Event expirado")
        else:
            # Debug para quando o botão vermelho não é criado
            if carta_tipo == "actions":
                print(f"DEBUG: [FULLSCREEN] Botão vermelho ✓ NÃO criado para Actions:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                if gestao_pacotes_ativa:
                    print(f"DEBUG: [FULLSCREEN]   Durante gestão de pacotes - botão DEVERIA aparecer!")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Fora da gestão de pacotes - verificar outras condições")
            elif carta_tipo == "events":
                print(f"DEBUG: [FULLSCREEN] Botão vermelho ✓ NÃO criado para Events:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                print(f"DEBUG: [FULLSCREEN]   É Event do topo? {(self.inventario.get('events', []) and carta_path == self.inventario.get('events', [])[0])}")
                
                # Verificar detalhes da expiração
                current_turn = getattr(self, '_current_turn', 0)
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    event_data = self._event_duration_tracking[carta_path]
                    start_turn = event_data['start_turn']
                    duration_turns = event_data['duration_turns']
                    turns_elapsed = current_turn - start_turn
                    is_expired = (turns_elapsed >= duration_turns)
                    print(f"DEBUG: [FULLSCREEN]   Event tracking encontrado - Expirado? {is_expired} (turnos: {turns_elapsed}/{duration_turns})")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Event não encontrado no tracking de duração")
        
        # Para Activities e Challenges, layout especial com botões específicos
        # IMPORTANTE: Limpar qualquer estado de venda anterior para garantir comportamento correto
        self._origem_venda = None
        self._tipos_venda = None
        self._page_venda = None
        self._current_sell_page = None
        self._inventario_conjunto = None
        
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [FULLSCREEN] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            print(f"DEBUG: [FULLSCREEN] Casa atual: {getattr(self, 'current_casa_tipo', 'neutral')}")
            print(f"DEBUG: [FULLSCREEN] Next Phase ativo: {getattr(self, '_next_phase_active', False)}")
            
            # Para Activities: botão ✔ abre página de confirmação de venda (se pode vender)
            # Para Challenges: botão ✔ aceita para carrossel (comportamento original)
            if carta_tipo == "activities" and pode_vender:
                # Botão ✔ canto superior direito (para venda)
                btn_certo = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_certo.place(relx=0.98, rely=0, anchor="ne")
                
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informações para navegação correta
                    self._origem_venda = "inventario"
                    # Se viemos de um inventário Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._tipos_venda = ["activities", "challenges"]
                        self._inventario_conjunto = True
                        print(f"DEBUG: Guardando contexto inventário conjunto Activities/Challenges")
                    else:
                        self._tipos_venda = None
                        self._inventario_conjunto = False
                        print(f"DEBUG: Guardando contexto inventário individual: {carta_tipo}")
                    # Guardar a página atual baseada no parâmetro da função
                    self._page_venda = page
                    self._current_sell_page = page
                    print(f"DEBUG: Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                btn_certo.config(command=abrir_confirm_activities)
                print(f"DEBUG: [FULLSCREEN] Botão ✔ configurado para venda de Activities")
            
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                # POSICIONAMENTO ESPECÍFICO DOS BOTÕES:
                # - Activities: Switch no canto superior direito
                # - Challenges: Switch no canto inferior direito, Quit no canto superior direito
                
                # BOTÃO SWITCH PARA CARROSSEL
                btn_switch_carrossel = None
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [FULLSCREEN] VERIFICAÇÃO SWITCH CARROSSEL ({carta_tipo}):")
                print(f"DEBUG: [FULLSCREEN]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [FULLSCREEN]   has_valid_positions: {has_valid_positions}")
                print(f"DEBUG: [FULLSCREEN]   pode_vender: {pode_vender}")
                
                # NOVA VERIFICAÇÃO: Para Activities, verificar se há Challenges no inventário (restrição Activity↔Activity)
                pode_fazer_troca_activity = True
                if carta_tipo == "activities":
                    challenges_no_inventario = len(self.inventario.get('challenges', []))
                    print(f"DEBUG: [FULLSCREEN] Verificando restrição Activity↔Activity - Challenges no inventário: {challenges_no_inventario}")
                    if challenges_no_inventario > 0:
                        pode_fazer_troca_activity = False
                        print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - Restrição Activity↔Activity ativa (Challenges no inventário)")
                
                if next_phase_active and has_valid_positions and pode_fazer_troca_activity:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_carrossel.image = switch_img  # Manter referência
                            
                            # POSICIONAMENTO ESPECÍFICO POR TIPO:
                            if carta_tipo == "activities":
                                # Activities: Switch no canto superior direito
                                btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                                print(f"DEBUG: [FULLSCREEN] ✅ Botão Switch Activity posicionado no canto superior direito")
                            else:  # carta_tipo == "challenges"
                                # Challenges: Switch no canto inferior direito (máximo canto possível)
                                btn_switch_carrossel.place(relx=1.0, rely=1.0, anchor="se")
                                print(f"DEBUG: [FULLSCREEN] ✅ Botão Switch Challenge posicionado no canto inferior direito (máximo canto)")
                            
                            print(f"DEBUG: [FULLSCREEN] ✅ Botão Switch carrossel CRIADO - Next Phase ativo + posições válidas + sem restrição Activity↔Activity")
                        else:
                            print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - imagem não encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_carrossel = None
                        print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - erro ao carregar imagem: {e}")
                else:
                    if not next_phase_active:
                        print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - Next Phase NÃO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - SEM posições válidas no carrossel")
                    elif carta_tipo == "activities" and not pode_fazer_troca_activity:
                        print(f"DEBUG: [FULLSCREEN] ❌ Botão Switch carrossel NÃO criado - Restrição Activity↔Activity (Challenges no inventário)")
                
                # Configurar comando do botão Switch
                def aceitar_carta():
                    # NOVA LÓGICA: Só mostrar overlay se vai SUBSTITUIR uma carta (não quando vai colocar numa posição vazia)
                    print("DEBUG: [FULLSCREEN] Verificando se vai substituir carta existente ou colocar em posição vazia")
                    
                    # Obter a posição de destino mais provável (primeira posição vazia ou acessível)
                    posicao_destino = None
                    carta_na_posicao_destino = None
                    
                    if hasattr(self, 'carrossel_idx_selecao') and self.carrossel_idx_selecao is not None:
                        # Se há uma posição específica selecionada, usar essa
                        posicao_destino = self.carrossel_idx_selecao
                    else:
                        # Encontrar a primeira posição acessível (vazia ou não)
                        if hasattr(self, 'cards'):
                            for i, carta_carrossel in enumerate(self.cards):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                    
                    # Verificar se há uma carta real na posição de destino
                    vai_substituir_carta = False
                    if posicao_destino is not None and hasattr(self, 'cards') and posicao_destino < len(self.cards):
                        carta_na_posicao_destino = self.cards[posicao_destino]
                        # Se não é back_card, significa que há uma carta real para substituir
                        if not os.path.basename(carta_na_posicao_destino).startswith("back_card_"):
                            vai_substituir_carta = True
                            print(f"DEBUG: [FULLSCREEN] Vai SUBSTITUIR carta existente na posição {posicao_destino}: {os.path.basename(carta_na_posicao_destino)}")
                        else:
                            print(f"DEBUG: [FULLSCREEN] Vai COLOCAR em posição VAZIA {posicao_destino}")
                    
                    if vai_substituir_carta:
                        print("DEBUG: [FULLSCREEN] Substituição detectada - mostrando overlay de confirmação")
                        self._mostrar_overlay_confirmacao_troca(carta_path, [carta_tipo], 0)
                    else:
                        print("DEBUG: [FULLSCREEN] Colocação em posição vazia - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, [carta_tipo], 0)
                
                if btn_switch_carrossel is not None:
                    btn_switch_carrossel.config(command=aceitar_carta)
                    print(f"DEBUG: [FULLSCREEN] Botão Switch configurado para aceitar {carta_tipo} no carrossel")
                
                # BOTÃO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase)
                if carta_tipo == "challenges" and not next_phase_active:
                    print(f"DEBUG: [FULLSCREEN] Criando botão Quit Challenge no canto superior direito")
                    
                    # Botão vermelho com símbolo de check (✓) para quit challenge
                    btn_quit_challenge = tk.Button(
                        self, 
                        text="✓", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#DC143C", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        cursor="hand2", 
                        activebackground="#B22222"
                    )
                    # Challenge: Quit no canto superior direito
                    btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
                    
                    # Comando do botão quit
                    def mostrar_confirmacao_quit():
                        print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_quit_challenge(carta_path)
                    
                    btn_quit_challenge.config(command=mostrar_confirmacao_quit)
                    print(f"DEBUG: [FULLSCREEN] ✅ Botão Quit Challenge criado no canto superior direito")
        
        # Para Users, Equipments e Services, adicionar botão de ativação/desativação
        # IMPORTANTE: APENAS após Next Phase ser ativado
        elif carta_tipo in ["users", "equipments", "services"]:
            # Verificar se é User_1.png - tratamento especial
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            if is_user_1:
                # Para User_1.png, não criar nenhum botão adicional além do X
                pass
            else:
                # NOVA FUNCIONALIDADE: Botão vermelho especial para REMOVE ROUTER context
                # Deve aparecer quando estamos no contexto REMOVE ROUTER e a carta está ativa
                if (carta_tipo == "equipments" and 
                    getattr(self, '_in_remove_router_context', False) and
                    self.is_card_active(carta_path, carta_tipo)):
                    
                    print(f"DEBUG: [REMOVE_ROUTER] Carta Equipment ativa detectada no contexto REMOVE ROUTER: {os.path.basename(carta_path)}")
                    
                    # Verificar se é um router ou um link com mesmo ID
                    is_link = self._is_link_card(carta_path)
                    is_removing_links = getattr(self, '_removing_associated_links', False)
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    
                    if is_link and is_removing_links:
                        # Verificar se o link tem o mesmo specific_id do router que foi removido
                        link_id = self._get_equipment_specific_id(carta_path)
                        if str(link_id) == str(router_id_being_removed):
                            print(f"DEBUG: [REMOVE_ROUTER] Link com ID {link_id} corresponde ao router removido {router_id_being_removed}")
                            
                            # Botão vermelho ✔ para remoção do link
                            btn_remove_link = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def remover_link():
                                self.show_remove_link_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_remove_link.config(command=remover_link)
                            btn_remove_link.place(relx=0.98, rely=0, anchor="ne")
                            print(f"DEBUG: [REMOVE_ROUTER] Botão ✔ vermelho configurado para remoção do link")
                        else:
                            print(f"DEBUG: [REMOVE_ROUTER] Link ID {link_id} não corresponde ao router removido {router_id_being_removed}")
                    elif not is_link and not is_removing_links:
                        # Router normal - usar confirmação de router
                        btn_remove_router = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                        def remover_router():
                            self.show_remove_router_confirmation(carta_path, carta_tipo, tipos, page)
                        btn_remove_router.config(command=remover_router)
                        btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [REMOVE_ROUTER] Botão ✔ vermelho configurado para remoção do router")
                    
                else:
                    # CORREÇÃO: Botões de ativação/desativação só aparecem DEPOIS de Next Phase ser ativado
                    # Antes disso, as cartas são apenas para visualização
                    next_phase_active = getattr(self, '_next_phase_active', False)
                    final_phase_active = getattr(self, '_final_phase_active', False)
                    
                    # CORREÇÃO CRÍTICA: NÃO criar botões de ativação/desativação quando estamos em contextos especiais
                    # Os botões vermelhos especiais devem ter prioridade sobre os botões de ativação/desativação
                    in_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
                    in_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
                    in_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
                    in_link_downgrade_context = getattr(self, '_in_link_downgrade_context', False)
                    
                    # NOVA FUNCIONALIDADE: Verificar expiração de Services ANTES de criar botões normais
                    if carta_tipo == "services":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Verificando expiração para Service: {os.path.basename(carta_path)}")
                        is_expired = self._is_service_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Resultado da verificação de expiração: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service EXPIRADO - criando botão vermelho de expiração")
                            # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                            red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao():
                                print(f"DEBUG: Mostrando overlay de expiração para Service {carta_path}")
                                self._mostrar_overlay_service_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao)
                            return  # Não criar outros botões se o Service expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service NÃO expirado - continuando com lógica normal")
                    
                    # NOVA FUNCIONALIDADE: Verificar expiração de Events ANTES de criar botões normais
                    if carta_tipo == "events":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Verificando expiração para Event: {os.path.basename(carta_path)}")
                        is_expired = self._is_event_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Resultado da verificação de expiração: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event EXPIRADO - criando botão vermelho de expiração")
                            # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                            red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao_event():
                                print(f"DEBUG: Mostrando overlay de expiração para Event {carta_path}")
                                self._mostrar_overlay_event_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao_event)
                            return  # Não criar outros botões se o Event expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event NÃO expirado - continuando com lógica normal")
                    
                    # Só mostrar botões de ativação/desativação se Next Phase estiver ativo E não estiver em Final Phase E não estiver em contextos especiais
                    if next_phase_active and not final_phase_active and not in_router_upgrade_context and not in_router_downgrade_context and not in_link_upgrade_context and not in_link_downgrade_context:
                        # Verificar se a carta está ativa
                        is_active = self.is_card_active(carta_path, carta_tipo)
                        
                        if is_active:
                            # Carta ativa: botão para desativar (vermelho com ✔)
                            btn_activate = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def desativar_carta():
                                self.show_deactivation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=desativar_carta)
                        else:
                            # Carta inativa: botão para ativar (verde com ✔)
                            btn_activate = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                            def ativar_carta():
                                self.show_activation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=ativar_carta)
                        
                        # Posicionar o botão no canto superior direito
                        btn_activate.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [FULLSCREEN] Botão de ativação/desativação criado para {carta_tipo} - Next Phase ativo")
                    else:
                        print(f"DEBUG: [FULLSCREEN] Botão de ativação/desativação NÃO criado para {carta_tipo} - Next Phase: {next_phase_active}, Final Phase: {final_phase_active}, Router Upgrade Context: {in_router_upgrade_context}, Router Downgrade Context: {in_router_downgrade_context}, Link Upgrade Context: {in_link_upgrade_context}, Link Downgrade Context: {in_link_downgrade_context}")

    def show_inventory_for_sell(self, carta_tipo, store_window=None, page=0):
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Verificar se o jogador pode vender cartas deste tipo na casa atual
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - Next Phase está ativo (vendas desabilitadas)")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # IMPORTANTE: Se está numa casa START, NÃO pode vender nenhuma carta
        if casa_atual_tipo == "start":
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - está numa casa START (nenhuma venda permitida)")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # Normalizar o tipo da casa atual (equipments vs equipment)
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        # Verificar se pode vender nesta casa (no inventário próprio, qualquer cor serve)
        # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
        pode_vender_tipo = False
        if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
            pode_vender_tipo = (casa_atual_tipo == carta_tipo)
        
        if not pode_vender_tipo:
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        print(f"DEBUG: Pode vender cartas {carta_tipo} do inventário - está numa casa {casa_atual_tipo}")
        
        # Garantir que a janela está visível e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que não está minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store está escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # Força update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com paginação
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no inventário: {len(cartas)}")
        
        # Paginação
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimensões que outras páginas de inventário
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                # CORREÇÃO: Verificar se a carta está ativa antes de permitir venda
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas não podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualização (não pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualização (cartas ativas não podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar página atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a lógica de verificação adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORREÇÃO: Verificar se a carta está ativa para determinar como mostrá-la
                # Cartas ATIVAS devem aparecer viradas para cima (não podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta está ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima (mas não pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa: virada para cima (NÃO pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (NÃO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa: virada para baixo (PODE ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", "back_card.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card não existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            
            # CORREÇÃO: Cursor diferente dependendo se a carta pode ser vendida
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # Cartas ativas e User_1.png são apenas para visualização (cursor normal)
            # Cartas inativas podem ser vendidas (cursor hand2)
            if is_user_1 or is_active:
                cursor_type = "arrow"  # Cursor normal para cartas que não podem ser vendidas
            else:
                cursor_type = "hand2"  # Cursor de mão para cartas que podem ser vendidas
            
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navegação (se houver mais de uma página)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (página anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (página seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # Força update final para garantir que tudo é exibido
        self.update_idletasks()
        self.update()
        
        # Botão voltar
        if store_window:
            def voltar_para_store():
                print("DEBUG: PlayerDashboard voltar_para_store chamado")
                try:
                    # Primeiro, esconde o PlayerDashboard
                    print("DEBUG: Escondendo PlayerDashboard...")
                    self.withdraw()
                    
                    # Aguarda um pouco para garantir que foi escondido
                    print("DEBUG: Aguardando para processar volta à Store...")
                    self.after(100, lambda: self._process_back_to_store(store_window))
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao iniciar volta para store: {e}")
                    import traceback
                    traceback.print_exc()
                    
            def _process_back_to_store(store_window):
                print("DEBUG: Processando volta à Store...")
                try:
                    # Verificar se a Store ainda existe
                    if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                        print("DEBUG: Store existe, forçando exibição...")
                        # Força a Store a aparecer
                        store_window.deiconify()
                        store_window.state('normal')
                        store_window.lift()
                        store_window.focus_force()
                        
                        # CORREÇÃO: Voltar para a interface principal da Store (não para página de compra específica)
                        print(f"DEBUG: Botão Back - Chamando voltar_para_store da Store...")
                        store_window.after(50, lambda: store_window.voltar_para_store())
                        print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                        
                    else:
                        print("DEBUG: Store não existe mais, voltando ao PlayerDashboard")
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                except Exception as e:
                    print(f"DEBUG: Erro ao processar volta à Store: {e}")
                    import traceback
                    traceback.print_exc()
                    # Em caso de erro, volta ao PlayerDashboard
                    try:
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    except Exception as fallback_e:
                        print(f"DEBUG: Erro crítico no fallback: {fallback_e}")
            
            # Adiciona o método auxiliar à instância
            self._process_back_to_store = _process_back_to_store
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário de venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário de venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Botão voltar - criado após a barra para ficar por cima
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell terminado com sucesso")

    def show_inventory_for_sell_after_sale(self, carta_tipo, store_window=None, page=0):
        """Versão especial de show_inventory_for_sell que ignora verificações de casa após uma venda bem-sucedida"""
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell_after_sale chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Garantir que a janela está visível e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que não está minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store está escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # Força update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com paginação
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no inventário após venda: {len(cartas)}")
        
        # Paginação
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimensões que outras páginas de inventário
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                print(f"DEBUG: Carta clicada para venda: {carta_path}")
                
                # Verificar se a carta está ativa (não pode ser vendida)
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas não podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualização (não pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualização (cartas ativas não podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar página atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a lógica de verificação adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORREÇÃO: Verificar se a carta está ativa para determinar como mostrá-la
                # Cartas ATIVAS devem aparecer viradas para cima (não podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta está ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa - mostrar virada para cima (não pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (NÃO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa - mostrar virada para baixo (pode ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", "back_card.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card não existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navegação (se houver mais de uma página)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (página anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (página seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário de venda após venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário de venda após venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Botão voltar - criado após a barra para ficar por cima
        def voltar_para_store():
            print("DEBUG: PlayerDashboard voltar_para_store chamado (após venda)")
            try:
                # Primeiro, esconde o PlayerDashboard
                print("DEBUG: Escondendo PlayerDashboard...")
                self.withdraw()
                
                # Aguarda um pouco para garantir que foi escondido
                print("DEBUG: Aguardando para processar volta à Store...")
                self.after(100, lambda: self._process_back_to_store_after_sale(store_window))
                
            except Exception as e:
                print(f"DEBUG: Erro ao iniciar volta para store após venda: {e}")
                import traceback
                traceback.print_exc()
        
        def _process_back_to_store_after_sale(store_window):
            print("DEBUG: Processando volta à Store após venda...")
            try:
                # Verificar se a Store ainda existe
                if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                    print("DEBUG: Store existe, forçando exibição...")
                    # Força a Store a aparecer
                    store_window.deiconify()
                    store_window.state('normal')
                    store_window.lift()
                    store_window.focus_force()
                    
                    # CORREÇÃO: Voltar para a interface principal da Store (não para página de compra específica)
                    print(f"DEBUG: Botão Back - Chamando voltar_para_store da Store...")
                    store_window.after(50, lambda: store_window.voltar_para_store())
                    print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                    
                else:
                    print("DEBUG: Store não existe mais, voltando ao PlayerDashboard")
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
            except Exception as e:
                print(f"DEBUG: Erro ao processar volta à Store após venda: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, volta ao PlayerDashboard
                try:
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback após venda: {fallback_e}")
                    traceback.print_exc()
        
        # Adiciona o método auxiliar à instância
        self._process_back_to_store_after_sale = _process_back_to_store_after_sale
        
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell_after_sale terminado com sucesso")

    def show_card_fullscreen_sell(self, carta_path, carta_tipo, store_window=None):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X para fechar - movido para canto superior esquerdo
        def fechar():
            # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
            current_page = getattr(self, '_current_sell_page', 0)
            # IMPORTANTE: Usar versão especial que ignora verificações de casa
            self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
        
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=fechar, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de venda APENAS se estiver numa casa do tipo correspondente
        # Verificar se o jogador está numa casa do tipo correspondente (no inventário próprio, qualquer cor serve)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        print(f"DEBUG: Verificando possibilidade de venda fullscreen no inventário - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}, casa_atual_cor: {casa_atual_cor}, other_player_house: {current_other_player_house}")
        
        # IMPORTANTE: User_1.png NUNCA pode ser vendida
        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
        if is_user_1:
            print(f"DEBUG: User_1.png NÃO pode ser vendida - apenas botão X disponível")
            pode_vender = False
        else:
            # CORREÇÃO: Verificar se a carta está ATIVA (cartas ativas nunca podem ser vendidas)
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            
            if is_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} - carta está ATIVA (cartas ativas não podem ser vendidas)")
                pode_vender = False
            # IMPORTANTE: Se Next Phase está ativo, também não pode vender (dupla verificação)
            elif getattr(self, '_next_phase_active', False):
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - Next Phase está ativo (vendas desabilitadas)")
                pode_vender = False
            # IMPORTANTE: Se está numa casa de outro jogador, PODE vender cartas INATIVAS do inventário do tipo correspondente
            elif current_other_player_house:
                print(f"DEBUG: Casa de outro jogador detectada - verificando se pode vender {carta_tipo} INATIVO")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Em casas de outros jogadores, pode vender se o tipo da casa corresponder ao tipo da carta E carta está INATIVA
                if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                        print(f"DEBUG: PODE vender carta {carta_tipo} INATIVA - está numa casa {casa_atual_tipo} de outro jogador")
                    else:
                        print(f"DEBUG: NÃO pode vender carta {carta_tipo} - casa {casa_atual_tipo} não corresponde")
            else:
                # Lógica original para casas próprias ou neutras - só pode vender cartas INATIVAS
                print(f"DEBUG: Casa própria ou neutra - verificando regras normais (apenas cartas INATIVAS)")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Verificar se pode vender cartas INATIVAS
                if carta_tipo in ["users", "equipments", "services"]:
                    # Para estas cartas, precisa estar na casa do mesmo tipo E carta deve estar INATIVA
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                elif carta_tipo in ["activities", "challenges"]:
                    # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
        
        # Botão de venda com checkmark no canto superior direito (substitui o botão verde picoin)
        if pode_vender:
            if current_other_player_house:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo} de outro jogador ({casa_atual_cor})")
            else:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo}")
            def abrir_confirm():
                self.show_sell_confirmation(carta_path, carta_tipo, store_window)
            
            # Botão com checkmark (✓) no canto superior direito
            btn_sell = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
            btn_sell.place(relx=0.98, rely=0, anchor="ne")
        else:
            # Verificar motivo específico para não poder vender
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            next_phase_active = getattr(self, '_next_phase_active', False)
            
            if is_user_1:
                print(f"DEBUG: User_1.png - apenas botão X disponível (nunca pode ser vendida)")
            elif is_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} - carta está ATIVA (cartas ativas não podem ser vendidas)")
            elif next_phase_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - Next Phase ativo (vendas desabilitadas)")
            elif current_other_player_house:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa de outro jogador ({casa_atual_cor}) do tipo {casa_atual_tipo}, necessário: {carta_tipo}")
            else:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")

    def show_sell_confirmation(self, carta_path, carta_tipo, store_window=None):
        import tkinter.messagebox
        
        # LOGGING DETALHADO PARA DEBUG
        print(f"DEBUG: [VENDA INÍCIO] ===== PROCESSO DE VENDA INICIADO =====")
        print(f"DEBUG: [VENDA INÍCIO] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [VENDA INÍCIO] Tipo: {carta_tipo}")
        print(f"DEBUG: [VENDA INÍCIO] Store fornecida: {store_window is not None}")
        if store_window:
            print(f"DEBUG: [VENDA INÍCIO] Store ID: {getattr(store_window, '_store_id', 'Sem ID')}")
            print(f"DEBUG: [VENDA INÍCIO] Player cor: {self.player_color}")
            print(f"DEBUG: [VENDA INÍCIO] Store casa_cor: {getattr(store_window, 'casa_cor', 'Não definida')}")
            print(f"DEBUG: [VENDA INÍCIO] Store casa_tipo: {getattr(store_window, 'casa_tipo', 'Não definido')}")
        
        # Definir variáveis necessárias
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # PRIMEIRO: Limpar tudo e mostrar a carta em fullscreen como fundo (igual à compra)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        
        # Mostrar a carta em fullscreen como fundo (igual à imagem de compra)
        try:
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            
            # Área disponível: toda a tela (igual à compra)
            available_width = screen_width
            available_height = screen_height
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(available_width/img_w, available_height/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Carta em fullscreen como fundo
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # Manter referência para evitar garbage collection
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
            print("DEBUG: Carta carregada em fullscreen como fundo")
            
        except Exception as e:
            print(f"DEBUG: ERRO ao carregar carta para fundo: {e}")
            # Mostrar um placeholder em caso de erro
            carta_real_lbl = tk.Label(self, text="Erro ao carregar carta", font=("Helvetica", 20), fg="red", bg="black")
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
        
        # SEGUNDO: Frame de confirmação (igual ao layout da compra na imagem)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        tk.Label(confirm_frame, text="Are you sure you want to sell?", font=("Helvetica", 16, "bold"), fg="white", bg="black").pack(pady=(40, 20))
        
        # Saldo atual (igual à confirmação de compra)
        tk.Label(confirm_frame, text=f"Your balance: {self.saldo}", font=("Helvetica", 16), fg="yellow", bg="black").pack(pady=(0, 10))
        
        # Valor da carta (usando base de dados integrada)
        valor = self._extrair_valor_venda_carta(carta_path)
        if valor is None:
            print("DEBUG: Valor não encontrado, usando fallback")
            valor = self._extrair_valor_fallback(carta_path)
        
        value_frame = tk.Frame(confirm_frame, bg="black")
        value_frame.pack(pady=(0, 30))
        
        tk.Label(value_frame, text="Card value: ", 
                font=("Helvetica", 16), fg="white", bg="black").pack(side="left")
        tk.Label(value_frame, text=str(valor), 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(side="left", padx=(5, 5))
        
        # Ícone da moeda (igual à confirmação de compra)
        try:
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            picoin_lbl = tk.Label(value_frame, image=picoin_img, bg="black")
            picoin_lbl.image = picoin_img
            picoin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar ícone da moeda: {e}")
        
        # Frame para os botões (igual à confirmação de compra)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack()
        
        def confirmar():
            print("DEBUG: Confirmar venda - início")
            print(f"DEBUG: Variáveis de controle - _inventario_conjunto: {getattr(self, '_inventario_conjunto', 'None')}")
            print(f"DEBUG: Variáveis de controle - _tipos_venda: {getattr(self, '_tipos_venda', 'None')}")
            print(f"DEBUG: Variáveis de controle - _current_sell_page: {getattr(self, '_current_sell_page', 'None')}")
            try:
                # CORREÇÃO: Lógica de venda correta
                # Player vende a carta: perde a carta, ganha dinheiro
                # Store compra a carta: ganha a carta, perde dinheiro
                if valor is not None and valor > 0:
                    # Player recebe o dinheiro pela venda
                    self.saldo += valor
                    print(f"DEBUG: Player vendeu carta por {valor}, novo saldo: {self.saldo}")
                    
                    # Store paga pela carta (perde dinheiro)
                    if store_window:
                        store_window.saldo -= valor
                        print(f"DEBUG: Store pagou {valor}, novo saldo: {store_window.saldo}")
                        
                        # IMPORTANTE: Devolver a carta aos baralhos da Store (sincronização)
                        # CORREÇÃO: Especificar a cor do jogador que está vendendo
                        if hasattr(store_window, 'adicionar_carta_ao_baralho'):
                            print(f"DEBUG: [VENDA EXECUÇÃO] ===== ADICIONANDO CARTA DE VOLTA À STORE =====")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Carta: {os.path.basename(carta_path)}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Tipo: {carta_tipo}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Cor do jogador vendedor: {self.player_color}")
                            
                            # Determinar a cor correta para adicionar a carta
                            cor_carta = self._get_color_from_path(carta_path)
                            # As cartas vendidas sempre vão para o baralho da cor do jogador
                            if not cor_carta:
                                cor_carta = self.player_color
                            
                            print(f"DEBUG: [VENDA EXECUÇÃO] Cor da carta determinada: {cor_carta}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Casa atual da Store: tipo='{store_window.casa_tipo}', cor='{store_window.casa_cor}'")
                            
                            # Estado ANTES da adição
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_antes = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECUÇÃO] ANTES: {cartas_antes} cartas de {carta_tipo} na cor {cor_carta}")
                            else:
                                print(f"DEBUG: [VENDA EXECUÇÃO] ANTES: Baralho {cor_carta}/{carta_tipo} não existe ou vazio")
                            
                            # CHAMAR A FUNÇÃO DE ADICIONAR
                            print(f"DEBUG: [VENDA EXECUÇÃO] Chamando store_window.adicionar_carta_ao_baralho()")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Parâmetros: carta_path={os.path.basename(carta_path)}, carta_tipo={carta_tipo}, carta_cor={cor_carta}")
                            
                            # CORREÇÃO ADICIONAL: Verificar se a função existe e chamá-la com try/except
                            try:
                                store_window.adicionar_carta_ao_baralho(carta_path, carta_tipo, cor_carta)
                                print(f"DEBUG: [VENDA EXECUÇÃO] adicionar_carta_ao_baralho executada COM SUCESSO")
                            except Exception as e:
                                print(f"DEBUG: [VENDA EXECUÇÃO] ERRO ao chamar adicionar_carta_ao_baralho: {e}")
                                # Fallback manual de sincronização
                                print(f"DEBUG: [VENDA EXECUÇÃO] Executando sincronização manual...")
                                if hasattr(store_window, 'cartas'):
                                    if cor_carta not in store_window.cartas:
                                        store_window.cartas[cor_carta] = {}
                                    if carta_tipo not in store_window.cartas[cor_carta]:
                                        store_window.cartas[cor_carta][carta_tipo] = []
                                    if carta_path not in store_window.cartas[cor_carta][carta_tipo]:
                                        store_window.cartas[cor_carta][carta_tipo].append(carta_path)
                                        print(f"DEBUG: [VENDA EXECUÇÃO] Carta adicionada manualmente ao baralho local")
                                    
                                    # Sincronização com baralho global
                                    try:
                                        from Store_v2 import baralhos
                                        if baralhos and cor_carta in baralhos and carta_tipo in baralhos[cor_carta]:
                                            if carta_path not in baralhos[cor_carta][carta_tipo]:
                                                baralhos[cor_carta][carta_tipo].append(carta_path)
                                                print(f"DEBUG: [VENDA EXECUÇÃO] Carta adicionada manualmente ao baralho global")
                                    except Exception as global_sync_error:
                                        print(f"DEBUG: [VENDA EXECUÇÃO] Erro na sincronização global: {global_sync_error}")
                            
                            
                            # Estado DEPOIS da adição
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_depois = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECUÇÃO] DEPOIS: {cartas_depois} cartas de {carta_tipo} na cor {cor_carta}")
                                
                                # Verificar se a carta específica está lá
                                carta_encontrada = carta_path in store_window.cartas[cor_carta][carta_tipo]
                                print(f"DEBUG: [VENDA EXECUÇÃO] Carta {os.path.basename(carta_path)} encontrada no baralho: {carta_encontrada}")
                                
                                # Listar algumas cartas para debug
                                cartas_sample = [os.path.basename(c) for c in store_window.cartas[cor_carta][carta_tipo][-3:]]
                                print(f"DEBUG: [VENDA EXECUÇÃO] Últimas 3 cartas no baralho: {cartas_sample}")
                            else:
                                print(f"DEBUG: [VENDA EXECUÇÃO] DEPOIS: Baralho {cor_carta}/{carta_tipo} ainda não existe!")
                            
                            print(f"DEBUG: [VENDA EXECUÇÃO] ===== ADIÇÃO CONCLUÍDA =====")
                        else:
                            print(f"DEBUG: [VENDA EXECUÇÃO] ERRO: Store não tem método adicionar_carta_ao_baralho")
                
                # Remove carta do inventário do Player
                if carta_tipo in self.inventario and carta_path in self.inventario[carta_tipo]:
                    self.inventario[carta_tipo].remove(carta_path)
                    print(f"DEBUG: Carta removida do inventário do Player: {carta_path}")
                
                print(f"DEBUG: Venda confirmada - Player saldo: {self.saldo}")
                
                # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
                # Se viemos de um inventário Activities/Challenges conjunto, voltar para esse
                if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                    print("DEBUG: Voltando para inventário conjunto Activities/Challenges")
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORREÇÃO: Verificar se a página ainda é válida após a venda
                    cartas_totais = []
                    for t in self._tipos_venda:
                        cartas_totais += self.inventario.get(t, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                    # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_matrix_carrossel com tipos: {self._tipos_venda}, page: {current_page}")
                    self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
                else:
                    print("DEBUG: Voltando para inventário do tipo específico")
                    # Caso normal: voltar para inventário do tipo específico
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORREÇÃO: Verificar se a página ainda é válida após a venda
                    cartas_restantes = self.inventario.get(carta_tipo, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_restantes) + cards_per_page - 1) // cards_per_page) if cartas_restantes else 1
                    # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas restantes: {len(cartas_restantes)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_for_sell_after_sale com carta_tipo: {carta_tipo}, page: {current_page}")
                    # IMPORTANTE: Usar versão especial que ignora verificações de casa para voltar após venda
                    self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
                
                # Limpar variáveis de controle
                self._origem_venda = None
                self._tipos_venda = None
                self._page_venda = None
                self._current_sell_page = None
                self._inventario_conjunto = None
                
                print("DEBUG: Venda confirmada com sucesso - limpeza concluída")
                
            except Exception as e:
                print(f"DEBUG: ERRO na confirmação: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, tentar voltar à interface principal
                try:
                    print("DEBUG: Tentando voltar à interface principal após erro")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar venda - carta_tipo: {carta_tipo}")
            
            # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
            # Se viemos de um inventário Activities/Challenges conjunto, voltar para esse
            if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                print("DEBUG: Voltando para inventário conjunto Activities/Challenges")
                current_page = getattr(self, '_current_sell_page', 0)
                # CORREÇÃO: Verificar se a página ainda é válida (mesmo sem venda, por segurança)
                cartas_totais = []
                for t in self._tipos_venda:
                    cartas_totais += self.inventario.get(t, [])
                cards_per_page = 4
                total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                if current_page is None:
                    current_page = 0
                if total_pages is None:
                    total_pages = 1
                current_page = min(current_page, total_pages - 1)
                print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
            else:
                # Caso normal: voltar para inventário do tipo específico
                current_page = getattr(self, '_current_sell_page', 0)
                # IMPORTANTE: Garantir que current_page é um número válido
                if current_page is None:
                    current_page = 0
                # IMPORTANTE: Para cancelamento, usar função normal que mostra todas as cartas
                print(f"DEBUG: Cancelamento - chamando show_inventory_for_sell normal com carta_tipo: {carta_tipo}, page: {current_page}")
                self.show_inventory_for_sell(carta_tipo, store_window, current_page)
            
            # Limpar variáveis de controle
            self._origem_venda = None
            self._tipos_venda = None
            self._page_venda = None
            self._current_sell_page = None
            self._inventario_conjunto = None
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação criados - Yes e No")
        print(f"DEBUG: Função confirmar configurada: {confirmar}")
        print(f"DEBUG: Função cancelar configurada: {cancelar}")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_activation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma página de confirmação para ativação de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirmação de ativação para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Activation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text="Do you want to activate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando ativação da carta {carta_path}")
            try:
                # Ativar a carta
                self.activate_card(carta_tipo, carta_path)
                
                # Recriar a TopBar antes de voltar ao inventário
                screen_width = self.winfo_screenwidth()
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                try:
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: TopBar recriada após confirmar ativação")
                except Exception as e:
                    print(f"DEBUG: Erro ao recriar TopBar: {e}")
                
                # Voltar para a página de inventário
                self.show_inventory_matrix(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar ativação: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o inventário
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada após erro na ativação")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar após erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar ativação - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao inventário
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada após cancelar ativação")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação de ativação criados - Yes e No")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_deactivation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma página de confirmação para desativação de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirmação de desativação para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Deactivation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text="Do you want to deactivate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando desativação da carta {carta_path}")
            try:
                # Desativar a carta
                self.deactivate_card(carta_path, carta_tipo)
                
                # Recriar a TopBar antes de voltar ao inventário
                screen_width = self.winfo_screenwidth()
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                try:
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: TopBar recriada após confirmar desativação")
                except Exception as e:
                    print(f"DEBUG: Erro ao recriar TopBar: {e}")
                
                # Voltar para a página de inventário
                self.show_inventory_matrix(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar desativação: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o inventário
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada após erro na desativação")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar após erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar desativação - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao inventário
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada após cancelar desativação")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação de desativação criados - Yes e No")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_remove_router_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para remoção de router no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Mostrando confirmação de remoção do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Do you want to remove the router {router_id}?"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Confirmando remoção do router {router_id}")
            try:
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido do inventário")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (página de inventário de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao enviar router para Store: {e}")
                    
                    # Verificar se há links ativos com o mesmo specific_id
                    links_ativos_mesmo_id = self._find_active_links_with_same_id(router_id)
                    
                    if links_ativos_mesmo_id:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Links ativos encontrados com ID {router_id}: {len(links_ativos_mesmo_id)}")
                        # Manter contexto ativo para remoção de links
                        self._in_remove_router_context = True
                        # Adicionar flag específica para indicar que estamos agora removendo links
                        self._removing_associated_links = True
                        self._router_id_being_removed = router_id
                        # Voltar ao inventário de equipments para remover links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Nenhum link ativo encontrado com ID {router_id}")
                        # Limpar flag do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        # Voltar à interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Voltando à interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO: Router não encontrado no inventário")
                    # Em caso de erro, voltar ao inventário
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao confirmar remoção: {e}")
                # Em caso de erro, voltar ao inventário
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Cancelando remoção do router")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Botões No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Overlay de confirmação de remoção criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_router_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para upgrade de router no contexto ROUTER UPGRADE"""
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Mostrando confirmação de upgrade do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Confirmando upgrade do router {router_id}")
            try:
                # Mapeamento: Small Router -> Medium Router
                equipment_mapping = {
                    1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
                    2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
                    3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
                }
                
                if router_id not in equipment_mapping:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Router ID {router_id} não suportado")
                    return
                
                small_router, medium_router = equipment_mapping[router_id]
                
                # Verificar se o jogador já tem o Medium Router correspondente no inventário
                equipments_inventory = self.inventario.get("equipments", [])
                medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
                
                if medium_router_exists:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ❌ {medium_router} já existe no inventário - upgrade não aplicado")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Small Router do inventário e ativos
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido do inventário")
                    
                    # Remover da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido da lista de equipments ativos")
                    
                    # Construir caminho para Medium Router (usar mesma estrutura de diretório)
                    base_dir = os.path.dirname(carta_path)
                    medium_router_path = os.path.join(base_dir, medium_router)
                    
                    # Adicionar Medium Router ao inventário (virado para baixo)
                    self.inventario["equipments"].append(medium_router_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] {medium_router} adicionado ao inventário (virado para baixo)")
                    
                    # Enviar Small Router para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao enviar Small Router para Store: {e}")
                    
                    # Limpar flags do contexto ROUTER UPGRADE
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    
                    # Voltar à página de inventário de Equipments
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ✅ Router Upgrade aplicado com sucesso!")
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Voltando à página de inventário de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERRO: Small Router não encontrado no inventário")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao confirmar upgrade: {e}")
                # Limpar flags e voltar à página de inventário de Equipments
                self._in_router_upgrade_context = False
                self._router_upgrade_target_id = None
                # REABILITAR BOTÃO BACK quando Ok é clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Overlay de confirmação de upgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_router_downgrade_confirmation(self, router_id):
        """Mostra confirmação específica para downgrade de router no contexto ROUTER DOWNGRADE"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Mostrando confirmação de downgrade do Router ID: {router_id}")
        
        # Salvar estado antes de limpar widgets
        self._save_dashboard_state()
        
        # Obter carta Equipment que está sendo processada para downgrade
        carta_path = None
        try:
            # Mapear router_id para carta Equipment correspondente
            router_to_equipment = {
                1: "Equipment_4.png",  # Medium Router 1
                2: "Equipment_5.png",  # Medium Router 2  
                3: "Equipment_6.png",  # Medium Router 3
            }
            
            if router_id in router_to_equipment:
                equipment_filename = router_to_equipment[router_id]
                # Encontrar caminho completo da carta no inventário
                for eq_path in self.inventario.get("equipments", []):
                    if os.path.basename(eq_path) == equipment_filename:
                        carta_path = eq_path
                        break
                        
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta encontrada para fundo: {carta_path}")
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao obter carta para fundo: {e}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (similar ao overlay de upgrade)
        if carta_path and os.path.exists(carta_path):
            try:
                carta_img = Image.open(carta_path)
                screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                
                # Calcular o ratio para ocupar o máximo possível da tela
                ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                carta_photo = ImageTk.PhotoImage(carta_resized)
                
                # Label com a imagem da carta como fundo
                carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                carta_label.image = carta_photo  # Manter referência
                carta_label.place(relx=0.5, rely=0.5, anchor="center")
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta carregada como fundo: {os.path.basename(carta_path)}")
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
                self.config(bg="black")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Nenhuma carta encontrada para fundo, usando fundo preto")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Confirmando downgrade do router {router_id}")
            try:
                # Processar efetivamente o downgrade
                self._processar_router_downgrade(router_id)
                
                # CORREÇÃO CRÍTICA: Limpar flags do contexto ROUTER DOWNGRADE ANTES de abrir inventário
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Limpando flags de contexto...")
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] ✅ Router Downgrade aplicado com sucesso!")
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Voltando ao inventário normal de equipamentos")
                
                # CORREÇÃO: Voltar ao inventário normal de equipments (não específico para downgrade)
                # Isso garante que o botão Back e botões de ativação/desativação funcionem normalmente
                self.show_inventory_matrix(["equipments"])
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar ao dashboard principal
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Overlay de confirmação de downgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_remove_link_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para remoção de link no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Mostrando confirmação de remoção do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Do you want to remove the link {link_id}?"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Confirmando remoção do link {link_id}")
            try:
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido do inventário")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (página de inventário de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao enviar link para Store: {e}")
                    
                    # Verificar se há mais links ativos com o mesmo ID
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    links_restantes = self._find_active_links_with_same_id(router_id_being_removed) if router_id_being_removed else []
                    
                    if links_restantes:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Ainda há {len(links_restantes)} link(s) ativo(s) com ID {router_id_being_removed}")
                        # Continuar no contexto de remoção de links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Todos os links com ID {router_id_being_removed} foram removidos")
                        # Limpar flags do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        self._removing_associated_links = False
                        self._router_id_being_removed = None
                        # Voltar à interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Voltando à interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] ERRO: Link não encontrado no inventário")
                    # Em caso de erro, voltar ao inventário
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao confirmar remoção: {e}")
                # Em caso de erro, voltar ao inventário
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Cancelando remoção do link")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Botões No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao_link)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao_link)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Overlay de confirmação de remoção de link criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def _find_active_links_with_same_id(self, router_id):
        """Encontra links ativos com o mesmo specific_id do router removido"""
        try:
            links_ativos = []
            
            # Verificar equipments ativos
            for carta_path in self.active_equipments:
                if self._is_link_card(carta_path):
                    link_id = self._get_equipment_specific_id(carta_path)
                    if str(link_id) == str(router_id):
                        links_ativos.append(carta_path)
                        print(f"DEBUG: [FIND_ACTIVE_LINKS] Link ativo encontrado: {os.path.basename(carta_path)} com ID {link_id}")
            
            return links_ativos
        except Exception as e:
            print(f"DEBUG: [FIND_ACTIVE_LINKS] Erro ao procurar links ativos: {e}")
            return []

    def _is_link_card(self, carta_path):
        """Verifica se uma carta é do tipo Link (Short Link ou Long Link)"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_7.png" -> "equipment_7")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    equipment_id = f"equipment_{match.group(1)}"
                    equipment_card = self.card_database.get_equipment(equipment_id)
                    
                    if equipment_card:
                        return equipment_card.category == "Link"
            
            # Fallback: verificar pelo número da carta
            # Equipment_7 a Equipment_12 são Links
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                return 7 <= card_num <= 12
                
        except Exception as e:
            print(f"DEBUG: [IS_LINK_CARD] Erro ao verificar se carta é link: {e}")
        
        return False

    def _get_equipment_specific_id(self, carta_path):
        """Obtém o specific_id de uma carta de equipment da base de dados"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_2.png" -> "2")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    card_num = int(match.group(1))
                    
                    # Mapear número da carta para equipment_id na base de dados
                    if 1 <= card_num <= 3:
                        # Small Router
                        equipment_id = f"small_router_{card_num}_red"  # Usar cor genérica
                    elif 4 <= card_num <= 6:
                        # Medium Router
                        equipment_id = f"medium_router_{card_num-3}_red"  # Usar cor genérica
                    elif 7 <= card_num <= 9:
                        # Short Link
                        equipment_id = f"short_link_{card_num-6}_red"  # Usar cor genérica
                    elif 10 <= card_num <= 12:
                        # Long Link
                        equipment_id = f"long_link_{card_num-9}_red"  # Usar cor genérica
                    else:
                        equipment_id = None
                    
                    if equipment_id:
                        equipment_card = self.card_database.get_equipment(equipment_id)
                        
                        if equipment_card:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment {equipment_id} specific_id: {equipment_card.specific_id}")
                            return equipment_card.specific_id
                        else:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment não encontrado na base de dados: {equipment_id}")
                    else:
                        print(f"DEBUG: [SPECIFIC_ID] Número de carta inválido: {card_num}")
                else:
                    print(f"DEBUG: [SPECIFIC_ID] Erro ao extrair ID do filename: {filename}")
        except Exception as e:
            print(f"DEBUG: [SPECIFIC_ID] Erro ao obter specific_id: {e}")
        
        # Fallback: extrair specific_id baseado no número da carta
        try:
            import re
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                # Calcular specific_id baseado no mapeamento
                if 1 <= card_num <= 3:
                    return card_num  # Small Router: 1, 2, 3
                elif 4 <= card_num <= 6:
                    return card_num - 3  # Medium Router: 1, 2, 3
                elif 7 <= card_num <= 9:
                    return card_num - 6  # Short Link: 1, 2, 3
                elif 10 <= card_num <= 12:
                    return card_num - 9  # Long Link: 1, 2, 3
        except:
            pass
        
        return "N/A"

    def _voltar_ao_inventario_equipments(self, tipos, page):
        """Método auxiliar para voltar ao inventário de equipments com TopBar"""
        try:
            # Recriar a TopBar
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [REMOVE_ROUTER_CONFIRM] TopBar recriada")
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO CRÍTICO no fallback: {e}")
            # Última tentativa: voltar à interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    # Corrigir aceitação de carta Challenge/Activity para adicionar ao carrossel
    def aceitar_carta_challenge_activity(self, carta_path, carta_tipo):
        # Chamar isto ao aceitar uma carta Challenge/Activity
        self.adicionar_carta_carrossel(carta_path, carta_tipo)
        # ... resto do fluxo de aceitação ...
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_link_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para upgrade de link no contexto LINK UPGRADE"""
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Mostrando confirmação de upgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Confirmando upgrade do link {link_id}")
            try:
                # Mapeamento: Long Link -> Short Link
                equipment_mapping = {
                    1: ("Equipment_10.png", "Equipment_7.png"),  # Long Link 1 -> Short Link 1
                    2: ("Equipment_11.png", "Equipment_8.png"),  # Long Link 2 -> Short Link 2
                    3: ("Equipment_12.png", "Equipment_9.png"),  # Long Link 3 -> Short Link 3
                }
                
                if link_id not in equipment_mapping:
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Link ID {link_id} não suportado")
                    return
                
                long_link, short_link = equipment_mapping[link_id]
                
                # Verificar se o jogador já tem o Short Link correspondente no inventário
                equipments_inventory = self.inventario.get("equipments", [])
                short_link_exists = any(os.path.basename(eq) == short_link for eq in equipments_inventory)
                
                if short_link_exists:
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] ❌ {short_link} já existe no inventário - upgrade não aplicado")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_upgrade_context = False
                    self._link_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Long Link do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Long Link removido do inventário")
                    
                    # Construir caminho para Short Link (usar mesma estrutura de diretório)
                    base_dir = os.path.dirname(carta_path)
                    short_link_path = os.path.join(base_dir, short_link)
                    
                    # Adicionar Short Link ao inventário (fica inativo por padrão)
                    self.inventario["equipments"].append(short_link_path)
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] {short_link} adicionado ao inventário (inativo)")
                    
                    # Enviar Long Link para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Long Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Erro ao enviar Long Link para Store: {e}")
                    
                    # Limpar flags do contexto LINK UPGRADE
                    self._in_link_upgrade_context = False
                    self._link_upgrade_target_id = None
                    
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    
                    # Voltar à página de inventário de Equipments
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] ✅ Link Upgrade aplicado com sucesso!")
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Voltando à página de inventário de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [LINK_UPGRADE_CONFIRM] ERRO: Long Link não encontrado no inventário")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_upgrade_context = False
                    self._link_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Erro ao confirmar upgrade: {e}")
                # Limpar flags e voltar à página de inventário de Equipments
                self._in_link_upgrade_context = False
                self._link_upgrade_target_id = None
                # REABILITAR BOTÃO BACK quando Ok é clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [LINK_UPGRADE] Botão Back REABILITADO após clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Overlay de confirmação de upgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_link_downgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para downgrade de link no contexto LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Mostrando confirmação de downgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Confirmando downgrade do link {link_id}")
            try:
                # Mapeamento: Short Link -> Long Link
                equipment_mapping = {
                    1: ("Equipment_7.png", "Equipment_10.png"),   # Short Link 1 -> Long Link 1
                    2: ("Equipment_8.png", "Equipment_11.png"),   # Short Link 2 -> Long Link 2
                    3: ("Equipment_9.png", "Equipment_12.png"),   # Short Link 3 -> Long Link 3
                }
                
                if link_id not in equipment_mapping:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Link ID {link_id} não suportado")
                    return
                
                short_link, long_link = equipment_mapping[link_id]
                
                # Verificar se o jogador já tem o Long Link correspondente no inventário
                equipments_inventory = self.inventario.get("equipments", [])
                long_link_exists = any(os.path.basename(eq) == long_link for eq in equipments_inventory)
                
                if long_link_exists:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ❌ {long_link} já existe no inventário - downgrade não aplicado")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Short Link do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link removido do inventário")
                    
                    # Construir caminho para Long Link (usar mesma estrutura de diretório)
                    base_dir = os.path.dirname(carta_path)
                    long_link_path = os.path.join(base_dir, long_link)
                    
                    # Adicionar Long Link ao inventário (fica inativo por padrão)
                    self.inventario["equipments"].append(long_link_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] {long_link} adicionado ao inventário (inativo)")
                    
                    # Enviar Short Link para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao enviar Short Link para Store: {e}")
                    
                    # Limpar flags do contexto LINK DOWNGRADE
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    
                    # Voltar à página de inventário de Equipments
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ✅ Link Downgrade aplicado com sucesso!")
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Voltando à página de inventário de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ERRO: Short Link não encontrado no inventário")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar à página de inventário de Equipments
                self._in_link_downgrade_context = False
                self._link_downgrade_target_id = None
                # REABILITAR BOTÃO BACK quando Ok é clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Overlay de confirmação de downgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    # Corrigir fullscreen do carrossel: botão X volta sempre à interface principal
    def show_card_fullscreen_carrossel(self, carta_path):
        print(f"DEBUG: [FULLSCREEN] === FUNÇÃO show_card_fullscreen_carrossel CHAMADA ===")
        print(f"DEBUG: [FULLSCREEN] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [FULLSCREEN] Caminho completo: {carta_path}")
        
        # CORREÇÃO CRÍTICA: Salvar estado da interface ANTES de destruir widgets
        print(f"DEBUG: [FULLSCREEN] === SALVANDO ESTADO ANTES DE FULLSCREEN ===")
        self._save_dashboard_state()
        
        # Preservar valores das barras de progresso ANTES de destruir os widgets
        saved_progress_values = {}
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            try:
                for stat in self.progress_bars:
                    # Verificar se o widget ainda existe antes de acessar seus valores
                    if self.progress_bars[stat].winfo_exists():
                        saved_progress_values[stat] = {
                            'value': self.progress_bars[stat]['value'],
                            'maximum': self.progress_bars[stat]['maximum']
                        }
                print(f"DEBUG: Valores das barras preservados antes de fullscreen: {saved_progress_values}")
            except Exception as e:
                print(f"DEBUG: Erro ao preservar valores das barras: {e}")
        
        # CORREÇÃO CRÍTICA: Usar estado salvo da dashboard em vez de verificar widgets atuais
        # Os widgets podem ter sido recriados ou removidos entre o salvamento do estado e o fullscreen
        botoes_plus_visiveis = {
            'rxd_visivel': False,
            'lost_visivel': False
        }
        botao_seta_visivel = False
        
        # Verificar se temos estado salvo da dashboard
        if hasattr(self, '_saved_dashboard_state'):
            state = self._saved_dashboard_state
            controles_estavam_visiveis = state.get('controles_gestao_visiveis', False)
            seta_estava_visivel = state.get('botao_seta_visivel', False)
            
            # NOVA LÓGICA: Usar flags específicas dos botões se disponíveis
            btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
            btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [FULLSCREEN] Estado salvo da dashboard:")
            print(f"DEBUG: [FULLSCREEN]   controles_gestao_visiveis: {controles_estavam_visiveis}")
            print(f"DEBUG: [FULLSCREEN]   botao_seta_visivel: {seta_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_seta_visivel: {btn_seta_estava_visivel}")
            
            # Priorizar flags específicas sobre flags genéricas
            if btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel:
                botoes_plus_visiveis = {
                    'rxd_visivel': btn_plus_rxd_estava_visivel,
                    'lost_visivel': btn_plus_lost_estava_visivel
                }
                print(f"DEBUG: [FULLSCREEN] Usando flags específicas dos botões +")
            elif controles_estavam_visiveis:
                # Fallback para lógica anterior
                botoes_plus_visiveis = {
                    'rxd_visivel': True,
                    'lost_visivel': True
                }
                print(f"DEBUG: [FULLSCREEN] Usando flag genérica - assumindo ambos os botões + ativos")
            
            # Para botão seta, priorizar flag específica
            if btn_seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível (flag específica)")
            elif seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível (flag genérica)")
        else:
            print(f"DEBUG: [FULLSCREEN] ⚠️ Estado da dashboard não encontrado - usando detecção de widgets atual")
            # Fallback para detecção atual se não temos estado salvo
            botoes_plus_visiveis = {
                'rxd_visivel': hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None and self._btn_plus_rxd.winfo_exists(),
                'lost_visivel': hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None and self._btn_plus_lost.winfo_exists()
            }
            botao_seta_visivel = hasattr(self, '_btn_seta') and self._btn_seta is not None and self._btn_seta.winfo_exists()
        
        print(f"DEBUG: [FULLSCREEN] Estado FINAL dos botões + preservado: {botoes_plus_visiveis}")
        print(f"DEBUG: [FULLSCREEN] Estado FINAL do botão seta preservado: {botao_seta_visivel}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X para fechar - canto superior esquerdo (cinza)
        def voltar_dashboard():
            print(f"DEBUG: [FULLSCREEN X] Iniciando retorno do fullscreen para dashboard")
            print(f"DEBUG: [FULLSCREEN X] Estado preservado: gestao_ativa={getattr(self, '_final_phase_gestao_ativa', False)}")
            
            # Preservar seleção da carta do carrossel ao voltar do fullscreen
            selected_carta = getattr(self, 'selected_carousel_card', None)
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [FULLSCREEN X] Recriando interface principal...")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # Restaurar seleção da carta após recriar interface
            if selected_carta is not None and selected_index is not None:
                self.selected_carousel_card = selected_carta
                self.selected_carousel_index = selected_index
                print(f"DEBUG: [FULLSCREEN X] Seleção da carta restaurada: índice {selected_index}")
            
            # RESTAURAR ESTADO USANDO O SISTEMA NOVO DE CAPTURA IMEDIATA
            print(f"DEBUG: [FULLSCREEN X] Chamando _restore_dashboard_state()...")
            self._restore_dashboard_state()
            
            # Restaurar valores das barras de progresso após recriar interface
            if saved_progress_values and hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                for stat, values in saved_progress_values.items():
                    if stat in self.progress_bars and stat in self.progress_labels:
                        self.progress_bars[stat]['maximum'] = values['maximum']
                        self.progress_bars[stat]['value'] = values['value']
                        self.progress_labels[stat]['text'] = str(int(values['value']))
                print(f"DEBUG: [FULLSCREEN X] Valores das barras restaurados: {saved_progress_values}")
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_dashboard, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão Switch no canto superior direito com imagem switch_card.png
        # SÓ APARECE EM ACTIVITIES/CHALLENGES DURANTE NEXT PHASE (MAS NÃO DURANTE FINAL PHASE)
        # CORREÇÃO PROBLEMA 2: Verificar tipo da carta para restringir funcionalidade
        switch_btn = None
        
        # Verificar se é uma carta de Activity ou Challenge
        carta_name = os.path.basename(carta_path).lower()
        is_activity_or_challenge = ("activity" in carta_name or "challenge" in carta_name)
        is_activity_card = "activity" in carta_name
        is_challenge_card = "challenge" in carta_name
        next_phase_active = getattr(self, '_next_phase_active', False)
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICAÇÃO BOTÃO SWITCH ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] carta_name: {carta_name}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] final_phase_active: {final_phase_active}")
        
        # NOVA VERIFICAÇÃO: Verificar se há cartas disponíveis para troca no inventário
        has_available_cards_for_switch = False
        if is_activity_or_challenge and next_phase_active and not final_phase_active:
            # CORREÇÃO: Para Activities no carrossel, verificar se há outras Activities no inventário
            # Activity só pode trocar com Activity quando NÃO há Challenges no inventário
            if is_activity_card:
                activity_cards = self.inventario.get("activities", [])
                challenge_cards = self.inventario.get("challenges", [])
                # APLICAR MESMA RESTRIÇÃO: Activity NÃO pode trocar se há Challenges no inventário
                if len(challenge_cards) > 0:
                    has_available_cards_for_switch = False
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - NÃO pode trocar: há {len(challenge_cards)} Challenges no inventário (restrição Activity→Activity)")
                else:
                    has_available_cards_for_switch = len(activity_cards) > 0
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - pode trocar: {len(activity_cards)} Activities no inventário, 0 Challenges")
            
            # CORREÇÃO CRÍTICA: Para Challenges no carrossel, verificar se há OUTRAS CHALLENGES no inventário
            # Challenge só pode trocar com outra Challenge
            elif is_challenge_card:
                challenge_cards = self.inventario.get("challenges", [])
                has_available_cards_for_switch = len(challenge_cards) > 0
                print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge card - Challenges no inventário: {len(challenge_cards)}, pode trocar: {has_available_cards_for_switch}")
        
        # RESTRIÇÃO: No Next Phase, só Activities podem ser trocadas (Challenges não)
        # Challenges no carrossel devem ser apenas visualizadas, não trocadas
        # MODIFICAÇÃO: Mostrar switch para Challenges também, mas com funcionalidade limitada
        # NOVA RESTRIÇÃO: Só mostrar switch se há cartas disponíveis para troca
        should_show_switch = (is_activity_or_challenge and next_phase_active and 
                            not final_phase_active and has_available_cards_for_switch)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] has_available_cards_for_switch: {has_available_cards_for_switch}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] should_show_switch: {should_show_switch}")
        
        # Durante Final Phase, não mostrar botão Switch
        # Durante Next Phase, só mostrar para Activities (não para Challenges)
        if should_show_switch:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    switch_btn = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    switch_btn.image = switch_img  # Manter referência
                    
                    # NOVA FUNCIONALIDADE: Mover switch para canto inferior direito se é Challenge (máximo canto)
                    if is_challenge_card:
                        switch_btn.place(relx=1.0, rely=1.0, anchor="se")  # Canto inferior direito (máximo canto possível)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] ✅ Botão Switch posicionado no canto inferior direito (Challenge - máximo canto)")
                    else:
                        switch_btn.place(relx=0.98, rely=0, anchor="ne")  # Canto superior direito (Activity)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] ✅ Botão Switch posicionado no canto superior direito (Activity)")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - imagem switch_card.png não encontrada em {switch_img_path}")
            except Exception as e:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - erro ao carregar imagem: {e}")
        else:
            if not has_available_cards_for_switch:
                if is_challenge_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - Não há Activities no inventário para trocar")
                elif is_activity_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - Não há Challenges no inventário para trocar")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - Carta não é Activity nem Challenge")
            elif is_challenge_card and next_phase_active:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - Challenge não pode ser trocada no Next Phase")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ❌ Botão Switch NÃO criado - condições não atendidas")
        
        # Configurar comando do botão Switch (abrir inventário para troca)
        def abrir_inventario_troca():
            # CORREÇÃO PROBLEMA 2: Verificações de segurança adicionais
            print(f"DEBUG: [abrir_inventario_troca] Iniciando verificações para carta: {os.path.basename(carta_path)}")
            
            # Verificar se a carta atual não é uma carta virada para baixo
            if "back_card" in os.path.basename(carta_path).lower():
                print("DEBUG: [abrir_inventario_troca] ❌ Não é possível trocar uma carta virada para baixo")
                return
            
            # NOVA VERIFICAÇÃO: Só permitir troca se for Activity
            carta_basename = os.path.basename(carta_path).lower()
            if "challenge" in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ❌ Challenges do carrossel não podem ser trocadas no Next Phase")
                return
            
            if "activity" not in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ❌ Só Activities podem ser trocadas")
                return
            
            # Verificar se Next Phase está ativo
            if not getattr(self, '_next_phase_active', False):
                print("DEBUG: [abrir_inventario_troca] ❌ Troca só permitida durante Next Phase")
                return
            
            print(f"DEBUG: [abrir_inventario_troca] ✅ Verificações passaram - abrindo inventário para troca")
            
            # Guardar a carta atual do carrossel para troca
            self.carta_carrossel_para_troca = carta_path
            # Encontrar o índice da carta no carrossel
            try:
                self.carrossel_idx_selecao = self.cards.index(carta_path)
                print(f"DEBUG: [abrir_inventario_troca] Carta encontrada no carrossel índice: {self.carrossel_idx_selecao}")
            except ValueError:
                print(f"DEBUG: [abrir_inventario_troca] ⚠️  Carta não encontrada no carrossel - usando índice 0")
                self.carrossel_idx_selecao = 0
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        
        if switch_btn is not None:
            switch_btn.config(command=abrir_inventario_troca)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] ✅ Botão Switch configurado para abrir inventário de troca")
        
        # NOVA FUNCIONALIDADE: Botão Quit Challenge (canto superior direito, vermelho com unicode ✓)
        # CORREÇÃO: Se Challenge na Final Phase, mostrar botão completion em vez de quit
        quit_btn = None
        
        # Verificar se Challenge atingiu Final Phase (n_turns completos)
        challenge_na_final_phase = False
        if is_challenge_card:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge detectado - verificando Final Phase")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] === ESTADO COMPLETO DO SISTEMA ===")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge path: {carta_path}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge basename: {os.path.basename(carta_path)}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _current_turn_number: {self._current_turn_number}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _challenge_start_turns: {self._challenge_start_turns}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] dados_carta retornados: {dados_carta}")
            
            if dados_carta:
                n_turns = dados_carta.get('n_turns', 0)
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns da carta extraído: {n_turns}")
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns tipo: {type(n_turns)}")
                
                if n_turns > 0:
                    # Verificar quantos turnos passaram desde que foi ativada
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === CALCULANDO TURNOS DECORRIDOS ===")
                    turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed retornado: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed tipo: {type(turns_elapsed)}")
                    
                    # COMPARAÇÃO CRÍTICA
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === COMPARAÇÃO CRÍTICA ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed >= n_turns: {turns_elapsed >= n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed > 1: {turns_elapsed > 1}")
                    
                    # CORREÇÃO: Overlay só aparece quando completar n_turns E não estar no turno de ativação
                    challenge_na_final_phase = (turns_elapsed >= n_turns) and (turns_elapsed > 1)
                    
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICAÇÃO FINAL PHASE CHALLENGE ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge: {os.path.basename(carta_path)}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns limite: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase (calculado): {challenge_na_final_phase}")
                    
                    # DETALHES ADICIONAIS PARA DEBUG
                    if carta_path in self._challenge_start_turns:
                        start_turn = self._challenge_start_turns[carta_path]
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Registo encontrado - Start turn: {start_turn}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Cálculo: {self._current_turn_number} - {start_turn} + 1 = {turns_elapsed}")
                    else:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] ⚠️ SEM REGISTO DE INÍCIO - usando turno padrão")
                    
                    # EXEMPLOS ESPECÍFICOS PARA DEBUG
                    if "Challenge_12" in os.path.basename(carta_path) and n_turns == 2:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_12 (n_turns=2) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 2")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Está na Final Phase? {challenge_na_final_phase}")
                    
                    if "Challenge_13" in os.path.basename(carta_path) and n_turns == 4:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_13 (n_turns=4) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 4")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Está na Final Phase? {challenge_na_final_phase}")
                    
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge sem n_turns válido ({n_turns})")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] Não foi possível obter dados da carta Challenge")
        else:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Não é uma carta Challenge")
        
        # CORREÇÃO: Remover completamente todos os botões Challenge no fullscreen
        # Os botões roxos (→) foram removidos conforme solicitado pelo utilizador
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === BOTÕES CHALLENGE REMOVIDOS ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase: {challenge_na_final_phase}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] ✅ Todos os botões Challenge foram removidos do fullscreen")

    # --- Carrossel: começa vazio e só adiciona Activities/Challenges aceites ---
    def adicionar_carta_carrossel(self, carta_path, carta_tipo):
        if carta_tipo in ["activities", "challenges"] and carta_path not in self.carrossel:
            self.carrossel.append(carta_path)
            
            # REGISTRO TEMPORAL: Se for Challenge, registar turno de início
            if carta_tipo == "challenges":
                self._register_challenge_start_turn(carta_path)
            
            self.atualizar_carrossel()

    def atualizar_carrossel(self):
        # Atualiza o carrossel para mostrar apenas as cartas em self.carrossel
        # (Implementação depende do teu método atual, mas deve usar self.carrossel)
        pass

    # No método onde o jogador aceita uma carta de Activities ou Challenges:
    # Chamar self.adicionar_carta_carrossel(carta_path, carta_tipo)
    
    def _check_user_inventory_for_carousel_access(self):
        """
        Verifica que User IDs o jogador tem no inventário e se estão virados para cima (ativos ou visíveis).
        User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
        Durante Next Phase, só conta cartas User que estejam viradas para cima.
        """
        user_ids = []
        user_cards = self.inventario.get("users", [])
        next_phase_active = getattr(self, '_next_phase_active', False)
        
        for carta_path in user_cards:
            carta_name = os.path.basename(carta_path)
            if carta_name.startswith("User_") and carta_name.endswith(".png"):
                try:
                    # Extrair número do nome: User_2.png -> 2
                    numero_str = carta_name.replace("User_", "").replace(".png", "")
                    numero = int(numero_str)
                    
                    # Verificar se a carta está virada para cima
                    is_face_up = False
                    if numero == 1:
                        # User_1.png sempre virada para cima
                        is_face_up = True
                    elif next_phase_active:
                        # Durante Next Phase, verificar se a carta está ativa (virada para cima)
                        is_face_up = self.is_card_active(carta_path, "users")
                    else:
                        # Antes de Next Phase, todas as cartas (exceto User_1) estão viradas para baixo
                        is_face_up = False
                    
                    # Só adicionar à lista se estiver virada para cima
                    if is_face_up:
                        # User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
                        user_id = numero - 1
                        if user_id >= 1:  # User ID começa em 1
                            user_ids.append(user_id)
                            print(f"DEBUG: User_{numero}.png ATIVO - User ID {user_id} disponível para carrossel")
                    else:
                        print(f"DEBUG: User_{numero}.png INATIVO - User ID não disponível para carrossel")
                        
                except (ValueError, IndexError):
                    continue
        
        # Cache dos User IDs para performance
        self._cached_user_ids = sorted(user_ids)
        print(f"DEBUG: User IDs ativos/visíveis encontrados no inventário: {self._cached_user_ids}")
        return self._cached_user_ids
    
    def _can_access_carousel_position(self, carrossel_idx):
        """
        Verifica se o jogador pode aceder a uma posição específica do carrossel durante Next Phase.
        Só pode clicar numa carta virada para baixo se tiver o User ID correspondente.
        Posição 0 (primeira carta da esquerda) requer User ID 1, posição 1 requer User ID 2, etc.
        """
        if not getattr(self, '_next_phase_active', False):
            # Se Next Phase não está ativo, pode aceder a qualquer posição
            return True
        
        # Durante Next Phase, verificar se tem o User ID necessário
        required_user_id = carrossel_idx + 1  # Posição 0 -> User ID 1, posição 1 -> User ID 2, etc.
        user_ids = self._check_user_inventory_for_carousel_access()
        
        can_access = required_user_id in user_ids
        print(f"DEBUG: Posição {carrossel_idx} requer User ID {required_user_id}, tem acesso: {can_access}")
        return can_access
    
    def _has_valid_carousel_positions(self):
        """
        Verifica se há posições válidas no carrossel onde o jogador pode colocar cartas.
        Durante Next Phase, só pode colocar cartas em posições que correspondem a User IDs ativos.
        """
        next_phase_active = getattr(self, '_next_phase_active', False)
        print(f"DEBUG: [_has_valid_carousel_positions] === INICIANDO VERIFICAÇÃO ===")
        print(f"DEBUG: [_has_valid_carousel_positions] Next Phase ativo: {next_phase_active}")
        
        if not next_phase_active:
            # Se Next Phase não está ativo, sempre pode colocar cartas
            print(f"DEBUG: [_has_valid_carousel_positions] Next Phase INATIVO - retornando True")
            return True
        
        # Durante Next Phase, verificar se há pelo menos uma posição acessível
        user_ids = self._check_user_inventory_for_carousel_access()
        print(f"DEBUG: [_has_valid_carousel_positions] User IDs disponíveis: {user_ids}")
        
        # Verificar se há cartas viradas para baixo em posições com User IDs correspondentes
        valid_positions_found = False
        for i, carta_path in enumerate(self.cards):
            carta_basename = os.path.basename(carta_path)
            is_back_card = carta_basename.startswith("back_card_")
            required_user_id = i + 1  # Posição 0 -> User ID 1, etc.
            has_user_id = required_user_id in user_ids
            
            print(f"DEBUG: [_has_valid_carousel_positions] Pos {i}: '{carta_basename}' -> back_card: {is_back_card}, req_user_id: {required_user_id}, has_user: {has_user_id}")
            
            if is_back_card and has_user_id:
                print(f"DEBUG: [_has_valid_carousel_positions] ✅ Posição {i} VÁLIDA para User ID {required_user_id}")
                valid_positions_found = True
        
        if not valid_positions_found:
            print("DEBUG: [_has_valid_carousel_positions] ❌ NENHUMA posição válida no carrossel")
        
        print(f"DEBUG: [_has_valid_carousel_positions] === RESULTADO: {valid_positions_found} ===")
        return valid_positions_found
    
    def _teste_adicionar_user_cards(self):
        """
        Função de teste para adicionar cartas User/Equipment/Service ao inventário para testar o sistema de ativação.
        Esta função pode ser removida em produção.
        """
        # Simular caminhos de cartas para teste (usar a cor do player)
        color_name = self.player_color.capitalize()  # Red, Blue, Green, Yellow
        
        test_cards = {
            "users": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_2.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_3.png",
            ],
            "equipments": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_2.png",
            ],
            "services": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_2.png",
            ]
        }
        
        # Adicionar ao inventário para teste
        for card_type, card_paths in test_cards.items():
            for carta_path in card_paths:
                if os.path.exists(carta_path) and carta_path not in self.inventario[card_type]:
                    self.inventario[card_type].append(carta_path)
                    print(f"DEBUG: [TESTE] Carta {card_type} adicionada ao inventário: {os.path.basename(carta_path)}")
        
        # Atualizar cache e destaques se necessário
        self._check_user_inventory_for_carousel_access()
        # IMPORTANTE: Só atualizar destaques se estivermos na interface principal e Next Phase estiver ativo
        # Evita erro de widgets destruídos durante transições
        if (getattr(self, '_next_phase_active', False) and 
            hasattr(self, 'card_labels') and 
            self.card_labels and 
            not getattr(self, '_inventory_opening', False)):
            try:
                self._update_carousel_highlights()
            except Exception as e:
                print(f"DEBUG: [TESTE] Erro ao atualizar destaques do carrossel: {e}")
        
        print(f"DEBUG: [TESTE] Inventário atual após adicionar cartas de teste:")
        for tipo, cartas in self.inventario.items():
            if cartas:
                print(f"DEBUG: [TESTE]   {tipo}: {len(cartas)} cartas")
                for carta in cartas[:3]:  # Mostrar primeiras 3
                    print(f"DEBUG: [TESTE]     - {os.path.basename(carta)}")
        
        print(f"DEBUG: [TESTE] Estado inicial das cartas ativas:")
        print(f"DEBUG: [TESTE]   Users ativos: {[os.path.basename(c) for c in self.active_users]} (máx: {self.max_users})")
        print(f"DEBUG: [TESTE]   Equipments ativos: {[os.path.basename(c) for c in self.active_equipments]} (sem limite)")
        print(f"DEBUG: [TESTE]   Services ativos: {[os.path.basename(c) for c in self.active_services]} (sem limite)")
        print(f"DEBUG: [TESTE] NOTA: Ativação só funciona após clicar 'Next Phase'")
        print(f"DEBUG: [TESTE] Inventário Users atual: {[os.path.basename(c) for c in self.inventario['users']]}")
    
    def _update_carousel_highlights(self):
        """
        Atualiza os destaques roxos das cartas do carrossel baseado nos User IDs disponíveis.
        Chama esta função quando Next Phase é ativado ou quando o inventário de Users muda.
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: _update_carousel_highlights - card_labels não existe ou está vazio, saltando atualização")
            return
        
        # Usar a função de seleção que já inclui a lógica de User IDs
        self._update_carousel_selection_highlights()
    
    def _debug_force_highlight_update(self):
        """
        Função de debug para forçar atualização dos destaques do carrossel.
        Útil para testar o sistema manualmente.
        """
        print("DEBUG: [FORÇA] Forçando atualização dos destaques do carrossel...")
        self._check_user_inventory_for_carousel_access()
        self._update_carousel_highlights()
        print("DEBUG: [FORÇA] Atualização dos destaques concluída")



    def abrir_inventario_para_carrossel(self, carrossel_idx):
        # Verificar se estamos numa casa onde podemos vender Activities ou Challenges
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # PROTEÇÃO CONTRA LOOP: Se já estamos a mostrar inventário, não abrir novamente
        if getattr(self, '_inventory_opening', False):
            return
        
        # BLOQUEIO DURANTE FINAL PHASE: Não permite abrir inventário
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Abertura de inventário BLOQUEADA durante Final Phase")
            return
        
        # CONTROLO DE ACESSO DURANTE NEXT PHASE
        if getattr(self, '_next_phase_active', False):
            if not self._can_access_carousel_position(carrossel_idx):
                print(f"DEBUG: Acesso negado à posição {carrossel_idx} do carrossel durante Next Phase")
                return
        
        # IMPORTANTE: Se Next Phase está ativo, sempre abrir inventário no modo Next Phase
        if getattr(self, '_next_phase_active', False):
            print("DEBUG: Next Phase ativo - abrindo inventário no modo Next Phase")
            # Abre o inventário de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        # Se estivermos numa casa Activities ou Challenges E Next Phase NÃO está ativo, mostrar inventário para venda
        elif casa_atual_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Em casa {casa_atual_tipo} - abrindo inventário para venda (Activities + Challenges)")
            self.show_inventory_matrix(["activities", "challenges"], page=0)
        else:
            # CORREÇÃO: Sempre permitir acesso a Activities/Challenges para cartas viradas para baixo
            # mesmo que não esteja numa casa Activities/Challenges - o controlo de venda é feito dentro do inventário
            print("DEBUG: Abrindo inventário Activities/Challenges - acesso sempre permitido para cartas viradas para baixo")
            
            # NOVA RESTRIÇÃO: Verificar se é tentativa de trocar Activity ativa por outra Activity
            carta_atual_carrossel = self.cards[carrossel_idx] if carrossel_idx < len(self.cards) else None
            
            if (carta_atual_carrossel and 
                "Activity" in os.path.basename(carta_atual_carrossel) and 
                len(self.inventario.get('challenges', [])) > 0):
                
                print("DEBUG: RESTRIÇÃO: Não é possível trocar Activity ativa enquanto houver Challenges no inventário")
                self._mostrar_mensagem_restricao_activity()
                return
            
            # Abre o inventário de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])

    def show_inventory_matrix_carrossel(self, tipos, page=0):
        print(f"DEBUG: show_inventory_matrix_carrossel chamado - tipos: {tipos}, page: {page}")
        
        # PROTEÇÃO CONTRA LOOP: Marcar que estamos a abrir inventário
        self._inventory_opening = True
        
        # Inventário em grelha 2x2 com navegação por páginas
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no carrossel")
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        else:
            title_str = "Activities / Challenges"
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # VERIFICAR SE É ACTIVITIES/CHALLENGES PARA LAYOUT ESPECIAL EM COLUNAS
        if set(tipos) == set(["activities", "challenges"]):
            print("DEBUG: Activities/Challenges detectado - usando layout em colunas")
            
            # Separar cartas por tipo
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            print(f"DEBUG: Activities: {len(cartas_activities)} cartas, Challenges: {len(cartas_challenges)} cartas")
            
            # Paginação baseada no maior número de cartas de qualquer tipo
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna 0 (esquerda)
            activities_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                carta_path = cartas_activities[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row, column=0, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Activity configurada para modo Next Phase na posição ({activities_row}, 0): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Activity adicionada na posição ({activities_row}, 0): {os.path.basename(carta_path)}")
                    
                    activities_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Activity {carta_path}")
                    continue
            
            # Colocar Challenges na coluna 1 (direita)
            challenges_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                carta_path = cartas_challenges[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row, column=1, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Challenge configurado para modo Next Phase na posição ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Challenge adicionado na posição ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    
                    challenges_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Challenge {carta_path}")
                    continue
            
            # Se não há cartas em nenhuma das colunas
            if activities_row == 0 and challenges_row == 0:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.grid(row=0, column=0, columnspan=2, pady=20)
                print("DEBUG: Nenhuma carta de Activities/Challenges - adicionado label 'Sem cartas disponíveis!'")
            
        else:
            # Layout normal para outros tipos (comportamento original)
            cartas = []
            for t in tipos:
                cartas += self.inventario.get(t, [])
            print(f"DEBUG: Cartas encontradas no inventário: {len(cartas)} cartas")
            
            # Paginação
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            print(f"DEBUG: Página {page}/{total_pages-1}, mostrando cartas {start_idx} a {end_idx-1}, cartas na página: {len(cartas_page)}")
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Reduzido para não tapar o título
            
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                except Exception:
                    print(f"DEBUG: Erro ao carregar carta {carta_path}")
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Verificar se Next Phase está ativo para comportamento especial
                if getattr(self, '_next_phase_active', False):
                    # No modo Next Phase, primeira carta clicada vai direto para fullscreen com X e ✔
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                    print(f"DEBUG: Carta {idx} configurada para modo Next Phase na posição ({row}, {col}): {os.path.basename(carta_path)}")
                else:
                    # Comportamento normal - ir para seleção do carrossel
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                    print(f"DEBUG: Carta {idx} adicionada na posição ({row}, {col}): {os.path.basename(carta_path)}")
            
            if not cartas_page:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.pack(pady=20)
                print("DEBUG: Nenhuma carta na página - adicionado label 'Sem cartas disponíveis!'")
        
        # Setas de navegação
        if total_pages > 1:
            # Coordenadas para alinhar as setas à direita da grelha de cartas
            # Assume que a grelha está centrada em relx=0.5, então relx=0.85 fica à direita
            seta_x = 0.90
            # Seta para cima (▲) - parte superior direita da grelha
            if page > 0:
                seta_cima = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page-1))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
                print("DEBUG: Seta para cima adicionada")
            # Seta para baixo (▼) - parte inferior direita da grelha
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page+1))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
                print("DEBUG: Seta para baixo adicionada")
        
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra colorida se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Botão Back centrado na parte inferior - criado após a barra para ficar por cima
        def back_to_dashboard_carrossel():
            # PROTEÇÃO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
            self._inventory_opening = False
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard_carrossel)
        back_btn.place(relx=0.5, rely=0.98, anchor="s")

        # Saldo no canto inferior direito - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))
        
        print(f"DEBUG: show_inventory_matrix_carrossel terminado com sucesso")

    def show_card_fullscreen_carrossel_selecao(self, carta_path, tipos, page=0):
        # Mostra carta em fullscreen com botões ✔ (aceitar) e ✖ (cancelar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no fullscreen carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen carrossel")
        
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Botão ✖ canto superior esquerdo - volta para página de inventário
        def voltar_inventario():
            self.show_inventory_matrix_carrossel(tipos, page)
        btn_x = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        # Botão Switch canto superior direito (APENAS se NÃO for Activities vendável)
        # Para Activities vendáveis, o botão ✔ irá ocupar esta posição
        carta_tipo_temp = "challenges"  # Valor padrão
        if set(tipos) == set(["activities", "challenges"]):
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo_temp = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo_temp = "challenges"
        
        # Verificar se é Activities vendável
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        activities_vendavel = (carta_tipo_temp == "activities" and 
                              not getattr(self, '_next_phase_active', False) and 
                              casa_atual_tipo == "activities")
        
        # Só criar botão Switch se NÃO for Activities vendável E se Next Phase estiver ativo E com posições válidas
        next_phase_active = getattr(self, '_next_phase_active', False)
        has_valid_positions = self._has_valid_carousel_positions()
        
        print(f"DEBUG: [CARROSSEL] VERIFICAÇÃO SWITCH PRINCIPAL:")
        print(f"DEBUG: [CARROSSEL]   activities_vendavel: {activities_vendavel}")
        print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
        
        if not activities_vendavel and next_phase_active and has_valid_positions:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    btn_switch_carrossel.image = switch_img  # Manter referência
                    btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                    
                    # CORREÇÃO: Aplicar a mesma lógica de detecção de substituição
                    def switch_com_detecao_substituicao():
                        print("DEBUG: [CARROSSEL_SELECAO] Verificando se vai substituir carta no carrossel")
                        
                        # Detectar posição de destino
                        posicao_destino = self.carrossel_idx_selecao
                        if posicao_destino is None:
                            # Se não há seleção específica, usar primeira posição acessível
                            for i in range(len(self.cards)):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                        
                        # Verificar se a posição de destino contém uma carta real (não back_card)
                        vai_substituir_carta = False
                        if posicao_destino is not None and posicao_destino < len(self.cards):
                            carta_na_posicao_destino = self.cards[posicao_destino]
                            vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                        
                        if vai_substituir_carta:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai substituir carta existente - mostrando overlay de confirmação")
                            self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                        else:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai colocar em posição vazia - indo diretamente para aceitar carta")
                            self.aceitar_carta_carrossel(carta_path, tipos, page)
                    
                    btn_switch_carrossel.config(command=switch_com_detecao_substituicao)
                    print(f"DEBUG: [CARROSSEL] ✅ Botão Switch principal CRIADO - condições atendidas")
                else:
                    btn_switch_carrossel = None
                    print(f"DEBUG: [CARROSSEL] ❌ Botão Switch principal NÃO criado - imagem não encontrada em {switch_img_path}")
            except Exception as e:
                btn_switch_carrossel = None
                print(f"DEBUG: [CARROSSEL] ❌ Botão Switch principal NÃO criado - erro ao carregar imagem: {e}")
        else:
            btn_switch_carrossel = None
            if activities_vendavel:
                print(f"DEBUG: [CARROSSEL] ❌ Botão Switch principal NÃO criado - Activities vendável irá usar posição para botão ✔")
            elif not next_phase_active:
                print(f"DEBUG: [CARROSSEL] ❌ Botão Switch principal NÃO criado - Next Phase NÃO ATIVO")
            elif not has_valid_positions:
                print(f"DEBUG: [CARROSSEL] ❌ Botão Switch principal NÃO criado - SEM posições válidas no carrossel")
        
        # Adicionar lógica de venda (igual ao show_card_fullscreen_inventory)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do carrossel - Next Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            # Determinar o tipo da carta atual
            carta_tipo = None
            if len(tipos) == 1:
                carta_tipo = tipos[0]
            elif set(tipos) == set(["activities", "challenges"]):
                # Se é uma página Activities/Challenges, determinar tipo pela carta específica
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename or "activities" in carta_basename:
                    carta_tipo = "activities"
                elif "challenge" in carta_basename or "challenges" in carta_basename:
                    carta_tipo = "challenges"
                else:
                    # Tentar determinar pelo caminho da pasta
                    carta_dirname = os.path.dirname(carta_path).lower()
                    if "activities" in carta_dirname:
                        carta_tipo = "activities"
                    elif "challenges" in carta_dirname:
                        carta_tipo = "challenges"
            
            print(f"DEBUG: Verificando possibilidade de venda carrossel - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # Verificar se pode vender
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
        
        # Adicionar lógica de venda (igual ao show_card_fullscreen_inventory)
        # IMPORTANTE: Para Activities e Challenges, usar layout especial sem botão picoin verde
        if pode_vender and carta_tipo not in ["activities", "challenges"]:
            print(f"DEBUG: Pode vender carta {carta_tipo} do carrossel - está numa casa {casa_atual_tipo}")
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((48,48)))
            def abrir_confirm():
                # Guardar informações para navegação correta
                self._origem_venda = "carrossel"
                self._tipos_venda = tipos
                self._page_venda = page
                self._current_sell_page = page
                # CORREÇÃO: Se viemos de um inventário Activities/Challenges, guardar isso
                if set(tipos) == set(["activities", "challenges"]):
                    self._inventario_conjunto = True
                else:
                    self._inventario_conjunto = False
                print(f"DEBUG: Iniciando venda do carrossel - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
            btn_picoin = tk.Button(self, image=picoin_img, bg="#4CAF50", borderwidth=0, command=abrir_confirm, cursor="hand2")
            btn_picoin.image = picoin_img  # type: ignore[attr-defined]
            btn_picoin.place(relx=0, rely=1, anchor="sw")
        elif pode_vender and carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Carta {carta_tipo} pode ser vendida mas usa layout especial - botão ✔ já configurado acima")
        else:
            print(f"DEBUG: NÃO pode vender carta {carta_tipo} do carrossel - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")
        
        # Para Activities e Challenges no carrossel, aplicar layout especial similar ao inventário
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [CARROSSEL] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            
            # Para Activities que podem ser vendidas, reconfigurar o botão Switch para venda
            if carta_tipo == "activities" and pode_vender:
                # Substituir comando do botão Switch para abrir venda em vez de aceitar para carrossel
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informações para navegação correta
                    self._origem_venda = "carrossel"
                    self._tipos_venda = tipos
                    self._page_venda = page
                    self._current_sell_page = page
                    # Se viemos de um inventário Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._inventario_conjunto = True
                    else:
                        self._inventario_conjunto = False
                    print(f"DEBUG: [CARROSSEL] Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Criar botão de venda adicional (✔) para Activities vendáveis na mesma posição padrão
                btn_venda_activities = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_venda_activities.place(relx=0.98, rely=0, anchor="ne")  # Posição consistente com inventário
                btn_venda_activities.config(command=abrir_confirm_activities)
                print(f"DEBUG: [CARROSSEL] Botão ✔ criado para venda de Activities na posição padrão")
                
                # Reposicionar botão Switch para baixo para não conflitar
                # IMPORTANTE: SÓ APARECE DURANTE NEXT PHASE E COM POSIÇÕES VÁLIDAS
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [CARROSSEL] VERIFICAÇÃO SWITCH ADICIONAL (Activities):")
                print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
                
                if next_phase_active and has_valid_positions:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_adicional = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_adicional.image = switch_img  # Manter referência
                            btn_switch_adicional.place(relx=1, rely=1, anchor="se")
                            print(f"DEBUG: [CARROSSEL] ✅ Botão Switch adicional CRIADO - Next Phase ativo + posições válidas")
                        else:
                            btn_switch_adicional = None
                            print(f"DEBUG: [CARROSSEL] ❌ Botão Switch adicional NÃO criado - imagem não encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_adicional = None
                        print(f"DEBUG: [CARROSSEL] ❌ Botão Switch adicional NÃO criado - erro ao carregar imagem: {e}")
                else:
                    btn_switch_adicional = None
                    if not next_phase_active:
                        print(f"DEBUG: [CARROSSEL] ❌ Botão Switch adicional NÃO criado - Next Phase NÃO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [CARROSSEL] ❌ Botão Switch adicional NÃO criado - SEM posições válidas no carrossel")
                
                def switch_action():
                    # CORREÇÃO: Aplicar a mesma lógica de detecção de progresso
                    print("DEBUG: [CARROSSEL] Verificando progresso do carrossel para Switch adicional")
                    
                    # Verificar se temos cartas ativas no carrossel com progresso
                    carrossel_tem_progresso = False
                    if hasattr(self, 'cards') and hasattr(self, 'card_stats'):
                        for i, carta_carrossel in enumerate(self.cards):
                            if not os.path.basename(carta_carrossel).startswith("back_card_"):
                                # Há carta ativa no carrossel - verificar se tem progresso
                                if i < len(self.card_stats):
                                    stats = self.card_stats[i]
                                    if stats.get('To send', 0) > 0 or stats.get('Rxd', 0) > 0 or stats.get('Lost', 0) > 0:
                                        carrossel_tem_progresso = True
                                        break
                    
                    if carrossel_tem_progresso:
                        print("DEBUG: [CARROSSEL] Carrossel tem progresso - mostrando overlay de confirmação")
                        self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                    else:
                        print("DEBUG: [CARROSSEL] Carrossel sem progresso - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, tipos, page)
                
                if btn_switch_adicional is not None:
                    btn_switch_adicional.config(command=switch_action)
                    print(f"DEBUG: [CARROSSEL] Botão Switch adicional configurado para Activities")
            
            # Para Challenges ou Activities que não podem ser vendidas, manter comportamento original do Switch
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                print(f"DEBUG: [CARROSSEL] Botão Switch mantém comportamento original para {carta_tipo} (aceitar no carrossel)")
        
        # BOTÃO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase) - INVENTÁRIO
        if carta_tipo == "challenges" and not getattr(self, '_next_phase_active', False):
            print(f"DEBUG: [CARROSSEL_INVENTARIO] Criando botão Quit Challenge no canto superior direito")
            
            # Botão vermelho com símbolo de check (✓) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            
            # Posição específica para inventário - verificar se há botão Switch no canto superior direito
            if btn_switch_carrossel is not None:
                # Se há botão Switch, posicionar o quit Challenge ligeiramente abaixo
                btn_quit_challenge.place(relx=0.98, rely=0.08, anchor="ne")
            else:
                # Se não há botão Switch, posicionar no canto superior direito
                btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do botão quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE_INVENTARIO] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [CARROSSEL_INVENTARIO] ✅ Botão Quit Challenge criado no canto superior direito")

    def aceitar_carta_carrossel(self, carta_path, tipos, page=0):
        # NOVA RESTRIÇÃO: Verificar se é tentativa de trocar Challenge por outra carta que não seja Activity
        idx = getattr(self, 'carrossel_idx_selecao', 0)
        carta_carrossel_atual = getattr(self, 'carta_carrossel_para_troca', None)
        
        # CORREÇÃO: Se carta_carrossel_atual é None, verificar se é uma posição back_card
        if carta_carrossel_atual is None and hasattr(self, 'cards') and idx < len(self.cards):
            carta_na_posicao = self.cards[idx]
            if os.path.basename(carta_na_posicao).startswith("back_card_"):
                carta_carrossel_atual = carta_na_posicao
                print(f"DEBUG: [aceitar_carta_carrossel] Posição {idx} é back_card: {carta_carrossel_atual}")
        
        print(f"DEBUG: [aceitar_carta_carrossel] ===== INICIANDO VERIFICAÇÃO DE TROCA =====")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_path (inventário): {carta_path}")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual: {carta_carrossel_atual}")
        print(f"DEBUG: [aceitar_carta_carrossel] carrossel_idx_selecao: {idx}")
        print(f"DEBUG: [aceitar_carta_carrossel] tipos: {tipos}")
        
        # IMPORTANTE: Verificar restrição Activity antes de qualquer processamento
        is_inventario_activity = "Activity" in os.path.basename(carta_path)
        if is_inventario_activity:
            challenges_no_inventario = len(self.inventario.get('challenges', []))
            print(f"DEBUG: [aceitar_carta_carrossel] Tentativa de colocar Activity no carrossel")
            print(f"DEBUG: [aceitar_carta_carrossel] Challenges no inventário: {challenges_no_inventario}")
            print(f"DEBUG: [aceitar_carta_carrossel] Lista de Challenges: {[os.path.basename(c) for c in self.inventario.get('challenges', [])]}")
            
            if challenges_no_inventario > 0:
                if carta_carrossel_atual:
                    is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                    if is_carrossel_activity:
                        print("DEBUG: RESTRIÇÃO ATIVADA: Não é possível trocar Activity ↔ Activity quando há Challenges no inventário")
                        self._mostrar_mensagem_restricao_activity_activity()
                        return
                else:
                    print("DEBUG: RESTRIÇÃO ATIVADA: Não é possível colocar Activity no carrossel vazio quando há Challenges no inventário")
                    self._mostrar_mensagem_restricao_activity_activity()
                    return
        
        if carta_carrossel_atual:
            # Verificar se é uma carta back_card (posição vazia)
            is_back_card = os.path.basename(carta_carrossel_atual).startswith("back_card_")
            
            if is_back_card:
                print("DEBUG: [aceitar_carta_carrossel] Posição vazia (back_card) - fazendo colocação simples")
                # É uma colocação em posição vazia, não uma troca
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Flag posição {idx} atualizada para True (virada para cima)")
                
                # Inicializar card_stats para a carta nova
                print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Inicializando card_stats para carta na posição {idx}")
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = new_stats
                        print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                    else:
                        print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCAÇÃO - card_stats não inicializado ou índice inválido")
                except Exception as e:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCAÇÃO ao obter message_size: {e}")
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
                if "Challenge" in os.path.basename(carta_path):
                    self._register_challenge_start_turn(carta_path)
                
                # CORREÇÃO CRÍTICA: Restaurar valores preservados se existirem
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {
                            "To send": preserved_stats["To send"],
                            "Rxd": preserved_stats["Rxd"],
                            "Lost": preserved_stats["Lost"]
                        }
                        print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] SOBREPOSIÇÃO - Valores preservados restaurados para posição {idx}: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                        
                        # Remover do mapeamento
                        del self._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do mapeamento de preservados")
                        
                        # Também remover do backup root se existir
                        root = self.master
                        if (hasattr(root, '_activity_preserved_stats') and 
                            carta_path in root._activity_preserved_stats):
                            del root._activity_preserved_stats[carta_path]
                            print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do backup root")
                
                # Remover carta do inventário
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do inventário {t}")
                        break
                
                print("DEBUG: Colocação concluída com sucesso!")
            else:
                # É uma troca real entre duas cartas
                # Verificar tipos das cartas
                is_carrossel_challenge = "Challenge" in os.path.basename(carta_carrossel_atual)
                is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                is_inventario_challenge = "Challenge" in os.path.basename(carta_path)
                
                print(f"DEBUG: [aceitar_carta_carrossel] Verificando restrições:")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel é Challenge: {is_carrossel_challenge}")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel é Activity: {is_carrossel_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Inventário é Activity: {is_inventario_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Inventário é Challenge: {is_inventario_challenge}")
                
                # RESTRIÇÃO 1: Challenge só pode ser trocado por Activity
                if is_carrossel_challenge and not is_inventario_activity:
                    print("DEBUG: RESTRIÇÃO: Challenge só pode ser trocado por Activity")
                    self._mostrar_mensagem_restricao_challenge_activity()
                    return
                
                # Fazer a troca entre a carta do carrossel e a carta selecionada do inventário
                print(f"DEBUG: Fazendo troca - Carta do carrossel: {carta_carrossel_atual}")
                print(f"DEBUG: Carta do inventário: {carta_path}")
                print(f"DEBUG: Índice do carrossel: {idx}")
                
                # 1. Colocar a carta do inventário no lugar da carta do carrossel
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] TROCA - Flag posição {idx} atualizada para True (virada para cima)")
                
                # CORREÇÃO CRÍTICA: Inicializar card_stats com message_size correto para carta nova
                print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO TROCA - Inicializando card_stats para carta trocada na posição {idx}")
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = new_stats
                        print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO TROCA - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                    else:
                        print(f"DEBUG: [aceitar_carta_carrossel] ERRO TROCA - card_stats não inicializado ou índice inválido")
                except Exception as e:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO TROCA ao obter message_size: {e}")
                    # Fallback para valores padrão
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
                if "Challenge" in os.path.basename(carta_path):
                    self._register_challenge_start_turn(carta_path)
                
                # CORREÇÃO CRÍTICA: Restaurar valores preservados da Activity se existirem
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    # Atualizar card_stats com valores preservados (SOBRESCREVE os valores iniciais acima)
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {
                            "To send": preserved_stats["To send"],
                            "Rxd": preserved_stats["Rxd"],
                            "Lost": preserved_stats["Lost"]
                        }
                        print(f"DEBUG: [ACEITAR_CARROSSEL] SOBREPOSIÇÃO - Valores preservados restaurados para posição {idx}: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                        
                        # Remover do mapeamento pois a carta está de volta ao carrossel
                        del self._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do mapeamento de preservados")
                        
                        # Também remover do backup root se existir
                        root = self.master
                        if (hasattr(root, '_activity_preserved_stats') and 
                            carta_path in root._activity_preserved_stats):
                            del root._activity_preserved_stats[carta_path]
                            print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do backup root")
                
                # 2. Remover a carta do inventário
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do inventário {t}")
                        break
                
                # 3. Adicionar a carta que estava no carrossel ao inventário (só se não for back_card)
                if not is_back_card:
                    # Determinar o tipo da carta que estava no carrossel
                    carta_tipo_carrossel = None
                    
                    # Primeiro, verificar se a carta já estava no inventário
                    for t in tipos:
                        if carta_carrossel_atual in self.inventario.get(t, []):
                            carta_tipo_carrossel = t
                            break
                    
                    # Se não encontrou, tentar determinar pelo caminho da carta
                    if not carta_tipo_carrossel:
                        carta_basename = os.path.basename(carta_carrossel_atual).lower()
                        carta_dirname = os.path.dirname(carta_carrossel_atual).lower()
                        
                        # Verificar se o nome do arquivo ou pasta contém o tipo
                        for t in tipos:
                            if t in carta_basename or t in carta_dirname:
                                carta_tipo_carrossel = t
                                break
                        
                        # Último recurso: usar o primeiro tipo disponível
                        if not carta_tipo_carrossel:
                            carta_tipo_carrossel = tipos[0]
                    
                    # Adicionar a carta do carrossel ao inventário
                    if carta_tipo_carrossel in self.inventario:
                        self.inventario[carta_tipo_carrossel].append(carta_carrossel_atual)
                        print(f"DEBUG: Adicionada carta {carta_carrossel_atual} ao inventário {carta_tipo_carrossel}")
                    else:
                        print(f"DEBUG: ERRO - Tipo {carta_tipo_carrossel} não encontrado no inventário")
                
                # 4. Limpar variáveis temporárias
                self.carta_carrossel_para_troca = None
                
                if is_back_card:
                    print("DEBUG: Colocação em posição vazia concluída com sucesso!")
                else:
                    print("DEBUG: Troca concluída com sucesso!")
        else:
            print("DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual é None - fazendo substituição normal")
            # Comportamento original - apenas substitui a carta virada para baixo
            self.cards[idx] = carta_path
            self.selected_card_idx = idx
            
            # CORREÇÃO CRÍTICA: Inicializar card_stats com message_size correto para carta nova
            print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO - Inicializando card_stats para nova carta na posição {idx}")
            try:
                message_size = self._get_card_message_size_from_database(carta_path)
                new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = new_stats
                    print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                else:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO - card_stats não inicializado ou índice inválido")
            except Exception as e:
                print(f"DEBUG: [aceitar_carta_carrossel] ERRO ao obter message_size: {e}")
                # Fallback para valores padrão
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
            
            # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
            if "Challenge" in os.path.basename(carta_path):
                self._register_challenge_start_turn(carta_path)
            
            # CORREÇÃO CRÍTICA: Restaurar valores preservados da Activity se existirem (SOBRESCREVE valores iniciais)
            if (hasattr(self, '_activity_preserved_stats') and 
                carta_path in self._activity_preserved_stats):
                
                preserved_stats = self._activity_preserved_stats[carta_path]
                # Atualizar card_stats com valores preservados (SOBRESCREVE os valores iniciais acima)
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {
                        "To send": preserved_stats["To send"],
                        "Rxd": preserved_stats["Rxd"],
                        "Lost": preserved_stats["Lost"]
                    }
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] SOBREPOSIÇÃO - Valores preservados restaurados para posição {idx}: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento pois a carta está de volta ao carrossel
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do mapeamento de preservados")
                    
                    # Também remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do backup root")
            
            # Remover carta do inventário activities/challenges
            for t in tipos:
                if carta_path in self.inventario.get(t, []):
                    self.inventario[t].remove(carta_path)
        
        # Voltar à interface principal
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_card_fullscreen_next_phase_selection(self, carta_path, tipos, page=0):
        """
        Mostra carta em fullscreen no modo Next Phase com apenas X e ✔
        Usado quando Next Phase está ativo e o utilizador clica numa carta do inventário
        """
        print(f"DEBUG: show_card_fullscreen_next_phase_selection chamado - Next Phase ativo")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no fullscreen Next Phase, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen Next Phase")

        # Mostrar carta em fullscreen
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X no canto superior esquerdo - volta para a página de inventário Activities/Challenges
        def voltar_inventario():
            print("DEBUG: Voltando para página de inventário Activities/Challenges do modo Next Phase")
            self.show_inventory_matrix_carrossel(tipos, page)
        
        btn_x = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão Switch no canto superior direito - aceita carta para o carrossel e vai para dashboard
        # APENAS se Final Phase NÃO estiver ativo
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        # VERIFICAR SE DEVE MOSTRAR BOTÃO SWITCH
        is_activity_card = "Activity" in os.path.basename(carta_path)
        is_challenge_card = "Challenge" in os.path.basename(carta_path)
        challenges_no_inventario = len(self.inventario.get('challenges', []))
        activities_no_inventario = len(self.inventario.get('activities', []))
        
        print(f"DEBUG: [NEXT PHASE] === VERIFICAÇÃO BOTÃO SWITCH ===")
        print(f"DEBUG: [NEXT PHASE] final_phase_active: {final_phase_active}")
        print(f"DEBUG: [NEXT PHASE] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [NEXT PHASE] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [NEXT PHASE] challenges_no_inventario: {challenges_no_inventario}")
        print(f"DEBUG: [NEXT PHASE] activities_no_inventario: {activities_no_inventario}")
        
        # Lógica de disponibilidade do botão switch:
        # CORREÇÃO: Verificar se há espaços vazios no carrossel OU cartas para trocar
        # - Se há espaços vazios (back_card) em posições acessíveis: sempre permitir
        # - Se não há espaços vazios: verificar se há cartas para trocar
        should_show_switch = False
        
        # Primeiro, verificar se há posições vazias acessíveis no carrossel
        has_empty_accessible_positions = False
        if hasattr(self, 'cards'):
            user_ids = self._check_user_inventory_for_carousel_access()
            for i, carta_path_carrossel in enumerate(self.cards):
                carta_basename = os.path.basename(carta_path_carrossel)
                is_back_card = carta_basename.startswith("back_card_")
                required_user_id = i + 1
                has_user_id = required_user_id in user_ids
                if is_back_card and has_user_id:
                    has_empty_accessible_positions = True
                    print(f"DEBUG: [NEXT PHASE] Posição {i} vazia e acessível (User ID {required_user_id})")
                    break
        
        print(f"DEBUG: [NEXT PHASE] has_empty_accessible_positions: {has_empty_accessible_positions}")
        
        # LÓGICA CORRIGIDA: Activity NÃO pode mostrar switch quando há Challenges no inventário
        # MESMO que haja posições vazias
        if is_activity_card and challenges_no_inventario > 0:
            should_show_switch = False
            print(f"DEBUG: [NEXT PHASE] ❌ Activity NÃO pode mostrar switch - há {challenges_no_inventario} Challenges no inventário (restrição Activity→Activity sempre aplicada)")
        elif has_empty_accessible_positions:
            # Se há posições vazias acessíveis E não é Activity com Challenges, permitir
            should_show_switch = True
            print(f"DEBUG: [NEXT PHASE] ✅ Há posições vazias acessíveis - botão switch permitido (colocação)")
        else:
            # Se não há posições vazias, verificar se há cartas para trocar
            if is_activity_card:
                # CORREÇÃO: Activity pode trocar com outra Activity do inventário OU com Activity do carrossel
                # Contar Activities totais (inventário + carrossel)
                activities_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Activity" in os.path.basename(carta_carrossel):
                            activities_no_carrossel += 1
                
                total_activities = activities_no_inventario + activities_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Activities no inventário: {activities_no_inventario}, no carrossel: {activities_no_carrossel}, total: {total_activities}")
                
                # Activity pode trocar se há pelo menos uma outra Activity (total > 1)
                if total_activities > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] ✅ Activity com {total_activities} Activities disponíveis (inventário + carrossel) - botão switch permitido (troca Activity→Activity)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ❌ Activity sem outras Activities para trocar (total: {total_activities}) - botão switch NÃO criado")
            elif is_challenge_card:
                # CORREÇÃO: Challenge pode trocar com outro Challenge do inventário OU com Challenge do carrossel
                # Contar Challenges totais (inventário + carrossel)
                challenges_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Challenge" in os.path.basename(carta_carrossel):
                            challenges_no_carrossel += 1
                
                total_challenges = challenges_no_inventario + challenges_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Challenges no inventário: {challenges_no_inventario}, no carrossel: {challenges_no_carrossel}, total: {total_challenges}")
                
                # Challenge pode trocar se há pelo menos um outro Challenge (total > 1)
                if total_challenges > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] ✅ Challenge com {total_challenges} Challenges disponíveis (inventário + carrossel) - botão switch permitido (troca)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ❌ Challenge sem outros Challenges para trocar (total: {total_challenges}) - botão switch NÃO criado")
            else:
                print(f"DEBUG: [NEXT PHASE] ❌ Carta não é Activity nem Challenge - botão switch NÃO criado")
        
        # Só criar botão switch se Final Phase não estiver ativo E se houver cartas disponíveis para trocar
        if not final_phase_active and should_show_switch:
            def aceitar_carta():
                print("DEBUG: [NEXT PHASE] *** aceitar_carta CHAMADA - SWITCH BUTTON CLICKED! ***")
                print(f"DEBUG: [NEXT PHASE] carta_path: {carta_path}")
                print(f"DEBUG: [NEXT PHASE] tipos: {tipos}")
                print(f"DEBUG: [NEXT PHASE] page: {page}")
                
                # CORREÇÃO: Aplicar a mesma lógica de detecção de substituição
                print("DEBUG: [NEXT PHASE] Verificando se vai substituir carta no carrossel")
                
                # Detectar posição de destino
                posicao_destino = getattr(self, 'carrossel_idx_selecao', None)
                if posicao_destino is None:
                    # Se não há seleção específica, usar primeira posição acessível
                    for i in range(len(self.cards)):
                        if self._can_access_carousel_position(i):
                            posicao_destino = i
                            break
                
                # Verificar se a posição de destino contém uma carta real (não back_card)
                vai_substituir_carta = False
                if posicao_destino is not None and posicao_destino < len(self.cards):
                    carta_na_posicao_destino = self.cards[posicao_destino]
                    vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                
                if vai_substituir_carta:
                    print("DEBUG: [NEXT PHASE] Vai substituir carta existente - mostrando overlay de confirmação")
                    self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                else:
                    print("DEBUG: [NEXT PHASE] Vai colocar em posição vazia - indo diretamente para aceitar carta")
                    self.aceitar_carta_carrossel(carta_path, tipos, page)
            
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_next_phase = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    btn_switch_next_phase.image = switch_img  # Manter referência
                    print(f"DEBUG: [NEXT PHASE] Botão Switch criado com imagem switch_card.png")
                else:
                    # Fallback para botão texto se imagem não existir
                    btn_switch_next_phase = tk.Button(self, text="⇄", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    print(f"DEBUG: [NEXT PHASE] Botão Switch criado com texto (imagem não encontrada em {switch_img_path})")
            except Exception as e:
                # Fallback para botão texto em caso de erro
                btn_switch_next_phase = tk.Button(self, text="⇄", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                print(f"DEBUG: [NEXT PHASE] Botão Switch criado com texto (erro ao carregar imagem: {e})")
            
            # POSICIONAMENTO ESPECÍFICO POR TIPO DE CARTA:
            if is_activity_card:
                # Activities: Switch no canto superior direito
                btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [NEXT PHASE] Botão Switch Activity posicionado no canto superior direito")
            else:  # is_challenge_card
                # CORREÇÃO: Challenges: Switch também no canto superior direito (ao lado do quit se houver)
                # Se quit button estiver presente, switch fica um pouco mais à esquerda
                next_phase_active = getattr(self, '_next_phase_active', False)
                if not final_phase_active and not next_phase_active:
                    # Quit button vai estar presente, switch fica mais à esquerda
                    btn_switch_next_phase.place(relx=0.90, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Botão Switch Challenge posicionado no canto superior direito (à esquerda do quit)")
                else:
                    # Quit button não vai estar presente, switch pode ficar no canto
                    btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Botão Switch Challenge posicionado no canto superior direito")
            
            print(f"DEBUG: [NEXT PHASE] Botão Switch configurado e posicionado")
        else:
            if not should_show_switch:
                print(f"DEBUG: [NEXT PHASE] Botão Switch NÃO criado - sem cartas disponíveis para trocar")
            else:
                print(f"DEBUG: [NEXT PHASE] Botão Switch NÃO criado - Final Phase está ativo")
        
        # BOTÃO QUIT CHALLENGE (apenas para Challenges, canto superior direito)
        # CORREÇÃO: Não deve aparecer quando Next Phase está ativo OU Final Phase está ativo
        next_phase_active = getattr(self, '_next_phase_active', False)
        if is_challenge_card and not final_phase_active and not next_phase_active:
            print(f"DEBUG: [NEXT PHASE] Criando botão Quit Challenge no canto superior direito")
            
            # Botão vermelho com símbolo de check (✓) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            # Challenge: Quit sempre no canto superior direito
            btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do botão quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [NEXT PHASE] ✅ Botão Quit Challenge criado no canto superior direito")
        else:
            if next_phase_active:
                print(f"DEBUG: [NEXT PHASE] ❌ Botão Quit Challenge NÃO criado - Next Phase está ativo")
            elif final_phase_active:
                print(f"DEBUG: [NEXT PHASE] ❌ Botão Quit Challenge NÃO criado - Final Phase está ativo")
            elif not is_challenge_card:
                print(f"DEBUG: [NEXT PHASE] ❌ Botão Quit Challenge NÃO criado - não é carta Challenge")
        
        print("DEBUG: Fullscreen Next Phase configurado - apenas X disponível durante Final Phase")

    def add_more_action_event_cards(self, min_actions=5, min_events=6):
        """
        Adiciona mais cartas de Actions/Events ao inventário se houver poucas.
        Usa filtragem baseada na base de dados para adicionar apenas cartas válidas.
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [add_more_action_event_cards] Base de dados não disponível")
            return
        
        player_color = self.player_color.lower()
        base_path = "/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster"
        
        # Verificar Actions
        current_actions = len(self.inventario.get("actions", []))
        if current_actions < min_actions:
            print(f"DEBUG: [add_more_action_event_cards] Actions insuficientes ({current_actions}/{min_actions}), adicionando mais...")
            actions_path = os.path.join(base_path, "Actions", "Residential-level")
            if os.path.exists(actions_path):
                try:
                    # ESPECÍFICO: Só adicionar Action_66.png se não estiver presente
                    action_66_path = os.path.join(actions_path, "Action_66.png")
                    if os.path.exists(action_66_path):
                        # Verificar se Action_66.png já está no inventário
                        action_66_present = any("Action_66.png" in carta for carta in self.inventario.get("actions", []))
                        if not action_66_present:
                            self.inventario["actions"].append(action_66_path)
                            print(f"DEBUG: [add_more_action_event_cards] Action adicionada: Action_66.png")
                        else:
                            print(f"DEBUG: [add_more_action_event_cards] Action_66.png já presente no inventário")
                    else:
                        print(f"DEBUG: [add_more_action_event_cards] Action_66.png não encontrada em {actions_path}")
                
                except Exception as e:
                    print(f"DEBUG: [add_more_action_event_cards] Erro ao adicionar Actions: {e}")
        
        # Verificar Events
        current_events = len(self.inventario.get("events", []))
        if current_events < min_events:
            print(f"DEBUG: [add_more_action_event_cards] Events insuficientes ({current_events}/{min_events}), adicionando mais...")
            events_path = os.path.join(base_path, "Events", "Residential-level")
            if os.path.exists(events_path):
                try:
                    files = os.listdir(events_path)
                    event_files = [os.path.join(events_path, f) for f in files if f.lower().endswith('.png')]
                    
                    valid_events = []
                    for card_file in event_files:
                        filename = os.path.basename(card_file)
                        match = re.search(r'Event_(\d+)\.', filename)
                        if match:
                            # ESPECIAL: Incluir APENAS Event_55 e Event_14
                            if filename == "Event_55.png" or filename == "Event_14.png":
                                if card_file not in self.inventario.get("events", []):
                                    valid_events.append(card_file)
                                    print(f"DEBUG: [add_more_action_event_cards] Event PERMITIDO: {filename}")
                            else:
                                print(f"DEBUG: [add_more_action_event_cards] Event IGNORADO (não é Event_55 nem Event_14): {filename}")
                    
                    # Adicionar cartas até atingir o mínimo
                    needed = min_events - current_events
                    for i in range(min(needed, len(valid_events))):
                        self.inventario["events"].append(valid_events[i])
                        print(f"DEBUG: [add_more_action_event_cards] Event adicionado: {os.path.basename(valid_events[i])}")
                
                except Exception as e:
                    print(f"DEBUG: [add_more_action_event_cards] Erro ao adicionar Events: {e}")
        
        print(f"DEBUG: [add_more_action_event_cards] Resultado final - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def _filter_action_event_cards(self, cartas_paths, card_type):
        """
        Filtra cartas de Actions/Events baseado no target e player_choice.
        Mostra cartas que:
        1. Têm target igual à cor do jogador atual, OU
        2. Têm target None e player_choice True (jogador pode escolher alvo), OU
        3. Têm target None e player_choice False/None (carta fica sempre com quem a tirou)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print(f"DEBUG: [_filter_action_event_cards] Base de dados não disponível - mostrando todas as cartas")
            return cartas_paths
        
        filtered_cards = []
        player_color = self.player_color.lower()
        
        for carta_path in cartas_paths:
            try:
                # Extrair ID da carta do nome do arquivo
                filename = os.path.basename(carta_path)
                if card_type == "actions":
                    # Action_1.png -> action_1
                    match = re.search(r'Action_(\d+)\.', filename)
                    if match:
                        card_id = f"action_{match.group(1)}"
                        card_data = self.card_database.get_action(card_id)
                    else:
                        continue
                elif card_type == "events":
                    # Event_1.png -> event_1
                    match = re.search(r'Event_(\d+)\.', filename)
                    if match:
                        card_id = f"event_{match.group(1)}"
                        card_data = self.card_database.get_event(card_id)
                    else:
                        continue
                else:
                    continue
                
                if card_data:
                    # Para Events, usar target_player; para Actions, usar target
                    if card_type == "events":
                        target = getattr(card_data, 'target_player', None)
                    else:
                        target = getattr(card_data, 'target', None)
                    player_choice = getattr(card_data, 'player_choice', False)
                    
                    # CRITÉRIO DE FILTRAGEM CORRIGIDO:
                    # 1. Target específico igual à cor do jogador
                    # 2. Target None com player_choice True (jogador escolhe alvo)
                    # 3. Target None com player_choice False/None (carta fica com quem tirou)
                    if (target == player_color or 
                        (target is None and player_choice) or 
                        (target is None and not player_choice)):
                        filtered_cards.append(carta_path)
                        if target == player_color:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target={target} - direcionada para jogador)")
                        elif target is None and player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=True - jogador escolhe)")
                        elif target is None and not player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=False - fica com quem tirou)")
                    else:
                        print(f"DEBUG: [_filter_action_event_cards] Carta REJEITADA: {filename} (target={target}, player_choice={player_choice} - não aplicável)")
                else:
                    print(f"DEBUG: [_filter_action_event_cards] Carta não encontrada na base de dados: {card_id}")
                    
            except Exception as e:
                print(f"DEBUG: [_filter_action_event_cards] Erro ao processar carta {filename}: {e}")
                continue
        
        print(f"DEBUG: [_filter_action_event_cards] Resultado final {card_type}: {len(filtered_cards)}/{len(cartas_paths)} cartas")
        return filtered_cards

    def reload_action_event_inventory(self):
        """
        Função de conveniência para recarregar o inventário de Actions/Events
        com mais cartas válidas para o jogador atual.
        """
        print("DEBUG: [reload_action_event_inventory] Recarregando inventário de Actions/Events...")
        
        # Limpar inventário atual (opcional)
        # self.inventario["actions"] = []
        # self.inventario["events"] = []
        
        # Adicionar mais cartas
        self.add_more_action_event_cards(min_actions=10, min_events=12)
        
        print(f"DEBUG: [reload_action_event_inventory] Inventário atualizado - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def processar_challenge_aceite(self, carta_challenge_path):
        """
        Processa a aceitação de uma carta Challenge implementando a lógica complexa de substituição:
        - Se há Activities ativas no carrossel: substitui uma Activity (com reset de valores)
        - Se há múltiplas Activities: jogador escolhe qual substituir
        - Se só há Challenges ativas: Challenge vai para inventário
        - Activity substituída vai para inventário Activities/Challenges
        """
        print(f"DEBUG: [processar_challenge_aceite] Processando Challenge: {os.path.basename(carta_challenge_path)}")
        
        # CORREÇÃO PROBLEMA 1: Verificar se Challenge já foi processado para evitar duplo processamento
        if hasattr(self, '_challenge_sendo_processado') and self._challenge_sendo_processado == carta_challenge_path:
            print(f"DEBUG: [processar_challenge_aceite] ⚠️  Challenge já está sendo processado - ignorando chamada duplicada")
            return
        
        # Marcar Challenge como sendo processado
        self._challenge_sendo_processado = carta_challenge_path
        
        # FECHAR A STORE se estiver aberta
        if hasattr(self, 'store_window') and self.store_window:
            print(f"DEBUG: [processar_challenge_aceite] Fechando Store...")
            try:
                self.store_window.destroy()
                self.store_window = None
                print(f"DEBUG: [processar_challenge_aceite] Store fechada com sucesso")
            except Exception as e:
                print(f"DEBUG: [processar_challenge_aceite] Erro ao fechar Store: {e}")
        
        # Desabilitar botão Store (Challenge aceite)
        self.disable_store_button()
        print(f"DEBUG: [processar_challenge_aceite] Botão Store desabilitado")
        
        try:
            # Primeiro, garantir que Challenge está no inventário
            if 'challenges' not in self.inventario:
                self.inventario['challenges'] = []
            if carta_challenge_path not in self.inventario['challenges']:
                self.inventario['challenges'].append(carta_challenge_path)
                print(f"DEBUG: [processar_challenge_aceite] Challenge adicionado ao inventário")
            
            # Verificar Activities ativas no carrossel
            activities_ativas = []
            for i, carta_carrossel in enumerate(self.cards):
                if carta_carrossel and "Activity" in os.path.basename(carta_carrossel):
                    activities_ativas.append((i, carta_carrossel))
            
            print(f"DEBUG: [processar_challenge_aceite] Activities ativas encontradas: {len(activities_ativas)}")
            for idx, carta in activities_ativas:
                print(f"DEBUG: [processar_challenge_aceite]   Posição {idx}: {os.path.basename(carta)}")
            
            if len(activities_ativas) == 0:
                # Caso 1: Não há Activities ativas - Challenge vai direto para inventário
                print("DEBUG: [processar_challenge_aceite] Nenhuma Activity ativa - Challenge vai para inventário")
                # Challenge já foi adicionado ao inventário acima
                
            elif len(activities_ativas) == 1:
                # Caso 2: Uma Activity ativa - substitui automaticamente
                idx_activity, carta_activity = activities_ativas[0]
                print(f"DEBUG: [processar_challenge_aceite] Uma Activity ativa - substituindo automaticamente posição {idx_activity}")
                self._substituir_activity_por_challenge(idx_activity, carta_activity, carta_challenge_path)
                
            else:
                # Caso 3: Múltiplas Activities ativas - jogador escolhe
                print(f"DEBUG: [processar_challenge_aceite] {len(activities_ativas)} Activities ativas - jogador deve escolher")
                self._mostrar_selecao_activity_para_substituir(activities_ativas, carta_challenge_path)
                
        finally:
            # Limpar marcador de processamento após 2 segundos para permitir futuras operações
            self.after(2000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [processar_challenge_aceite] Marcador de processamento será limpo em 2 segundos")
    
    def _substituir_activity_por_challenge(self, idx_carrossel, carta_activity_path, carta_challenge_path):
        """
        Executa a substituição de uma Activity por uma Challenge no carrossel:
        - CORRECCIÓN: Reseta card_stats e barras de progresso para valores da nova Challenge
        - Move Activity para inventário
        - Remove Challenge do inventário
        - Coloca Challenge no carrossel
        """
        try:
            print(f"DEBUG: [_substituir_activity_por_challenge] INÍCIO - Substituindo Activity posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Activity: {os.path.basename(carta_activity_path)}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge: {os.path.basename(carta_challenge_path)}")
            
            # 1. RESETAR VALORES DA ACTIVITY (To send volta ao inicial, Rxd e Lost = 0)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Resetando valores...")
            self._resetar_valores_activity(carta_activity_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Valores resetados")
            
            # 2. MOVER ACTIVITY PARA INVENTÁRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Movendo Activity para inventário...")
            if 'activities' not in self.inventario:
                self.inventario['activities'] = []
            if carta_activity_path not in self.inventario['activities']:
                self.inventario['activities'].append(carta_activity_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Activity movida para inventário")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Activity movida")
            
            # 3. REMOVER CHALLENGE DO INVENTÁRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Removendo Challenge do inventário...")
            if carta_challenge_path in self.inventario.get('challenges', []):
                self.inventario['challenges'].remove(carta_challenge_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Challenge removido do inventário")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Challenge removido")
            
            # 4. COLOCAR CHALLENGE NO CARROSSEL
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Colocando Challenge no carrossel...")
            self.cards[idx_carrossel] = carta_challenge_path
            
            # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
            if not hasattr(self, 'card_face_up_flags'):
                self.card_face_up_flags = [False, False, False, False]
            if idx_carrossel < len(self.card_face_up_flags):
                self.card_face_up_flags[idx_carrossel] = True
                print(f"DEBUG: [_substituir_activity_por_challenge] Flag posição {idx_carrossel} atualizada para True (virada para cima)")
            
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge colocado no carrossel posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Challenge colocado")
            
            # 5. CORREÇÃO CRÍTICA: RESETAR card_stats PARA A NOVA CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 5: Resetando card_stats para Challenge...")
            challenge_message_size = self._get_card_message_size_from_database(carta_challenge_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Message size da Challenge: {challenge_message_size}")
            
            # Resetar card_stats[idx_carrossel] com valores da Challenge
            if idx_carrossel < len(self.card_stats):
                self.card_stats[idx_carrossel] = {
                    "To send": challenge_message_size,  # Novo message_size da Challenge
                    "Rxd": 0,                          # Sempre 0 para nova carta
                    "Lost": 0                          # Sempre 0 para nova carta
                }
                print(f"DEBUG: [_substituir_activity_por_challenge] ✅ card_stats[{idx_carrossel}] resetado:")
                print(f"DEBUG: [_substituir_activity_por_challenge]   To send: {challenge_message_size}")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Rxd: 0")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Lost: 0")
            
            # 6. CORREÇÃO CRÍTICA: ATUALIZAR BARRAS DE PROGRESSO PARA A CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 6: Atualizando barras para Challenge...")
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Configurar barra To send com message_size da Challenge
                if "To send" in self.progress_bars:
                    self.progress_bars["To send"].configure(maximum=challenge_message_size)
                    self.progress_bars["To send"].set(challenge_message_size)  # Barra 100% cheia
                    self.progress_labels["To send"].config(text=str(challenge_message_size))
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Barra To send: {challenge_message_size}/{challenge_message_size}")
                
                # Resetar Rxd para 0
                if "Rxd" in self.progress_bars:
                    self.progress_bars["Rxd"].set(0)
                    self.progress_labels["Rxd"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Barra Rxd: 0")
                
                # Resetar Lost para 0
                if "Lost" in self.progress_bars:
                    self.progress_bars["Lost"].set(0)
                    self.progress_labels["Lost"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Barra Lost: 0")
                
                # Forçar atualização visual
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        self.progress_bars[stat].update_idletasks()
                        self.progress_bars[stat].update()
                    if stat in self.progress_labels:
                        self.progress_labels[stat].update_idletasks()
                        self.progress_labels[stat].update()
                
                self.update_idletasks()
                self.update()
                print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Barras atualizadas e refreshed")
            
            # 7. LIMPAR ESTADO DE SELEÇÃO E PROCESSAMENTO PARA EVITAR CONFLITOS
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Limpando estado de seleção...")
            if hasattr(self, 'selected_carousel_card'):
                self.selected_carousel_card = None
            if hasattr(self, 'selected_carousel_index'):
                self.selected_carousel_index = None
            if hasattr(self, 'carta_carrossel_para_troca'):
                self.carta_carrossel_para_troca = None
            if hasattr(self, 'carrossel_idx_selecao'):
                self.carrossel_idx_selecao = None
            print(f"DEBUG: [_substituir_activity_por_challenge] Estado de seleção limpo")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Estado limpo")
            
            # 8. ATUALIZAR INTERFACE (se estiver visível)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8: Atualizando interface...")
            if hasattr(self, 'card_labels') and self.card_labels:
                try:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Chamando playerdashboard_interface...")
                    # Recriar interface para mostrar mudanças
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface atualizada")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao atualizar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback interface: {traceback.format_exc()}")
            else:
                print(f"DEBUG: [_substituir_activity_por_challenge] Não há card_labels - criando interface diretamente...")
                try:
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface criada diretamente")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao criar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback criação: {traceback.format_exc()}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8: Interface processada")
            
            # 9. LIMPAR MARCADOR DE PROCESSAMENTO DEPOIS DE UM BREVE DELAY
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 9: Programando limpeza...")
            self.after(1000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [_substituir_activity_por_challenge] ✅ SUBSTITUIÇÃO COMPLETA")
            print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Challenge {os.path.basename(carta_challenge_path)} substitui Activity na posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Valores resetados: To send={challenge_message_size}, Rxd=0, Lost=0")
            
        except Exception as e:
            print(f"DEBUG: [_substituir_activity_por_challenge] ERRO CRÍTICO: {e}")
            import traceback
            print(f"DEBUG: [_substituir_activity_por_challenge] Traceback completo: {traceback.format_exc()}")
            # Em caso de erro, tentar voltar à interface principal
            try:
                print(f"DEBUG: [_substituir_activity_por_challenge] Tentando recuperar interface...")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                print(f"DEBUG: [_substituir_activity_por_challenge] Interface recuperada")
            except Exception as e2:
                print(f"DEBUG: [_substituir_activity_por_challenge] ERRO ao recuperar interface: {e2}")
    
    def _resetar_valores_activity(self, carta_activity_path):
        """
        Reseta os valores de uma Activity interrompida por Challenge:
        - To send volta ao valor inicial (message_size)
        - Rxd (recebidos) = 0
        - Lost (perdidos) = 0
        """
        print(f"DEBUG: [_resetar_valores_activity] Resetando valores para {os.path.basename(carta_activity_path)}")
        
        try:
            # Verificar se as barras de progresso existem
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print(f"DEBUG: [_resetar_valores_activity] Barras de progresso não inicializadas")
                return
            
            # Obter message_size da carta para resetar "To send"
            message_size = self._get_card_message_size(carta_activity_path)
            print(f"DEBUG: [_resetar_valores_activity] Message size da Activity: {message_size}")
            
            # RESETAR "To send" para valor inicial (message_size)
            if "To send" in self.progress_bars:
                self.progress_bars["To send"]["value"] = message_size
                self.progress_bars["To send"]["maximum"] = message_size
                if "To send" in self.progress_labels:
                    self.progress_labels["To send"]["text"] = str(message_size)
                print(f"DEBUG: [_resetar_valores_activity] To send resetado para {message_size}")
            
            # RESETAR "Rxd" para 0
            if "Rxd" in self.progress_bars:
                self.progress_bars["Rxd"]["value"] = 0
                if "Rxd" in self.progress_labels:
                    self.progress_labels["Rxd"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Rxd resetado para 0")
            
            # RESETAR "Lost" para 0
            if "Lost" in self.progress_bars:
                self.progress_bars["Lost"]["value"] = 0
                if "Lost" in self.progress_labels:
                    self.progress_labels["Lost"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Lost resetado para 0")
            
            # Forçar atualização visual das barras
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars:
                    self.progress_bars[stat].update()
                if stat in self.progress_labels:
                    self.progress_labels[stat].update()
            
            print(f"DEBUG: [_resetar_valores_activity] Reset completo - Activity interrompida")
            
        except Exception as e:
            print(f"DEBUG: [_resetar_valores_activity] ERRO ao resetar valores: {e}")
            import traceback
            traceback.print_exc()
    
    def _mostrar_selecao_activity_para_substituir(self, activities_ativas, carta_challenge_path):
        """
        Mostra interface para jogador escolher qual Activity substituir quando há múltiplas ativas.
        """
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Mostrando seleção para {len(activities_ativas)} Activities")
        
        # Limpar widgets
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # Título
        title = tk.Label(self, text="Choose Activity to Replace", font=("Helvetica", 20, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Subtítulo
        subtitle = tk.Label(self, text=f"Replace with: {os.path.basename(carta_challenge_path)}", 
                           font=("Helvetica", 14), fg="yellow", bg="black")
        subtitle.place(relx=0.5, y=100, anchor="n")
        
        # Frame para as Activities
        selection_frame = tk.Frame(self, bg="black")
        selection_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 100, 140
        
        # Mostrar cada Activity ativa como opção clicável
        for i, (idx_carrossel, carta_activity_path) in enumerate(activities_ativas):
            try:
                img = ImageTk.PhotoImage(Image.open(carta_activity_path).resize((card_w, card_h)))
                
                # Label da carta
                carta_lbl = tk.Label(selection_frame, image=img, bg="black", cursor="hand2", 
                                   highlightthickness=2, highlightcolor="yellow")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=0, column=i, padx=15, pady=10)
                
                # Label com posição no carrossel
                pos_lbl = tk.Label(selection_frame, text=f"Position {idx_carrossel + 1}", 
                                 font=("Helvetica", 12, "bold"), fg="white", bg="black")
                pos_lbl.grid(row=1, column=i, pady=(5, 0))
                
                # Bind do clique para executar substituição
                def fazer_substituicao(idx=idx_carrossel, carta=carta_activity_path):
                    try:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ===== CLIQUE DETECTADO =====")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Jogador escolheu posição {idx}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Activity: {os.path.basename(carta)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Challenge: {os.path.basename(carta_challenge_path)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Chamando _substituir_activity_por_challenge...")
                        self._substituir_activity_por_challenge(idx, carta, carta_challenge_path)
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] _substituir_activity_por_challenge concluída")
                    except Exception as e:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO ao executar substituição: {e}")
                        import traceback
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Traceback: {traceback.format_exc()}")
                        # Em caso de erro, voltar à interface principal
                        try:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Tentando recuperar com playerdashboard_interface...")
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface recuperada com sucesso")
                        except Exception as e2:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO crítico ao voltar à interface: {e2}")
                
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Binding clique para Activity {i}: {os.path.basename(carta_activity_path)}")
                
                # Testar se o widget responde a eventos básicos de hover primeiro
                def on_enter(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse entrou na Activity {pos}")
                    lbl.config(highlightbackground="yellow")
                def on_leave(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse saiu da Activity {pos}")
                    lbl.config(highlightbackground="black")
                    
                carta_lbl.bind("<Enter>", on_enter)
                carta_lbl.bind("<Leave>", on_leave)
                
                # Bind de clique com debug detalhado
                carta_lbl.bind("<Button-1>", lambda e, f=fazer_substituicao, pos=i: (
                    print(f"DEBUG: [LAMBDA] ===== CLIQUE RECEBIDO ====="),
                    print(f"DEBUG: [LAMBDA] Widget: {e.widget}"),
                    print(f"DEBUG: [LAMBDA] Coordenadas: x={e.x}, y={e.y}"),
                    print(f"DEBUG: [LAMBDA] Activity posição: {pos}"),
                    print(f"DEBUG: [LAMBDA] Executando função de substituição..."),
                    f(),
                    print(f"DEBUG: [LAMBDA] Função executada!")
                )[-1])
                
                # Verificar se os widgets estão realmente visíveis e interativos
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widget Activity {i} criado:")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Widget: {carta_lbl}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Posição: {carta_lbl.winfo_x()}, {carta_lbl.winfo_y()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Tamanho: {carta_lbl.winfo_width()}x{carta_lbl.winfo_height()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Cursor: {carta_lbl.cget('cursor')}")
                
            except Exception as e:
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Erro ao carregar Activity {carta_activity_path}: {e}")
        
        # Botão cancelar
        cancel_btn = tk.Button(self, text="Cancel", font=("Helvetica", 14, "bold"), 
                              bg="#F44336", fg="white", width=8,
                              command=lambda: (print("DEBUG: [_mostrar_selecao_activity_para_substituir] Botão Cancel clicado"), 
                                             self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)))
        cancel_btn.place(relx=0.5, rely=0.8, anchor="center")
        
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface de seleção criada")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widgets criados: {len(self.winfo_children())} widgets")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Aguardando clique do jogador...")

    def _mostrar_mensagem_restricao_activity(self):
        """
        Mostra mensagem informando que não é possível trocar Activity ativa 
        enquanto houver Challenges no inventário.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot replace active Activity\nwhile Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar após 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_challenge_activity(self):
        """
        Mostra mensagem informando que Challenge só pode ser trocado por Activity.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_challenge_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Challenge can only be\nreplaced with Activity", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar após 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_activity_activity(self):
        """
        Mostra mensagem informando que Activity só pode ser trocada por outra Activity 
        se não há Challenges no inventário.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=450, height=220)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot swap Activity ↔ Activity\nwhen Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Submensagem
        submessage_lbl = tk.Label(overlay_frame, 
                                text="Use Challenges first", 
                                font=("Helvetica", 12), fg="lightgray", bg="black", justify="center")
        submessage_lbl.pack(pady=5)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=15)
        
        # Auto-fechar após 4 segundos (mais tempo para ler a mensagem)
        self.after(4000, fechar_mensagem)

    def show_card_fullscreen_readonly(self, carta_path, carta_tipo):
        """
        Mostra uma carta em fullscreen apenas para visualização (sem opções de venda).
        Usado para cartas ativas (viradas para cima) que não podem ser vendidas.
        """
        print(f"DEBUG: show_card_fullscreen_readonly chamado para {os.path.basename(carta_path)} (tipo: {carta_tipo})")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        
        try:
            # Carrega e redimensiona a imagem
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Mostra a carta centralizada
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
            # Função para voltar ao inventário
            def voltar_inventario():
                # Volta para a página de inventário do tipo correspondente
                if hasattr(self, '_current_sell_page') and self._current_sell_page is not None:
                    page = self._current_sell_page
                else:
                    page = 0
                # CORREÇÃO: Usar versão especial after_sale para manter consistência de estado
                self.show_inventory_for_sell_after_sale(carta_tipo, None, page)
            
            # Botão X para fechar - canto superior esquerdo
            x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), 
                            bg="#AAAAAA", fg="white", width=2, height=1, 
                            borderwidth=0, highlightthickness=0, 
                            command=voltar_inventario, cursor="hand2", 
                            activebackground="#CCCCCC")
            x_btn.place(relx=0.02, rely=0, anchor="nw")
            
        except Exception as e:
            print(f"DEBUG: Erro ao mostrar carta readonly: {e}")
            # Em caso de erro, volta ao inventário
            page = getattr(self, '_current_sell_page', 0)
            if page is None:
                page = 0
            self.show_inventory_for_sell(carta_tipo, None, page)

# Exemplo de uso isolado:
if __name__ == "__main__":
    root = tk.Tk()
    root.attributes("-fullscreen", True)  
    PlayerDashboard(root, player_color="red", saldo=1000, other_players=["green", "blue", "yellow"])
    check_gpio_key(root)
    root.mainloop()