import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk, UnidentifiedImageError
import os
import re
import traceback
import subprocess
import time
import threading
import string
import itertools
import netifaces
import socket
import json
import asyncio
import uuid
import __main__
from asyncio import Queue
try:
    import websockets
except ImportError:
    print("WARNING: websockets not installed. Online multiplayer will not work.")
    websockets = None
try:
    import RPi.GPIO as GPIO
except ImportError:
    # Mock para ambiente de desenvolvimento sem GPIO
    class MockGPIO:
        BCM = "BCM"
        IN = "IN"
        PUD_UP = "PUD_UP"
        LOW = False
        @staticmethod
        def setmode(mode): pass
        @staticmethod  
        def setup(pin, mode, pull_up_down=None): pass
        @staticmethod
        def input(pin): return True
        @staticmethod
        def cleanup(): pass
    GPIO = MockGPIO()
import random
from Store import StoreWindow

def normalize_session_state(session):
    """
    CORRE√á√ÉO CR√çTICA: Normaliza o campo 'state' da sess√£o para string
    Resolve problema onde servidor pode enviar enum em vez de string
    """
    if not isinstance(session, dict):
        return session
        
    state = session.get('state')
    if state is None:
        return session
    
    # Se √© enum, extrair o value
    if hasattr(state, 'value'):
        session['state'] = str(state.value)
        print(f"[DEBUG] ENUM CONVERTIDO: {state} -> '{state.value}'")
    elif hasattr(state, 'name'):
        session['state'] = str(state.name)
        print(f"[DEBUG] ENUM CONVERTIDO (name): {state} -> '{state.name}'")
    elif not isinstance(state, str):
        session['state'] = str(state)
        print(f"[DEBUG] TIPO CONVERTIDO: {type(state)} -> '{str(state)}'")
    else:
        print(f"[DEBUG] ‚úì STATE J√Å √â STRING: '{state}'")
    
    return session

# MENU INTEGRATION VARIABLES
LOCAL_PORT = 5050
DISCOVERY_PORT = 5001
TCP_PORT = LOCAL_PORT
USERNAME_FILE = os.path.join(os.path.dirname(__file__), "username.txt")
keyboard_state = "uppercase"
game_flow = "create"
clients = []
CARD_TYPES = ["users", "actions", "equipments", "challenges", "activities", "events", "services"]
COLORS = ["green", "yellow", "red", "blue", "neutral"]
baralhos = {}

# Menu player class
class MenuPlayer:
    def __init__(self, name: str, color: str, start_pos: int):
        self.name = name
        self.color = color
        self.pos = start_pos
    def __repr__(self):
        return f"<Player {self.name!r} pos={self.pos} color={self.color!r}>"

# ===============================
# NETMASTER CLIENT CLASS
# ===============================
class NetMasterClient:
    """Cliente WebSocket para conectar ao servidor NetMaster"""
    
    # Vari√°veis de classe para handlers globais compartilhados
    _global_handlers = {}
    _global_dashboard_setter = None
    
    def __init__(self, server_url="ws://netmaster.vps.tecnico.ulisboa.pt:8000"):
        self.server_url = server_url
        self.websocket = None
        self.player_id = None
        self.session_id = None
        self.connected = False
        self.message_handlers = {}
        self.connection_status_callback = None
        
        # NOVO: Sistema de queue para evitar conflito de corrotinas
        self.message_queue = None
        self.reader_task = None
        self.processor_task = None
        self._reading_lock = asyncio.Lock()
        
        # Flag para controle de join de sess√µes
        self.is_joining_session = False
        
        # *** NOVO: Registrar handlers globais automaticamente em TODAS as inst√¢ncias ***
        print(f"[NETMASTER_CLIENT] Nova inst√¢ncia criada - registrando handlers globais...")
        print(f"[NETMASTER_CLIENT] DEBUG: NetMasterClient._global_handlers = {NetMasterClient._global_handlers}")
        print(f"[NETMASTER_CLIENT] DEBUG: NetMasterClient._global_dashboard_setter = {NetMasterClient._global_dashboard_setter}")
        
        for handler_type, handler_func in NetMasterClient._global_handlers.items():
            self.message_handlers[handler_type] = handler_func
            print(f"[NETMASTER_CLIENT] ‚úì Handler global registrado: {handler_type}")
        
        # Registrar m√©todo set_active_dashboard se dispon√≠vel
        if NetMasterClient._global_dashboard_setter:
            self.set_active_dashboard = NetMasterClient._global_dashboard_setter
            print(f"[NETMASTER_CLIENT] ‚úì set_active_dashboard registrado")
        
        print(f"[NETMASTER_CLIENT] FINAL: self.message_handlers = {list(self.message_handlers.keys())}")
        
    def set_connection_status_callback(self, callback):
        """Define callback para mudan√ßas no status de conex√£o"""
        self.connection_status_callback = callback
        
    def set_message_handler(self, message_type, handler):
        """Define handler para tipos espec√≠ficos de mensagem"""
        print(f"[SET_HANDLER] Registrando handler: {message_type}")
        print(f"[SET_HANDLER] Handler function: {handler}")
        self.message_handlers[message_type] = handler
        print(f"[SET_HANDLER] Handlers ap√≥s registo: {list(self.message_handlers.keys())}")
        
        # Armazenar refer√™ncia para dashboard se o handler pertence a uma
        try:
            if hasattr(handler, '__self__') and hasattr(handler.__self__, 'on_multiplayer_turn_changed'):
                self._dashboard_ref = handler.__self__
                print(f"[HANDLER_REF] Dashboard reference armazenada: {type(self._dashboard_ref)}")
        except:
            pass
    
    @classmethod
    def register_global_handler(cls, message_type, handler):
        """Registra handler global que ser√° aplicado a TODAS as inst√¢ncias"""
        print(f"[NETMASTER_CLIENT] REGISTER_GLOBAL_HANDLER: Registrando {message_type}")
        print(f"[NETMASTER_CLIENT] REGISTER_GLOBAL_HANDLER: Handler function: {handler}")
        cls._global_handlers[message_type] = handler
        print(f"[NETMASTER_CLIENT] REGISTER_GLOBAL_HANDLER: _global_handlers agora: {cls._global_handlers}")
        
        # Aplicar a todas as inst√¢ncias existentes tamb√©m (se houver)
        # Nota: Em Python, n√£o h√° uma forma f√°cil de rastrear todas as inst√¢ncias
        # mas como estamos registrando no __init__, isso n√£o deveria ser problema
    
    @classmethod
    def set_global_dashboard_setter(cls, setter_func):
        """Define fun√ß√£o global para set_active_dashboard"""
        print(f"[NETMASTER_CLIENT] SET_GLOBAL_DASHBOARD_SETTER: Registrando dashboard setter")
        print(f"[NETMASTER_CLIENT] SET_GLOBAL_DASHBOARD_SETTER: Setter function: {setter_func}")
        cls._global_dashboard_setter = setter_func
    
    async def connect(self):
        """Conecta ao servidor WebSocket com prote√ß√£o contra m√∫ltiplas conex√µes"""
        try:
            print(f"[CONNECTION] *** FUNCTION CONNECT() CHAMADA! ***")
            
            # Verificar se j√° estamos conectados
            if self.connected and self.websocket and not self.websocket.closed:
                print(f"[CONNECTION] *** J√Å CONECTADO - REUTILIZANDO CONEX√ÉO ***")
                return True
            
            # Cancelar tasks anteriores se existirem - com verifica√ß√£o de loop
            current_loop = asyncio.get_running_loop()
            
            if hasattr(self, 'reader_task') and self.reader_task and not self.reader_task.done():
                print(f"[CONNECTION] *** CANCELANDO READER ANTERIOR ***")
                if self.reader_task.get_loop() == current_loop:
                    self.reader_task.cancel()
                    try:
                        await self.reader_task
                    except asyncio.CancelledError:
                        pass
                else:
                    print(f"[CONNECTION] *** READER EM LOOP DIFERENTE - IGNORANDO ***")
            
            if hasattr(self, 'processor_task') and self.processor_task and not self.processor_task.done():
                print(f"[CONNECTION] *** CANCELANDO PROCESSOR ANTERIOR ***")
                if self.processor_task.get_loop() == current_loop:
                    self.processor_task.cancel()
                    try:
                        await self.processor_task
                    except asyncio.CancelledError:
                        pass
                else:
                    print(f"[CONNECTION] *** PROCESSOR EM LOOP DIFERENTE - IGNORANDO ***")
            
            if hasattr(self, '_heartbeat_task') and self._heartbeat_task and not self._heartbeat_task.done():
                print(f"[CONNECTION] *** CANCELANDO HEARTBEAT ANTERIOR ***")
                if self._heartbeat_task.get_loop() == current_loop:
                    self._heartbeat_task.cancel()
                    try:
                        await self._heartbeat_task
                    except asyncio.CancelledError:
                        pass
                else:
                    print(f"[CONNECTION] *** HEARTBEAT EM LOOP DIFERENTE - IGNORANDO ***")
            
            if websockets is None:
                raise Exception("websockets library not available")
                
            print(f"[CONNECTION] Conectando ao servidor NetMaster: {self.server_url}")
            
            # Obter o loop de evento atual
            loop = asyncio.get_running_loop()
            print(f"[CONNECTION] *** LOOP OBTIDO: {loop} ***")
            
            # Configurar timeouts maiores para evitar disconnections
            self.websocket = await websockets.connect(
                self.server_url,
                ping_interval=25,  # Ping a cada 25 segundos (antes do heartbeat de 30s)
                ping_timeout=30,   # Timeout de 30 segundos para pong (mais tolerante)
                close_timeout=15   # Timeout de 15 segundos para fechar
            )
            self.connected = True
            print(f"[CONNECTION] *** CONEX√ÉO ESTABELECIDA! *** WebSocket: {self.websocket}")
            
            if self.connection_status_callback:
                self.connection_status_callback(True, "Conectado ao servidor")
            
            # NOVO: Inicializar sistema de queue
            self.message_queue = Queue()
            
            # Iniciar single reader e message processor √öNICOS
            print(f"[CONNECTION] *** INICIANDO SINGLE READER ***")
            self.reader_task = loop.create_task(self._single_websocket_reader())
            print(f"[CONNECTION] *** READER TASK CRIADA: {self.reader_task} ***")
            
            print(f"[CONNECTION] *** INICIANDO MESSAGE PROCESSOR ***")
            self.processor_task = loop.create_task(self._message_processor())
            print(f"[CONNECTION] *** PROCESSOR TASK CRIADA: {self.processor_task} ***")

            # Iniciar loop de heartbeat
            print(f"[CONNECTION] *** INICIANDO start_heartbeat_loop() ***")
            self._heartbeat_task = loop.create_task(self.start_heartbeat_loop())
            print(f"[CONNECTION] *** TASK start_heartbeat_loop() CRIADA: {self._heartbeat_task} ***")

            return True
            
        except Exception as e:
            print(f"Erro ao conectar: {e}")
            self.connected = False
            if self.connection_status_callback:
                self.connection_status_callback(False, f"Erro de conex√£o: {str(e)}")
            return False
    
    async def disconnect(self):
        """Desconecta do servidor"""
        if self.websocket and self.connected:
            await self.websocket.close()
            self.connected = False
            if self.connection_status_callback:
                self.connection_status_callback(False, "Desconectado")
    
    async def send_message(self, message):
        """Envia mensagem para o servidor"""
        print(f"[DEBUG] send_message: conectado={self.connected}, websocket={self.websocket is not None}")
        print(f"[DEBUG] Enviando mensagem: {message}")
        
        if not self.connected or not self.websocket:
            print("N√£o conectado ao servidor")
            return False
        
        try:
            message_str = json.dumps(message)
            print(f"[DEBUG] JSON serializado: {message_str}")
            await self.websocket.send(message_str)
            print(f"[DEBUG] Mensagem enviada com sucesso")
            return True
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _single_websocket_reader(self):
        """L√™ mensagens do WebSocket e as coloca na queue - √öNICA CORROTINA LENDO"""
        message_count = 0
        
        try:
            print(f"[SINGLE_READER] *** INICIANDO LEITURA √öNICA DO WEBSOCKET ***")
            
            async for message in self.websocket:
                message_count += 1
                print(f"[SINGLE_READER] Mensagem #{message_count}: {message}")
                
                # CRITICAL: Log ALL messages during join
                if self.is_joining_session:
                    print(f"[JOIN_CRITICAL] *** MENSAGEM DURANTE JOIN #{message_count} ***")
                    print(f"[JOIN_CRITICAL] MESSAGE: {message}")
                    print(f"[JOIN_CRITICAL] TIMESTAMP: {time.time()}")
                
                # SPECIAL: Log para session_joined
                if '"type": "session_joined"' in message:
                    print(f"[SINGLE_READER] *** SESSION_JOINED DETECTADO NA MENSAGEM #{message_count}! ***")
                    print(f"[SINGLE_READER] CONTENT: {message[:500]}...")
                
                # SPECIAL: Log para test_connectivity
                if '"type": "test_connectivity"' in message:
                    print(f"[SINGLE_READER] *** TEST_CONNECTIVITY DETECTADO NA MENSAGEM #{message_count}! ***")
                    print(f"[SINGLE_READER] CONTENT: {message}")
                
                # ENHANCED: Log WebSocket state
                print(f"[SINGLE_READER] WebSocket state: {self.websocket.state if hasattr(self.websocket, 'state') else 'unknown'}")
                print(f"[SINGLE_READER] WebSocket closed: {self.websocket.closed if hasattr(self.websocket, 'closed') else 'unknown'}")
                
                # Colocar mensagem na queue para processamento
                await self.message_queue.put(message)
                print(f"[SINGLE_READER] Mensagem #{message_count} adicionada √† queue")
                
        except Exception as e:
            print(f"[SINGLE_READER] Erro na leitura: {e}")
            import traceback
            print(f"[SINGLE_READER] Traceback: {traceback.format_exc()}")
            self.connected = False
            
        print(f"[SINGLE_READER] *** LEITURA FINALIZADA - {message_count} mensagens ***")
    
    async def _message_processor(self):
        """Processa mensagens da queue e executa handlers"""
        processed_count = 0
        
        try:
            print(f"[MESSAGE_PROCESSOR] *** INICIANDO PROCESSAMENTO DE MENSAGENS ***")
            
            while self.connected:
                try:
                    # Aguardar mensagem da queue com timeout
                    message = await asyncio.wait_for(self.message_queue.get(), timeout=1.0)
                    processed_count += 1
                    
                    print(f"[MESSAGE_PROCESSOR] Processando mensagem #{processed_count}: {message}")
                    
                    try:
                        data = json.loads(message)
                        message_type = data.get('type')
                        
                        print(f"[MESSAGE_PROCESSOR] Tipo: {message_type}")
                        
                        # DEBUG: Log ALL messages for join debugging
                        print(f"[JOIN_DEBUG] *** MENSAGEM RECEBIDA ***")
                        print(f"[JOIN_DEBUG] Tipo: {message_type}")
                        print(f"[JOIN_DEBUG] Data completa: {data}")
                        print(f"[JOIN_DEBUG] Timestamp: {time.time()}")
                        
                        # SPECIFIC: Debug session_joined messages
                        if message_type == 'session_joined':
                            print(f"[SESSION_JOINED_DEBUG] *** SESSION_JOINED DETECTADO! ***")
                            print(f"[SESSION_JOINED_DEBUG] Handlers dispon√≠veis: {list(self.message_handlers.keys())}")
                            print(f"[SESSION_JOINED_DEBUG] Handler session_joined existe: {'session_joined' in self.message_handlers}")
                            print(f"[SESSION_JOINED_DEBUG] Data recebida: {data}")
                            
                            # CRITICAL: Se handler existe mas n√£o foi executado, for√ßar execu√ß√£o
                            if 'session_joined' in self.message_handlers:
                                print(f"[SESSION_JOINED_DEBUG] Handler encontrado, for√ßando execu√ß√£o...")
                        
                        # SPECIFIC: Debug test_connectivity messages
                        if message_type == 'test_connectivity':
                            print(f"[TEST_CONNECTIVITY_DEBUG] *** TEST_CONNECTIVITY DETECTADO! ***")
                            print(f"[TEST_CONNECTIVITY_DEBUG] Data recebida: {data}")
                            print(f"[TEST_CONNECTIVITY_DEBUG] Timestamp: {time.time()}")
                        
                        # CRITICAL: Detec√ß√£o espec√≠fica para game_started
                        if message_type == 'game_started':
                            print(f"[GAME_STARTED_CRITICAL] *** GAME_STARTED RECEBIDO! ***")
                            print(f"[GAME_STARTED_CRITICAL] Data: {data}")
                            print(f"[GAME_STARTED_CRITICAL] Timestamp: {time.time()}")
                            print(f"[GAME_STARTED_CRITICAL] Processed count: {processed_count}")
                            
                            # For√ßar execu√ß√£o imediata do handler
                            if 'game_started' in self.message_handlers:
                                try:
                                    print(f"[GAME_STARTED_CRITICAL] Executando handler game_started...")
                                    self.message_handlers['game_started'](data)
                                    print(f"[GAME_STARTED_CRITICAL] Handler executado com sucesso!")
                                except Exception as handler_error:
                                    print(f"[GAME_STARTED_CRITICAL] ERRO no handler: {handler_error}")
                                    import traceback
                                    print(f"[GAME_STARTED_CRITICAL] Traceback: {traceback.format_exc()}")
                            else:
                                print(f"[GAME_STARTED_CRITICAL] ERRO: Handler n√£o encontrado!")
                                print(f"[GAME_STARTED_CRITICAL] Handlers dispon√≠veis: {list(self.message_handlers.keys())}")
                        
                        # CR√çTICO: DETEC√á√ÉO DE HANDLERS EM FALTA E RE-REGISTO AUTOM√ÅTICO
                        if message_type == 'turn_changed' and 'turn_changed' not in self.message_handlers:
                            print(f"[CRITICAL_FIX] *** HANDLER turn_changed EM FALTA! EMERG√äNCIA RE-REGISTO! ***")
                            print(f"[CRITICAL_FIX] Handlers actuais: {list(self.message_handlers.keys())}")
                            
                            # Tentar encontrar a dashboard instance e re-registar handlers
                            try:
                                dashboard_ref = None
                                
                                # Primeiro: usar refer√™ncia armazenada se existir
                                if hasattr(self, '_dashboard_ref') and self._dashboard_ref:
                                    dashboard_ref = self._dashboard_ref
                                    print(f"[CRITICAL_FIX] Usando dashboard reference armazenada")
                                
                                # Segundo: procurar em __main__
                                if not dashboard_ref:
                                    import __main__
                                    if hasattr(__main__, 'dashboard') and hasattr(__main__.dashboard, 'on_multiplayer_turn_changed'):
                                        dashboard_ref = __main__.dashboard
                                        print(f"[CRITICAL_FIX] Dashboard encontrada em __main__")
                                
                                # Terceiro: procurar via garbage collector
                                if not dashboard_ref:
                                    import gc
                                    for obj in gc.get_objects():
                                        if (hasattr(obj, 'on_multiplayer_turn_changed') and 
                                            hasattr(obj, 'waiting_for_turn') and
                                            callable(getattr(obj, 'on_multiplayer_turn_changed', None))):
                                            dashboard_ref = obj
                                            print(f"[CRITICAL_FIX] Dashboard encontrada via GC: {type(obj)}")
                                            break
                                
                                if dashboard_ref and hasattr(dashboard_ref, 'on_multiplayer_turn_changed'):
                                    print(f"[CRITICAL_FIX] *** RE-REGISTANDO HANDLERS CR√çTICOS ***")
                                    self.set_message_handler('turn_changed', dashboard_ref.on_multiplayer_turn_changed)
                                    self.set_message_handler('player_joined', getattr(dashboard_ref, 'on_player_joined', lambda x: None))
                                    self.set_message_handler('player_left', getattr(dashboard_ref, 'on_player_left', lambda x: None))
                                    self.set_message_handler('heartbeat_ack', getattr(dashboard_ref, 'on_heartbeat_ack', lambda x: None))
                                    print(f"[CRITICAL_FIX] ‚úì Handlers re-registados! Novos handlers: {list(self.message_handlers.keys())}")
                                    
                                    # Agora processar a mensagem turn_changed imediatamente
                                    print(f"[CRITICAL_FIX] *** PROCESSANDO MENSAGEM turn_changed IMEDIATAMENTE ***")
                                    dashboard_ref.on_multiplayer_turn_changed(data)
                                    print(f"[CRITICAL_FIX] ‚úì Mensagem turn_changed processada com sucesso!")
                                else:
                                    print(f"[CRITICAL_FIX] ‚ùå N√£o foi poss√≠vel encontrar dashboard instance para re-registo")
                                    
                            except Exception as fix_error:
                                print(f"[CRITICAL_FIX] ERRO no re-registo: {fix_error}")
                                import traceback
                                print(f"[CRITICAL_FIX] Traceback: {traceback.format_exc()}")
                        
                        # Chamar handler espec√≠fico se existir
                        if message_type in self.message_handlers:
                            print(f"[MESSAGE_PROCESSOR] Executando handler para {message_type}")
                            try:
                                handler = self.message_handlers[message_type]
                                print(f"[MESSAGE_PROCESSOR] Handler: {handler}")
                                handler(data)
                                print(f"[MESSAGE_PROCESSOR] Handler {message_type} executado com sucesso")
                            except Exception as handler_error:
                                print(f"[MESSAGE_PROCESSOR] *** ERRO NO HANDLER {message_type}: {handler_error}")
                                import traceback
                                print(f"[MESSAGE_PROCESSOR] Traceback: {traceback.format_exc()}")
                        else:
                            print(f"[MESSAGE_PROCESSOR] Nenhum handler para {message_type}")
                            print(f"[MESSAGE_PROCESSOR] Handlers dispon√≠veis: {list(self.message_handlers.keys())}")
                            print(f"[MESSAGE_PROCESSOR] *** DEBUG: Verificando inst√¢ncia global tamb√©m ***")
                            
                            # Tentar acessar a inst√¢ncia global via __main__
                            try:
                                import __main__
                                if hasattr(__main__, 'netmaster_client') and hasattr(__main__.netmaster_client, 'message_handlers'):
                                    print(f"[MESSAGE_PROCESSOR] Handlers globais: {list(__main__.netmaster_client.message_handlers.keys())}")
                                    # Tentar usar handler global se existe
                                    if message_type in __main__.netmaster_client.message_handlers:
                                        handler = __main__.netmaster_client.message_handlers[message_type]
                                        try:
                                            print(f"[MESSAGE_PROCESSOR] *** USANDO HANDLER GLOBAL para {message_type} ***")
                                            handler(data)
                                            print(f"[MESSAGE_PROCESSOR] Handler global {message_type} executado com sucesso")
                                            continue
                                        except Exception as handler_error:
                                            print(f"[MESSAGE_PROCESSOR] *** ERRO NO HANDLER GLOBAL {message_type}: {handler_error}")
                                else:
                                    print(f"[MESSAGE_PROCESSOR] Inst√¢ncia global n√£o dispon√≠vel ou sem message_handlers")
                            except Exception as global_access_error:
                                print(f"[MESSAGE_PROCESSOR] Erro acessando inst√¢ncia global: {global_access_error}")
                            
                            # Se √© uma mensagem cr√≠tica que perdemos, log cr√≠tico
                            if message_type in ['turn_changed', 'game_started', 'player_joined', 'player_left', 'timer_sync']:
                                print(f"[MESSAGE_PROCESSOR] *** MENSAGEM CR√çTICA PERDIDA: {message_type} ***")
                                print(f"[MESSAGE_PROCESSOR] *** RECOMENDA√á√ÉO: Verificar registo de handlers ***")
                            
                            # FALLBACK ESPECIAL: Se √© pending_cards, tentar usar inst√¢ncia global diretamente
                            if message_type == 'pending_cards':
                                print(f"[MESSAGE_PROCESSOR] *** FALLBACK: pending_cards sem handler - tentando inst√¢ncia global ***")
                                try:
                                    # Importar inst√¢ncia global diretamente via __main__
                                    import __main__
                                    if hasattr(__main__, 'netmaster_client'):
                                        global_client = __main__.netmaster_client
                                        print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Verificando inst√¢ncia global... ***")
                                        
                                        # Se a inst√¢ncia global tem o handler, usar diretamente
                                        if hasattr(global_client, 'message_handlers') and 'pending_cards' in global_client.message_handlers:
                                            handler = global_client.message_handlers['pending_cards']
                                            print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Usando handler da inst√¢ncia global! ***")
                                            handler(data)
                                            print(f"[MESSAGE_PROCESSOR] *** FALLBACK: pending_cards executado com sucesso via inst√¢ncia global! ***")
                                            continue
                                        else:
                                            # Se n√£o tem handler, registrar na inst√¢ncia global e usar diretamente
                                            from PlayerDashboard import register_global_handlers
                                            print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Registrando handlers na inst√¢ncia global... ***")
                                            register_global_handlers()
                                            
                                            # Agora usar o handler diretamente da inst√¢ncia global AP√ìS o registo
                                            if hasattr(__main__, 'netmaster_client') and hasattr(__main__.netmaster_client, 'message_handlers') and 'pending_cards' in __main__.netmaster_client.message_handlers:
                                                handler = __main__.netmaster_client.message_handlers['pending_cards']
                                                print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Handler registrado na inst√¢ncia global! Executando... ***")
                                                handler(data)
                                                print(f"[MESSAGE_PROCESSOR] *** FALLBACK: pending_cards executado com sucesso! ***")
                                                continue
                                            else:
                                                print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Falha completa - handler n√£o dispon√≠vel na inst√¢ncia global ap√≥s registo ***")
                                    else:
                                        print(f"[MESSAGE_PROCESSOR] *** FALLBACK: Inst√¢ncia global n√£o encontrada ***")
                                            
                                except Exception as fallback_error:
                                    print(f"[MESSAGE_PROCESSOR] *** FALLBACK ERROR: {fallback_error} ***")
                                    import traceback
                                    print(f"[MESSAGE_PROCESSOR] *** FALLBACK TRACEBACK: {traceback.format_exc()} ***")
                            
                            # BACKUP: Verificar se √© session_joined e tentar chamada direta
                            if message_type == 'session_joined':
                                print(f"[MESSAGE_PROCESSOR] *** BACKUP: Tentando chamar on_session_joined diretamente ***")
                                try:
                                    # Buscar inst√¢ncia do PlayerDashboard que tem o m√©todo
                                    import __main__
                                    if hasattr(__main__, 'dashboard') and hasattr(__main__.dashboard, 'on_session_joined'):
                                        print(f"[MESSAGE_PROCESSOR] Encontrou dashboard.on_session_joined, executando...")
                                        __main__.dashboard.on_session_joined(data)
                                        print(f"[MESSAGE_PROCESSOR] BACKUP: on_session_joined executado com sucesso!")
                                    else:
                                        print(f"[MESSAGE_PROCESSOR] BACKUP: N√£o encontrou dashboard.on_session_joined")
                                except Exception as backup_error:
                                    print(f"[MESSAGE_PROCESSOR] BACKUP: Erro: {backup_error}")
                                    import traceback
                                    print(f"[MESSAGE_PROCESSOR] BACKUP: Traceback: {traceback.format_exc()}")
                            
                    except json.JSONDecodeError:
                        print(f"[MESSAGE_PROCESSOR] JSON inv√°lido: {message}")
                    except Exception as e:
                        print(f"[MESSAGE_PROCESSOR] Erro processando: {e}")
                        import traceback
                        print(f"[MESSAGE_PROCESSOR] Traceback: {traceback.format_exc()}")
                    
                    # Marcar task como conclu√≠da
                    self.message_queue.task_done()
                    
                except asyncio.TimeoutError:
                    # Timeout normal - continuar verificando
                    continue
                except Exception as e:
                    print(f"[MESSAGE_PROCESSOR] Erro no loop: {e}")
                    break
                    
        except Exception as e:
            print(f"[MESSAGE_PROCESSOR] Erro geral: {e}")
            import traceback
            print(f"[MESSAGE_PROCESSOR] Traceback: {traceback.format_exc()}")
            
        print(f"[MESSAGE_PROCESSOR] *** PROCESSAMENTO FINALIZADO - {processed_count} mensagens ***")

    async def listen_for_messages(self):
        """DEPRECADO: Manter para compatibilidade - agora usa o sistema de queue"""
        print(f"[DEPRECATED_LISTEN] Esta fun√ß√£o foi substitu√≠da pelo sistema de queue")
        print(f"[DEPRECATED_LISTEN] Reader task: {self.reader_task}")
        print(f"[DEPRECATED_LISTEN] Processor task: {self.processor_task}")
        
        # Se as tasks n√£o existem, criar elas
        if not self.reader_task or self.reader_task.done():
            print(f"[DEPRECATED_LISTEN] Criando reader task...")
            self.reader_task = asyncio.create_task(self._single_websocket_reader())
            
        if not self.processor_task or self.processor_task.done():
            print(f"[DEPRECATED_LISTEN] Criando processor task...")
            self.processor_task = asyncio.create_task(self._message_processor())
        
        # Aguardar as tasks
        try:
            await asyncio.gather(self.reader_task, self.processor_task)
        except Exception as e:
            print(f"[DEPRECATED_LISTEN] Erro aguardando tasks: {e}")
    
    async def test_websocket_connectivity(self):
        """Testa se o WebSocket est√° realmente recebendo mensagens"""
        try:
            print(f"[CONNECTIVITY_TEST] Iniciando teste de conectividade...")
            
            # Registrar handler tempor√°rio para detectar resposta
            test_received = False
            
            def temp_handler(data):
                nonlocal test_received
                msg_type = data.get('type', '')
                if msg_type in ['sessions_list', 'welcome', 'sessions_list_update']:
                    test_received = True
                    print(f"[CONNECTIVITY_TEST] Mensagem recebida: {msg_type}")
            
            # Registrar handler tempor√°rio
            self.set_message_handler('CONNECTIVITY_TEST', temp_handler)
            
            # Enviar mensagem de teste
            result = await self.list_sessions()
            print(f"[CONNECTIVITY_TEST] list_sessions enviado: {result}")
            
            # Aguardar resposta por 3 segundos
            for i in range(30):  # 3 segundos (30 * 0.1s)
                if test_received:
                    print(f"[CONNECTIVITY_TEST] Teste PASSOU - WebSocket est√° recebendo mensagens")
                    return True
                await asyncio.sleep(0.1)
            
            print(f"[CONNECTIVITY_TEST] Teste FALHOU - WebSocket N√ÉO est√° recebendo mensagens")
            return False
            
        except Exception as e:
            print(f"[CONNECTIVITY_TEST] Erro no teste: {e}")
            return False
        finally:
            # Remover handler tempor√°rio
            if hasattr(self, 'message_handlers') and 'CONNECTIVITY_TEST' in self.message_handlers:
                del self.message_handlers['CONNECTIVITY_TEST']
                print(f"[CONNECTIVITY_TEST] Handler tempor√°rio removido")
    
    async def create_session(self, player_name, color, duration_minutes=30):
        """Cria nova sess√£o de jogo"""
        message = {
            'type': 'create_session',
            'player_name': player_name,
            'color': color,
            'duration_minutes': duration_minutes
        }
        return await self.send_message(message)
    
    async def join_session(self, session_id, player_name, color):
        """Junta-se a uma sess√£o existente"""
        print(f"[JOIN_SESSION] *** INICIANDO JOIN_SESSION ***")
        print(f"[JOIN_SESSION] session_id: {session_id}")
        print(f"[JOIN_SESSION] player_name: {player_name}")
        print(f"[JOIN_SESSION] color: {color}")
        print(f"[JOIN_SESSION] connected: {self.connected}")
        print(f"[JOIN_SESSION] websocket: {self.websocket}")
        
        message = {
            'type': 'join_session',
            'session_id': session_id,
            'player_name': player_name,
            'color': color
        }
        print(f"[JOIN_SESSION] Enviando: {message}")
        result = await self.send_message(message)
        print(f"[JOIN_SESSION] Resultado: {result}")
        return result
    
    async def start_game(self):
        """Inicia o jogo (apenas host)"""
        if not self.player_id:
            return False
            
        message = {
            'type': 'start_game',
            'player_id': self.player_id
        }
        return await self.send_message(message)
    
    async def send_game_action(self, action_type, action_data):
        """Envia a√ß√£o de jogo"""
        if not self.player_id:
            return False
            
        message = {
            'type': 'game_action',
            'player_id': self.player_id,
            'action_type': action_type,
            'action_data': action_data
        }
        return await self.send_message(message)
    
    async def list_sessions(self):
        """Solicita lista de sess√µes dispon√≠veis"""
        print(f"[DEBUG] list_sessions chamado, connected: {self.connected}")
        message = {
            'type': 'list_sessions'
        }
        print(f"[DEBUG] Enviando mensagem list_sessions: {message}")
        result = await self.send_message(message)
        print(f"[DEBUG] Mensagem list_sessions enviada, resultado: {result}")
        return result
    
    async def send_heartbeat(self):
        """Envia heartbeat para manter a conex√£o ativa"""
        if not self.connected or not self.websocket:
            return False
            
        message = {
            'type': 'heartbeat',
            'player_id': self.player_id,
            'timestamp': time.time()
        }
        
        try:
            result = await self.send_message(message)
            player_name = getattr(self, 'player_name', 'Unknown')
            if self.player_id:
                print(f"[HEARTBEAT] Heartbeat enviado - player_id: {self.player_id}, player_name: {player_name}")
                print(f"[HEARTBEAT] *** HEARTBEAT DATA: {message} ***")
            else:
                print(f"[HEARTBEAT] *** WARNING: Heartbeat enviado sem player_id! ***")
                print(f"[HEARTBEAT] *** HEARTBEAT DATA: {message} ***")
                print(f"[HEARTBEAT] *** ESTE HEARTBEAT SER√Å IGNORADO PELO SERVIDOR! ***")
            return result
        except Exception as e:
            print(f"[HEARTBEAT] Erro ao enviar heartbeat: {e}")
            return False
    
    async def start_heartbeat_loop(self):
        """Inicia o loop de heartbeat em background"""
        print(f"[HEARTBEAT] Iniciando loop de heartbeat...")
        
        while self.connected:
            try:
                await self.send_heartbeat()
                
                # Aguardar 20 segundos antes do pr√≥ximo heartbeat (mais frequente que ping_interval)
                # Dividir em 20 esperas de 1 segundo para permitir parada mais r√°pida
                for _ in range(20):
                    if not self.connected:
                        break
                    await asyncio.sleep(1)
                    
            except websockets.exceptions.ConnectionClosed:
                print(f"[HEARTBEAT] Conex√£o WebSocket fechada")
                self.connected = False
                break
            except Exception as e:
                print(f"[HEARTBEAT] Erro no loop de heartbeat: {e}")
                # Tentar reconectar ap√≥s erro
                await asyncio.sleep(5)
                if not self.connected:
                    break
        
        print(f"[HEARTBEAT] Loop de heartbeat finalizado")

# Inst√¢ncia global do cliente
netmaster_client = NetMasterClient()

# Fun√ß√£o global para registar handlers b√°sicos
def register_global_handlers():
    """Regista handlers globais que precisam estar sempre dispon√≠veis"""
    print("[GLOBAL_HANDLERS] *** REGISTANDO HANDLERS GLOBAIS ***")
    print(f"[GLOBAL_HANDLERS] DEBUG: netmaster_client object: {netmaster_client}")
    print(f"[GLOBAL_HANDLERS] DEBUG: netmaster_client type: {type(netmaster_client)}")
    print(f"[GLOBAL_HANDLERS] DEBUG: netmaster_client has set_message_handler: {hasattr(netmaster_client, 'set_message_handler')}")
    print(f"[GLOBAL_HANDLERS] DEBUG: netmaster_client.message_handlers before: {getattr(netmaster_client, 'message_handlers', 'NOT_FOUND')}")
    
    # Vari√°vel global para manter refer√™ncia √† inst√¢ncia ativa do PlayerDashboard
    active_player_dashboard = None
    
    # Sistema de cartas em espera - PERSISTENTE entre execu√ß√µes
    import tempfile
    import json
    
    # Arquivo tempor√°rio para persistir cartas em espera
    temp_dir = tempfile.gettempdir()
    pending_cards_file = os.path.join(temp_dir, "netmaster_pending_cards.json")
    
    def load_pending_cards():
        """Carrega cartas pendentes do arquivo tempor√°rio"""
        try:
            if os.path.exists(pending_cards_file):
                with open(pending_cards_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    print(f"[GLOBAL_HANDLERS] üìÇ Carregadas {len(data)} cartas pendentes do arquivo")
                    return data
        except Exception as e:
            print(f"[GLOBAL_HANDLERS] Erro ao carregar cartas pendentes: {e}")
        return []
    
    def save_pending_cards(cards_queue):
        """Salva cartas pendentes no arquivo tempor√°rio"""
        try:
            with open(pending_cards_file, 'w', encoding='utf-8') as f:
                json.dump(cards_queue, f, indent=2, ensure_ascii=False)
                print(f"[GLOBAL_HANDLERS] üíæ Salvadas {len(cards_queue)} cartas pendentes")
        except Exception as e:
            print(f"[GLOBAL_HANDLERS] Erro ao salvar cartas pendentes: {e}")
    
    def clear_pending_cards():
        """Remove arquivo de cartas pendentes"""
        try:
            if os.path.exists(pending_cards_file):
                os.remove(pending_cards_file)
                print(f"[GLOBAL_HANDLERS] Arquivo de cartas pendentes removido")
        except Exception as e:
            print(f"[GLOBAL_HANDLERS] Erro ao remover arquivo de cartas pendentes: {e}")
    
    # Carregar cartas pendentes existentes (de execu√ß√µes anteriores)
    pending_cards_queue = load_pending_cards()
    if pending_cards_queue:
        print(f"[GLOBAL_HANDLERS] Sistema iniciado com {len(pending_cards_queue)} cartas pendentes de execu√ß√µes anteriores")
    
    def set_active_dashboard(dashboard):
        nonlocal active_player_dashboard, pending_cards_queue
        active_player_dashboard = dashboard
        dashboard_color = getattr(dashboard, 'player_color', 'UNKNOWN')
        print(f"[GLOBAL_HANDLERS] PlayerDashboard ativo definido: {dashboard_color}")
        
        # Processar cartas que estavam em espera
        if pending_cards_queue:
            print(f"[GLOBAL_HANDLERS] Processando {len(pending_cards_queue)} cartas que estavam em espera...")
            processed_count = 0
            remaining_queue = []
            
            for queued_data in pending_cards_queue:
                try:
                    print(f"[GLOBAL_HANDLERS] ‚úì Processando carta em espera para {dashboard_color}")
                    dashboard.on_pending_cards_received(queued_data)
                    processed_count += 1
                except Exception as e:
                    print(f"[GLOBAL_HANDLERS] ‚ùå Erro ao processar carta em espera: {e}")
                    # Manter carta na fila se houver erro
                    remaining_queue.append(queued_data)
            
            # Atualizar fila com cartas que n√£o foram processadas
            pending_cards_queue = remaining_queue
            
            if processed_count > 0:
                print(f"[GLOBAL_HANDLERS] ‚úì {processed_count} cartas em espera foram processadas com sucesso")
                
            if pending_cards_queue:
                print(f"[GLOBAL_HANDLERS] {len(pending_cards_queue)} cartas permanecem em espera")
                save_pending_cards(pending_cards_queue)
            else:
                print(f"[GLOBAL_HANDLERS] üéâ Todas as cartas em espera foram processadas!")
                clear_pending_cards()
    
    # Handlers globais b√°sicos que funcionam sem inst√¢ncia do PlayerDashboard
    def on_pending_cards_global(data):
        """Handler global para cartas pendentes"""
        print(f"[GLOBAL_HANDLERS] *** CARTAS PENDENTES RECEBIDAS ***")
        print(f"[GLOBAL_HANDLERS] Data: {data}")
        
        # DEBUG: Verificar se h√° inst√¢ncia ativa
        print(f"[GLOBAL_HANDLERS] Verificando inst√¢ncia ativa...")
        print(f"[GLOBAL_HANDLERS] active_player_dashboard: {active_player_dashboard}")
        
        if active_player_dashboard:
            print(f"[GLOBAL_HANDLERS] Tipo da inst√¢ncia: {type(active_player_dashboard)}")
            print(f"[GLOBAL_HANDLERS] Cor do jogador: {getattr(active_player_dashboard, 'player_color', 'UNKNOWN')}")
            print(f"[GLOBAL_HANDLERS] Tem m√©todo on_pending_cards_received: {hasattr(active_player_dashboard, 'on_pending_cards_received')}")
        
        # Tentar usar inst√¢ncia ativa se dispon√≠vel
        if active_player_dashboard and hasattr(active_player_dashboard, 'on_pending_cards_received'):
            try:
                print("[GLOBAL_HANDLERS] ‚úì Redirecionando para PlayerDashboard ativo...")
                active_player_dashboard.on_pending_cards_received(data)
                print("[GLOBAL_HANDLERS] ‚úì Redirecionamento conclu√≠do com sucesso!")
                return
            except Exception as e:
                print(f"[GLOBAL_HANDLERS] ‚ùå Erro ao redirecionar para PlayerDashboard: {e}")
                import traceback
                print(f"[GLOBAL_HANDLERS] Traceback: {traceback.format_exc()}")
        
        # Sem inst√¢ncia ativa - adicionar √† fila de espera PERSISTENTE
        print("[GLOBAL_HANDLERS] PlayerDashboard n√£o dispon√≠vel - adicionando cartas √† fila de espera persistente...")
        pending_cards_queue.append(data)
        save_pending_cards(pending_cards_queue)  # Salvar imediatamente no arquivo
        print(f"[GLOBAL_HANDLERS] Total cartas em espera (persistente): {len(pending_cards_queue)}")
        
        # Processar as cartas globalmente (para debug)
        cards = data.get('cards', [])
        for card in cards:
            card_path = card.get('card_path', card.get('card_id', 'unknown'))  # Suportar ambos os formatos
            card_type = card.get('card_type', 'unknown')
            from_player = card.get('from_player', 'unknown')
            print(f"[GLOBAL_HANDLERS] üé¥ Carta em espera (PERSISTENTE): {os.path.basename(card_path)} ({card_type}) de {from_player}")
        
        print(f"[GLOBAL_HANDLERS] Cartas ser√£o processadas quando PlayerDashboard for ativo (mesmo em execu√ß√µes futuras!)")
        
    def on_card_returned_to_store_global(data):
        """Handler global para cartas devolvidas"""
        print(f"[GLOBAL_HANDLERS] Carta devolvida √† loja: {data}")
        
        # Tentar usar inst√¢ncia ativa se dispon√≠vel
        if active_player_dashboard and hasattr(active_player_dashboard, 'on_card_returned_to_store'):
            try:
                print("[GLOBAL_HANDLERS] ‚úì Redirecionando para PlayerDashboard ativo...")
                active_player_dashboard.on_card_returned_to_store(data)
                return
            except Exception as e:
                print(f"[GLOBAL_HANDLERS] Erro ao redirecionar para PlayerDashboard: {e}")
                
        print("[GLOBAL_HANDLERS] PlayerDashboard n√£o dispon√≠vel - carta devolvida processada globalmente")
    
    def on_timer_sync_global(data):
        """Handler global para sincroniza√ß√£o do timer"""
        print(f"[GLOBAL_HANDLERS] *** TIMER_SYNC GLOBAL RECEBIDO ***")
        print(f"[GLOBAL_HANDLERS] Data: {data}")
        
        nonlocal active_player_dashboard
        if active_player_dashboard:
            try:
                print(f"[GLOBAL_HANDLERS] ‚úì Redirecionando timer_sync para PlayerDashboard ativo")
                active_player_dashboard.on_timer_sync(data)
            except Exception as e:
                print(f"[GLOBAL_HANDLERS] ‚ùå Erro ao processar timer_sync: {e}")
        else:
            print("[GLOBAL_HANDLERS] PlayerDashboard n√£o dispon√≠vel - timer_sync ignorado")
    
    def on_game_finished_global(data):
        """Handler global para fim de jogo"""
        print(f"[GLOBAL_HANDLERS] *** GAME_FINISHED GLOBAL RECEBIDO ***")
        print(f"[GLOBAL_HANDLERS] Data: {data}")
        
        nonlocal active_player_dashboard
        if active_player_dashboard:
            try:
                print(f"[GLOBAL_HANDLERS] ‚úì Redirecionando game_finished para PlayerDashboard ativo")
                # Chamar diretamente o m√©todo show_game_result_screen
                if hasattr(active_player_dashboard, 'show_game_result_screen'):
                    active_player_dashboard.show_game_result_screen(data)
                else:
                    print(f"[GLOBAL_HANDLERS] PlayerDashboard n√£o tem m√©todo show_game_result_screen")
            except Exception as e:
                print(f"[GLOBAL_HANDLERS] ‚ùå Erro ao processar game_finished: {e}")
        else:
            print("[GLOBAL_HANDLERS] PlayerDashboard n√£o dispon√≠vel - game_finished ignorado")
            
    try:
        # *** USAR M√âTODO DE CLASSE PARA REGISTRAR EM TODAS AS INST√ÇNCIAS ***
        NetMasterClient.register_global_handler('pending_cards', on_pending_cards_global)
        NetMasterClient.register_global_handler('card_returned_to_store', on_card_returned_to_store_global)
        NetMasterClient.register_global_handler('timer_sync', on_timer_sync_global)
        NetMasterClient.register_global_handler('game_finished', on_game_finished_global)
        NetMasterClient.set_global_dashboard_setter(set_active_dashboard)
        
        # Tamb√©m registrar na inst√¢ncia global atual para compatibilidade
        netmaster_client.set_message_handler('pending_cards', on_pending_cards_global)
        netmaster_client.set_message_handler('card_returned_to_store', on_card_returned_to_store_global)
        netmaster_client.set_message_handler('timer_sync', on_timer_sync_global)
        netmaster_client.set_message_handler('game_finished', on_game_finished_global)
        netmaster_client.set_active_dashboard = set_active_dashboard
        
        print("[GLOBAL_HANDLERS] ‚úì Handlers globais registados com sucesso:")
        print("[GLOBAL_HANDLERS]   - pending_cards (inteligente)")
        print("[GLOBAL_HANDLERS]   - card_returned_to_store (inteligente)")
        print("[GLOBAL_HANDLERS]   - timer_sync (inteligente)")
        print("[GLOBAL_HANDLERS]   - game_finished (inteligente)")
        
        # DEBUG: Verificar se os handlers realmente foram registrados
        print(f"[GLOBAL_HANDLERS] DEBUG: Verificando handlers registrados...")
        print(f"[GLOBAL_HANDLERS] DEBUG: NetMasterClient._global_handlers: {NetMasterClient._global_handlers}")
        print(f"[GLOBAL_HANDLERS] DEBUG: netmaster_client.message_handlers keys: {list(netmaster_client.message_handlers.keys())}")
        print(f"[GLOBAL_HANDLERS] DEBUG: Handler 'pending_cards' existe: {'pending_cards' in netmaster_client.message_handlers}")
        print(f"[GLOBAL_HANDLERS] DEBUG: Handler 'card_returned_to_store' existe: {'card_returned_to_store' in netmaster_client.message_handlers}")
        print(f"[GLOBAL_HANDLERS] DEBUG: Handler 'timer_sync' existe: {'timer_sync' in netmaster_client.message_handlers}")
        print(f"[GLOBAL_HANDLERS] DEBUG: Handler 'game_finished' existe: {'game_finished' in netmaster_client.message_handlers}")
        
    except Exception as e:
        print(f"[GLOBAL_HANDLERS] ERROR: Erro ao registar handlers globais: {e}")
        import traceback
        print(f"[GLOBAL_HANDLERS] ERROR: Traceback: {traceback.format_exc()}")

# Registar handlers globais imediatamente
print("[INIT] *** CHAMANDO register_global_handlers() ***")
print(f"[INIT] ANTES: NetMasterClient._global_handlers = {NetMasterClient._global_handlers}")
print(f"[INIT] ANTES: NetMasterClient._global_dashboard_setter = {NetMasterClient._global_dashboard_setter}")

register_global_handlers()

print("[INIT] *** register_global_handlers() COMPLETADO ***")
print(f"[INIT] DEPOIS: NetMasterClient._global_handlers = {NetMasterClient._global_handlers}")
print(f"[INIT] DEPOIS: NetMasterClient._global_dashboard_setter = {NetMasterClient._global_dashboard_setter}")

# Debug final
print(f"[INIT] FINAL DEBUG: netmaster_client.message_handlers: {netmaster_client.message_handlers}")
print(f"[INIT] FINAL DEBUG: Handlers dispon√≠veis: {list(netmaster_client.message_handlers.keys())}")

# Importar utilit√°rios para detec√ß√£o de Raspberry Pi
from raspberry_pi_utils import get_universal_paths, find_existing_path, get_possible_raspberry_pi_paths
# Importar sistema de integra√ß√£o da base de dados
try:
    from card_integration import IntegratedCardDatabase
    from cards_database import ActionType
    print("DEBUG: IntegratedCardDatabase e ActionType importadas com sucesso")
except ImportError as e:
    print(f"DEBUG: ERRO ao importar IntegratedCardDatabase ou ActionType: {e}")
    IntegratedCardDatabase = None
    ActionType = None

# Obter caminhos universais usando os utilit√°rios
universal_paths = get_universal_paths()
IMG_DIR = universal_paths['img_dir']
print(f"DEBUG: Usando IMG_DIR: {IMG_DIR} (ambiente: {universal_paths['environment']})")

# Detectar automaticamente onde est√£o as cartas
def detect_cartas_base_dir():
    """Detecta automaticamente o diret√≥rio base das cartas usando caminhos universais"""
    # Usar os caminhos universais j√° detectados
    universal_paths = get_universal_paths()
    
    # CORRE√á√ÉO ESPEC√çFICA: Se estivermos no Raspberry Pi, for√ßar o caminho correto
    if universal_paths['environment'] == 'raspberry_pi':
        raspberry_cartas_dir = "/home/joaorebolo2/netmaster_menu/img/cartas"
        if os.path.exists(raspberry_cartas_dir):
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Usando caminho correto: {raspberry_cartas_dir}")
            return raspberry_cartas_dir
        else:
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Caminho esperado n√£o existe: {raspberry_cartas_dir}")
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Usando fallback: {universal_paths['cartas_dir']}")
            return universal_paths['cartas_dir']
    
    # Para desenvolvimento local, usar a l√≥gica original
    # Testar se o diret√≥rio base tem a estrutura esperada de cartas
    test_paths = [
        os.path.join(universal_paths['base_dir'], "Activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Users", "Residential-level"),  
        os.path.join(universal_paths['base_dir'], "Events", "Residential-level")
    ]
    
    if any(os.path.exists(test_path) for test_path in test_paths):
        print(f"DEBUG: Usando diret√≥rio de cartas: {universal_paths['base_dir']}")
        return universal_paths['base_dir']
    
    # Se n√£o encontrar na estrutura esperada, tentar o diret√≥rio de cartas
    if os.path.exists(universal_paths['cartas_dir']):
        print(f"DEBUG: Usando diret√≥rio de cartas alternativo: {universal_paths['cartas_dir']}")
        return os.path.dirname(universal_paths['cartas_dir'])
    
    print("DEBUG: Nenhum diret√≥rio de cartas encontrado, usando base_dir como fallback")
    return universal_paths['base_dir']

def detect_player_inventory_base_dir():
    """Detecta automaticamente o diret√≥rio base do invent√°rio do jogador"""
    # Usar os utilit√°rios universais
    universal_paths = get_universal_paths()
    
    print(f"DEBUG: [detect_player_inventory_base_dir] Ambiente detectado: {universal_paths['environment']}")
    print(f"DEBUG: [detect_player_inventory_base_dir] Verificando diret√≥rios poss√≠veis...")
    print(f"DEBUG: [detect_player_inventory_base_dir] Diret√≥rio base: {universal_paths['base_dir']}")
    
    # CORRE√á√ÉO ESPEC√çFICA: Se estivermos no Raspberry Pi, for√ßar o caminho correto
    if universal_paths['environment'] == 'raspberry_pi':
        raspberry_cartas_dir = "/home/joaorebolo2/netmaster_menu/img/cartas"
        if os.path.exists(raspberry_cartas_dir):
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Usando caminho correto: {raspberry_cartas_dir}")
            return raspberry_cartas_dir
        else:
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Caminho esperado n√£o existe: {raspberry_cartas_dir}")
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Usando fallback: {universal_paths['cartas_dir']}")
            return universal_paths['cartas_dir']
    
    # Para desenvolvimento local, usar a l√≥gica original
    # Testar se o diret√≥rio base tem a estrutura esperada
    test_paths = [
        os.path.join(universal_paths['base_dir'], "Activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Users", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Events", "Residential-level"),
        # Para Raspberry Pi, testar tamb√©m estrutura alternativa
        os.path.join(universal_paths['base_dir'], "activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "users", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "events", "Residential-level")
    ]
    
    print(f"DEBUG: [detect_player_inventory_base_dir] Testando caminhos:")
    for j, test_path in enumerate(test_paths):
        exists = os.path.exists(test_path)
        print(f"DEBUG: [detect_player_inventory_base_dir]   Teste {j+1}: {test_path} -> {exists}")
        
        if exists:
            print(f"DEBUG: [detect_player_inventory_base_dir] Encontrado invent√°rio em: {universal_paths['base_dir']}")
            return universal_paths['base_dir']
    
    print("DEBUG: Nenhum diret√≥rio de invent√°rio do jogador encontrado!")
    print(f"DEBUG: Usando fallback: {universal_paths['base_dir']}")
    return universal_paths['base_dir']

CARTAS_BASE_DIR = detect_cartas_base_dir()
COIN_IMG = os.path.join(IMG_DIR, "picoin.png")
USER_ICONS = [
    os.path.join(IMG_DIR, "red_user_icon.png"),
    os.path.join(IMG_DIR, "green_user_icon.png"),
    os.path.join(IMG_DIR, "blue_user_icon.png"),
    os.path.join(IMG_DIR, "yellow_user_icon.png"),
]

CARD_IMG = os.path.join(IMG_DIR, "cartas", "back_card.png")

# GPIO setup para bot√£o KEY1
KEY1_PIN = 23
GPIO.setmode(GPIO.BCM)
GPIO.setup(KEY1_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

BOARD = [
    # Top row (left to right)
    ("start", "neutral"),      # 0 canto azul
    ("users", "blue"),         # 1
    ("actions", "neutral"),     # 2 (cinzento)
    ("equipments", "blue"),     # 3
    ("challenges", "neutral"), # 4 (cinzento)
    ("activities", "red"),      # 5
    ("events", "neutral"),     # 6 (cinzento)
    ("services", "red"),       # 7

    # Right column (top to bottom)
    ("start", "neutral"),      # 8 canto vermelho
    ("users", "red"),          # 9
    ("actions", "neutral"),     # 10 (cinzento)
    ("equipments", "red"),      # 11
    ("challenges", "neutral"), # 12 (cinzento)
    ("activities", "yellow"),   # 13
    ("events", "neutral"),     # 14 (cinzento)
    ("services", "yellow"),    # 15

    # Bottom row (right to left)
    ("start", "neutral"),      # 16 canto amarelo
    ("users", "yellow"),       # 17
    ("actions", "neutral"),     # 18 (cinzento)
    ("equipments", "yellow"),   # 19
    ("challenges", "neutral"), # 20 (cinzento)
    ("activities", "green"),    # 21
    ("events", "neutral"),     # 22 (cinzento)
    ("services", "green"),     # 23

    # Left column (bottom to top)
    ("start", "neutral"),      # 24 canto verde
    ("users", "green"),        # 25
    ("actions", "neutral"),     # 26 (cinzento)
    ("equipments", "green"),    # 27
    ("challenges", "neutral"), # 28 (cinzento)
    ("activities", "blue"),     # 29
    ("events", "neutral"),     # 30 (cinzento)
    ("services", "blue"),      # 31
]
NUM_CASAS = len(BOARD)

START_POSITIONS = {
    "blue": 0,
    "red": 8,
    "yellow": 16,
    "green": 24
}

def check_gpio_key(root):
    if GPIO.input(KEY1_PIN) == GPIO.LOW:
        GPIO.cleanup()
        root.destroy()
    root.after(100, lambda: check_gpio_key(root))
    
def mostrar_carta_fullscreen_root(root, carta_path, selected_card_idx=0):
    # Limpa tudo do root
    for widget in root.winfo_children():
        widget.destroy()
    root.configure(bg="black")

    pil_img = Image.open(carta_path)
    img_w, img_h = pil_img.size
    max_w, max_h = root.winfo_screenwidth(), root.winfo_screenheight()
    ratio = min(max_w/img_w, max_h/img_h)
    new_w, new_h = int(img_w*ratio), int(img_h*ratio)
    pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

    carta_img = ImageTk.PhotoImage(pil_img)
    carta_real_lbl = tk.Label(root, image=carta_img, bg="black")
    carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
    carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

    # Bot√£o de fechar (X)
    x_img_path = os.path.join(os.path.dirname(__file__), "img", "X_button.png")
    x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
    x_btn = tk.Label(root, image=x_img, cursor="hand2", bg="black")
    x_btn.image = x_img  # type: ignore[attr-defined]
    x_btn.place(relx=0.98, rely=0.02, anchor="ne")

    def fechar():
        carta_real_lbl.destroy()
        x_btn.destroy()
        # Restaura o dashboard mantendo a carta selecionada
        PlayerDashboard(root, player_color="green", saldo=1000, other_players=["red", "blue", "yellow"], selected_card_idx=selected_card_idx)
    x_btn.bind("<Button-1>", lambda e: fechar())

def make_card_callback(parent, idx):
    def callback(event):
        # Remove destaque de todas as cartas
        for lbl in parent.card_labels:
            try:
                if lbl.winfo_exists():
                    lbl.config(highlightthickness=0)
            except tk.TclError:
                continue
            # lbl.selected = False  # Removido para linter
        # Destaca a carta clicada
        clicked_label = event.widget
        try:
            if clicked_label.winfo_exists():
                clicked_label.config(highlightbackground="#8000FF", highlightcolor="#8000FF", highlightthickness=4)
        except tk.TclError:
            pass
        # clicked_label.selected = True  # Removido para linter
        parent.selected_label = clicked_label # Adicionado para armazenar a refer√™ncia
        parent.selected_card_idx = idx
        parent.update_progress_bars_for_card(idx)
    return callback

def get_equipment_object_name(carta_path, card_database=None):
    """
    Obt√©m o object_name de uma carta Equipment para usar na dete√ß√£o de objetos.
    
    Args:
        carta_path: Caminho para a carta Equipment (ex: "/path/Equipment_1.png")
        card_database: Inst√¢ncia da base de dados de cartas (opcional)
        
    Returns:
        Object name para dete√ß√£o (ex: "router_simples_vermelho") ou None se n√£o encontrado
    """
    try:
        if not card_database:
            # Criar inst√¢ncia tempor√°ria da base de dados se necess√°rio
            from card_integration import IntegratedCardDatabase
            card_database = IntegratedCardDatabase(".")
        
        # Extrair informa√ß√µes do caminho da carta
        filename = os.path.basename(carta_path)
        
        # Determinar cor baseada no diret√≥rio
        color = None
        if "/Blue/" in carta_path or "/blue/" in carta_path:
            color = "blue"
        elif "/Red/" in carta_path or "/red/" in carta_path:
            color = "red"
        elif "/Green/" in carta_path or "/green/" in carta_path:
            color = "green"
        elif "/Yellow/" in carta_path or "/yellow/" in carta_path:
            color = "yellow"
        
        if not color:
            print(f"DEBUG: [OBJECT_NAME] N√£o foi poss√≠vel determinar cor para {carta_path}")
            return None
        
        # Mapear filename para equipment_id na base de dados
        # Equipment_1.png, Equipment_2.png, Equipment_3.png -> small_router_1_color
        # Equipment_4.png, Equipment_5.png, Equipment_6.png -> medium_router_1_color
        # Equipment_7.png, Equipment_8.png, Equipment_9.png -> short_link_1_color
        # Equipment_10.png, Equipment_11.png, Equipment_12.png -> long_link_1_color
        
        match = re.match(r'Equipment_(\d+)\.png', filename)
        if not match:
            print(f"DEBUG: [OBJECT_NAME] Formato de filename inv√°lido: {filename}")
            return None
        
        equipment_num = int(match.group(1))
        
        # Mapear n√∫mero para tipo e ID espec√≠fico
        if 1 <= equipment_num <= 3:
            equipment_type = "small_router"
            specific_id = equipment_num
        elif 4 <= equipment_num <= 6:
            equipment_type = "medium_router"
            specific_id = equipment_num - 3
        elif 7 <= equipment_num <= 9:
            equipment_type = "short_link"
            specific_id = equipment_num - 6
        elif 10 <= equipment_num <= 12:
            equipment_type = "long_link"
            specific_id = equipment_num - 9
        else:
            print(f"DEBUG: [OBJECT_NAME] N√∫mero de equipment inv√°lido: {equipment_num}")
            return None
        
        # Construir equipment_id
        equipment_id = f"{equipment_type}_{specific_id}_{color}"
        
        # Obter carta da base de dados
        equipment_result = card_database.get_equipment_with_file(equipment_id)
        
        if equipment_result:
            equipment_card, file_path = equipment_result
            if hasattr(equipment_card, 'object_name') and equipment_card.object_name:
                print(f"DEBUG: [OBJECT_NAME] Object name encontrado para {filename}: {equipment_card.object_name}")
                return equipment_card.object_name
            else:
                print(f"DEBUG: [OBJECT_NAME] EquipmentCard encontrado mas sem object_name: {equipment_id}")
                return None
        else:
            print(f"DEBUG: [OBJECT_NAME] Equipment n√£o encontrado na base de dados para equipment_id: {equipment_id}")
            return None
            
    except Exception as e:
        print(f"DEBUG: [OBJECT_NAME] Erro ao obter object_name: {e}")
        return None

def create_yolo_loading_screen(parent_window, object_name):
    """
    Cria uma tela de loading fullscreen que aparece durante a inicializa√ß√£o do YOLO.
    
    Args:
        parent_window: Janela principal do PlayerDashboard
        object_name: Nome do objeto sendo detectado
        
    Returns:
        Janela de loading criada
    """
    try:
        # Criar janela de loading como Toplevel
        loading_window = tk.Toplevel(parent_window)
        loading_window.title("YOLO Detection Loading")
        loading_window.configure(bg="black")
        
        # Configurar fullscreen
        screen_width = parent_window.winfo_screenwidth()
        screen_height = parent_window.winfo_screenheight()
        loading_window.geometry(f"{screen_width}x{screen_height}+0+0")
        loading_window.overrideredirect(True)
        loading_window.attributes("-fullscreen", True)
        
        # Garantir que a janela fica sempre no topo
        loading_window.attributes("-topmost", True)
        loading_window.lift()
        loading_window.focus_force()
        
        # Frame principal centralizado
        main_frame = tk.Frame(loading_window, bg="black")
        main_frame.pack(expand=True, fill="both")
        
        # Container para conte√∫do centralizado
        content_frame = tk.Frame(main_frame, bg="black")
        content_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # T√≠tulo principal
        title_label = tk.Label(content_frame, 
                              text="YOLO Object Detection", 
                              font=("Helvetica", 20, "bold"), 
                              fg="#8A2BE2", 
                              bg="black")
        title_label.pack(pady=(0, 20))
        
        # Subt√≠tulo com objeto sendo detectado - texto explicativo em branco
        init_label = tk.Label(content_frame, 
                             text="Initializing detection for:", 
                             font=("Helvetica", 15), 
                             fg="white", 
                             bg="black")
        init_label.pack(pady=(0, 5))
        
        # Nome do objeto em ciano para destaque
        object_label = tk.Label(content_frame, 
                               text=object_name, 
                               font=("Helvetica", 15), 
                               fg="#00FFFF", 
                               bg="black")
        object_label.pack(pady=(0, 25))
        
        # Indicador de loading animado
        loading_label = tk.Label(content_frame, 
                                text="Loading", 
                                font=("Helvetica", 18, "bold"), 
                                fg="#FFD700", 
                                bg="black")
        loading_label.pack(pady=(0, 20))
        
        # Barra de progresso visual simples
        progress_frame = tk.Frame(content_frame, bg="black")
        progress_frame.pack(pady=(0, 30))
        
        # Criar barra de progresso usando labels
        progress_bars = []
        for i in range(8):
            bar = tk.Label(progress_frame, text="‚ñ†", font=("Helvetica", 20), 
                          fg="#333333", bg="black")
            bar.pack(side="left", padx=2)
            progress_bars.append(bar)
        
        # Mensagem de status
        status_label = tk.Label(content_frame, 
                               text="Starting camera and loading AI model...", 
                               font=("Helvetica", 14), 
                               fg="#CCCCCC", 
                               bg="black")
        status_label.pack(pady=(0, 10))
        
        # Mensagem informativa
        info_label = tk.Label(content_frame, 
                             text="This may take a few seconds", 
                             font=("Helvetica", 12, "italic"), 
                             fg="#888888", 
                             bg="black")
        info_label.pack()
        
        # Anima√ß√£o do loading
        loading_states = ["Loading", "Loading.", "Loading..", "Loading..."]
        loading_index = 0
        
        progress_index = 0
        progress_colors = ["#FF0000", "#FF4500", "#FFD700", "#00FF00"]
        
        def animate_loading():
            nonlocal loading_index, progress_index
            
            # Animar texto de loading
            loading_label.config(text=loading_states[loading_index])
            loading_index = (loading_index + 1) % len(loading_states)
            
            # Animar barra de progresso
            # Reset todas as barras
            for bar in progress_bars:
                bar.config(fg="#333333")
            
            # Iluminar barras progressivamente
            for i in range((progress_index % 16) // 2 + 1):
                if i < len(progress_bars):
                    color_idx = min(i, len(progress_colors) - 1)
                    progress_bars[i].config(fg=progress_colors[color_idx])
            
            progress_index += 1
            
            # Continuar anima√ß√£o se a janela ainda existe
            try:
                loading_window.after(300, animate_loading)
            except tk.TclError:
                # Janela foi destru√≠da
                pass
        
        # Iniciar anima√ß√£o
        animate_loading()
        
        # For√ßar atualiza√ß√£o da interface
        loading_window.update_idletasks()
        loading_window.update()
        
        print(f"DEBUG: [LOADING] Loading screen criado com sucesso")
        
        return loading_window
        
    except Exception as e:
        print(f"DEBUG: [LOADING] Erro ao criar loading screen: {e}")
        return None

def execute_detection_script_direct(object_name, parent_window=None, existing_loading_window=None):
    """
    Executa o script YOLO diretamente com loading screen j√° existente.
    
    Args:
        object_name: Nome do objeto para dete√ß√£o
        parent_window: Janela principal 
        existing_loading_window: Loading screen j√° criado
    
    Returns:
        True se o script executou com sucesso, False caso contr√°rio
    """
    try:
        # Usar os utilit√°rios universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION_DIRECT] Simulando execu√ß√£o do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            # Simular delay e fechar loading screen
            if existing_loading_window:
                def close_loading_and_return():
                    existing_loading_window.destroy()
                    if parent_window:
                        parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
                parent_window.after(3000, close_loading_and_return)
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe
        if not os.path.exists(script_path):
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION_DIRECT] Script n√£o encontrado")
                return False
        
        print(f"DEBUG: [DETECTION_DIRECT] Executando: {script_path} {object_name}")
        
        # Tornar o script execut√°vel
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION_DIRECT] Script iniciado (PID: {process.pid})")
        
        # Monitorar script com loading screen existente
        if parent_window and existing_loading_window:
            def check_yolo_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO deve estar inicializado - fechar loading screen
                    print(f"DEBUG: [DETECTION_DIRECT] Fechando loading screen - YOLO inicializando")
                    existing_loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclus√£o
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            parent_window.after(1000, check_script_completion)
                        else:
                            print(f"DEBUG: [DETECTION_DIRECT] YOLO terminou - restaurando interface")
                            parent_window.deiconify()
                            parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
                    
                    parent_window.after(1000, check_script_completion)
                else:
                    # Script terminou antes de inicializar
                    existing_loading_window.destroy()
                    parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
            
            # Aguardar 4.5 segundos para YOLO inicializar
            parent_window.after(4500, check_yolo_initialization)
        
        return True
        
    except Exception as e:
        print(f"DEBUG: [DETECTION_DIRECT] Erro: {e}")
        if existing_loading_window:
            existing_loading_window.destroy()
        return False

def execute_detection_with_continuation(object_name, parent_window, loading_window, continuation_callback):
    """
    Executa o script YOLO com loading screen e chama callback quando terminar.
    
    Args:
        object_name: Nome do objeto para dete√ß√£o
        parent_window: Janela principal 
        loading_window: Loading screen j√° criado
        continuation_callback: Fun√ß√£o a chamar quando detec√ß√£o terminar
    
    Returns:
        True se o script executou com sucesso, False caso contr√°rio
    """
    try:
        # Usar os utilit√°rios universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION_CONTINUATION] Simulando execu√ß√£o do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            # Simular delay e chamar callback
            if loading_window:
                def close_loading_and_continue():
                    loading_window.destroy()
                    continuation_callback()
                parent_window.after(3000, close_loading_and_continue)
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe
        if not os.path.exists(script_path):
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION_CONTINUATION] Script n√£o encontrado")
                return False
        
        print(f"DEBUG: [DETECTION_CONTINUATION] Executando: {script_path} {object_name}")
        
        # Tornar o script execut√°vel
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION_CONTINUATION] Script iniciado (PID: {process.pid})")
        
        # Monitorar script com loading screen existente
        if parent_window and loading_window:
            def check_yolo_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO deve estar inicializado - fechar loading screen
                    print(f"DEBUG: [DETECTION_CONTINUATION] Fechando loading screen - YOLO inicializando")
                    loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclus√£o
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            parent_window.after(1000, check_script_completion)
                        else:
                            print(f"DEBUG: [DETECTION_CONTINUATION] YOLO terminou - chamando callback")
                            parent_window.deiconify()
                            continuation_callback()
                    
                    parent_window.after(1000, check_script_completion)
                else:
                    # Script terminou antes de inicializar
                    loading_window.destroy()
                    continuation_callback()
            
            # Aguardar 4.5 segundos para YOLO inicializar
            parent_window.after(4500, check_yolo_initialization)
        
        return True
        
    except Exception as e:
        print(f"DEBUG: [DETECTION_CONTINUATION] Erro: {e}")
        if loading_window:
            loading_window.destroy()
        return False

def execute_detection_script(object_name, parent_window=None):
    """
    Executa o script detection_fullscreen.sh com o object_name especificado.
    
    Args:
        object_name: Nome do objeto para dete√ß√£o (ex: "router_simples_vermelho")
        parent_window: Refer√™ncia √† janela principal para controle de visibilidade
        
    Returns:
        True se o script executou com sucesso, False caso contr√°rio
    """
    try:
        # Usar os utilit√°rios universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION] Simulando execu√ß√£o do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe, sen√£o tentar caminhos alternativos
        if not os.path.exists(script_path):
            # Tentar encontrar em caminhos poss√≠veis usando os utilit√°rios
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    print(f"DEBUG: [DETECTION] Script encontrado em: {script_path}")
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION] Script n√£o encontrado em nenhum dos caminhos:")
                for path in alternative_paths[:5]:  # Mostrar apenas os primeiros 5 para n√£o poluir o log
                    print(f"DEBUG: [DETECTION]   - {path}")
                print(f"DEBUG: [DETECTION]   ... e {len(alternative_paths)-5} outros caminhos")
                return False
        else:
            print(f"DEBUG: [DETECTION] Script encontrado em: {script_path}")
        
        # Executar o script
        print(f"DEBUG: [DETECTION] Executando: {script_path} {object_name}")
        
        # Tornar o script execut√°vel
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # CORRE√á√ÉO: Executar script SEM capturar sa√≠da para mostrar interface YOLO no LCD
        print(f"DEBUG: [DETECTION] Iniciando detec√ß√£o com interface visual no LCD...")
        
        # NOVA FUNCIONALIDADE: Criar loading screen antes de esconder interface Python
        loading_window = None
        if parent_window:
            print(f"DEBUG: [DETECTION] Criando loading screen...")
            loading_window = create_yolo_loading_screen(parent_window, object_name)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION] Script iniciado em background (PID: {process.pid})")
        print(f"DEBUG: [DETECTION] Interface YOLO deve aparecer em alguns segundos...")
        print(f"DEBUG: [DETECTION] Loading screen ativa at√© YOLO inicializar")
        
        # Monitorar inicializa√ß√£o do YOLO e conclus√£o do script
        if parent_window and loading_window:
            def check_yolo_initialization():
                # Verificar se o YOLO j√° inicializou (processo ainda rodando + tempo suficiente)
                poll_result = process.poll()
                if poll_result is None:
                    # Processo ainda est√° rodando - verificar se j√° passou tempo suficiente para YOLO inicializar
                    # Ap√≥s 4-5 segundos, assumir que YOLO j√° inicializou e esconder loading screen
                    print(f"DEBUG: [DETECTION] YOLO deve estar inicializado - escondendo loading screen")
                    loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python agora
                    
                    # Continuar monitorando conclus√£o do script
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            # Processo ainda est√° rodando - verificar novamente em 1 segundo
                            parent_window.after(1000, check_script_completion)
                        else:
                            # Processo terminou - restaurar interface Python
                            print(f"DEBUG: [DETECTION] Script YOLO terminou (c√≥digo: {poll_result})")
                            print(f"DEBUG: [DETECTION] Restaurando interface Python...")
                            parent_window.deiconify()  # Mostrar janela novamente
                    
                    # Come√ßar monitoramento de conclus√£o
                    parent_window.after(1000, check_script_completion)
                else:
                    # Processo j√° terminou antes do YOLO inicializar - limpar loading screen
                    print(f"DEBUG: [DETECTION] Script terminou antes do YOLO inicializar (c√≥digo: {poll_result})")
                    loading_window.destroy()
                    parent_window.deiconify()
            
            # Aguardar 9-10 segundos para YOLO inicializar antes de esconder loading screen
            parent_window.after(9500, check_yolo_initialization)
        
        # Retornar sucesso imediatamente - script roda em background
        return True
            
    except subprocess.TimeoutExpired:
        print(f"DEBUG: [DETECTION] Script timeout ap√≥s 120 segundos")
        return False
    except Exception as e:
        print(f"DEBUG: [DETECTION] Erro ao executar script: {e}")
        return False

# ===============================
# INTEGRATED MENU SYSTEM
# ===============================

def preparar_baralhos():
    """Prepara os baralhos de cartas do menu integrado"""
    global baralhos
    baralhos = {}
    for cor in COLORS:
        baralhos[cor] = {}
        for tipo in CARD_TYPES:
            cartas = []
            
            # Mapear nomes de tipos para pastas
            folder_name = tipo
            if tipo == "actions":
                folder_name = "actions"
            elif tipo == "services":
                folder_name = "services"
            
            # Estrutura: cartas/[tipo]/Residential-level/
            base_path = os.path.join(IMG_DIR, "cartas", folder_name, "Residential-level")
            
            # Para tipos que t√™m cores
            if folder_name in ["equipments", "services", "users"]:
                color_folder = cor.capitalize()
                if cor == "neutral":
                    for test_color in ["Blue", "Green", "Red", "Yellow"]:
                        color_path = os.path.join(base_path, test_color)
                        if os.path.exists(color_path):
                            card_files = [os.path.join(color_path, f) for f in os.listdir(color_path) 
                                        if f.lower().endswith((".png", ".jpg", ".jpeg"))]
                            cartas.extend(card_files)
                else:
                    color_path = os.path.join(base_path, color_folder)
                    if os.path.exists(color_path):
                        cartas = [os.path.join(color_path, f) for f in os.listdir(color_path) 
                                if f.lower().endswith((".png", ".jpg", ".jpeg"))]
            else:
                if os.path.exists(base_path):
                    cartas = [os.path.join(base_path, f) for f in os.listdir(base_path) 
                            if f.lower().endswith((".png", ".jpg", ".jpeg"))]
            
            if cartas:
                random.shuffle(cartas)
                baralhos[cor][tipo] = cartas.copy()
            else:
                baralhos[cor][tipo] = []

def animate_typing(label, text, delay=50, callback=None):
    """Anima√ß√£o de escrita para o menu"""
    def _type(i=0):
        if i <= len(text):
            label.config(text=text[:i])
            label.after(delay, _type, i + 1)
        elif callback:
            callback()
    _type()

def update_keyboard(keyboard_frame):
    """Atualizar layout do teclado conforme estado"""
    for widget in keyboard_frame.winfo_children():
        widget.destroy()

    key_font = ("Helvetica", 10)
    key_width = 1
    key_height = 1

    if keyboard_state == "uppercase":
        rows = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"]
    else:
        rows = ["qwertyuiop", "asdfghjkl", "zxcvbnm"]

    for row in rows:
        rf = tk.Frame(keyboard_frame, bg="white")
        rf.pack(pady=6)
        for ch in row:
            tk.Button(
                rf, text=ch, width=key_width, height=key_height,
                font=key_font,
                command=lambda c=ch, kf=keyboard_frame: add_char(c, kf),
                bg="white", fg="black",
                activebackground="white", activeforeground="black"
            ).pack(side=tk.LEFT, padx=0, pady=0)

    ctrl = tk.Frame(keyboard_frame, bg="white")
    ctrl.pack(pady=8)
    
    def get_name_entry(kf):
        # Find the name_entry widget in the parent hierarchy
        parent = kf.master
        for widget in parent.winfo_children():
            if isinstance(widget, tk.Frame):
                for child in widget.winfo_children():
                    if isinstance(child, tk.Entry):
                        return child
        return None
    
    tk.Button(ctrl, text="Space", width=4, font=key_font, 
              command=lambda: space(get_name_entry(keyboard_frame)), 
              bg="white", fg="black", activebackground="white", activeforeground="black").pack(side=tk.LEFT, padx=1)
    tk.Button(ctrl, text="Back", width=4, font=key_font, 
              command=lambda: backspace(get_name_entry(keyboard_frame)), 
              bg="white", fg="black", activebackground="white", activeforeground="black").pack(side=tk.LEFT, padx=1)
    tk.Button(ctrl, text="Enter", width=4, font=key_font, 
              command=lambda: enter_key(keyboard_frame), 
              bg="white", fg="black", activebackground="white", activeforeground="black").pack(side=tk.LEFT, padx=1)
    tk.Button(ctrl, text="ABC", width=4, font=key_font, 
              command=lambda: toggle_keyboard_state(keyboard_frame), 
              bg="white", fg="black", activebackground="white", activeforeground="black").pack(side=tk.LEFT, padx=1)

def toggle_keyboard_state(keyboard_frame):
    """Alternar uppercase/lowercase"""
    global keyboard_state
    keyboard_state = "lowercase" if keyboard_state == "uppercase" else "uppercase"
    update_keyboard(keyboard_frame)

def show_keyboard(event, keyboard_frame):
    """Mostrar teclado flutuante ao focar na entry"""
    update_keyboard(keyboard_frame)
    keyboard_frame.place(relx=0.5, rely=0.65, anchor="n")

def add_char(char, keyboard_frame):
    """Adicionar caractere ao campo de texto"""
    global keyboard_state
    # Find the name_entry widget in the parent hierarchy
    parent = keyboard_frame.master
    name_entry = None
    for widget in parent.winfo_children():
        if isinstance(widget, tk.Frame):
            for child in widget.winfo_children():
                if isinstance(child, tk.Entry):
                    name_entry = child
                    break
        if name_entry:
            break
    
    if name_entry:
        name_entry.insert(tk.END, char)
        if keyboard_state == "uppercase":
            keyboard_state = "lowercase"
            update_keyboard(keyboard_frame)

def backspace(name_entry):
    """Fun√ß√£o backspace do teclado virtual"""
    if name_entry:
        current = name_entry.get()
        name_entry.delete(0, tk.END)
        name_entry.insert(0, current[:-1])

def space(name_entry):
    """Adicionar espa√ßo"""
    if name_entry:
        name_entry.insert(tk.END, " ")

def enter_key(keyboard_frame):
    """Tecla Enter - esconder teclado"""
    if keyboard_frame.winfo_ismapped():
        keyboard_frame.place_forget()

class IntegratedMenuSystem:
    """Sistema de menu integrado no PlayerDashboard"""
    
    def __init__(self, root):
        self.root = root
        self.screen_width = root.winfo_screenwidth()
        self.screen_height = root.winfo_screenheight()
        self.host_name = ""
        self.host_color = ""
        self.jogador = None
        
        # Inicializar dados de sess√£o para multiplayer
        self.sessions_data = []
        self.current_sessions = []
        
        # Carregar imagens do menu
        self.load_menu_images()
        
        # Configurar handler global para heartbeat_ack
        self.setup_heartbeat_handler()
        
        # Preparar baralhos
        preparar_baralhos()
    
    def load_menu_images(self):
        """Carregar todas as imagens necess√°rias para o menu"""
        print("[IMAGE] [DEBUG] Carregando imagens do menu...")
        
        # Tentar carregar a imagem NetMaster de diferentes locais
        netmaster_image_loaded = False
        possible_netmaster_paths = [
            os.path.join(IMG_DIR, "logo_netmaster_icon_v3.png"),  # Raspberry Pi
            os.path.join(IMG_DIR, "netmaster_logo.png"),         # Alternativo
            os.path.join("/home/joaorebolo2/netmaster_menu/img", "logo_netmaster_icon_v3.png"),  # Caminho espec√≠fico Raspberry Pi
        ]
        
        for netmaster_img_path in possible_netmaster_paths:
            try:
                if os.path.exists(netmaster_img_path):
                    self.netmaster_img = ImageTk.PhotoImage(
                        Image.open(netmaster_img_path).resize((140,55))
                    )
                    self.use_netmaster_img = True
                    netmaster_image_loaded = True
                    print(f"[DEBUG] Logo NetMaster carregado: {netmaster_img_path}")
                    break
            except (FileNotFoundError, UnidentifiedImageError) as e:
                print(f"[DEBUG] Erro ao carregar logo NetMaster de {netmaster_img_path}: {e}")
                continue
        
        if not netmaster_image_loaded:
            self.netmaster_img = None
            self.use_netmaster_img = False
            print("[DEBUG] Logo NetMaster n√£o encontrado")

        # Tentar carregar a imagem do padr√£o de rede
        network_pattern_loaded = False
        possible_network_pattern_paths = [
            os.path.join(IMG_DIR, "network_pattern.png"),  # Caminho padr√£o
            os.path.join("/home/joaorebolo2/netmaster_menu/img", "network_pattern.png"),  # Raspberry Pi
        ]
        
        for pattern_path in possible_network_pattern_paths:
            try:
                if os.path.exists(pattern_path):
                    # Carregar imagem original para obter dimens√µes da tela
                    pattern_img = Image.open(pattern_path)
                    # Redimensionar para a largura da tela com altura mais generosa
                    screen_width = 800  # Pode ser ajustado conforme necess√°rio
                    new_height = 120  # Altura fixa mais generosa para a barra superior
                    
                    self.network_pattern_img = ImageTk.PhotoImage(
                        pattern_img.resize((screen_width, new_height), Image.Resampling.LANCZOS)
                    )
                    self.use_network_pattern = True
                    network_pattern_loaded = True
                    print(f"[DEBUG] Network pattern carregado: {pattern_path}")
                    break
            except (FileNotFoundError, UnidentifiedImageError) as e:
                print(f"[DEBUG] Erro ao carregar network pattern de {pattern_path}: {e}")
                continue
        
        if not network_pattern_loaded:
            self.network_pattern_img = None
            self.use_network_pattern = False
            print("[DEBUG] Network pattern n√£o encontrado")
        
        print(f"[DEBUG] Carregamento de imagens conclu√≠do:")
        print(f"   - NetMaster: {netmaster_image_loaded}")
        print(f"   - Network Pattern: {network_pattern_loaded}")

        try:
            self.create_icon = ImageTk.PhotoImage(
                Image.open(os.path.join(IMG_DIR, "create_game_icon_button.png")).resize((100,100))
            )
            self.use_create_icon = True
        except (FileNotFoundError, UnidentifiedImageError):
            self.create_icon = None
            self.use_create_icon = False

        try:
            self.search_icon = ImageTk.PhotoImage(
                Image.open(os.path.join(IMG_DIR, "search_game_icon_button.png")).resize((100,100))
            )
            self.use_search_icon = True
        except (FileNotFoundError, UnidentifiedImageError):
            self.search_icon = None
            self.use_search_icon = False

        try:
            self.local_icon = ImageTk.PhotoImage(
                Image.open(os.path.join(IMG_DIR, "local_game_icon_button.png")).resize((115, 130))
            )
            self.use_local_icon = True
        except (FileNotFoundError, UnidentifiedImageError):
            self.local_icon = None
            self.use_local_icon = False
            
        try:
            self.remote_icon = ImageTk.PhotoImage(
                Image.open(os.path.join(IMG_DIR, "remote_game_icon_button.png")).resize((115, 130))
            )
            self.use_remote_icon = True
        except (FileNotFoundError, UnidentifiedImageError):
            self.remote_icon = None
            self.use_remote_icon = False

    def setup_heartbeat_handler(self):
        """Configura handler global para heartbeat_ack para manter watchdog atualizado"""
        def on_heartbeat_ack(data):
            """Handler para heartbeat_ack - mant√©m timestamp do watchdog atualizado"""
            print(f"[HEARTBEAT] ACK recebido: {data.get('timestamp', 'sem timestamp')}")
            # Atualizar timestamp do watchdog para evitar reconex√µes desnecess√°rias
            if hasattr(self, '_last_message_time'):
                import time
                self._last_message_time = time.time()
        
        # Registar handler globalmente
        netmaster_client.set_message_handler('heartbeat_ack', on_heartbeat_ack)
        print("[HEARTBEAT] Handler heartbeat_ack registado com sucesso")

    def add_network_pattern_decorations(self, parent):
        """Adiciona padr√£o de rede na parte superior e inferior do ecr√£"""
        print(f"[NETWORK] [DEBUG] add_network_pattern_decorations chamado:")
        print(f"   - use_network_pattern: {getattr(self, 'use_network_pattern', False)}")
        print(f"   - network_pattern_img exists: {hasattr(self, 'network_pattern_img')}")
        print(f"   - network_pattern_img is not None: {getattr(self, 'network_pattern_img', None) is not None}")
        
        if getattr(self, 'use_network_pattern', False) and hasattr(self, 'network_pattern_img') and self.network_pattern_img:
            try:
                # Padr√£o superior - posicionado mais acima
                top_pattern = tk.Label(parent, image=self.network_pattern_img, bg="black")
                top_pattern.place(x=0, y=-55, width=800, height=120, anchor="nw")
                print("[DEBUG] Top pattern adicionado com sucesso")
                
                # Padr√£o inferior - posicionado mais para baixo no ecr√£
                bottom_pattern = tk.Label(parent, image=self.network_pattern_img, bg="black")
                bottom_pattern.place(x=0, y=450, width=800, height=120, anchor="nw")
                print("[DEBUG] Bottom pattern adicionado com sucesso")
            except Exception as e:
                print(f"[DEBUG] Erro ao adicionar network patterns: {e}")
        else:
            print("[DEBUG] Network patterns n√£o adicionados - condi√ß√µes n√£o atendidas")

    def show_main_menu(self):
        """Mostrar menu principal integrado"""
        # Parar todas as anima√ß√µes ativas
        self.loading_animation_active = False
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        # Texto inicial
        init_tf = tk.Frame(self.root, bg="black")
        init_tf.place(relx=0.5, rely=0.32, anchor="center")
        il1 = tk.Label(init_tf, text="", font=("Helvetica", 18, "bold"), bg="black", fg="white", 
                       wraplength=int(self.screen_width*0.8), justify="center")
        il2 = tk.Label(init_tf, text="", font=("Helvetica", 16), bg="black", fg="white", 
                       wraplength=int(self.screen_width*0.8), justify="center")
        il1.pack(pady=(0,8))
        il2.pack(pady=(0,12))

        # Bot√µes
        btn_frame = tk.Frame(self.root, bg="black")
        def show_buttons():
            btn_frame.place(relx=0.5, rely=0.68, anchor="center")
            
            # Bot√£o Create Game
            if self.use_create_icon:
                tk.Button(
                    btn_frame,
                    image=self.create_icon,
                    bg="black",
                    bd=0,
                    activebackground="black",
                    highlightthickness=0,
                    command=lambda: self.open_name_input("create")
                ).pack(side=tk.TOP, pady=10)
            else:
                tk.Button(
                    btn_frame,
                    text="Create Game",
                    font=("Helvetica", 16, "bold"),
                    bg="#4CAF50",
                    fg="white",
                    command=lambda: self.open_name_input("create")
                ).pack(side=tk.TOP, pady=10)
                
            # Bot√£o Search Game
            if self.use_search_icon:
                tk.Button(
                    btn_frame,
                    image=self.search_icon,
                    bg="black",
                    bd=0,
                    activebackground="black",
                    highlightthickness=0,
                    command=lambda: self.open_name_input("search")
                ).pack(side=tk.TOP, pady=10)
            else:
                tk.Button(
                    btn_frame,
                    text="Search Game",
                    font=("Helvetica", 16, "bold"),
                    bg="#2196F3",
                    fg="white",
                    command=lambda: self.open_name_input("search")
                ).pack(side=tk.TOP, pady=10)

        animate_typing(il1, "Welcome to NetMaster! ", delay=50,
                       callback=lambda: animate_typing(il2, "What would you like to do today?", delay=40, callback=show_buttons))

    def open_name_input(self, flow_type="create"):
        """Abrir entrada de nome"""
        global game_flow
        game_flow = flow_type
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")

        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)

        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.32, anchor="center")
        l1 = tk.Label(tf, text="", font=("Helvetica",18,"bold"), bg="black", fg="white", 
                      wraplength=int(self.screen_width*0.8), justify="center")
        l2 = tk.Label(tf, text="", font=("Helvetica",16), bg="black", fg="white", 
                      wraplength=int(self.screen_width*0.8), justify="center")
        l1.pack(pady=(0,8))
        l2.pack(pady=(0,12))

        # Input
        input_fr = tk.Frame(self.root, bg="black")
        name_entry = tk.Entry(input_fr, font=("Helvetica",14), width=22, justify="center")
        
        # Frame do teclado
        keyboard_frame = tk.Frame(self.root, bg="white")
        
        name_entry.bind("<Button-1>", lambda e: show_keyboard(e, keyboard_frame))
        submit_btn = tk.Button(input_fr, text="Submit", font=("Helvetica",12,"bold"),
                               command=lambda: self.submit_name(name_entry, keyboard_frame), 
                               bg="#005c75", fg="white")

        def show_input():
            input_fr.place(relx=0.5, rely=0.44, anchor="n")
            name_entry.pack(pady=10)
            submit_btn.pack()

        animate_typing(l1, "Initializing user profile...", delay=50,
                       callback=lambda: animate_typing(l2, "What should we call you?", delay=40, callback=show_input))

        update_keyboard(keyboard_frame)

    def submit_name(self, name_entry, keyboard_frame):
        """Salvar nome e avan√ßar"""
        name = name_entry.get().strip().capitalize()
        if name:
            self.host_name = name
            with open(USERNAME_FILE, "w") as f:
                f.write(name)
            if keyboard_frame.winfo_ismapped():
                keyboard_frame.place_forget()
            
            # Controlar fluxo baseado na sele√ß√£o
            if game_flow == "create":
                self.show_color_selection_page_create(name)
            else:
                self.show_game_type_page_search(name)

    def show_game_type_page_search(self, name):
        """Mostrar p√°gina de sele√ß√£o Local/Remote para Search Game (com barras network_pattern)"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        self.root.configure(bg="black")

        # Adicionar padr√µes de rede APENAS para o fluxo "search"
        self.add_network_pattern_decorations(self.root)

        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        # Texto inicial - posi√ß√£o ajustada
        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.3, anchor="center")

        great_lbl = tk.Label(tf, text="", font=("Helvetica", 18, "bold"), bg="black", fg="white", 
                             wraplength=int(self.screen_width*0.8), justify="center")
        great_lbl.pack(pady=(0,8))
        how_lbl = tk.Label(tf, text="", font=("Helvetica", 16), bg="black", fg="white", 
                           wraplength=int(self.screen_width*0.8), justify="center")
        how_lbl.pack(pady=(0,12))

        def show_play_buttons():
            btns_frame = tk.Frame(self.root, bg="black")
            btns_frame.place(relx=0.5, rely=0.65, anchor="center")  # Posi√ß√£o mais baixa

            def select_local():
                """Ir para Join Session para Search Game flow"""
                self.show_join_session_page(name)

            # Bot√£o Local Game
            if self.use_local_icon:
                tk.Button(
                    btns_frame,
                    image=self.local_icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    command=select_local
                ).pack(side=tk.TOP, pady=0)
            else:
                tk.Button(
                    btns_frame,
                    text="Local Game",
                    font=("Helvetica", 16, "bold"),
                    bg="#4CAF50",
                    fg="white",
                    command=select_local
                ).pack(side=tk.TOP, pady=0)

            # Bot√£o Remote Game - sempre desativado e com texto "Coming soon!"
            if self.use_remote_icon:
                tk.Button(
                    btns_frame,
                    image=self.remote_icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    state="disabled"
                ).pack(side=tk.TOP, pady=0)
            else:
                tk.Button(
                    btns_frame,
                    text="Coming soon!",
                    font=("Helvetica", 16, "bold"),
                    bg="#666666",
                    fg="#999999",
                    state="disabled"
                ).pack(side=tk.TOP, pady=0)

        animate_typing(great_lbl, f"Welcome {name}!", delay=60,
            callback=lambda: animate_typing(how_lbl, "How do you want to play?", delay=40, callback=show_play_buttons)
        )

    def show_join_session_page(self, name):
        """Mostrar p√°gina Join Session para Search Game flow"""
        # CR√çTICO: Salvar o nome do jogador para uso posterior
        self.join_player_name = name
        print(f"[DEBUG] Nome do jogador salvo: '{name}'")
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # *** CORRE√á√ÉO CR√çTICA: REGISTRAR HANDLERS SESSIONS_LIST IMEDIATAMENTE ***
        # Antes de qualquer auto-refresh ou polling come√ßar!
        
        def on_session_list_received(data):
            """Handler para quando recebemos a lista de sess√µes do servidor"""
            print(f"[DEBUG] *** SESSION_LIST_RECEIVED DETALHADO ***")
            print(f"[DEBUG] Data completa recebida: {data}")
            print(f"[DEBUG] Tipo de data: {type(data)}")
            print(f"[DEBUG] Keys em data: {list(data.keys()) if isinstance(data, dict) else 'N/A'}")
            
            sessions_list = data.get('sessions', [])
            
            # CORRE√á√ÉO CR√çTICA: Normalizar states das sess√µes
            print(f"[DEBUG] Normalizando states de {len(sessions_list)} sess√µes...")
            for i, session in enumerate(sessions_list):
                old_state = session.get('state')
                session = normalize_session_state(session)
                sessions_list[i] = session
                new_state = session.get('state')
                if str(old_state) != str(new_state):
                    print(f"[DEBUG] Sess√£o {i+1}: {old_state} -> {new_state}")
            
            total_sessions = data.get('total_sessions', 0)
            available_sessions = data.get('available_sessions', 0)
            
            print(f"[DEBUG] sessions_list extra√≠da: {sessions_list}")
            print(f"[DEBUG] total_sessions: {total_sessions}")
            print(f"[DEBUG] available_sessions: {available_sessions}")
            print(f"[DEBUG] Len sessions_list: {len(sessions_list)}")
            
            if sessions_list:
                for i, session in enumerate(sessions_list):
                    session_state = session.get('state')
                    print(f"[DEBUG] Sess√£o {i+1}: ID={session.get('id')}, Host={session.get('host_player_id')}, Players={session.get('current_players')}")
                    print(f"[DEBUG] CRITICAL - Sess√£o {i+1} STATE: '{session_state}' (tipo: {type(session_state)})")
                    
                    # Verificar se √© enum vs string
                    if hasattr(session_state, 'value'):
                        print(f"[DEBUG] STATE √â ENUM - valor: {session_state.value}")
                    elif isinstance(session_state, str):
                        print(f"[DEBUG] ‚úì STATE √â STRING - valor: '{session_state}'")
                    else:
                        print(f"[DEBUG] STATE √â OUTRO TIPO: {type(session_state)}")
            else:
                print(f"[DEBUG] PROBLEMA: Lista de sess√µes est√° vazia mesmo com total_sessions={total_sessions}")
            
            self.current_sessions = sessions_list
            # CR√çTICO: Atualizar sessions_data para polling check
            self.sessions_data = sessions_list
            print(f"[DEBUG] sessions_data atualizada com {len(sessions_list)} sess√µes")
            
            # CORRE√á√ÉO CR√çTICA: FOR√áAR atualiza√ß√£o da UI sempre que sessions_list √© recebida
            print(f"[DEBUG] For√ßando atualiza√ß√£o da UI com {len(sessions_list)} sess√µes...")
            try:
                # Tentar usar display_sessions diretamente se existe
                if hasattr(self, 'display_sessions'):
                    print(f"[DEBUG] ‚úì Chamando display_sessions diretamente...")
                    self.root.after(0, lambda: self.display_sessions(sessions_list))
                # Fallback para fun√ß√£o salva
                elif hasattr(self, '_display_sessions_func'):
                    print(f"[DEBUG] ‚úì Chamando _display_sessions_func...")
                    self.root.after(0, lambda: self._display_sessions_func(sessions_list))
                else:
                    print(f"[DEBUG] Nenhuma fun√ß√£o display_sessions dispon√≠vel - sess√µes recebidas mas UI n√£o atualizada")
            except Exception as e:
                print(f"[DEBUG] ‚ùå Erro ao atualizar UI: {e}")
                
        def on_sessions_list_update(data):
            """Handler para quando recebemos updates da lista de sess√µes"""
            print(f"[DEBUG] on_sessions_list_update chamado com data: {data}")
            sessions_list = data.get('sessions', [])
            
            # CORRE√á√ÉO CR√çTICA: Normalizar states das sess√µes no update
            print(f"[DEBUG] Normalizando states de {len(sessions_list)} sess√µes (update)...")
            for i, session in enumerate(sessions_list):
                old_state = session.get('state')
                session = normalize_session_state(session)
                sessions_list[i] = session
                new_state = session.get('state')
                if str(old_state) != str(new_state):
                    print(f"[DEBUG] Update Sess√£o {i+1}: {old_state} -> {new_state}")
            
            print(f"[DEBUG] sessions_list update extra√≠da: {sessions_list}")
            
            # CRITICAL DEBUG: Verificar state de cada sess√£o no update
            if sessions_list:
                for i, session in enumerate(sessions_list):
                    session_state = session.get('state')
                    print(f"[DEBUG] UPDATE - Sess√£o {i+1} STATE: '{session_state}' (tipo: {type(session_state)})")
            
            self.current_sessions = sessions_list
            # CR√çTICO: Atualizar sessions_data para updates tamb√©m
            self.sessions_data = sessions_list
            print(f"[DEBUG] sessions_data atualizada com {len(sessions_list)} sess√µes (via update)")
            
            # CORRE√á√ÉO CR√çTICA: FOR√áAR atualiza√ß√£o da UI sempre que sessions_list_update √© recebida
            print(f"[DEBUG] For√ßando atualiza√ß√£o da UI via UPDATE com {len(sessions_list)} sess√µes...")
            try:
                # Tentar usar display_sessions diretamente se existe
                if hasattr(self, 'display_sessions'):
                    print(f"[DEBUG] ‚úì Chamando display_sessions diretamente (UPDATE)...")
                    self.root.after(0, lambda: self.display_sessions(sessions_list))
                # Fallback para fun√ß√£o salva
                elif hasattr(self, '_display_sessions_func'):
                    print(f"[DEBUG] ‚úì Chamando _display_sessions_func (UPDATE)...")
                    self.root.after(0, lambda: self._display_sessions_func(sessions_list))
                else:
                    print(f"[DEBUG] Nenhuma fun√ß√£o display_sessions dispon√≠vel - UPDATE recebido mas UI n√£o atualizada")
            except Exception as e:
                print(f"[DEBUG] ‚ùå Erro ao atualizar UI (UPDATE): {e}")
        
        # REGISTRAR HANDLERS IMEDIATAMENTE - ANTES de qualquer auto-refresh!
        print(f"[CRITICAL] Registando handlers sessions_list IMEDIATAMENTE...")
        netmaster_client.set_message_handler('session_list', on_session_list_received)
        netmaster_client.set_message_handler('sessions_list', on_session_list_received)  # Nome correto do servidor
        netmaster_client.set_message_handler('sessions_list_update', on_sessions_list_update)
        print(f"[CRITICAL] Handlers sessions_list registrados com SUCESSO!")

        # Adicionar padr√µes de rede para Search Game flow
        self.add_network_pattern_decorations(self.root)

        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        # Texto inicial
        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.3, anchor="center")
        
        title_lbl = tk.Label(tf, text="", font=("Helvetica", 18, "bold"), bg="black", fg="white", 
                             wraplength=int(self.screen_width*0.8), justify="center")
        title_lbl.pack(pady=(0,8))
        
        subtitle_lbl = tk.Label(tf, text="", font=("Helvetica", 14), bg="black", fg="white", 
                                wraplength=int(self.screen_width*0.8), justify="center")
        subtitle_lbl.pack(pady=(0,12))

        def show_sessions_list():
            # Frame para lista de sess√µes
            sessions_frame = tk.Frame(self.root, bg="black")
            sessions_frame.place(relx=0.5, rely=0.45, anchor="center")
            
            # Vari√°vel para armazenar as sess√µes recebidas
            self.current_sessions = []
            self.sessions_frame_ref = sessions_frame
            self.auto_refresh_active = True  # Flag para controlar auto-refresh
            
            # CR√çTICO: Registar handler global ANTES de qualquer outra opera√ß√£o
            print(f"[SEARCH] [DEBUG] Registando handler global ANTES de buscar sess√µes...")
            try:
                netmaster_client.set_message_handler('sessions_list_update', self.on_global_sessions_list_update)
                print(f"[SEARCH] [DEBUG] Handler global registado com SUCESSO!")
            except Exception as e:
                print(f"[SEARCH] [ERROR] Erro ao registar handler: {e}")

            # FUN√á√ÉO DE CONEX√ÉO DEDICADA (movida para fora da thread)
            async def ensure_connection_and_handler():
                try:
                    if not netmaster_client.connected:
                        print(f"[SEARCH] [CRITICAL] Cliente n√£o conectado - conectando agora...")
                        success = await netmaster_client.connect()
                        print(f"[SEARCH] [CRITICAL] Conex√£o resultado: {success}")
                    
                    # FOR√áA registo m√∫ltiplo do handler para garantir
                    print(f"[SEARCH] [CRITICAL] For√ßando registo TRIPLO do handler...")
                    netmaster_client.set_message_handler('sessions_list_update', self.on_global_sessions_list_update)
                    netmaster_client.set_message_handler('session_list_update', self.on_global_sessions_list_update)
                    
                    # CORRE√á√ÉO CR√çTICA: SEMPRE registrar sessions_list handler!
                    # O problema era que este handler estava comentado, causando perda de mensagens sessions_list
                    print(f"[SEARCH] [CRITICAL] CORRIGINDO: Registrando sessions_list handler obrigat√≥rio...")
                    netmaster_client.set_message_handler('sessions_list', self.on_global_sessions_list_update)
                    print(f"[SEARCH] [CRITICAL] ‚úì sessions_list handler REGISTRADO com sucesso!")
                    
                    # CORRE√á√ÉO CR√çTICA 2: REGISTRAR welcome handler para cliente procurador!
                    # Cliente procurador tamb√©m precisa receber welcome message para funcionar corretamente
                    print(f"[SEARCH] [CRITICAL] CORRIGINDO: Registrando welcome handler obrigat√≥rio...")
                    netmaster_client.set_message_handler('welcome', self.on_server_welcome)
                    print(f"[SEARCH] [CRITICAL] ‚úì welcome handler REGISTRADO com sucesso!")
                    
                    print(f"[SEARCH] [CRITICAL] Handler registado com TRIPLA PROTE√á√ÉO!")
                    print(f"[SEARCH] [CRITICAL] ‚úì sessions_list handler agora ativo para receber respostas do servidor")
                    print(f"[SEARCH] [CRITICAL] ‚úì welcome handler agora ativo para receber mensagem de boas-vindas")
                    
                    # FOR√áA list_sessions imediato para "anunciar" presen√ßa ao servidor
                    print(f"[SEARCH] [CRITICAL] Enviando list_sessions para anunciar presen√ßa...")
                    await netmaster_client.list_sessions()
                    print(f"[SEARCH] [CRITICAL] Presen√ßa anunciada ao servidor!")
                    
                except Exception as e:
                    print(f"[SEARCH] [ERROR] Erro na conex√£o/registo cr√≠tico: {e}")

            # ‚úì CONEX√ÉO SIMPLES: Usar fetch_sessions_sync existente sem threads extras
            print(f"[SEARCH] [SIMPLE] *** USANDO CONEX√ÉO SIMPLES SEM THREADS EXTRAS ***")
            
            def display_sessions(sessions_list):
                """Exibe a lista de sess√µes recebida do servidor"""
                print(f"[DEBUG] display_sessions chamado com {len(sessions_list) if sessions_list else 0} sess√µes")
                print(f"[DEBUG] sessions_list completa: {sessions_list}")
                
                # Verificar se sessions_frame ainda existe
                try:
                    # Limpar frame atual
                    for widget in sessions_frame.winfo_children():
                        widget.destroy()
                except tk.TclError:
                    print("[DEBUG] sessions_frame foi destru√≠do, retornando")
                    return
                
                if not sessions_list:
                    print(f"[DEBUG] Nenhuma sess√£o dispon√≠vel, mostrando mensagem")
                    
                    # Criar indicador animado de busca
                    loading_container = tk.Frame(sessions_frame, bg="black")
                    loading_container.pack(pady=20)
                    
                    no_sessions_lbl = tk.Label(loading_container, text="Searching for available sessions...", 
                                             font=("Helvetica", 14), bg="black", fg="#999999")
                    no_sessions_lbl.pack(pady=(0, 10))
                    
                    hint_lbl = tk.Label(loading_container, text="New sessions will appear automatically", 
                                      font=("Helvetica", 11), bg="black", fg="#666666")
                    hint_lbl.pack()
                    
                    # Adicionar anima√ß√£o pulsante ao texto de busca
                    def animate_search_text():
                        if hasattr(self, 'auto_refresh_active') and self.auto_refresh_active and no_sessions_lbl.winfo_exists():
                            current_text = no_sessions_lbl.cget("text")
                            if current_text.endswith("..."):
                                no_sessions_lbl.config(text="Searching for available sessions")
                            else:
                                no_sessions_lbl.config(text="Searching for available sessions...")
                            # Repetir anima√ß√£o a cada 1 segundo
                            self.root.after(1000, animate_search_text)
                    
                    # Iniciar anima√ß√£o
                    self.root.after(500, animate_search_text)
                else:
                    print(f"[DEBUG] Processando {len(sessions_list)} sess√µes...")
                    for i, session in enumerate(sessions_list):
                        # CORRE√á√ÉO CR√çTICA: Normalizar state da sess√£o antes de processar
                        session = normalize_session_state(session)
                        sessions_list[i] = session
                        
                        print(f"[DEBUG] Processando sess√£o {i+1}: {session}")
                        # Extrair informa√ß√µes da sess√£o
                        host_name = None
                        current_players = session.get('current_players', 0)
                        max_players = session.get('max_players', 4)
                        duration_minutes = session.get('duration_minutes', 30)
                        session_id = session.get('id', 'Unknown')
                        
                        # Tentar encontrar o nome do host
                        players = session.get('players', {})
                        host_player_id = session.get('host_player_id')
                        if host_player_id and host_player_id in players:
                            host_name = players[host_player_id].get('name', 'Unknown Host')
                        else:
                            # Se n√£o conseguir encontrar o host, usar o primeiro jogador
                            if players:
                                first_player = list(players.values())[0]
                                host_name = first_player.get('name', 'Unknown Host')
                            else:
                                host_name = "Unknown Host"
                        
                        print(f"[DEBUG] Criando bot√£o para sess√£o: {host_name} ({current_players}/{max_players})")
                        
                        session_btn = tk.Button(
                            sessions_frame,
                            text=f"{host_name}'s Game\n({current_players}/{max_players} players)\n{duration_minutes}min",
                            font=("Helvetica", 11, "bold"),
                            bg="#2196F3",
                            fg="white",
                            width=25,
                            height=3,
                            command=lambda s=session: self.join_selected_session(name, s)
                        )
                        session_btn.pack(pady=5)
                        print(f"[DEBUG] Bot√£o criado para sess√£o {session_id}")
                
                # Bot√£o Refresh
                refresh_btn = tk.Button(
                    sessions_frame,
                    text="Refresh",
                    font=("Helvetica", 12),
                    bg="#555555",
                    fg="white",
                    command=lambda: self.refresh_sessions()
                )
                refresh_btn.pack(pady=10)
                print(f"[DEBUG] display_sessions conclu√≠do")
            
            # *** ARMAZENAR refer√™ncia para os handlers poderem usar display_sessions ***
            self._display_sessions_func = display_sessions
            
            # *** HANDLERS J√Å FORAM REGISTRADOS NO IN√çCIO DA FUN√á√ÉO show_join_session_page ***
            # C√≥digo duplicado de handlers removido para evitar conflitos
            
            # CRUCIAL: Tamb√©m configurar auto-refresh imediato para n√£o depender s√≥ do broadcast
            print(f"[AUTO-REFRESH] Iniciando auto-refresh imediato para capturar sess√µes criadas...")
            self.schedule_immediate_auto_refresh()
            
            # IMPORTANTE: Configurar handlers para join session desde o in√≠cio
            # Isso garante que quando o jogador fizer join, os handlers j√° est√£o configurados
            netmaster_client.set_message_handler('session_joined', self.on_session_joined)
            netmaster_client.set_message_handler('player_joined', self.on_session_joined)  # Poss√≠vel varia√ß√£o
            netmaster_client.set_message_handler('join_success', self.on_session_joined)   # Poss√≠vel varia√ß√£o
            netmaster_client.set_message_handler('joined_session', self.on_session_joined) # Poss√≠vel varia√ß√£o
            netmaster_client.set_message_handler('join_error', self.on_join_error)
            netmaster_client.set_message_handler('error', self.on_join_error)  # Fallback para erros
            
            # NOTA: Handler game_started ser√° registrado apenas na waiting room
            # para evitar conflitos de m√∫ltiplas registra√ß√µes
            netmaster_client.set_message_handler('turn_changed', self.on_multiplayer_turn_changed)
            
            # Tentar buscar sess√µes do servidor
            def fetch_sessions_sync():
                """Fun√ß√£o s√≠ncrona que executa a busca de sess√µes"""
                async def fetch_sessions():
                    try:
                        print(f"[DEBUG] fetch_sessions iniciado...")
                        print(f"[DEBUG] netmaster_client.connected: {netmaster_client.connected}")
                        
                        # Conectar ao NetMaster server se ainda n√£o conectado
                        if not netmaster_client.connected:
                            print(f"[DEBUG] Cliente n√£o conectado, tentando conectar...")
                            success = await netmaster_client.connect()
                            print(f"[DEBUG] Resultado da conex√£o: {success}")
                            if not success:
                                raise Exception("Failed to connect to server")
                        
                        # IMPORTANTE: Registar handler global para receber broadcasts
                        print(f"[DEBUG] Registando handler global sessions_list_update...")
                        netmaster_client.set_message_handler('sessions_list_update', self.on_global_sessions_list_update)
                        print(f"[DEBUG] Handler global registado com sucesso!")
                        
                        # Limpar sess√µes existentes antes de solicitar
                        self.sessions_data = []
                        
                        # Solicitar lista de sess√µes
                        print(f"[DEBUG] Solicitando lista de sess√µes...")
                        result = await netmaster_client.list_sessions()
                        print(f"[DEBUG] Resultado de list_sessions: {result}")
                        print(f"[DEBUG] Solicita√ß√£o de lista enviada com sucesso")
                        
                        # Aguardar resposta do servidor (dar tempo para processar)
                        print(f"[DEBUG] Aguardando resposta do servidor...")
                        for i in range(10):  # Aguardar at√© 5 segundos
                            await asyncio.sleep(0.5)
                            if hasattr(self, 'sessions_data') and self.sessions_data:
                                print(f"[DEBUG] Sess√µes recebidas ap√≥s {(i+1)*0.5}s: {len(self.sessions_data)}")
                                self.root.after(0, lambda: display_sessions(self.sessions_data))
                                return
                            print(f"[DEBUG] Aguardando... tentativa {i+1}/10")
                        
                        print(f"[DEBUG] Timeout aguardando resposta - usando resultado direto se houver")
                        if result and hasattr(self, 'sessions_data') and self.sessions_data:
                            print(f"[DEBUG] Usando sessions_data: {len(self.sessions_data)} sess√µes")
                            self.root.after(0, lambda: display_sessions(self.sessions_data))
                        else:
                            print(f"[DEBUG] Nenhuma sess√£o encontrada")
                            self.root.after(0, lambda: display_sessions([]))
                        
                    except Exception as e:
                        print(f"[DEBUG] Error fetching sessions: {e}")
                        import traceback
                        traceback.print_exc()
                        # Mostrar mensagem de erro e fallback para "no sessions"
                        self.root.after(0, lambda: display_sessions([]))
                
                # Executar em thread separada com loop de eventos
                def run_async():
                    try:
                        print(f"[DEBUG] run_async iniciado...")
                        # Tentar usar loop existente se houver
                        try:
                            loop = asyncio.get_running_loop()
                            print(f"[DEBUG] Loop existente encontrado, criando task...")
                            # Se j√° h√° um loop, agendar a task
                            loop.create_task(fetch_sessions())
                        except RuntimeError:
                            print(f"[DEBUG] Nenhum loop ativo, criando novo...")
                            # N√£o h√° loop ativo, criar um novo
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            
                            # IMPORTANTE: N√£o fechar o loop ap√≥s run_until_complete
                            # Manter ativo para futuras opera√ß√µes (como join_session)
                            task = loop.create_task(fetch_sessions())
                            try:
                                loop.run_until_complete(task)
                                print(f"[DEBUG] Fetch sessions conclu√≠do - mantendo loop ativo")
                                # N√ÉO fechar o loop - pode ser reutilizado para join_session
                            except Exception as e:
                                print(f"[ERROR] [DEBUG] Erro no fetch sessions: {e}")
                                loop.close()
                                raise
                    except Exception as e:
                        print(f"[DEBUG] Error in async execution: {e}")
                        import traceback
                        traceback.print_exc()
                        self.root.after(0, lambda: display_sessions([]))
                
                # Executar em thread separada para n√£o bloquear UI
                import threading
                print(f"[DEBUG] Iniciando thread para busca de sess√µes...")
                thread = threading.Thread(target=run_async, daemon=True)
                thread.start()
            
            # Mostrar loading inicialmente
            loading_lbl = tk.Label(sessions_frame, text="Loading sessions...", 
                                 font=("Helvetica", 14), bg="black", fg="#999999")
            loading_lbl.pack(pady=20)
            
            # Executar busca de sess√µes
            print(f"[DEBUG] Chamando fetch_sessions_sync...")
            fetch_sessions_sync()
            
            # *** IMPLEMENTAR AUTO-REFRESH CONT√çNUO ***
            def auto_refresh_sessions():
                """Fun√ß√£o que verifica automaticamente por novas sess√µes"""
                if not hasattr(self, 'auto_refresh_active') or not self.auto_refresh_active:
                    print(f"[AUTO-REFRESH] Auto-refresh desativado, parando...")
                    return
                
                if not hasattr(self, 'sessions_frame_ref') or not self.sessions_frame_ref.winfo_exists():
                    print(f"[AUTO-REFRESH] Frame de sess√µes n√£o existe mais, parando...")
                    return
                
                print(f"[AUTO-REFRESH] *** VERIFICANDO NOVAS SESS√ïES ***")
                
                # Fun√ß√£o ass√≠ncrona para buscar sess√µes em background
                async def background_fetch():
                    try:
                        if netmaster_client.connected:
                            success = await netmaster_client.list_sessions()
                            print(f"[AUTO-REFRESH] list_sessions result: {success}")
                            # Aguardar um pouco para resposta
                            await asyncio.sleep(0.5)
                        else:
                            print(f"[AUTO-REFRESH] Cliente n√£o conectado, tentando reconectar...")
                            await netmaster_client.connect()
                    except Exception as e:
                        print(f"[AUTO-REFRESH] Erro: {e}")
                
                # Executar em background sem bloquear
                def run_background_fetch():
                    try:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        loop.run_until_complete(background_fetch())
                        loop.close()
                    except Exception as e:
                        print(f"[AUTO-REFRESH] Erro na thread: {e}")
                
                # Executar em thread separada
                import threading
                thread = threading.Thread(target=run_background_fetch, daemon=True)
                thread.start()
                
                # Agendar pr√≥xima verifica√ß√£o em 3 segundos
                self.root.after(3000, auto_refresh_sessions)
            
            # Iniciar auto-refresh ap√≥s 2 segundos da busca inicial
            print(f"[AUTO-REFRESH] Agendando auto-refresh autom√°tico...")
            self.root.after(2000, auto_refresh_sessions)

        animate_typing(title_lbl, "Available Game Sessions", delay=50,
                       callback=lambda: animate_typing(subtitle_lbl, "Select a session to join:", delay=40, callback=show_sessions_list))

    def schedule_immediate_auto_refresh(self):
        """Agenda auto-refresh imediato para capturar sess√µes criadas por outros"""
        print(f"[AUTO-REFRESH] *** SCHEDULE_IMMEDIATE_AUTO_REFRESH INICIADO ***")
        
        # NOVA FUNCIONALIDADE: Rastreamento de broadcast para fallback agressivo
        self.last_broadcast_time = 0
        self.broadcast_missed_count = 0
        
        def immediate_refresh():
            """Executa refresh imediato"""
            if not hasattr(self, 'auto_refresh_active') or not self.auto_refresh_active:
                print(f"[AUTO-REFRESH] Auto-refresh n√£o ativo, cancelando")
                return
                
            print(f"[AUTO-REFRESH] Executando refresh imediato...")
            
            # Fun√ß√£o ass√≠ncrona para buscar
            async def immediate_fetch():
                try:
                    if netmaster_client.connected:
                        await netmaster_client.list_sessions()
                        print(f"[AUTO-REFRESH] Refresh imediato executado")
                except Exception as e:
                    print(f"[AUTO-REFRESH] Erro no refresh imediato: {e}")
            
            # Executar em thread
            def run_immediate():
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(immediate_fetch())
                    loop.close()
                except Exception as e:
                    print(f"[AUTO-REFRESH] Erro na thread imediata: {e}")
            
            import threading
            thread = threading.Thread(target=run_immediate, daemon=True)
            thread.start()
            
            # NOVA L√ìGICA: Determinar intervalo baseado em broadcast recebidos
            import time
            current_time = time.time()
            time_since_last_broadcast = current_time - self.last_broadcast_time
            
            # Se n√£o recebeu broadcast h√° mais de 5 segundos, usar polling agressivo
            if time_since_last_broadcast > 5:
                self.broadcast_missed_count += 1
                interval = 1000  # 1 segundo - polling agressivo
                print(f"[AUTO-REFRESH] SEM BROADCAST h√° {time_since_last_broadcast:.1f}s - POLLING AGRESSIVO (1s)")
            else:
                self.broadcast_missed_count = 0
                interval = 3000  # 3 segundos - polling normal
                print(f"[AUTO-REFRESH] Broadcast recente - polling normal (3s)")
            
            # Agendar pr√≥ximo refresh
            self.root.after(interval, immediate_refresh)
        
        # Iniciar refresh imediato ap√≥s 1 segundo
        self.root.after(1000, immediate_refresh)

    def refresh_sessions(self):
        """Atualiza a lista de sess√µes com retry logic robusto"""
        print(f"[DEBUG] *** REFRESH_SESSIONS CHAMADO ***")
        print(f"[DEBUG] netmaster_client.connected: {netmaster_client.connected}")
        print(f"[DEBUG] Handlers ativos: {list(netmaster_client.message_handlers.keys())}")
        
        # Evitar m√∫ltiplos refreshes simult√¢neos
        if hasattr(self, 'is_refreshing') and self.is_refreshing:
            print(f"[DEBUG] Refresh j√° em andamento, ignorando...")
            return
        
        self.is_refreshing = True
        
        # Fun√ß√£o para encontrar o frame de sess√µes e atualizar display
        def update_sessions_display(sessions_list):
            """Atualiza o display de sess√µes no frame existente"""
            try:
                print(f"[DEBUG] update_sessions_display chamado com {len(sessions_list)} sess√µes")
                if hasattr(self, 'sessions_frame_ref') and self.sessions_frame_ref.winfo_exists():
                    sessions_frame = self.sessions_frame_ref
                    print(f"[DEBUG] Atualizando display com {len(sessions_list)} sess√µes")
                    
                    # Limpar frame atual
                    for widget in sessions_frame.winfo_children():
                        widget.destroy()
                    
                    if not sessions_list:
                        print(f"[DEBUG] Nenhuma sess√£o dispon√≠vel ap√≥s refresh")
                        no_sessions_lbl = tk.Label(sessions_frame, text="No sessions available. Click Refresh to try again.", 
                                                 font=("Helvetica", 14), bg="black", fg="#999999")
                        no_sessions_lbl.pack(pady=20)
                    else:
                        print(f"[DEBUG] Processando {len(sessions_list)} sess√µes no refresh...")
                        for i, session in enumerate(sessions_list):
                            print(f"[DEBUG] Refresh - Processando sess√£o {i+1}: {session}")
                            # Extrair informa√ß√µes da sess√£o
                            host_name = None
                            current_players = session.get('current_players', 0)
                            max_players = session.get('max_players', 4)
                            duration_minutes = session.get('duration_minutes', 30)
                            session_id = session.get('id', 'Unknown')
                            
                            # Tentar encontrar o nome do host
                            players = session.get('players', {})
                            host_player_id = session.get('host_player_id')
                            if host_player_id and host_player_id in players:
                                host_name = players[host_player_id].get('name', 'Unknown Host')
                            else:
                                # Se n√£o conseguir encontrar o host, usar o primeiro jogador
                                if players:
                                    first_player = list(players.values())[0]
                                    host_name = first_player.get('name', 'Unknown Host')
                                else:
                                    host_name = "Unknown Host"
                            
                            print(f"[DEBUG] Refresh - Criando bot√£o para sess√£o: {host_name} ({current_players}/{max_players})")
                            
                            session_btn = tk.Button(
                                sessions_frame,
                                text=f"{host_name}'s Game\n({current_players}/{max_players} players)\n{duration_minutes}min",
                                font=("Helvetica", 11, "bold"),
                                bg="#2196F3",
                                fg="white",
                                width=25,
                                height=3,
                                command=lambda s=session: self.join_selected_session(self.player_name, s)
                            )
                            session_btn.pack(pady=5)
                            print(f"[DEBUG] Refresh - Bot√£o criado para sess√£o {session_id}")
                    
                    # Re-adicionar bot√£o Refresh
                    refresh_btn = tk.Button(
                        sessions_frame,
                        text="Refresh",
                        font=("Helvetica", 12),
                        bg="#555555",
                        fg="white",
                        command=lambda: self.refresh_sessions()
                    )
                    refresh_btn.pack(pady=10)
                    print(f"[DEBUG] Display refresh conclu√≠do")
                    
                else:
                    print(f"[DEBUG] sessions_frame_ref n√£o existe mais")
            except Exception as e:
                print(f"[DEBUG] Erro ao atualizar display: {e}")
                import traceback
                traceback.print_exc()
        
        # Primeiro: Tentar usar o handler global se j√° h√° sess√µes em cache
        if hasattr(self, 'sessions_data') and self.sessions_data:
            print(f"[DEBUG] *** USANDO CACHE DE SESS√ïES: {len(self.sessions_data)} ***")
            update_sessions_display(self.sessions_data)
            
        # Marcar que estamos fazendo refresh para o handler global detectar
        self.is_refreshing = True
        
        # Implementar robust retry mechanism
        def refresh_sessions_sync():
            """Fun√ß√£o s√≠ncrona que executa a atualiza√ß√£o de sess√µes com retry logic"""
            async def robust_fetch_sessions():
                try:
                    print(f"[DEBUG] *** ROBUST FETCH_SESSIONS INICIADO ***")
                    print(f"[DEBUG] netmaster_client.connected: {netmaster_client.connected}")
                    
                    # Garantir conex√£o ativa
                    if not netmaster_client.connected:
                        print(f"[DEBUG] Tentando reconectar...")
                        success = await netmaster_client.connect()
                        if not success:
                            print(f"[DEBUG] ERRO: Falha na reconex√£o")
                            self.is_refreshing = False
                            return
                    
                    # RETRY LOGIC ROBUSTO: Tentar m√∫ltiplas vezes at√© conseguir resposta v√°lida
                    max_retries = 5
                    retry_delay = 0.5  # Iniciar com 0.5s
                    
                    for attempt in range(max_retries):
                        print(f"[DEBUG] *** TENTATIVA {attempt + 1}/{max_retries} ***")
                        
                        # Limpar data antes de cada tentativa
                        initial_sessions_count = len(self.sessions_data) if hasattr(self, 'sessions_data') else 0
                        
                        # Enviar solicita√ß√£o
                        success = await netmaster_client.list_sessions()
                        print(f"[DEBUG] list_sessions result: {success}")
                        
                        if success:
                            # Aguardar resposta com timeout progressivo
                            wait_time = retry_delay * (attempt + 1)
                            print(f"[DEBUG] Aguardando resposta por {wait_time}s...")
                            await asyncio.sleep(wait_time)
                            
                            # Verificar se recebemos dados
                            current_sessions_count = len(self.sessions_data) if hasattr(self, 'sessions_data') else 0
                            print(f"[DEBUG] Sessions count - Antes: {initial_sessions_count}, Depois: {current_sessions_count}")
                            
                            # SUCESSO: Se dados mudaram ou se encontramos sess√µes
                            if current_sessions_count > 0 or current_sessions_count != initial_sessions_count:
                                print(f"[DEBUG] *** SUCESSO! Encontradas {current_sessions_count} sess√µes ***")
                                self.root.after(0, lambda: update_sessions_display(self.sessions_data))
                                self.is_refreshing = False
                                return
                            
                            # Se ainda n√£o temos dados, tentar pr√≥xima tentativa
                            print(f"[DEBUG] Tentativa {attempt + 1} falhou - sem dados v√°lidos")
                        else:
                            print(f"[DEBUG] Tentativa {attempt + 1} falhou - erro na comunica√ß√£o")
                        
                        # Aguardar antes da pr√≥xima tentativa
                        if attempt < max_retries - 1:
                            print(f"[DEBUG] Aguardando {retry_delay}s antes da pr√≥xima tentativa...")
                            await asyncio.sleep(retry_delay)
                            retry_delay *= 1.5  # Aumentar delay exponencialmente
                    
                    # Se todas as tentativas falharam
                    print(f"[DEBUG] *** TODAS AS TENTATIVAS FALHARAM - USANDO FALLBACK ***")
                    fallback_sessions = self.sessions_data if hasattr(self, 'sessions_data') else []
                    self.root.after(0, lambda: update_sessions_display(fallback_sessions))
                    self.is_refreshing = False
                    
                except Exception as e:
                    print(f"[DEBUG] Erro no robust fetch: {e}")
                    import traceback
                    traceback.print_exc()
                    self.is_refreshing = False
                try:
                    print(f"[DEBUG] *** REFRESH fetch_sessions iniciado ***")
                    print(f"[DEBUG] netmaster_client.connected: {netmaster_client.connected}")
                    
                    # Conectar ao NetMaster server se ainda n√£o conectado
                    if not netmaster_client.connected:
                        print(f"[DEBUG] Cliente n√£o conectado, tentando conectar...")
                        success = await netmaster_client.connect()
                        print(f"[DEBUG] Resultado da conex√£o: {success}")
                        if not success:
                            raise Exception("Failed to connect to server")
                    
                    print(f"[DEBUG] *** ENVIANDO LIST_SESSIONS ***")
                    
                    # Solicitar lista de sess√µes
                    print(f"[DEBUG] Refresh - Solicitando lista de sess√µes...")
                    result = await netmaster_client.list_sessions()
                    print(f"[DEBUG] Refresh - Resultado de list_sessions: {result}")
                    
                    print(f"[DEBUG] *** AGUARDANDO RESPOSTA DO SERVIDOR ***")
                    
                    # Aguardar resposta do servidor (dar tempo para processar)
                    print(f"[DEBUG] Refresh - Aguardando resposta do servidor...")
                    found_sessions = False
                    for i in range(20):  # Aguardar at√© 10 segundos (mais tempo)
                        await asyncio.sleep(0.5)
                        if hasattr(self, 'sessions_data') and self.sessions_data is not None:
                            print(f"[DEBUG] *** SESS√ïES ENCONTRADAS AP√ìS {(i+1)*0.5}s: {len(self.sessions_data)} ***")
                            self.root.after(0, lambda: update_sessions_display(self.sessions_data))
                            found_sessions = True
                            break
                        print(f"[DEBUG] Refresh - Aguardando... tentativa {i+1}/20")
                    
                    if not found_sessions:
                        print(f"[DEBUG] *** TIMEOUT - MOSTRANDO LISTA VAZIA ***")
                        # Se n√£o recebeu resposta, mostrar lista vazia
                        self.root.after(0, lambda: update_sessions_display([]))
                        
                    # Reset flag
                    self.is_refreshing = False
                        
                except Exception as e:
                    print(f"[DEBUG] *** ERRO NO REFRESH: {e} ***")
                    import traceback
                    traceback.print_exc()
                    # Mostrar mensagem de erro e fallback para "no sessions"
                    self.root.after(0, lambda: update_sessions_display([]))
                    self.is_refreshing = False
            
            # Executar em thread separada com loop de eventos
            def run_async():
                try:
                    print(f"[DEBUG] *** REFRESH run_async iniciado ***")
                    # Tentar usar loop existente se houver
                    try:
                        loop = asyncio.get_running_loop()
                        print(f"[DEBUG] Refresh - Loop existente encontrado, criando task...")
                        # Se j√° h√° um loop, agendar a task
                        loop.create_task(robust_fetch_sessions())
                    except RuntimeError:
                        print(f"[DEBUG] Refresh - Nenhum loop ativo, criando novo...")
                        # N√£o h√° loop ativo, criar um novo
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        loop.run_until_complete(robust_fetch_sessions())
                except Exception as e:
                    print(f"[DEBUG] *** ERRO NO REFRESH ASYNC: {e} ***")
                    import traceback
                    traceback.print_exc()
                    self.root.after(0, lambda: update_sessions_display([]))
                    self.is_refreshing = False
            
            # Executar em thread separada para n√£o bloquear UI
            import threading
            print(f"[DEBUG] *** INICIANDO THREAD PARA REFRESH ***")
            thread = threading.Thread(target=run_async, daemon=True)
            thread.start()
        
        refresh_sessions_sync()

    def refresh_display_with_sessions(self, sessions_list):
        """Atualiza o display de sess√µes diretamente com lista fornecida"""
        def update_ui():
            try:
                print(f"[DEBUG] refresh_display_with_sessions chamado com {len(sessions_list)} sess√µes")
                if hasattr(self, 'sessions_frame_ref') and self.sessions_frame_ref.winfo_exists():
                    sessions_frame = self.sessions_frame_ref
                    
                    # Limpar frame atual
                    for widget in sessions_frame.winfo_children():
                        widget.destroy()
                    
                    if not sessions_list:
                        print(f"[DEBUG] Nenhuma sess√£o para mostrar")
                        no_sessions_lbl = tk.Label(sessions_frame, text="No sessions available. Click Refresh to try again.", 
                                                 font=("Helvetica", 14), bg="black", fg="#999999")
                        no_sessions_lbl.pack(pady=20)
                    else:
                        print(f"[DEBUG] Processando {len(sessions_list)} sess√µes...")
                        for i, session in enumerate(sessions_list):
                            print(f"[DEBUG] Auto-refresh - Processando sess√£o {i+1}: {session.get('id')}")
                            # Extrair informa√ß√µes da sess√£o
                            host_name = None
                            current_players = session.get('current_players', 0)
                            max_players = session.get('max_players', 4)
                            duration_minutes = session.get('duration_minutes', 30)
                            session_id = session.get('id', 'Unknown')
                            
                            # Tentar encontrar o nome do host
                            players = session.get('players', {})
                            host_player_id = session.get('host_player_id')
                            if host_player_id and host_player_id in players:
                                host_name = players[host_player_id].get('name', 'Unknown Host')
                            else:
                                # Se n√£o conseguir encontrar o host, usar o primeiro jogador
                                if players:
                                    first_player = list(players.values())[0]
                                    host_name = first_player.get('name', 'Unknown Host')
                                else:
                                    host_name = "Unknown Host"
                            
                            print(f"[DEBUG] Auto-refresh - Criando bot√£o para: {host_name} ({current_players}/{max_players})")
                            
                            session_btn = tk.Button(
                                sessions_frame,
                                text=f"{host_name}'s Game\n({current_players}/{max_players} players)\n{duration_minutes}min",
                                font=("Helvetica", 11, "bold"),
                                bg="#2196F3",
                                fg="white",
                                width=25,
                                height=3,
                                command=lambda s=session: self.join_selected_session(getattr(self, 'join_player_name', 'Player'), s)
                            )
                            session_btn.pack(pady=5)
                    
                    # Re-adicionar bot√£o Refresh
                    refresh_btn = tk.Button(
                        sessions_frame,
                        text="Refresh",
                        font=("Helvetica", 12),
                        bg="#555555",
                        fg="white",
                        command=lambda: self.refresh_sessions()
                    )
                    refresh_btn.pack(pady=10)
                    print(f"[DEBUG] Auto-refresh display conclu√≠do")
                    
                else:
                    print(f"[DEBUG] sessions_frame_ref n√£o existe para auto-refresh")
            except Exception as e:
                print(f"[DEBUG] Erro no auto-refresh display: {e}")
                import traceback
                traceback.print_exc()
        
        # Executar na thread principal do tkinter
        self.root.after(0, update_ui)

    def stop_auto_refresh(self):
        """Para o auto-refresh autom√°tico de sess√µes"""
        if hasattr(self, 'auto_refresh_active'):
            print(f"[AUTO-REFRESH] Parando auto-refresh...")
            self.auto_refresh_active = False
        else:
            print(f"[AUTO-REFRESH] Auto-refresh j√° estava inativo")

    def join_selected_session(self, name, session):
        """Processar sele√ß√£o de sess√£o e ir para sele√ß√£o de cor"""
        # Parar auto-refresh quando selecionamos uma sess√£o
        self.stop_auto_refresh()
        
        self.selected_session = session
        # Ir para sele√ß√£o de cor ap√≥s selecionar sess√£o
        self.show_color_selection_page(name, "local")

    def show_game_type_page(self, name, flow_type="search"):
        """Fun√ß√£o de compatibilidade - redireciona para as fun√ß√µes espec√≠ficas"""
        if flow_type == "create":
            self.show_game_type_page_create(name)
        else:
            self.show_game_type_page_search(name)

    def show_color_selection_page_create(self, name):
        """Mostrar sele√ß√£o de cor para Create Game flow"""
        # Parar auto-refresh quando mudamos de p√°gina
        self.stop_auto_refresh()
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")

        # Adicionar padr√µes de rede para Create Game flow
        self.add_network_pattern_decorations(self.root)

        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.36, anchor="center")
        lbl1 = tk.Label(tf, text="", font=("Helvetica",18,"bold"), bg="black", fg="#6F0DB6", 
                        wraplength=int(self.screen_width*0.8), justify="center")
        lbl2 = tk.Label(tf, text="", font=("Helvetica",14), bg="black", fg="white", 
                        wraplength=int(self.screen_width*0.8), justify="center")
        lbl1.pack(pady=(0,8))
        lbl2.pack(pady=(0,12))

        def show_buttons():
            bf = tk.Frame(self.root, bg="black")
            bf.place(relx=0.5, rely=0.6, anchor="center")
            
            for color, fname in [("Red","red_user_icon.png"),
                                 ("Green","green_user_icon.png"),
                                 ("Blue","blue_user_icon.png"),
                                 ("Yellow","yellow_user_icon.png")]:
                icon = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, fname)).resize((65,65)))
                btn = tk.Button(
                    bf,
                    image=icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    command=lambda c=color: self.show_local_remote_page_create(name, c)
                )
                btn.image = icon  # Keep reference
                btn.pack(side=tk.LEFT, padx=10)

        animate_typing(lbl1, name, delay=50,
                       callback=lambda: animate_typing(lbl2,
                           "pick a color that feels like you!\nThis will represent your network.",
                           delay=50, callback=show_buttons))

    def show_local_remote_page_create(self, name, color):
        """Mostrar p√°gina Local/Remote para Create Game flow (com TopBar da cor)"""
        self.host_color = color
        self.host_name = name
        
        color_map = {
            "green": "#70AD47",
            "yellow": "#F2BA0D", 
            "red": "#EE6F68",
            "blue": "#43BEF2"
        }
        bar_color = color_map.get(self.host_color.lower(), "#AAAAAA")
        
        self.jogador = MenuPlayer(self.host_name, self.host_color.lower(), START_POSITIONS[self.host_color.lower()])
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")

        # N√ÉO adicionar padr√µes de rede para Create Game flow

        # Barra superior
        topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.host_color.lower()}.png")
        try:
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((self.screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            topbar_label = tk.Label(self.root, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            topbar_label.image = topbar_img  # Keep reference
            topbar_label.place(x=0, y=0, width=self.screen_width, height=60)
        except:
            # Fallback se imagem n√£o existir
            top_bar = tk.Frame(self.root, bg=bar_color, height=60)
            top_bar.place(x=0, y=0, width=self.screen_width)

        name_lbl = tk.Label(self.root, text=self.host_name, font=("Helvetica", 18, "bold"), 
                            fg="black", bg=bar_color, bd=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Coin display
        try:
            coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            coin_lbl = tk.Label(self.root, image=coin_img, bg=bar_color, bd=0)
            coin_lbl.image = coin_img  # Keep reference
            coin_lbl.place(x=self.screen_width-100, y=30)
        except:
            pass
            
        saldo_lbl = tk.Label(self.root, text="1000", font=("Helvetica", 16, "bold"), 
                             fg="black", bg=bar_color, bd=0)
        saldo_lbl.place(x=self.screen_width-70, y=30)

        # Frame central
        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.3, anchor="center")

        great_lbl = tk.Label(tf, text="", font=("Helvetica", 18, "bold"), bg="black", fg="white", 
                             wraplength=int(self.screen_width*0.8), justify="center")
        great_lbl.pack(pady=(0,8))
        how_lbl = tk.Label(tf, text="", font=("Helvetica", 14), bg="black", fg="white", 
                           wraplength=int(self.screen_width*0.8), justify="center")
        how_lbl.pack(pady=(0,12))

        def show_play_buttons():
            btns_frame = tk.Frame(self.root, bg="black")
            btns_frame.place(relx=0.5, rely=0.65, anchor="center")
            
            def launch_local():
                # Para Local Game no Create flow, ir para "Creating session..."
                self.show_connection_loading(self.host_name, "local")
                
            # Bot√£o Local Game
            if self.use_local_icon:
                btn1 = tk.Button(
                    btns_frame,
                    image=self.local_icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    command=launch_local
                )
                btn1.image = self.local_icon  # Keep reference
                btn1.pack(side=tk.TOP, pady=0)
            else:
                tk.Button(
                    btns_frame,
                    text="Local Game",
                    font=("Helvetica", 16, "bold"),
                    bg="#4CAF50",
                    fg="white",
                    command=launch_local
                ).pack(side=tk.TOP, pady=0)
                
            # Bot√£o Remote Game - sempre desativado
            if self.use_remote_icon:
                btn2 = tk.Button(
                    btns_frame,
                    image=self.remote_icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    state="disabled"
                )
                btn2.image = self.remote_icon  # Keep reference
                btn2.pack(side=tk.TOP, pady=0)
            else:
                tk.Button(
                    btns_frame,
                    text="Coming soon!",
                    font=("Helvetica", 16, "bold"),
                    bg="#666666",
                    fg="#999999",
                    state="disabled"
                ).pack(side=tk.TOP, pady=0)

        animate_typing(great_lbl, "Great!", delay=60,
            callback=lambda: animate_typing(how_lbl, "How do you want to play?", delay=40, callback=show_play_buttons)
        )

    def show_color_selection_page(self, name, game_type):
        """Mostrar sele√ß√£o de cor para Search Game flow"""
        # Parar auto-refresh quando mudamos de p√°gina
        self.stop_auto_refresh()
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")

        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)

        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")

        tf = tk.Frame(self.root, bg="black")
        tf.place(relx=0.5, rely=0.36, anchor="center")
        lbl1 = tk.Label(tf, text="", font=("Helvetica",18,"bold"), bg="black", fg="#6F0DB6", 
                        wraplength=int(self.screen_width*0.8), justify="center")
        lbl2 = tk.Label(tf, text="", font=("Helvetica",14), bg="black", fg="white", 
                        wraplength=int(self.screen_width*0.8), justify="center")
        lbl1.pack(pady=(0,8))
        lbl2.pack(pady=(0,12))

        def show_buttons():
            bf = tk.Frame(self.root, bg="black")
            bf.place(relx=0.5, rely=0.6, anchor="center")
            
            # Obter cores dispon√≠veis da sess√£o selecionada
            available_colors = []
            if hasattr(self, 'selected_session') and self.selected_session:
                available_colors = self.selected_session.get('available_colors', ["red", "green", "blue", "yellow"])
                print(f"[STYLE] [DEBUG] Cores dispon√≠veis na sess√£o: {available_colors}")
            else:
                # Fallback para todas as cores se n√£o h√° sess√£o selecionada
                available_colors = ["red", "green", "blue", "yellow"]
                print(f"[STYLE] [DEBUG] Usando todas as cores (sem sess√£o selecionada)")
            
            # Mapear cores para √≠cones
            color_icons = [
                ("red", "red_user_icon.png"),
                ("green", "green_user_icon.png"), 
                ("blue", "blue_user_icon.png"),
                ("yellow", "yellow_user_icon.png")
            ]
            
            # Guardar refer√™ncia aos bot√µes para desabilit√°-los
            self.color_buttons = []
            
            # Filtrar apenas cores dispon√≠veis
            for color_name, fname in color_icons:
                if color_name in [c.lower() for c in available_colors]:
                    icon = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, fname)).resize((65,65)))
                    btn = tk.Button(
                        bf,
                        image=icon,
                        bd=0,
                        bg="black",
                        activebackground="black",
                        highlightthickness=0,
                        command=lambda c=color_name, b=bf: self.handle_color_selection(c.title(), name, game_type, b)
                    )
                    btn.image = icon  # Keep reference
                    btn.pack(side=tk.LEFT, padx=10)
                    self.color_buttons.append(btn)
                    print(f"[STYLE] [DEBUG] Adicionado bot√£o para cor: {color_name}")

        animate_typing(lbl1, name, delay=50,
                       callback=lambda: animate_typing(lbl2,
                           "pick a color that feels like you!\nThis will represent your network.",
                           delay=50, callback=show_buttons))

    def handle_color_selection(self, color, name, game_type, button_frame):
        """Handle color selection with button disabling and joining state"""
        print(f"[TARGET] [DEBUG] Color selected: {color}, disabling buttons...")
        
        # Obter nome do host da sess√£o selecionada
        host_name = "Host"  # Default
        if hasattr(self, 'selected_session') and self.selected_session:
            host_player_id = self.selected_session.get('host_player_id')
            players = self.selected_session.get('players', {})
            if host_player_id and host_player_id in players:
                host_name = players[host_player_id].get('name', 'Host')
        
        print(f"[TARGET] [DEBUG] Host name: {host_name}")
        
        # Desabilitar todos os bot√µes para evitar cliques m√∫ltiplos
        if hasattr(self, 'color_buttons'):
            for btn in self.color_buttons:
                try:
                    btn.config(state='disabled')
                except tk.TclError:
                    pass  # Bot√£o j√° foi destru√≠do
        
        # Mostrar p√°gina completa de joining
        self.show_joining_session_page(host_name)
        
        # Chamar o m√©todo original de join
        self.join_session_with_color(color, name, game_type)

    def join_session_with_color(self, color, name, game_type):
        """Vers√£o SIMPLIFICADA de join - sem complexidades desnecess√°rias"""
        print(f"[SIMPLE_JOIN] Iniciando join simples: {name} como {color}")
        print(f"[SIMPLE_JOIN] *** M√âTODO join_session_with_color CHAMADO ***")
        
        # Flag b√°sica para evitar m√∫ltiplos joins
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            print(f"[SIMPLE_JOIN] J√° est√° fazendo join, ignorando...")
            return
            
        print(f"[JOIN_FLAG] *** DEFININDO is_joining_session = True ***")
        self.is_joining_session = True
        netmaster_client.is_joining_session = True  # CRITICAL: Set tamb√©m no cliente!
        print(f"[JOIN_FLAG] *** FLAGS DEFINIDAS: self={self.is_joining_session}, client={netmaster_client.is_joining_session} ***")
        
        self.join_player_name = name
        self.host_color = color
        self.host_name = name
        self.jogador = MenuPlayer(name, color.lower(), START_POSITIONS[color.lower()])
        
        def simple_join():
            try:
                # CRITICAL: Registrar handlers PRIMEIRO, no thread principal
                print(f"[SIMPLE_JOIN] Registrando handlers no thread principal...")
                netmaster_client.set_message_handler('session_joined', self.on_session_joined)
                netmaster_client.set_message_handler('sessions_list_update', self.simple_sessions_update)
                netmaster_client.set_message_handler('error', self.on_join_error)
                netmaster_client.set_message_handler('game_finished', self.on_menu_game_finished)  # Adicionar handler de fim de jogo
                
                # DEBUG: Confirmar handlers registrados
                print(f"[SIMPLE_JOIN] Handlers registrados: {list(netmaster_client.message_handlers.keys())}")
                print(f"[SIMPLE_JOIN] Handler session_joined: {netmaster_client.message_handlers.get('session_joined')}")
                print(f"[SIMPLE_JOIN] Handler game_finished: {netmaster_client.message_handlers.get('game_finished')}")
                
                async def async_join():
                    print(f"[SIMPLE_JOIN] Conectando ao servidor...")
                    
                    # Conectar se necess√°rio
                    if not netmaster_client.connected:
                        success = await netmaster_client.connect()
                        if not success:
                            raise Exception("Falha na conex√£o")
                    
                    print(f"[SIMPLE_JOIN] Conex√£o estabelecida")
                    
                    # Pequena pausa para garantir que tudo est√° pronto
                    await asyncio.sleep(0.1)
                    
                    # Enviar join
                    session_id = self.selected_session.get('id')
                    print(f"[SIMPLE_JOIN] Enviando join para sess√£o {session_id}")
                    await netmaster_client.join_session(session_id, name, color.lower())
                    
                    print(f"[SIMPLE_JOIN] Join enviado, aguardando resposta...")
                    start_time = time.time()
                    
                    # Aguardar resposta (m√°ximo 15 segundos)
                    for i in range(15):
                        print(f"[SIMPLE_JOIN] Aguardando... tentativa {i+1}/15, is_joining_session={self.is_joining_session}")
                        
                        if not self.is_joining_session:  # Success!
                            print(f"[SIMPLE_JOIN] Join conclu√≠do com sucesso em {time.time() - start_time:.2f}s!")
                            return
                        await asyncio.sleep(1)
                    
                    # Timeout
                    elapsed = time.time() - start_time
                    print(f"[SIMPLE_JOIN] Timeout ap√≥s {elapsed:.2f}s - join falhou")
                    self.is_joining_session = False
                    self.root.after(0, lambda: self.show_error_message("Timeout no join da sess√£o"))
                
                # CORRE√á√ÉO CR√çTICA: Usar nova conex√£o WebSocket dedicada para join
                # O problema √© que a conex√£o existente est√° "ocupada" com outras opera√ß√µes
                async def dedicated_join_connection():
                    join_client = None
                    connection_transferred = False  # Flag para controlar se a conex√£o foi transferida
                    try:
                        print(f"[DEDICATED_JOIN] Criando nova conex√£o dedicada para join...")
                        
                        # Criar cliente limpo para join
                        join_client = NetMasterClient()
                        join_client.is_joining_session = True
                        
                        # Registrar handler espec√≠fico para session_joined
                        session_joined_received = False
                        
                        def on_dedicated_session_joined(data):
                            nonlocal session_joined_received
                            print(f"[DEDICATED_JOIN] *** SESSION_JOINED RECEBIDO! ***")
                            print(f"[DEDICATED_JOIN] *** DADOS RECEBIDOS: {data} ***")
                            
                            # CR√çTICO: Definir player_id e session_id no join_client IMEDIATAMENTE
                            player_id = data.get('player_id')
                            session_data = data.get('session', {})
                            session_id = session_data.get('id')
                            player_info = data.get('player_info', {})
                            player_name = player_info.get('name')
                            
                            print(f"[DEDICATED_JOIN] *** EXTRAINDO IDs DA MENSAGEM ***")
                            print(f"[DEDICATED_JOIN] *** player_id: {player_id} ***")
                            print(f"[DEDICATED_JOIN] *** session_id: {session_id} ***")
                            print(f"[DEDICATED_JOIN] *** player_name: {player_name} ***")
                            
                            if player_id:
                                join_client.player_id = player_id
                                print(f"[DEDICATED_JOIN] *** join_client.player_id DEFINIDO: {join_client.player_id} ***")
                            else:
                                print(f"[DEDICATED_JOIN] *** ERROR: player_id √© None! ***")
                            
                            if session_id:
                                join_client.session_id = session_id
                                print(f"[DEDICATED_JOIN] *** join_client.session_id DEFINIDO: {join_client.session_id} ***")
                            else:
                                print(f"[DEDICATED_JOIN] *** ERROR: session_id √© None! ***")
                            
                            if player_name:
                                join_client.player_name = player_name
                                print(f"[DEDICATED_JOIN] *** join_client.player_name DEFINIDO: {join_client.player_name} ***")
                            
                            session_joined_received = True
                            # Atualizar flags principais
                            self.is_joining_session = False
                            netmaster_client.is_joining_session = False
                            # Processar com handler existente
                            self.root.after(0, lambda: self.on_session_joined(data))
                        
                        def on_dedicated_test_connectivity(data):
                            print(f"[DEDICATED_JOIN] *** TEST_CONNECTIVITY RECEBIDO! ***")
                        
                        def on_dedicated_game_started(data):
                            print(f"[DEDICATED_JOIN] *** GAME_STARTED RECEBIDO! ***")
                            # Processar com handler existente do sistema principal
                            self.root.after(0, lambda: self.on_game_started(data))
                        
                        # CORRE√á√ÉO: Usar set_message_handler (m√©todo correto da classe)
                        join_client.set_message_handler('session_joined', on_dedicated_session_joined)
                        join_client.set_message_handler('test_connectivity', on_dedicated_test_connectivity)
                        join_client.set_message_handler('game_started', on_dedicated_game_started)
                        
                        # Conectar
                        print(f"[DEDICATED_JOIN] Conectando...")
                        success = await join_client.connect()
                        if not success:
                            raise Exception("Falha na conex√£o dedicada")
                        
                        print(f"[DEDICATED_JOIN] Conex√£o estabelecida, aguardando welcome...")
                        await asyncio.sleep(0.5)  # Aguardar welcome
                        
                        # Enviar join
                        session_id = self.selected_session.get('id')
                        print(f"[DEDICATED_JOIN] Enviando join para sess√£o {session_id}")
                        success = await join_client.join_session(session_id, name, color.lower())
                        
                        if success:
                            print(f"[DEDICATED_JOIN] Join enviado, aguardando session_joined...")
                            
                            # Aguardar session_joined por at√© 10 segundos
                            for i in range(100):  # 100 * 0.1s = 10s
                                if session_joined_received:
                                    print(f"[DEDICATED_JOIN] *** SUCESSO! session_joined recebido em {i*0.1:.1f}s ***")
                                    break
                                await asyncio.sleep(0.1)
                            else:
                                print(f"[DEDICATED_JOIN] TIMEOUT - session_joined n√£o recebido em 10s")
                                self.root.after(0, lambda: self.show_error_message("Timeout na conex√£o √† sess√£o"))
                        else:
                            print(f"[DEDICATED_JOIN] Falha no envio do join")
                            self.root.after(0, lambda: self.show_error_message("Falha no envio do join"))
                        
                        # Manter conex√£o ativa para mensagens futuras
                        if session_joined_received:
                            print(f"[DEDICATED_JOIN] Join sucesso! Transferindo controle para cliente principal...")
                            
                            # CORRE√á√ÉO CR√çTICA: Transferir websocket e garantir heartbeat
                            old_websocket = netmaster_client.websocket
                            netmaster_client.websocket = join_client.websocket
                            netmaster_client.connected = True
                            
                            print(f"[DEDICATED_JOIN] WebSocket transferido com sucesso!")
                            
                            # CORRE√á√ÉO CR√çTICA: Iniciar tasks de reading/processing no main client
                            try:
                                loop = asyncio.get_event_loop()
                                
                                # Garantir que message listener est√° ativo
                                if not hasattr(netmaster_client, '_message_listener_task') or netmaster_client._message_listener_task.done():
                                    print(f"[DEDICATED_JOIN] Iniciando message listener no cliente principal...")
                                    netmaster_client._message_listener_task = loop.create_task(netmaster_client.listen_for_messages())
                                    print(f"[DEDICATED_JOIN] Message listener iniciado com sucesso!")
                                else:
                                    print(f"[DEDICATED_JOIN] Message listener j√° est√° ativo no cliente principal")
                                
                                # Garantir que heartbeat est√° ativo
                                if not hasattr(netmaster_client, '_heartbeat_task') or netmaster_client._heartbeat_task.done():
                                    print(f"[DEDICATED_JOIN] Reiniciando heartbeat no cliente principal...")
                                    netmaster_client._heartbeat_task = loop.create_task(netmaster_client.start_heartbeat_loop())
                                    print(f"[DEDICATED_JOIN] Heartbeat reiniciado com sucesso!")
                                else:
                                    print(f"[DEDICATED_JOIN] Heartbeat j√° est√° ativo no cliente principal")
                                    
                            except Exception as task_error:
                                print(f"[DEDICATED_JOIN] Erro ao iniciar tasks: {task_error}")
                            
                            # CR√çTICO: Registrar handlers imediatamente ap√≥s transfer para evitar perda de game_started
                            print(f"[DEDICATED_JOIN] *** REGISTRANDO HANDLERS CR√çTICOS IMEDIATAMENTE ***")
                            try:
                                # Configurar refer√™ncia do dashboard no cliente
                                netmaster_client._dashboard_ref = self
                                
                                # CR√çTICO: Transferir player_id do join_client para main client
                                if hasattr(join_client, 'player_id') and join_client.player_id:
                                    print(f"[DEDICATED_JOIN] *** ANTES TRANSFER - join_client.player_id: {join_client.player_id} ***")
                                    print(f"[DEDICATED_JOIN] *** ANTES TRANSFER - netmaster_client.player_id: {getattr(netmaster_client, 'player_id', 'NONE')} ***")
                                    netmaster_client.player_id = join_client.player_id
                                    print(f"[DEDICATED_JOIN] *** PLAYER_ID TRANSFERIDO: {netmaster_client.player_id} ***")
                                    print(f"[DEDICATED_JOIN] *** VERIFICATION - netmaster_client.player_id: {netmaster_client.player_id} ***")
                                else:
                                    print(f"[DEDICATED_JOIN] *** WARNING: join_client n√£o tem player_id v√°lido! ***")
                                    print(f"[DEDICATED_JOIN] *** join_client.player_id: {getattr(join_client, 'player_id', 'NONE')} ***")
                                
                                # CR√çTICO: Transferir session_id do join_client para main client
                                if hasattr(join_client, 'session_id') and join_client.session_id:
                                    print(f"[DEDICATED_JOIN] *** ANTES TRANSFER - join_client.session_id: {join_client.session_id} ***")
                                    print(f"[DEDICATED_JOIN] *** ANTES TRANSFER - netmaster_client.session_id: {getattr(netmaster_client, 'session_id', 'NONE')} ***")
                                    netmaster_client.session_id = join_client.session_id
                                    print(f"[DEDICATED_JOIN] *** SESSION_ID TRANSFERIDO: {netmaster_client.session_id} ***")
                                    print(f"[DEDICATED_JOIN] *** VERIFICATION - netmaster_client.session_id: {netmaster_client.session_id} ***")
                                else:
                                    print(f"[DEDICATED_JOIN] *** WARNING: join_client n√£o tem session_id v√°lido! ***")
                                    print(f"[DEDICATED_JOIN] *** join_client.session_id: {getattr(join_client, 'session_id', 'NONE')} ***")
                                
                                # CR√çTICO: Marcar que IDs foram transferidos para evitar sobrescrita
                                netmaster_client._ids_transferred_from_dedicated_join = True
                                print(f"[DEDICATED_JOIN] *** FLAG DE TRANSFER√äNCIA DEFINIDA ***")
                                
                                # CR√çTICO: Transferir player_name tamb√©m para debugging
                                if hasattr(join_client, 'player_name') and join_client.player_name:
                                    netmaster_client.player_name = join_client.player_name
                                    print(f"[DEDICATED_JOIN] *** PLAYER_NAME TRANSFERIDO: {netmaster_client.player_name} ***")
                                elif hasattr(self, 'join_player_name') and self.join_player_name:
                                    netmaster_client.player_name = self.join_player_name
                                    print(f"[DEDICATED_JOIN] *** PLAYER_NAME TRANSFERIDO DE join_player_name: {netmaster_client.player_name} ***")
                                else:
                                    print(f"[DEDICATED_JOIN] *** WARNING: Nenhum player_name dispon√≠vel para transferir ***")
                                
                                # Registrar handlers essenciais IMEDIATAMENTE
                                netmaster_client.set_message_handler('game_started', self.on_game_started)
                                netmaster_client.set_message_handler('ALL_MESSAGES_DEBUG', self.on_any_message_debug)
                                netmaster_client.set_message_handler('player_joined', self.on_player_joined)
                                netmaster_client.set_message_handler('player_left', self.on_player_left)
                                netmaster_client.set_message_handler('turn_changed', self.on_multiplayer_turn_changed)
                                
                                print(f"[DEDICATED_JOIN] *** HANDLERS CR√çTICOS REGISTRADOS COM SUCESSO! ***")
                                print(f"[DEDICATED_JOIN] Handlers ativos: {list(netmaster_client.message_handlers.keys())}")
                                
                                # Definir flags necess√°rias para handlers funcionarem
                                self.multiplayer_mode = True
                                self.in_waiting_room = True
                                
                                print(f"[DEDICATED_JOIN] *** FLAGS CONFIGURADAS: multiplayer_mode=True, in_waiting_room=True ***")
                                
                            except Exception as handler_error:
                                print(f"[DEDICATED_JOIN] Erro ao registrar handlers: {handler_error}")
                            
                            print(f"[DEDICATED_JOIN] Cliente principal agora usa conex√£o estabelecida pelo join dedicado")
                            
                            # Marcar que a conex√£o foi transferida
                            connection_transferred = True
                            
                            # Manter ativo - os tasks do cliente principal continuam rodando normalmente
                            while netmaster_client.connected and join_client.connected:
                                await asyncio.sleep(0.5)
                        
                    except Exception as error:
                        error_msg = str(error)
                        print(f"[DEDICATED_JOIN] Erro: {error_msg}")
                        self.root.after(0, lambda: self.show_error_message(f"Erro na conex√£o: {error_msg}"))
                    finally:
                        # S√≥ desconectar se a conex√£o N√ÉO foi transferida com sucesso
                        if not connection_transferred and join_client and join_client.connected:
                            try:
                                print(f"[DEDICATED_JOIN] Desconectando cliente dedicado (sem transfer√™ncia)...")
                                await join_client.disconnect()
                            except:
                                pass
                        elif connection_transferred:
                            print(f"[DEDICATED_JOIN] Conex√£o transferida com sucesso - mantendo ativa")
                
                # Executar em thread daemon
                def run_dedicated_join():
                    print(f"[DEDICATED_JOIN] *** THREAD DEDICATED JOIN INICIADA ***")
                    try:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        print(f"[DEDICATED_JOIN] *** LOOP CRIADO, EXECUTANDO dedicated_join_connection() ***")
                        loop.run_until_complete(dedicated_join_connection())
                        print(f"[DEDICATED_JOIN] *** dedicated_join_connection() COMPLETADO ***")
                    except Exception as error:
                        error_msg = str(error)
                        print(f"[DEDICATED_JOIN] Erro no loop: {error_msg}")
                    finally:
                        loop.close()
                        print(f"[DEDICATED_JOIN] *** THREAD DEDICATED JOIN FINALIZADA ***")
                
                print(f"[SIMPLE_JOIN] *** INICIANDO THREAD DEDICATED JOIN ***")
                threading.Thread(target=run_dedicated_join, daemon=True).start()
                print(f"[SIMPLE_JOIN] *** THREAD DEDICATED JOIN INICIADA - CONTINUANDO ***")
                    
            except Exception as e:
                print(f"[SIMPLE_JOIN] Erro: {e}")
                self.is_joining_session = False
                self.root.after(0, lambda: self.show_error_message(f"Erro no join: {e}"))
        
        threading.Thread(target=simple_join, daemon=True).start()

    def simple_sessions_update(self, data):
        """Handler SIMPLES para sessions_list_update COM DETEC√á√ÉO DE GAME_STARTED"""
        print(f"[SIMPLE_UPDATE] Recebida sessions_list_update")
        
        # *** CRITICAL FIX: DETECTAR GAME_STARTED VIA SESSIONS_LIST_UPDATE ***
        if (getattr(self, 'in_waiting_room', False) and 
            getattr(self, 'multiplayer_mode', False) and
            hasattr(self, '_current_session_id')):
            
            print(f"[GAME_STARTED_DETECTION] Verificando se nossa sess√£o foi iniciada...")
            print(f"[GAME_STARTED_DETECTION] Nossa sess√£o ID: {getattr(self, '_current_session_id', 'NONE')}")
            
            sessions = data.get('sessions', [])
            print(f"[GAME_STARTED_DETECTION] Sess√µes recebidas: {len(sessions)}")
            
            our_session_found = False
            for session in sessions:
                session_id = session.get('id')
                session_state = session.get('state', 'unknown')
                print(f"[GAME_STARTED_DETECTION] Sess√£o {session_id}: estado={session_state}")
                
                if session_id == self._current_session_id:
                    our_session_found = True
                    print(f"[GAME_STARTED_DETECTION] NOSSA SESS√ÉO ENCONTRADA: {session_id}, estado: {session_state}")
                    
                    if session_state == 'playing':
                        print(f"[GAME_STARTED_DETECTION] *** SESS√ÉO INICIADA! SIMULANDO GAME_STARTED ***")
                        
                        # Criar mensagem game_started sint√©tica
                        synthetic_game_started = {
                            'type': 'game_started',
                            'session': session,
                            'message': 'O jogo come√ßou! (detectado via sessions_list_update)'
                        }
                        
                        print(f"[GAME_STARTED_DETECTION] Executando on_game_started com dados sint√©ticos...")
                        self.root.after(0, lambda: self.on_game_started(synthetic_game_started))
                        return  # Importante: retornar aqui para n√£o processar o resto
            
            if not our_session_found:
                print(f"[GAME_STARTED_DETECTION] NOSSA SESS√ÉO N√ÉO ENCONTRADA - pode ter sido iniciada e removida da lista")
                # Se nossa sess√£o desapareceu da lista, provavelmente foi iniciada
                if len(sessions) == 0:
                    print(f"[GAME_STARTED_DETECTION] *** LISTA VAZIA - SESS√ÉO PROVAVELMENTE INICIADA ***")
                    
                    # Criar mensagem game_started sint√©tica b√°sica
                    synthetic_game_started = {
                        'type': 'game_started',
                        'session': {
                            'id': self._current_session_id,
                            'state': 'playing',
                            'current_player_id': getattr(self, '_host_player_id', None),
                            'current_turn_index': 0,
                            'player_order': [],
                            'players': {}
                        },
                        'message': 'O jogo come√ßou! (detectado via desaparecimento da sess√£o)'
                    }
                    
                    print(f"[GAME_STARTED_DETECTION] Executando on_game_started com dados sint√©ticos b√°sicos...")
                    self.root.after(0, lambda: self.on_game_started(synthetic_game_started))
                    return
        
        # Se estamos fazendo join, verificar se fomos adicionados
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            sessions = data.get('sessions', [])
            for session in sessions:
                if session['id'] == self.selected_session.get('id'):
                    players = session.get('players', {})
                    for player_id, player_info in players.items():
                        if player_info.get('name') == self.join_player_name:
                            print(f"[SIMPLE_UPDATE] Join detectado via sessions_list_update!")
                            self.is_joining_session = False
                            
                            # Salvar ID da sess√£o para detec√ß√£o de game_started
                            self._current_session_id = session['id']
                            print(f"[GAME_STARTED_DETECTION] Sess√£o ID salva: {self._current_session_id}")
                            
                            # Criar resposta sint√©tica
                            join_data = {
                                'type': 'session_joined',
                                'session': session,
                                'player_id': player_id,
                                'player_info': player_info
                            }
                            self.root.after(0, lambda: self.on_session_joined(join_data))
                            return
        
        # Atualizar lista normal
        self.sessions_data = data.get('sessions', [])
        if hasattr(self, 'current_page') and self.current_page == "multiplayer_menu":
            self.root.after(0, self.refresh_multiplayer_menu)

    def on_any_message_debug(self, data):
        """Handler debug para capturar todas as mensagens durante join"""
        msg_type = data.get('type', 'unknown')
        print(f"[ALL_MESSAGES_DEBUG] *** HANDLER UNIVERSAL CHAMADO! *** Tipo: {msg_type}")
        print(f"[ALL_MESSAGES_DEBUG] is_joining_session: {getattr(self, 'is_joining_session', False)}")
        print(f"[ALL_MESSAGES_DEBUG] in_waiting_room: {getattr(self, 'in_waiting_room', False)}")
        print(f"[ALL_MESSAGES_DEBUG] multiplayer_mode: {getattr(self, 'multiplayer_mode', False)}")
        print(f"[ALL_MESSAGES_DEBUG] Timestamp: {time.time()}")
        print(f"[ALL_MESSAGES_DEBUG] Data: {data}")
        
        # CRITICAL: Capturar mensagens game_started SEMPRE
        if msg_type == 'game_started':
            print(f"[GAME_STARTED_DEBUG] *** GAME_STARTED DETECTADO NO HANDLER UNIVERSAL! ***")
            print(f"[GAME_STARTED_DEBUG] *** TIMESTAMP: {time.time()} ***")
            print(f"[GAME_STARTED_DEBUG] *** PLAYER ID: {getattr(netmaster_client, 'player_id', 'UNDEFINED')} ***")
            print(f"[GAME_STARTED_DEBUG] *** SESSION ID: {getattr(netmaster_client, 'session_id', 'UNDEFINED')} ***")
            print(f"[GAME_STARTED_DEBUG] *** IN_WAITING_ROOM: {getattr(self, 'in_waiting_room', 'UNDEFINED')} ***")
            print(f"[GAME_STARTED_DEBUG] *** MULTIPLAYER_MODE: {getattr(self, 'multiplayer_mode', 'UNDEFINED')} ***")
            print(f"[GAME_STARTED_DEBUG] Dados do game_started: {data}")
            print(f"[GAME_STARTED_DEBUG] For√ßando execu√ß√£o do handler on_game_started...")
            # Chamar handler espec√≠fico tamb√©m pelo universal como backup
            if hasattr(self, 'on_game_started'):
                print(f"[GAME_STARTED_DEBUG] Chamando self.on_game_started diretamente...")
                self.on_game_started(data)
                print(f"[GAME_STARTED_DEBUG] *** on_game_started EXECUTADO COM SUCESSO! ***")
            else:
                print(f"[GAME_STARTED_DEBUG] ERROR: on_game_started n√£o existe!")
        
        # SUPER CRITICAL: Log de TODAS as mensagens depois do join
        if hasattr(self, 'in_waiting_room') and self.in_waiting_room:
            print(f"[ALL_MESSAGES_DEBUG] *** ESTAMOS NA WAITING ROOM - CAPTURANDO TODAS AS MENSAGENS ***")
            print(f"[ALL_MESSAGES_DEBUG] Tipo da mensagem: {msg_type}")
            print(f"[ALL_MESSAGES_DEBUG] Timestamp: {time.time()}")
            if msg_type not in ['sessions_list_update', 'heartbeat']:
                print(f"[ALL_MESSAGES_DEBUG] *** MENSAGEM IMPORTANTE RECEBIDA NA WAITING ROOM: {msg_type} ***")
        
        # CR√çTICO: Processar sessions_list SEMPRE, n√£o s√≥ durante join
        if msg_type in ['sessions_list', 'sessions_list_update']:
            print(f"[ALL_MESSAGES_DEBUG] *** PROCESSANDO {msg_type} NO HANDLER GLOBAL ***")
            self.handle_sessions_list_global(data)
        
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            print(f"[SEARCH] [JOIN_DEBUG] *** MENSAGEM RECEBIDA DURANTE JOIN: {msg_type} ***")
            print(f"[SEARCH] [JOIN_DEBUG] Data completa: {data}")
            
            # Verificar se √© uma mensagem de join de qualquer tipo
            if any(keyword in msg_type.lower() for keyword in ['join', 'session', 'player']):
                print(f"[SEARCH] [JOIN_DEBUG] *** POSS√çVEL MENSAGEM DE JOIN: {msg_type} ***")
                
                # Se cont√©m informa√ß√£o de sess√£o e player, pode ser um join
                if 'session' in data and ('player' in data or 'player_info' in data or 'players' in data):
                    print(f"[SEARCH] [JOIN_DEBUG] *** DETECTADA MENSAGEM COM SESS√ÉO E PLAYER - FOR√áANDO JOIN! ***")
                    print(f"[SEARCH] [JOIN_DEBUG] Chamando on_session_joined com esta mensagem...")
                    self.on_session_joined(data)
                elif msg_type == 'sessions_list_update':
                    print(f"[SEARCH] [JOIN_DEBUG] Recebida sessions_list_update - verificando se foi adicionado...")
                    # Verificar se o meu nome aparece na lista de jogadores
                    sessions = data.get('sessions', [])
                    for session in sessions:
                        players = session.get('players', {})
                        for player_id, player_data in players.items():
                            if player_data.get('name') == self.join_player_name:
                                print(f"[SEARCH] [JOIN_DEBUG] *** ENCONTRADO MEU NOME NA SESSIONS_LIST_UPDATE! ***")
                                print(f"[SEARCH] [JOIN_DEBUG] Player ID encontrado: {player_id}")
                                print(f"[SEARCH] [JOIN_DEBUG] Player data: {player_data}")
                                # Construir resposta de join sint√©tica
                                synthetic_join = {
                                    'type': 'session_joined',
                                    'session': session,
                                    'player_id': player_id,
                                    'player_info': player_data
                                }
                                print(f"[SEARCH] [JOIN_DEBUG] Criando join sint√©tico: {synthetic_join}")
                                self.on_session_joined(synthetic_join)
                                return
            
            # For√ßar verifica√ß√£o no handler espec√≠fico se for sessions_list_update
            if msg_type == 'sessions_list_update':
                print(f"[SEARCH] [JOIN_DEBUG] Repassando sessions_list_update para handler espec√≠fico...")
                self.on_global_sessions_list_update(data)
        else:
            print(f"[ALL_MESSAGES_DEBUG] N√£o estou em processo de join, ignorando mensagem {msg_type}")

    def handle_sessions_list_global(self, data):
        """Handler global SIMPLIFICADO para sessions_list"""
        print(f"[SESSIONS] *** RECEBIDA LISTA DE SESS√ïES ***")
        
        try:
            sessions_list = data.get('sessions', [])
            print(f"[SESSIONS] {len(sessions_list)} sess√µes dispon√≠veis")
            
            # Atualizar dados globais
            self.current_sessions = sessions_list
            self.sessions_data = sessions_list
            
            # Se estamos na p√°gina de sess√µes, atualizar interface
            if hasattr(self, 'sessions_frame_ref') and self.sessions_frame_ref:
                try:
                    if self.sessions_frame_ref.winfo_exists():
                        print(f"[SESSIONS] Atualizando display de sess√µes...")
                        self.update_sessions_display_simple(sessions_list)
                except:
                    pass
                    
        except Exception as e:
            print(f"[SESSIONS] Erro: {e}")
    
    def update_sessions_display_simple(self, sessions_list):
        """Atualiza display de sess√µes de forma SIMPLES"""
        def update_ui():
            try:
                if not self.sessions_frame_ref.winfo_exists():
                    return
                    
                # Limpar frame
                for widget in self.sessions_frame_ref.winfo_children():
                    widget.destroy()
                
                if not sessions_list:
                    tk.Label(self.sessions_frame_ref, text="No sessions available", 
                            font=("Helvetica", 14), bg="black", fg="#999999").pack(pady=20)
                else:
                    for session in sessions_list:
                        session_id = session.get('id', 'Unknown')
                        host_name = 'Unknown'
                        players = session.get('players', {})
                        for player_data in players.values():
                            host_name = player_data.get('name', 'Unknown')
                            break
                        
                        session_text = f"Session {session_id} - Host: {host_name}"
                        
                        session_btn = tk.Button(self.sessions_frame_ref, text=session_text,
                                              font=("Helvetica", 12), bg="#4CAF50", fg="white",
                                              command=lambda s=session: self.join_session_simple(s))
                        session_btn.pack(pady=5, padx=20, fill="x")
                        
            except Exception as e:
                print(f"[SESSIONS] Erro ao atualizar UI: {e}")
        
        # Executar na UI thread
        self.root.after(0, update_ui)
    
    def join_session_simple(self, session):
        """Join a session de forma SIMPLES"""
        print(f"[JOIN] Tentando entrar na sess√£o: {session.get('id')}")
        
        try:
            # Usar m√©todo existente de join
            if hasattr(self, 'join_selected_session'):
                self.join_selected_session(self.player_name, session)
            else:
                print(f"[JOIN] M√©todo join_selected_session n√£o encontrado")
        except Exception as e:
            print(f"[JOIN] Erro ao entrar na sess√£o: {e}")

    def on_session_joined(self, data):
        """Callback quando se junta √† sess√£o com sucesso"""
        print(f"[TARGET] [DEBUG] on_session_joined chamado com data: {data}")
        
        try:
            # Reset joining flag e parar anima√ß√£o
            print(f"[TARGET] [DEBUG] Antes: is_joining_session = {self.is_joining_session}")
            self.is_joining_session = False
            print(f"[TARGET] [DEBUG] Depois: is_joining_session = {self.is_joining_session}")
            
            self.joining_animation_active = False
            print(f"[TARGET] [DEBUG] joining_animation_active definido como False")
            
            def update_ui():
                try:
                    print(f"[TARGET] [DEBUG] Iniciando update_ui")
                    session_data = data.get('session', {})
                    player_info = data.get('player_info', {})
                    
                    # NOTA: N√ÉO sobrescrever IDs que foram transferidos do dedicated join client
                    flag_exists = hasattr(netmaster_client, '_ids_transferred_from_dedicated_join')
                    print(f"[SESSION_JOINED] *** VERIFICANDO FLAG _ids_transferred_from_dedicated_join: {flag_exists} ***")
                    print(f"[SESSION_JOINED] *** CURRENT netmaster_client.player_id: {getattr(netmaster_client, 'player_id', 'NONE')} ***")
                    print(f"[SESSION_JOINED] *** CURRENT netmaster_client.session_id: {getattr(netmaster_client, 'session_id', 'NONE')} ***")
                    print(f"[SESSION_JOINED] *** MESSAGE player_id: {data.get('player_id')} ***")
                    print(f"[SESSION_JOINED] *** MESSAGE session_id: {session_data.get('id')} ***")
                    
                    if not flag_exists:
                        print(f"[SESSION_JOINED] *** DEFININDO IDs A PARTIR DA MENSAGEM session_joined ***")
                        netmaster_client.session_id = session_data.get('id')
                        netmaster_client.player_id = data.get('player_id')
                        print(f"[SESSION_JOINED] Session ID definido: {netmaster_client.session_id}")
                        print(f"[SESSION_JOINED] Player ID definido: {netmaster_client.player_id}")
                    else:
                        print(f"[SESSION_JOINED] *** IDs J√Å TRANSFERIDOS DO DEDICATED JOIN - N√ÉO SOBRESCREVER ***")
                        print(f"[SESSION_JOINED] Session ID mantido: {netmaster_client.session_id}")
                        print(f"[SESSION_JOINED] Player ID mantido: {netmaster_client.player_id}")
                        print(f"[SESSION_JOINED] Session ID da mensagem (ignorado): {session_data.get('id')}")
                        print(f"[SESSION_JOINED] Player ID da mensagem (ignorado): {data.get('player_id')}")
                    
                    # *** EMERGENCY FIX: SEMPRE garantir que temos player_id v√°lido ***
                    message_player_id = data.get('player_id')
                    print(f"[SESSION_JOINED] *** EMERGENCY FIX DEBUG ***")
                    print(f"[SESSION_JOINED] *** message_player_id: {message_player_id} ***")
                    print(f"[SESSION_JOINED] *** netmaster_client.player_id: {getattr(netmaster_client, 'player_id', 'NONE')} ***")
                    print(f"[SESSION_JOINED] *** Condi√ß√£o 1 - message_player_id existe: {bool(message_player_id)} ***")
                    print(f"[SESSION_JOINED] *** Condi√ß√£o 2 - n√£o temos player_id: {not netmaster_client.player_id} ***")
                    print(f"[SESSION_JOINED] *** Condi√ß√£o 3 - player_id diferente: {netmaster_client.player_id != message_player_id if message_player_id else False} ***")
                    
                    if message_player_id:
                        print(f"[SESSION_JOINED] *** EMERGENCY FIX ATIVO: FOR√áANDO player_id correto ***")
                        print(f"[SESSION_JOINED] *** ANTES: {getattr(netmaster_client, 'player_id', 'NONE')} ***")
                        print(f"[SESSION_JOINED] *** FOR√áANDO PARA: {message_player_id} ***")
                        netmaster_client.player_id = message_player_id
                        print(f"[SESSION_JOINED] *** DEPOIS: {netmaster_client.player_id} ***")
                        print(f"[SESSION_JOINED] *** EMERGENCY FIX APLICADO COM SUCESSO ***")
                    else:
                        print(f"[SESSION_JOINED] *** ERROR: message_player_id √© None/vazio! ***")
                    
                    # Set player name for debugging
                    message_player_name = player_info.get('name')
                    if message_player_name:
                        netmaster_client.player_name = message_player_name
                        print(f"[SESSION_JOINED] *** PLAYER_NAME DEFINIDO: {netmaster_client.player_name} ***")
                    
                    # *** CRITICAL: Salvar ID da sess√£o para detec√ß√£o de game_started ***
                    self._current_session_id = session_data.get('id')
                    print(f"[GAME_STARTED_DETECTION] Session ID salva no join: {self._current_session_id}")
                    
                    # CRITICAL: Definir modo multiplayer para o joinee
                    self.multiplayer_mode = True
                    print(f"[MULTIPLAYER_FIX] *** MULTIPLAYER_MODE DEFINIDO COMO TRUE PARA JOINEE ***")
                    
                    # Armazenar informa√ß√µes do jogador no cliente
                    netmaster_client.player_color = player_info.get('color', getattr(self, 'selected_color', 'red'))
                    netmaster_client.player_name = player_info.get('name', getattr(self, 'join_player_name', 'Player'))
                    
                    print(f"[TARGET] Juntou-se √† sess√£o: {netmaster_client.session_id}")
                    print(f"[PLAYER] Player ID: {netmaster_client.player_id}")
                    print(f"[STYLE] Player Color: {netmaster_client.player_color}")
                    print(f"[NOTE] Player Name: {netmaster_client.player_name}")
                    print(f"[DATA] Session data: {session_data}")
                    print(f"[MULTIPLAYER_FIX] multiplayer_mode agora √©: {self.multiplayer_mode}")
                    
                    # Mostrar mensagem de sucesso primeiro, depois transi√ß√£o para waiting room
                    self.show_join_success_message(session_data)
                    print(f"[TARGET] [DEBUG] update_ui conclu√≠do com sucesso")
                except Exception as ui_error:
                    print(f"[TARGET] [ERROR] Erro em update_ui: {ui_error}")
                    import traceback
                    print(f"[TARGET] [ERROR] Traceback: {traceback.format_exc()}")
            
            print(f"[TARGET] [DEBUG] Agendando update_ui")
            self.root.after(0, update_ui)
            print(f"[TARGET] [DEBUG] on_session_joined conclu√≠do com sucesso")
            
        except Exception as handler_error:
            print(f"[TARGET] [ERROR] Erro em on_session_joined: {handler_error}")
            import traceback
            print(f"[TARGET] [ERROR] Traceback: {traceback.format_exc()}")
            # Mesmo com erro, marcar como n√£o joining para evitar timeout infinito
            self.is_joining_session = False
    
    def show_join_success_message(self, session_data):
        """Mostrar mensagem de sucesso ao juntar-se √† sess√£o"""
        print("[TARGET] [DEBUG] Mostrando mensagem de sucesso de join")
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", 
                    font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Frame principal centralizado
        main_frame = tk.Frame(self.root, bg="black")
        main_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Mensagem de sucesso
        # Obter nome do host
        host_player_id = session_data.get('host_player_id')
        host_name = "Host"  # fallback
        if host_player_id and host_player_id in session_data.get('players', {}):
            host_name = session_data['players'][host_player_id].get('name', 'Host')
        
        success_text = tk.Label(main_frame, text=f"Joined {host_name}'s session \nsuccessfully!", 
                               font=("Helvetica", 18, "bold"), bg="black", fg="#4CAF50")
        success_text.pack(pady=20)
        
        # Aguardar 2 segundos e depois mostrar waiting room
        self.root.after(2000, lambda: self.show_session_waiting_room(session_data))
    
    def start_waiting_room_timeout_checker(self):
        """Inicia verifica√ß√£o peri√≥dica na waiting room para capturar mensagens perdidas"""
        print(f"[TIMEOUT_CHECKER] *** INICIANDO TIMEOUT CHECKER ***")
        self.waiting_room_timeout_active = True
        self.check_waiting_room_timeout()
    
    def check_waiting_room_timeout(self):
        """Verifica se h√° timeout na waiting room e for√ßa verifica√ß√£o de estado"""
        if not hasattr(self, 'waiting_room_timeout_active') or not self.waiting_room_timeout_active:
            print(f"[TIMEOUT_CHECKER] Timeout checker desativado, parando")
            return
            
        if hasattr(self, 'in_waiting_room') and self.in_waiting_room:
            print(f"[TIMEOUT_CHECKER] *** AINDA NA WAITING ROOM - VERIFICA√á√ÉO ATIVA ***")
            print(f"[TIMEOUT_CHECKER] Timestamp: {time.time()}")
            print(f"[TIMEOUT_CHECKER] is_session_host: {getattr(self, 'is_session_host', False)}")
            print(f"[TIMEOUT_CHECKER] multiplayer_mode: {getattr(self, 'multiplayer_mode', False)}")
            print(f"[TIMEOUT_CHECKER] countdown_active: {getattr(self, 'countdown_active', False)}")
            
            # CRITICAL: Verificar se h√° handlers registrados
            print(f"[TIMEOUT_CHECKER] Handlers registrados:")
            if hasattr(netmaster_client, 'message_handlers'):
                for handler_name in netmaster_client.message_handlers:
                    print(f"[TIMEOUT_CHECKER]   - {handler_name}")
            
            # Solicitar atualiza√ß√£o de sess√µes como backup
            if hasattr(self, 'client_socket') and self.client_socket:
                try:
                    print(f"[TIMEOUT_CHECKER] Solicitando atualiza√ß√£o de sess√µes...")
                    self.client_socket.emit('get_sessions_list')
                except Exception as e:
                    print(f"[TIMEOUT_CHECKER] Erro ao solicitar sess√µes: {e}")
            
            # Reagendar para pr√≥xima verifica√ß√£o (a cada 3 segundos)
            self.root.after(3000, self.check_waiting_room_timeout)
        else:
            print(f"[TIMEOUT_CHECKER] N√£o na waiting room, parando verifica√ß√µes")
            self.waiting_room_timeout_active = False

    def on_join_error(self, data):
        """Callback para erro ao juntar-se √† sess√£o"""
        # Reset joining flag e parar anima√ß√£o
        self.is_joining_session = False
        self.joining_animation_active = False
        self.join_error_occurred = True  # Flag espec√≠fica para indicar erro
        
        error_msg = data.get('message', 'Erro ao juntar-se √† sess√£o')
        print(f"[ERROR] Erro join session: {error_msg}")
        self.root.after(0, lambda: self.show_error_message(error_msg))

    def show_error_message(self, message):
        """Mostrar mensagem de erro"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Mensagem de erro
        error_frame = tk.Frame(self.root, bg="black")
        error_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        tk.Label(error_frame, text="Connection Error", font=("Helvetica", 20, "bold"), 
                bg="black", fg="#f44336").pack(pady=10)
        
        # Melhorar mensagem dependendo do tipo de erro
        if "n√£o encontrada" in message.lower():
            display_msg = "Session not found!\n\nThe session may have been closed or expired.\nPlease try joining a different session."
        else:
            display_msg = message
            
        tk.Label(error_frame, text=display_msg, font=("Helvetica", 14), 
                bg="black", fg="white", wraplength=400, justify="center").pack(pady=10)
        
        # Bot√£o voltar
        tk.Button(error_frame, text="Back to Main Menu", font=("Helvetica", 12),
                 bg="#6F0DB6", fg="white", command=self.show_main_menu).pack(pady=20)

    def show_connection_loading(self, name, game_type):
        """Mostrar tela de loading enquanto conecta ao servidor"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Loading frame
        loading_frame = tk.Frame(self.root, bg="black")
        loading_frame.place(relx=0.5, rely=0.5, anchor="center")

        self.connection_status_label = tk.Label(loading_frame, text="Connecting to NetMaster server...", 
                                               font=("Helvetica", 16), bg="black", fg="white")
        self.connection_status_label.pack(pady=20)
        
        # Barra de progresso simples
        self.progress_bars_connection = []
        progress_frame = tk.Frame(loading_frame, bg="black")
        progress_frame.pack(pady=10)
        
        for i in range(8):
            bar = tk.Label(progress_frame, text="‚ñ°", font=("Helvetica", 14), bg="black", fg="gray")
            bar.pack(side=tk.LEFT, padx=2)
            self.progress_bars_connection.append(bar)
        
        # Bot√£o cancelar
        cancel_btn = tk.Button(loading_frame, text="Cancelar", 
                              font=("Helvetica", 12), bg="#f44336", fg="white",
                              command=lambda: self.cancel_connection(name))
        cancel_btn.pack(pady=20)
        
        # Iniciar anima√ß√£o de loading
        self.loading_animation_active = True
        self.animate_connection_loading()
        
        # Configurar callbacks do cliente
        netmaster_client.set_connection_status_callback(self.on_connection_status_change)
        netmaster_client.set_message_handler('welcome', self.on_server_welcome)
        netmaster_client.set_message_handler('session_created', self.on_session_created)
        netmaster_client.set_message_handler('session_joined', self.on_session_joined)
        netmaster_client.set_message_handler('join_error', self.on_join_error)
        netmaster_client.set_message_handler('waiting_timeout', self.on_waiting_timeout)
        netmaster_client.set_message_handler('game_finished', self.on_menu_game_finished)
        netmaster_client.set_message_handler('error', self.on_server_error)
        
        # Handlers para sess√µes (globais)
        netmaster_client.set_message_handler('sessions_list', self.on_global_sessions_list)
        netmaster_client.set_message_handler('sessions_list_update', self.on_global_sessions_list_update)
        # Varia√ß√µes poss√≠veis que o servidor pode enviar
        netmaster_client.set_message_handler('session_list', self.on_global_sessions_list)
        netmaster_client.set_message_handler('session_list_update', self.on_global_sessions_list_update)
        
        # Iniciar conex√£o em thread separada
        threading.Thread(target=self.connect_to_server, args=(name, game_type), daemon=True).start()
    
    def animate_connection_loading(self):
        """Anima a barra de loading"""
        if not getattr(self, 'loading_animation_active', False):
            return
            
        # Verificar se ainda temos as barras necess√°rias
        if not hasattr(self, 'progress_bars_connection') or not self.progress_bars_connection:
            return
            
        for i, bar in enumerate(self.progress_bars_connection):
            # S√≥ executar se a anima√ß√£o ainda est√° ativa
            if not getattr(self, 'loading_animation_active', False):
                return
                
            delay = i * 100
            self.root.after(delay, lambda b=bar: self._safe_configure_bar(b, "#4CAF50", "‚ñ†") if getattr(self, 'loading_animation_active', False) else None)
            self.root.after(delay + 800, lambda b=bar: self._safe_configure_bar(b, "gray", "‚ñ°") if getattr(self, 'loading_animation_active', False) else None)
        
        # Repetir anima√ß√£o apenas se ainda est√° ativa
        if getattr(self, 'loading_animation_active', False):
            self.root.after(1000, self.animate_connection_loading)
    
    def _safe_configure_bar(self, bar, fg_color, text):
        """Configura uma barra de progresso de forma segura, verificando se ainda existe"""
        try:
            if bar.winfo_exists():
                bar.configure(fg=fg_color, text=text)
        except (tk.TclError, AttributeError):
            # Widget foi destru√≠do, ignorar
            pass
    
    def connect_to_server(self, name, game_type):
        """Conecta ao servidor em thread separada"""
        try:
            # Verificar se websockets est√° dispon√≠vel
            if websockets is None:
                error_msg = "Websockets n√£o dispon√≠vel. \nFuncionalidade multiplayer desabilitada."
                print(f"[ERROR] {error_msg}")
                if hasattr(self, 'connection_status_label'):
                    self.root.after(0, lambda: self.connection_status_label.configure(
                        text=error_msg, fg="red"))
                return
            
            # Executar conex√£o ass√≠ncrona e manter o loop ativo
            
            # Executar conex√£o ass√≠ncrona corretamente
            def run_connection():
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    
                    async def connect_and_maintain():
                        success = await netmaster_client.connect()
                        if success:
                            print("‚úì Conectado ao servidor NetMaster")
                            # CR√çTICO: Aguardar welcome message primeiro
                            await asyncio.sleep(0.5)
                            
                            # Manter o loop ativo para receber mensagens
                            try:
                                while netmaster_client.connected:
                                    await asyncio.sleep(0.1)  # Verifica√ß√£o mais frequente
                            except Exception as e:
                                print(f"[ERROR] Erro na manuten√ß√£o da conex√£o: {e}")
                        else:
                            print("[ERROR] Falha na conex√£o")
                    
                    # CORRE√á√ÉO CR√çTICA: Executar sem fechar o loop
                    loop.run_until_complete(connect_and_maintain())
                    # REMOVIDO: loop.close() - deixar loop ativo para receber mensagens
                except Exception as e:
                    print(f"[ERROR] Erro no loop de conex√£o: {e}")
            
            # Executar em thread daemon para n√£o bloquear UI
            threading.Thread(target=run_connection, daemon=True).start()
                
        except Exception as e:
            print(f"[ERROR] Erro na conex√£o: {e}")
            if hasattr(self, 'connection_status_label'):
                self.root.after(0, lambda: self.connection_status_label.configure(
                    text=f"Erro de conex√£o: {str(e)}", fg="red"))
    
    def on_connection_status_change(self, connected, message):
        """Callback para mudan√ßas no status de conex√£o"""
        def update_ui():
            if hasattr(self, 'connection_status_label'):
                color = "#4CAF50" if connected else "#f44336"
                self.connection_status_label.configure(text=message, fg=color)
                
                if connected:
                    # Conectado com sucesso
                    if hasattr(self, 'host_color') and self.host_color:
                        # Se j√° temos cor selecionada no Create Game flow, mostrar sele√ß√£o de dura√ß√£o
                        self.connection_status_label.configure(text="Connected! \nSelecting game duration...", fg="#4CAF50")
                        self.root.after(1000, lambda: self.show_duration_selection_page())
                    else:
                        # Caso contr√°rio, mostrar sele√ß√£o de cor (Search Game flow)
                        self.root.after(1000, lambda: self.show_server_connected_page())
        
        self.root.after(0, update_ui)
    
    def on_server_welcome(self, data):
        """Callback quando servidor envia boas-vindas"""
        print(f"Servidor: {data}")
    
    def on_session_created(self, data):
        """Callback quando sess√£o √© criada com sucesso"""
        def update_ui():
            session_data = data.get('session', {})
            # NOTA: Para cria√ß√£o de sess√£o (host), sempre definir IDs normalmente
            netmaster_client.session_id = session_data.get('id')
            netmaster_client.player_id = data.get('player_id')
            print(f"[SESSION_CREATED] Session ID definido (Host): {netmaster_client.session_id}")
            print(f"[SESSION_CREATED] Player ID definido (Host): {netmaster_client.player_id}")
            
            # *** CRITICAL FIX: DEFINIR MULTIPLAYER_MODE PARA HOST ***
            self.multiplayer_mode = True
            print(f"[SESSION_CREATED] *** MULTIPLAYER_MODE DEFINIDO COMO TRUE PARA HOST ***")
            print(f"[SESSION_CREATED] *** VERIFICA√á√ÉO: self.multiplayer_mode = {self.multiplayer_mode} ***")
            print(f"[SESSION_CREATED] *** VERIFICA√á√ÉO: hasattr = {hasattr(self, 'multiplayer_mode')} ***")
            
            print(f"[TARGET] Sess√£o criada: {netmaster_client.session_id}")
            print(f"[PLAYER] Player ID: {netmaster_client.player_id}")
            print(f"[DATA] Session data: {session_data}")
            
            # Configurar handlers b√°sicos para atualiza√ß√µes de sess√£o
            print(f"[CONFIG] [DEBUG] Configurando handlers b√°sicos para host...")
            netmaster_client.set_message_handler('player_joined', self.on_player_joined)
            netmaster_client.set_message_handler('player_left', self.on_player_left)
            # NOTA: Handler game_started ser√° registrado na waiting room para consist√™ncia
            netmaster_client.set_message_handler('turn_changed', self.on_multiplayer_turn_changed)
            print(f"[CONFIG] [DEBUG] Handlers b√°sicos configurados!")
            
            self.show_session_waiting_room(session_data)
        
        self.root.after(0, update_ui)
    
    def on_server_error(self, data):
        """Callback para erros do servidor"""
        error_msg = data.get('message', 'Erro desconhecido')
        
        def update_ui():
            if hasattr(self, 'connection_status_label'):
                self.connection_status_label.configure(text=f"Erro: {error_msg}", fg="red")
        
        self.root.after(0, update_ui)
    
    def on_global_sessions_list(self, data):
        """Handler global para sessions_list"""
        print(f"[NETWORK] [DEBUG] on_global_sessions_list chamado com data: {data}")
        sessions_list = data.get('sessions', [])
        print(f"[NETWORK] [DEBUG] sessions_list global: {len(sessions_list)} sess√µes")
        # Armazenar para uso posterior se necess√°rio
        if hasattr(self, 'current_sessions'):
            self.current_sessions = sessions_list
        # Tamb√©m armazenar em sessions_data para fetch_sessions
        self.sessions_data = sessions_list
        print(f"[NETWORK] [DEBUG] sessions_data atualizado: {len(self.sessions_data)} sess√µes")
    
    def on_global_sessions_list_update(self, data):
        """Handler global para sessions_list_update"""
        print(f"[NETWORK] [DEBUG] *** GLOBAL_SESSIONS_LIST_UPDATE DETALHADO ***")
        print(f"[NETWORK] [DEBUG] Data completa recebida: {data}")
        print(f"[NETWORK] [DEBUG] Tipo de data: {type(data)}")
        print(f"[NETWORK] [DEBUG] Keys em data: {list(data.keys()) if isinstance(data, dict) else 'N/A'}")
        
        # *** CRITICAL FIX: VERIFICAR SE ESTAMOS EM MULTIPLAYER_MODE ***
        if hasattr(self, 'multiplayer_mode') and self.multiplayer_mode:
            print(f"[MULTIPLAYER_PREVENTION] *** MULTIPLAYER_MODE ATIVO - IGNORANDO SESSIONS_LIST_UPDATE ***")
            print(f"[MULTIPLAYER_PREVENTION] Este update n√£o deve afetar o jogo em andamento")
            print(f"[MULTIPLAYER_PREVENTION] Sessions list vazia √© normal ap√≥s game_started")
            return
        
        # ADICIONAR: Timestamp para confirmar quando √© recebido
        import time
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        print(f"[BROADCAST] [SUCCESS] *** RECEBIDO √†s {timestamp} ***")
        
        # NOVA FUNCIONALIDADE: Registar tempo do √∫ltimo broadcast para fallback
        self.last_broadcast_time = time.time()
        self.broadcast_missed_count = 0
        print(f"[BROADCAST] [SUCCESS] Broadcast timestamp atualizado - fallback resetado")
        
        sessions_list = data.get('sessions', [])
        print(f"[NETWORK] [DEBUG] sessions_list_update global: {len(sessions_list)} sess√µes")
        
        if sessions_list:
            for i, session in enumerate(sessions_list):
                print(f"[NETWORK] [DEBUG] Sess√£o global {i+1}: ID={session.get('id')}, Host={session.get('host_player_id')}, Players={session.get('current_players')}")
        else:
            print(f"[NETWORK] [DEBUG] PROBLEMA GLOBAL: Lista de sess√µes est√° vazia")
        
        # CR√çTICO: Verificar se estamos em processo de join
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            print(f"[TARGET] [DEBUG] *** ESTAMOS JUNTANDO √Ä SESS√ÉO - VERIFICAR SE FOI BEM-SUCEDIDO ***")
            print(f"[TARGET] [DEBUG] join_player_name: {getattr(self, 'join_player_name', 'UNDEFINED')}")
            
            if hasattr(self, 'join_player_name') and self.join_player_name:
                player_name = self.join_player_name
                print(f"[TARGET] [DEBUG] Procurando jogador '{player_name}' em {len(sessions_list)} sess√µes...")
                
                # Procurar em TODAS as sess√µes por nosso jogador
                for session in sessions_list:
                    session_id = session.get('id', 'UNKNOWN')
                    players = session.get('players', {})
                    print(f"[TARGET] [DEBUG] Sess√£o {session_id}: {len(players)} jogadores")
                    
                    # Verificar se nosso jogador est√° na lista de players
                    for player_id, player_data in players.items():
                        player_data_name = player_data.get('name', 'UNKNOWN')
                        print(f"[TARGET] [DEBUG]   Player: {player_data_name} (ID: {player_id})")
                        
                        if player_data_name == player_name:
                            print(f"[TARGET] [DEBUG] *** SUCESSO! ENCONTRADO PLAYER {player_name} NA SESS√ÉO {session_id} ***")
                            print(f"[TARGET] [DEBUG] Player ID: {player_id}")
                            print(f"[TARGET] [DEBUG] Player data: {player_data}")
                            
                            # Limpar flag de join
                            self.is_joining_session = False
                            
                            # Construir resposta de join sint√©tica
                            join_data = {
                                'type': 'session_joined',
                                'session': session,
                                'player_id': player_id,
                                'player_info': player_data
                            }
                            print(f"[TARGET] [DEBUG] Criando join sint√©tico: {join_data}")
                            
                            # For√ßar chamada IMEDIATA
                            self.on_session_joined(join_data)
                            return
                
                print(f"[TARGET] [DEBUG] Player '{player_name}' N√ÉO encontrado em nenhuma sess√£o!")
        
        # CR√çTICO: Verificar se estamos na waiting room e evitar recri√°-la desnecessariamente  
        print(f"[WAITING_ROOM] [PREVENTION_CHECK] Verificando se devemos prevenir recria√ß√£o...")
        print(f"[WAITING_ROOM] [PREVENTION_CHECK] hasattr(self, 'in_waiting_room'): {hasattr(self, 'in_waiting_room')}")
        print(f"[WAITING_ROOM] [PREVENTION_CHECK] self.in_waiting_room: {getattr(self, 'in_waiting_room', 'UNDEFINED')}")
        
        if (hasattr(self, 'in_waiting_room') and self.in_waiting_room):
            print(f"[WAITING_ROOM] [UPDATE] PREVEN√á√ÉO ATIVA - estamos na waiting room")
            print(f"[WAITING_ROOM] [UPDATE] waiting_time_label exists: {hasattr(self, 'waiting_time_label')}")
            print(f"[WAITING_ROOM] [UPDATE] waiting_time_label is not None: {getattr(self, 'waiting_time_label', None) is not None}")
            
            # Verificar se temos o label da waiting room
            if (hasattr(self, 'waiting_time_label') and self.waiting_time_label and 
                hasattr(self.waiting_time_label, 'winfo_exists')):
                try:
                    if self.waiting_time_label.winfo_exists():
                        print(f"[WAITING_ROOM] [UPDATE] waiting_time_label existe - EVITANDO recria√ß√£o da interface")
                        # Apenas atualizar dados de sess√£o se necess√°rio, mas n√£o recriar interface
                        for session in sessions_list:
                            if (hasattr(netmaster_client, 'session_id') and 
                                session.get('id') == netmaster_client.session_id):
                                # Atualizar tempo de espera se mudou significativamente
                                new_waiting_time = session.get('waiting_time_left', 0)
                                if (hasattr(self, '_last_waiting_time') and 
                                    abs(new_waiting_time - getattr(self, '_last_waiting_time', 0)) > 5):
                                    print(f"[WAITING_ROOM] [UPDATE] Tempo mudou de {getattr(self, '_last_waiting_time', 0)} para {new_waiting_time}")
                                    self._last_waiting_time = new_waiting_time
                                    # CORRE√á√ÉO: Usar sincroniza√ß√£o em vez de stop/restart para evitar altern√¢ncia
                                    if hasattr(self, 'waiting_time_label') and self.waiting_time_label:
                                        try:
                                            if self.waiting_time_label.winfo_exists():
                                                # Sincronizar countdown imediatamente
                                                minutes = new_waiting_time // 60
                                                seconds = new_waiting_time % 60
                                                if minutes > 0:
                                                    time_text = f"Time left: {minutes}m {seconds}s"
                                                else:
                                                    time_text = f"Time left: {seconds}s"
                                                
                                                self.waiting_time_label.configure(text=time_text, fg="#4CAF50")
                                                
                                                # Incrementar countdown ID para invalidar timers antigos
                                                self._current_countdown_id = getattr(self, '_current_countdown_id', 0) + 1
                                                print(f"[WAITING_ROOM] [SYNC] Sincronizando para countdown ID {self._current_countdown_id}")
                                                
                                                # Iniciar novo countdown sincronizado sem delay
                                                self.update_waiting_countdown(new_waiting_time)
                                        except tk.TclError:
                                            print(f"[WAITING_ROOM] [SYNC] Label inv√°lido, ignorando sincroniza√ß√£o")
                        print(f"[WAITING_ROOM] [UPDATE] Interface preservada - retornando sem recria√ß√£o")
                        return
                    else:
                        print(f"[WAITING_ROOM] [UPDATE] waiting_time_label existe mas foi destru√≠do - prosseguindo")
                except tk.TclError:
                    print(f"[WAITING_ROOM] [UPDATE] waiting_time_label inv√°lido - prosseguindo")
            else:
                print(f"[WAITING_ROOM] [UPDATE] waiting_time_label n√£o existe - prosseguindo")
        else:
            print(f"[WAITING_ROOM] [PREVENTION_CHECK] N√ÉO estamos na waiting room - prosseguindo normalmente")
        
        # Verificar se estamos tentando juntar a uma sess√£o e se fomos adicionados (fallback antigo)
        if hasattr(self, 'selected_session') and self.selected_session and hasattr(self, 'join_player_name'):
            session_id = self.selected_session.get('id')
            player_name = self.join_player_name  # Nome do jogador que est√° tentando se juntar
            
            print(f"[TARGET] [DEBUG] Verificando se jogador {player_name} foi adicionado √† sess√£o {session_id}")
            
            # Procurar a sess√£o onde tentamos nos juntar
            for session in sessions_list:
                if session.get('id') == session_id:
                    players = session.get('players', {})
                    print(f"[TARGET] [DEBUG] Players na sess√£o: {list(players.values())}")
                    # Verificar se nosso jogador est√° na lista de players
                    for player_id, player_data in players.items():
                        if player_data.get('name') == player_name:
                            print(f"[TARGET] [DEBUG] DETECTADO JOIN BEM-SUCEDIDO! Player {player_name} encontrado na sess√£o {session_id}")
                            # Simular session_joined
                            join_data = {
                                'type': 'session_joined',
                                'session': session,
                                'player_id': player_id,
                                'player_info': player_data
                            }
                            # For√ßar chamada imediata
                            self.root.after(100, lambda: self.on_session_joined(join_data))
                            return
        
        # Se estamos em processo de join mas n√£o encontramos o player, for√ßar timeout
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            print(f"[TARGET] [DEBUG] Join em progresso mas player n√£o encontrado nas sess√µes - verificando novamente...")
            # Dar mais tempo para a mensagem session_joined chegar
            self.root.after(2000, self.check_join_timeout)
        
        # Armazenar para uso posterior se necess√°rio
        if hasattr(self, 'current_sessions'):
            self.current_sessions = sessions_list
        # Tamb√©m armazenar em sessions_data para fetch_sessions
        self.sessions_data = sessions_list
        print(f"[NETWORK] [DEBUG] sessions_data atualizado: {len(self.sessions_data)} sess√µes")
        
        # CRUCIAL: Auto-atualizar a lista se estamos em modo de refresh/lista
        if hasattr(self, 'is_refreshing') and self.is_refreshing:
            print(f"[NETWORK] [DEBUG] *** AUTO-REFRESH DETECTADO - ATUALIZANDO DISPLAY ***")
            if hasattr(self, 'sessions_frame_ref') and self.sessions_frame_ref and self.sessions_frame_ref.winfo_exists():
                # Atualizar display imediatamente com as novas sess√µes
                self.refresh_display_with_sessions(sessions_list)
                self.is_refreshing = False
            else:
                print(f"[NETWORK] [DEBUG] Frame de sess√µes n√£o existe para auto-refresh")
        
        # *** NOVA FUNCIONALIDADE: SEMPRE ATUALIZAR SE ESTAMOS NA P√ÅGINA DE SESS√ïES ***
        # Verificar se estamos na p√°gina de lista de sess√µes e auto-refresh est√° ativo
        elif (hasattr(self, 'auto_refresh_active') and self.auto_refresh_active and 
              hasattr(self, 'sessions_frame_ref') and self.sessions_frame_ref and 
              self.sessions_frame_ref.winfo_exists()):
            print(f"[NETWORK] [DEBUG] *** AUTO-UPDATE ATIVO - ATUALIZANDO LISTA AUTOMATICAMENTE ***")
            # S√≥ atualizar se n√£o estamos em processo de join para evitar conflitos
            if not (hasattr(self, 'is_joining_session') and self.is_joining_session):
                print(f"[NETWORK] [DEBUG] Atualizando lista com {len(sessions_list)} sess√µes...")
                self.refresh_display_with_sessions(sessions_list)
            else:
                print(f"[NETWORK] [DEBUG] Join em progresso, pulando auto-update")
    
    def check_join_timeout(self):
        """Verificar se join timeout deve ser ativado"""
        if hasattr(self, 'is_joining_session') and self.is_joining_session:
            print(f"[TARGET] [DEBUG] Join timeout check - ainda esperando resposta")
            # Ainda n√£o recebemos confirma√ß√£o, for√ßar fallback
            if hasattr(self, 'selected_session') and hasattr(self, 'join_player_name'):
                print(f"[TARGET] [DEBUG] For√ßando fallback para mostrar join success...")
                # Criar session_data b√°sico para fallback
                fallback_session_data = {
                    'id': getattr(self, 'selected_session', 'unknown'),
                    'players': {},
                    'state': 'waiting',
                    'current_players': 1,
                    'max_players': 4
                }
                self.show_join_success_message(fallback_session_data)
    
    def on_waiting_timeout(self, data):
        """Callback para timeout de espera"""
        timeout_msg = data.get('message', 'Tempo limite de espera atingido')
        allow_solo = data.get('allow_solo', False)
        
        print(f"[TIMEOUT] TIMEOUT recebido!")
        print(f"[MESSAGE] Dados do timeout: {data}")
        print(f"Allow solo: {allow_solo}")
        
        # Parar todas as anima√ß√µes ativas imediatamente
        self.loading_animation_active = False
        self.countdown_active = False  # Parar countdown
        
        def update_ui():
            print("[STYLE] Atualizando UI para Time Limit Reached...")
            
            # Garantir que as imagens est√£o carregadas
            if not hasattr(self, 'network_pattern_img') or not hasattr(self, 'netmaster_img'):
                print("[RELOAD] Recarregando imagens...")
                self.load_menu_images()
            
            # Limpar a tela
            for widget in self.root.winfo_children():
                widget.destroy()
            
            self.root.configure(bg="black")
            
            # Frame principal primeiro - CORRE√á√ÉO: Criar primeiro para n√£o cobrir os patterns
            main_frame = tk.Frame(self.root, bg="black")
            main_frame.pack(expand=True, fill='both')
            
            # Adicionar padr√µes de rede DEPOIS do main_frame para ficarem por cima
            print(f"[NETWORK] Adicionando network patterns - use_network_pattern: {getattr(self, 'use_network_pattern', False)}")
            print(f"[IMAGE] network_pattern_img exists: {hasattr(self, 'network_pattern_img') and self.network_pattern_img is not None}")
            
            self.add_network_pattern_decorations(self.root)
            
            # Logo NetMaster - implementa√ß√£o id√™ntica √† p√°gina principal
            if getattr(self, 'use_netmaster_img', False) and hasattr(self, 'netmaster_img') and self.netmaster_img:
                print("[TARGET] Usando logo NetMaster")
                tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
            else:
                print("[NOTE] Usando texto NetMaster")
                tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
            
            # T√≠tulo - movido mais para baixo para n√£o colidir com o logo
            title_label = tk.Label(main_frame, text="Time Limit Reached", 
                                 font=("Helvetica", 24, "bold"), bg="black", fg="#ff6b6b")
            title_label.pack(pady=(120, 30))
            
            # Informa√ß√£o adicional baseada no allow_solo
            if allow_solo:
                # Adicionar bot√£o para continuar direto ao jogo
                continue_game_btn = tk.Button(main_frame, text="Play Solo Game", 
                                            font=("Helvetica", 16, "bold"), bg="#2196F3", fg="white",
                                            command=self.start_multiplayer_solo_game, width=20, height=2)
                continue_game_btn.pack(pady=30)
            
            # Frame para bot√µes - movido mais para baixo
            buttons_frame = tk.Frame(main_frame, bg="black")
            buttons_frame.pack(pady=50)
            
            # Bot√£o voltar ao menu
            back_btn = tk.Button(buttons_frame, text="Back to Main Menu", 
                               font=("Helvetica", 14, "bold"), bg="#4CAF50", fg="white",
                               command=self.show_main_menu, width=15, height=2)
            back_btn.pack(pady=5)
            
            print("‚úì UI Time Limit Reached atualizada com sucesso!")
        
        # CORRE√á√ÉO: Executar imediatamente sem delay para resposta mais r√°pida
        self.root.after(0, update_ui)
    
    def on_multiplayer_turn_changed(self, data):
        """Handler para mudan√ßas de turno no menu system"""
        print("[RELOAD] [MENU_TURN_CHANGED] Mudan√ßa de turno recebida no menu system!")
        
        current_player_id = data.get('current_player_id')
        current_player_name = data.get('current_player_name', 'Unknown')
        current_player_color = data.get('current_player_color', 'unknown')
        player_order = data.get('player_order', [])
        current_turn_index = data.get('current_turn_index', 0)
        
        print(f"[TARGET] [MENU_TURN_CHANGED] Jogador atual: {current_player_name} ({current_player_color})")
        print(f"[NOTE] [MENU_TURN_CHANGED] Ordem dos jogadores: {player_order}")
        print(f"[NUMBER] [MENU_TURN_CHANGED] √çndice do turno: {current_turn_index}")
        
        # Verificar se √© a vez deste jogador
        my_player_id = getattr(netmaster_client, 'player_id', None)
        is_my_turn = (current_player_id == my_player_id)
        
        def update_ui():
            if is_my_turn:
                print("‚úì [MENU_TURN_CHANGED] √â a minha vez - transicionando para dashboard")
                # Criar dados de sess√£o simulados para o dashboard
                session_data = {
                    'current_player_id': current_player_id,
                    'player_order': player_order,
                    'current_turn_index': current_turn_index,
                    'players': getattr(netmaster_client, 'session_data', {}).get('players', {})
                }
                self.launch_multiplayer_dashboard(session_data)
            else:
                print("[WAITING] [MENU_TURN_CHANGED] N√£o √© a minha vez - mostrando/mantendo tela de espera")
                # Se j√° estamos numa tela de espera, n√£o fazer nada
                # Se n√£o, criar nova tela de espera
                session_data = {
                    'current_player_id': current_player_id,
                    'player_order': player_order,
                    'current_turn_index': current_turn_index,
                    'players': getattr(netmaster_client, 'session_data', {}).get('players', {})
                }
                self.launch_multiplayer_dashboard_waiting(current_player_name, current_player_color, session_data)
        
        # Agendar atualiza√ß√£o da UI para pr√≥ximo frame
        try:
            self.root.after(0, update_ui)
        except Exception as e:
            print(f"[ERROR] [MENU_TURN_CHANGED] Erro ao agendar atualiza√ß√£o da UI: {e}")
            update_ui()  # Tentar executar diretamente
    
    def on_menu_game_finished(self, data):
        """Handler para mensagens de fim de jogo no menu"""
        print(f"Jogo finalizado no menu!")
        print(f"[DATA] Dados do resultado: {data}")
        
        # Extrair dados do resultado
        winner_name = data.get('winner_name', 'Desconhecido')
        ranking = data.get('ranking', [])
        
        def update_ui():
            # Parar todas as anima√ß√µes ativas
            self.loading_animation_active = False
            
            # Mostrar tela de resultado
            self.show_game_result_screen(data)
        
        self.root.after(0, update_ui)
    
    def start_multiplayer_solo_game(self):
        """Continua a sess√£o atual como jogo solo (sem criar nova sess√£o)"""
        # A sess√£o do servidor ainda existe, apenas iniciar o dashboard em modo solo
        selected_color = getattr(self, 'selected_color', 'red')
        player_name = getattr(self, 'current_player_name', 'Player')
        
        # Fechar menu e iniciar dashboard
        self.root.destroy()
        
        # Iniciar PlayerDashboard mantendo conex√£o com servidor mas em modo solo
        root = tk.Tk()
        other_players = []  # Jogo solo - sem outros jogadores
        
        dashboard = PlayerDashboard(
            root=root,
            player_color=selected_color,
            saldo=1000,
            other_players=other_players,
            player_name=player_name,
            selected_card_idx=0
        )
        
        root.mainloop()
    
    def start_solo_game(self):
        """Inicia um jogo solo ap√≥s timeout"""
        # Usar a cor selecionada ou padr√£o
        selected_color = getattr(self, 'selected_color', 'red')
        player_name = getattr(self, 'current_player_name', 'Player')
        
        # Fechar menu e iniciar dashboard local
        self.root.destroy()
        
        # Iniciar PlayerDashboard em modo solo
        root = tk.Tk()
        other_players = []  # Jogo solo - sem outros jogadores
        
        dashboard = PlayerDashboard(
            root=root,
            player_color=selected_color,
            saldo=1000,
            other_players=other_players,
            player_name=player_name,
            selected_card_idx=0
        )
        
        root.mainloop()
    
    def show_server_connected_page(self):
        """Mostrar p√°gina de sele√ß√£o de dura√ß√£o e cor ap√≥s conectar"""
        self.loading_animation_active = False
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Status de conex√£o
        status_frame = tk.Frame(self.root, bg="black")
        status_frame.place(relx=0.5, rely=0.25, anchor="center")
        
        tk.Label(status_frame, text="‚úì Conectado ao servidor!", 
                font=("Helvetica", 16, "bold"), bg="black", fg="#4CAF50").pack()
        tk.Label(status_frame, text="Configure sua sess√£o de jogo", 
                font=("Helvetica", 14), bg="black", fg="white").pack(pady=(5, 0))
        
        # Sele√ß√£o de dura√ß√£o
        duration_frame = tk.Frame(self.root, bg="black")
        duration_frame.place(relx=0.5, rely=0.4, anchor="center")
        
        tk.Label(duration_frame, text="Dura√ß√£o do jogo (minutos):", 
                font=("Helvetica", 14, "bold"), bg="black", fg="white").pack(pady=(0, 10))
        
        duration_buttons_frame = tk.Frame(duration_frame, bg="black")
        duration_buttons_frame.pack()
        
        # Dura√ß√£o padr√£o de 30 minutos
        self.selected_duration = 30
        
        duration_options = [15, 30, 45, 60]
        self.duration_buttons = {}
        
        for duration in duration_options:
            btn = tk.Button(
                duration_buttons_frame,
                text=f"{duration}min",
                font=("Helvetica", 12, "bold"),
                bg="#4CAF50" if duration == 30 else "#666666",
                fg="white",
                width=8,
                command=lambda d=duration: self.select_duration(d)
            )
            btn.pack(side=tk.LEFT, padx=5)
            self.duration_buttons[duration] = btn
        
        # Sele√ß√£o de cores
        colors_label_frame = tk.Frame(self.root, bg="black")
        colors_label_frame.place(relx=0.5, rely=0.55, anchor="center")
        
        tk.Label(colors_label_frame, text="Selecione sua cor:", 
                font=("Helvetica", 14, "bold"), bg="black", fg="white").pack()
        
        colors_frame = tk.Frame(self.root, bg="black")
        colors_frame.place(relx=0.5, rely=0.65, anchor="center")
        
        for color, fname in [("Red","red_user_icon.png"),
                             ("Green","green_user_icon.png"),
                             ("Blue","blue_user_icon.png"),
                             ("Yellow","yellow_user_icon.png")]:
            try:
                icon = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, fname)).resize((65,65)))
                btn = tk.Button(
                    colors_frame,
                    image=icon,
                    bd=0,
                    bg="black",
                    activebackground="black",
                    highlightthickness=0,
                    command=lambda c=color: self.create_server_session(c)
                )
                btn.image = icon  # Keep reference
                btn.pack(side=tk.LEFT, padx=15)
            except:
                # Fallback para bot√£o de texto
                tk.Button(
                    colors_frame,
                    text=color,
                    font=("Helvetica", 12, "bold"),
                    bg=color.lower(),
                    fg="white",
                    command=lambda c=color: self.create_server_session(c)
                ).pack(side=tk.LEFT, padx=10)
        
        # Bot√£o voltar
        tk.Button(self.root, text="‚Üê Voltar", font=("Helvetica", 12), 
                 bg="#666666", fg="white",
                 command=lambda: self.cancel_connection(self.host_name)).place(relx=0.1, rely=0.9)

    def select_duration(self, duration):
        """Selecionar dura√ß√£o do jogo"""
        self.selected_duration = duration
        
        # Atualizar apar√™ncia dos bot√µes
        for dur, btn in self.duration_buttons.items():
            if dur == duration:
                btn.configure(bg="#4CAF50")
            else:
                btn.configure(bg="#666666")
    
    def show_duration_selection_page(self):
        """Mostrar p√°gina de sele√ß√£o de dura√ß√£o para Create Game flow"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Frame para texto - posicionado mais para baixo
        text_frame = tk.Frame(self.root, bg="black")
        text_frame.place(relx=0.5, rely=0.30, anchor="center")
        
        # T√≠tulo
        title_label = tk.Label(text_frame, text="Select Game Duration", 
                             font=("Helvetica", 20, "bold"), bg="black", fg="white")
        title_label.pack(pady=(0, 20))
        
        # Frame principal para bot√µes - posicionado mais para baixo
        main_frame = tk.Frame(self.root, bg="black")
        main_frame.place(relx=0.5, rely=0.60, anchor="center")
        
        # Frame para bot√µes de dura√ß√£o
        duration_frame = tk.Frame(main_frame, bg="black")
        duration_frame.pack(pady=15)
        
        # Op√ß√µes de dura√ß√£o
        durations = [15, 30, 45, 60]
        self.duration_buttons = {}
        self.selected_duration = 30  # Padr√£o
        
        for i, duration in enumerate(durations):
            row = i // 2
            col = i % 2
            
            btn = tk.Button(duration_frame, text=f"{duration} min", 
                          font=("Helvetica", 14, "bold"), 
                          bg="#666666" if duration != 30 else "#4CAF50",  # 30 min selecionado por padr√£o
                          fg="white", width=12, height=2,
                          command=lambda d=duration: self.select_duration(d))
            btn.grid(row=row, column=col, padx=10, pady=10)
            self.duration_buttons[duration] = btn
        
        # Bot√£o para criar sess√£o - reduzido o espa√ßamento
        create_btn = tk.Button(main_frame, text="Create Game Session", 
                             font=("Helvetica", 16, "bold"), bg="#2196F3", fg="white",
                             command=lambda: self.create_server_session(self.host_color), 
                             width=20, height=2)
        create_btn.pack(pady=20)
    
    def create_server_session(self, color):
        """Criar sess√£o no servidor com a cor e dura√ß√£o selecionadas"""
        self.host_color = color
        self.selected_color = color  # Armazenar para uso posterior
        self.current_player_name = getattr(self, 'host_name', 'Player')  # Armazenar nome
        duration = getattr(self, 'selected_duration', 30)  # Dura√ß√£o padr√£o de 30 minutos
        
        # Mostrar loading
        self.show_session_creation_loading()
        
        # Criar sess√£o no servidor usando o m√©todo thread-safe
        def create_session():
            try:
                # Usar o loop existente se dispon√≠vel, sen√£o criar novo
                try:
                    loop = asyncio.get_running_loop()
                    print("[CREATE] [DEBUG] Usando loop existente")
                    # Se h√° um loop rodando, agendamos a corrotina
                    future = asyncio.run_coroutine_threadsafe(self._create_session_async(color, duration), loop)
                    success = future.result(timeout=30)  # 30 segundos timeout
                except RuntimeError:
                    # N√£o h√° loop rodando, criar um novo
                    print("[CREATE] [DEBUG] Criando novo loop asyncio")
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    try:
                        success = loop.run_until_complete(self._create_session_async(color, duration))
                    finally:
                        loop.close()
                
                if not success:
                    self.root.after(0, lambda: self.show_session_creation_error("Falha ao criar sess√£o"))
                    
            except Exception as e:
                error_msg = f"Erro: {str(e)}"
                self.root.after(0, lambda: self.show_session_creation_error(error_msg))
        
        threading.Thread(target=create_session, daemon=True).start()
    
    async def _create_session_async(self, color, duration):
        """M√©todo async para criar sess√£o - separado para melhor gerenciamento"""
        try:
            # CR√çTICO: Garantir conex√£o antes de criar sess√£o
            if not netmaster_client.connected:
                print("[CREATE] [DEBUG] Conectando ao servidor antes de criar sess√£o...")
                connect_success = await netmaster_client.connect()
                if not connect_success:
                    raise Exception("Falha na conex√£o ao servidor")
                print("[CREATE] [DEBUG] Conectado com sucesso!")
            
            # IMPORTANTE: Registar handler global para broadcasts
            print("[CREATE] [DEBUG] Registando handler global sessions_list_update...")
            netmaster_client.set_message_handler('sessions_list_update', self.on_global_sessions_list_update)
            print("[CREATE] [DEBUG] Handler global registado!")
            
            # Criar sess√£o
            success = await netmaster_client.create_session(self.host_name, color.lower(), duration)
            return success
            
        except Exception as e:
            print(f"[CREATE] [ERROR] Erro em _create_session_async: {e}")
            raise
    
    def show_session_creation_loading(self):
        """Mostrar loading durante cria√ß√£o de sess√£o"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        loading_frame = tk.Frame(self.root, bg="black")
        loading_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        tk.Label(loading_frame, text="NetMaster", 
                font=("Helvetica", 20, "bold"), bg="black", fg="white").pack(pady=10)
        tk.Label(loading_frame, text="Creating Session...", 
                font=("Helvetica", 16), bg="black", fg="white").pack(pady=10)
        
        # Spinner de loading
        self.loading_text = tk.Label(loading_frame, text="...", 
                                    font=("Helvetica", 24), bg="black", fg="white")
        self.loading_text.pack(pady=10)
        
        self.animate_session_loading()
    
    def animate_session_loading(self):
        """Anima o loading da cria√ß√£o de sess√£o"""
        # Verificar se a anima√ß√£o deve continuar
        if not getattr(self, 'loading_animation_active', True):
            return
            
        if hasattr(self, 'loading_text') and self.loading_text and hasattr(self.loading_text, 'winfo_exists'):
            try:
                if self.loading_text.winfo_exists():
                    current = self.loading_text.cget('text')
                    if current == "...":
                        self.loading_text.configure(text="...")
                    else:
                        self.loading_text.configure(text="...")
                    
                    # S√≥ continuar se a anima√ß√£o ainda est√° ativa
                    if getattr(self, 'loading_animation_active', True):
                        self.root.after(500, self.animate_session_loading)
            except tk.TclError:
                # Widget foi destru√≠do, parar anima√ß√£o
                return
    
    def show_session_creation_error(self, error_msg):
        """Mostrar erro na cria√ß√£o de sess√£o"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        error_frame = tk.Frame(self.root, bg="black")
        error_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        tk.Label(error_frame, text="Erro na Cria√ß√£o", 
                font=("Helvetica", 18, "bold"), bg="black", fg="#f44336").pack(pady=10)
        tk.Label(error_frame, text=error_msg, 
                font=("Helvetica", 14), bg="black", fg="white").pack(pady=10)
        
        tk.Button(error_frame, text="Tentar Novamente", 
                 font=("Helvetica", 12, "bold"), bg="#4CAF50", fg="white",
                 command=self.show_server_connected_page).pack(pady=10)
    
    def show_joining_session_page(self, host_name):
        """Mostrar p√°gina de joining session com anima√ß√£o"""
        print(f"[TARGET] [DEBUG] Mostrando p√°gina joining para host: {host_name}")
        
        # Parar todas as anima√ß√µes ativas
        self.loading_animation_active = False
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Logo NetMaster na mesma posi√ß√£o que outras p√°ginas
        if self.use_netmaster_img:
            tk.Label(self.root, image=self.netmaster_img, bg="black").place(relx=0.5, y=10, anchor="n")
        else:
            tk.Label(self.root, text="NetMaster", 
                    font=("Helvetica", 20, "bold"), bg="black", fg="white").place(relx=0.5, y=10, anchor="n")
        
        # Frame principal centralizado
        main_frame = tk.Frame(self.root, bg="black")
        main_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Texto de joining
        joining_text = tk.Label(main_frame, text=f"Joining {host_name}'s session", 
                               font=("Helvetica", 18), bg="black", fg="white")
        joining_text.pack(pady=10)
        
        # Pontos animados
        self.joining_dots_label = tk.Label(main_frame, text="...", 
                                          font=("Helvetica", 24), bg="black", fg="#4CAF50")
        self.joining_dots_label.pack(pady=5)
        
        # Iniciar anima√ß√£o dos pontos
        self.joining_animation_active = True
        self.animate_joining_dots()
    
    def animate_joining_dots(self):
        """Animar os pontos na p√°gina de joining"""
        if not getattr(self, 'joining_animation_active', False):
            return
            
        if hasattr(self, 'joining_dots_label') and self.joining_dots_label:
            try:
                if self.joining_dots_label.winfo_exists():
                    current = self.joining_dots_label.cget('text')
                    if current == "...":
                        self.joining_dots_label.configure(text=".")
                    elif current == ".":
                        self.joining_dots_label.configure(text="..")
                    else:
                        self.joining_dots_label.configure(text="...")
                    
                    # Continuar anima√ß√£o se ainda est√° ativa
                    if getattr(self, 'joining_animation_active', False):
                        self.root.after(500, self.animate_joining_dots)
            except tk.TclError:
                # Widget foi destru√≠do, parar anima√ß√£o
                self.joining_animation_active = False
    
    def show_session_waiting_room(self, session_data):
        """Mostrar sala de espera da sess√£o"""
        print(f"[HOME] Entrando na sala de espera...")
        print(f"[DATA] Session data recebida: {session_data}")
        
        # *** CR√çTICO: Configurar refer√™ncia para polling de game_started ***
        netmaster_client._dashboard_ref = self
        self._host_player_id = session_data.get('host_player_id')
        print(f"[GAME_STARTED_SETUP] Dashboard ref configurada, host_id: {self._host_player_id}")
        
        # *** CR√çTICO: VERIFICA√á√ÉO ROBUSTA DE LISTEN_FOR_MESSAGES ***
        print(f"[WAITING_ROOM] *** VERIFICA√á√ÉO CR√çTICA DE LISTEN_FOR_MESSAGES ***")
        
        # Verificar estado das tasks
        task_exists = hasattr(netmaster_client, '_message_listener_task') and netmaster_client._message_listener_task is not None
        task_running = task_exists and not netmaster_client._message_listener_task.done()
        
        print(f"[WAITING_ROOM] Task exists: {task_exists}")
        print(f"[WAITING_ROOM] Task running: {task_running}")
        
        if task_exists:
            print(f"[WAITING_ROOM] Task state: {netmaster_client._message_listener_task}")
            if netmaster_client._message_listener_task.done():
                print(f"[WAITING_ROOM] Task is done - checking exception...")
                try:
                    exception = netmaster_client._message_listener_task.exception()
                    print(f"[WAITING_ROOM] Task exception: {exception}")
                except:
                    print(f"[WAITING_ROOM] Could not get task exception")
        
        print(f"[WAITING_ROOM] *** VERIFICA√á√ÉO: WebSocket funcionando normalmente ***")
        print(f"[WAITING_ROOM] Connected: {netmaster_client.connected}")
        print(f"[WAITING_ROOM] WebSocket exists: {netmaster_client.websocket is not None}")
        
        print(f"[WAITING_ROOM] *** FIM VERIFICA√á√ÉO CR√çTICA ***")
        
        # Definir flag para indicar que estamos na waiting room
        self.in_waiting_room = True
        self._last_waiting_time = session_data.get('waiting_time_left', 0)
        
        # Parar todas as anima√ß√µes ativas
        self.loading_animation_active = False
        # Inicializar countdown como ativo
        self.countdown_active = True
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        self.root.configure(bg="black")
        
        # Adicionar padr√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # Header
        header_frame = tk.Frame(self.root, bg="black")
        header_frame.place(relx=0.5, rely=0.1, anchor="center")
        
        # Usar a imagem NetMaster se dispon√≠vel
        if self.use_netmaster_img:
            tk.Label(header_frame, image=self.netmaster_img, bg="black").pack()
        else:
            tk.Label(header_frame, text="NetMaster", 
                    font=("Helvetica", 24, "bold"), bg="black", fg="white").pack()
        tk.Label(header_frame, text=f"Session ID: {session_data.get('id')}", 
                font=("Helvetica", 14, "bold"), bg="black", fg="#4CAF50").pack()
        
        # Info da sess√£o - diferente se √© host ou n√£o
        info_frame = tk.Frame(self.root, bg="black")
        info_frame.place(relx=0.5, rely=0.3, anchor="center")
        
        # Se n√£o √© o host, mostrar "Waiting for game to start" com anima√ß√£o
        if netmaster_client.player_id != session_data.get('host_player_id'):
            tk.Label(info_frame, text="Waiting for game to start", 
                    font=("Helvetica", 16, "bold"), bg="black", fg="white").pack(pady=5)
            
            # Pontos animados para jogadores n√£o-host
            self.waiting_dots_label = tk.Label(info_frame, text="...", 
                                              font=("Helvetica", 20), bg="black", fg="#4CAF50")
            self.waiting_dots_label.pack(pady=5)
            
            # Iniciar anima√ß√£o dos pontos
            self.waiting_animation_active = True
            self.animate_waiting_dots()
        else:
            # Se √© o host, mostrar mensagem normal
            tk.Label(info_frame, text="Waiting for players to join...", 
                    font=("Helvetica", 14), bg="black", fg="white").pack(pady=5)
        
        # Tempo restante de espera
        waiting_time_left = session_data.get('waiting_time_left', 0)
        if waiting_time_left > 0:
            self.waiting_time_label = tk.Label(info_frame, text=f"Time left: {waiting_time_left}s", 
                                               font=("Helvetica", 12), bg="black", fg="#ffeb3b")
            self.waiting_time_label.pack(pady=5)
            
            # CORRE√á√ÉO: Resetar ID do countdown para evitar conflitos
            self._current_countdown_id = 0
            
            # Iniciar countdown
            self.update_waiting_countdown(waiting_time_left)
        
        # Lista de jogadores
        players_frame = tk.Frame(self.root, bg="black")
        players_frame.place(relx=0.5, rely=0.5, anchor="center")

        tk.Label(players_frame, text="Players in Session:", 
                font=("Helvetica", 16, "bold"), bg="black", fg="white").pack(pady=(0, 10))
        
        # Mapeamento de cores para cores visuais
        color_map = {
            'red': '#ff4444',
            'green': '#44ff44', 
            'blue': '#4444ff',
            'yellow': '#ffff44'
        }
        
        for player_id, player_data in session_data.get('players', {}).items():
            player_color = player_data.get('color', 'white')
            display_color = color_map.get(player_color, 'white')
            
            # Frame para cada jogador
            player_frame = tk.Frame(players_frame, bg="black")
            player_frame.pack(pady=2)
            
            # Nome do jogador com cor
            tk.Label(player_frame, text=f"‚Ä¢ {player_data['name']}", 
                    font=("Helvetica", 14, "bold"), bg="black", fg=display_color).pack()
        
        # Bot√µes
        buttons_frame = tk.Frame(self.root, bg="black")
        buttons_frame.place(relx=0.5, rely=0.8, anchor="center")
        
        # Bot√£o Start Game (apenas para host)
        host_player_id = session_data.get('host_player_id')
        current_player_id = netmaster_client.player_id
        current_players = session_data.get('current_players', 0)
        
        print(f"[START_GAME] [DEBUG] Verifica√ß√£o do bot√£o Start Game:")
        print(f"[START_GAME] [DEBUG] - Host player ID: {host_player_id}")
        print(f"[START_GAME] [DEBUG] - Current player ID: {current_player_id}")
        print(f"[START_GAME] [DEBUG] - √â host?: {current_player_id == host_player_id}")
        print(f"[START_GAME] [DEBUG] - Current players: {current_players}")
        
        if current_player_id == host_player_id:
            print(f"[START_GAME] [DEBUG] Criando bot√£o Start Game para o host")
            start_btn = tk.Button(buttons_frame, text="Start Game", 
                                 font=("Helvetica", 14, "bold"), bg="#4CAF50", fg="white",
                                 command=self.start_multiplayer_game)
            start_btn.pack(pady=5)
            
            # CORRE√á√ÉO: Permitir iniciar com 2 ou mais jogadores
            if current_players < 2:
                print(f"[START_GAME] [DEBUG] Desabilitando bot√£o - apenas {current_players} jogadores")
                start_btn.configure(state='disabled', text="Need at least 2 players...")
            else:
                print(f"[START_GAME] [DEBUG] Habilitando bot√£o - {current_players} jogadores")
                start_btn.configure(state='normal', text="Start Game")
        else:
            print(f"[START_GAME] [DEBUG] N√£o √© host - n√£o criando bot√£o Start Game")
        
        # Bot√£o sair
        tk.Button(buttons_frame, text="Leave Session", 
                 font=("Helvetica", 12), bg="#f44336", fg="white",
                 command=self.leave_session).pack(pady=5)
        
        # CR√çTICO: Configurar handlers para atualiza√ß√µes da sess√£o
        # Este √© o momento √∫nico e correto para registrar o handler game_started
        # para ambos Host e Joinee
        print(f"[HANDLER_SETUP] *** REGISTRANDO HANDLERS DA WAITING ROOM ***")
        netmaster_client.set_message_handler('player_joined', self.on_player_joined)
        netmaster_client.set_message_handler('player_left', self.on_player_left)
        netmaster_client.set_message_handler('game_started', self.on_game_started)
        netmaster_client.set_message_handler('turn_changed', self.on_multiplayer_turn_changed)
        
        # *** NOVO HANDLER PARA BROADCAST DE JOGADORES ***
        netmaster_client.set_message_handler('players_info_sync', self.on_players_info_sync)
        print(f"[HANDLER_SETUP] Handler players_info_sync registrado com sucesso!")
        
        print(f"[HANDLER_SETUP] Handler game_started registrado com sucesso!")
        
        # CRITICAL: Garantir que o handler universal est√° SEMPRE registrado
        print(f"[HANDLER_FORCE] *** FOR√áANDO REGISTRO DO HANDLER ALL_MESSAGES_DEBUG ***")
        netmaster_client.set_message_handler('ALL_MESSAGES_DEBUG', self.on_any_message_debug)
        print(f"[HANDLER_FORCE] Handler ALL_MESSAGES_DEBUG registrado")
        print(f"[HANDLER_FORCE] Handlers ativos: {list(netmaster_client.message_handlers.keys())}")
        
        # *** CRITICAL FIX: POLLING ATIVO PARA GAME_STARTED ***
        print(f"[GAME_STARTED_FIX] *** INICIANDO POLLING ATIVO PARA GAME_STARTED ***")
        self.start_game_started_polling()
        
        # CRITICAL: Iniciar timeout checker para waiting room
        self.start_waiting_room_timeout_checker()
        
        # DEBUG: Verificar se handlers est√£o registrados
        print(f"[WAITING_ROOM] [DEBUG] Handlers registrados:")
        if hasattr(netmaster_client, 'message_handlers'):
            for handler_name in netmaster_client.message_handlers:
                print(f"[WAITING_ROOM] [DEBUG]   - {handler_name}")
        
        # DEBUG: Verificar estado da liga√ß√£o periodicamente COM VERIFICA√á√ÉO DE ATIVIDADE
        def check_connection_periodically():
            if hasattr(self, 'countdown_active') and getattr(self, 'countdown_active', True):
                connection_status = f"connected={netmaster_client.connected}, websocket={netmaster_client.websocket is not None}"
                print(f"[CONNECTION] [DEBUG] Estado da liga√ß√£o na sala de espera: {connection_status}")
                print(f"[CONNECTION] [DEBUG] Handlers ativos: {list(netmaster_client.message_handlers.keys())}")
                print(f"[CONNECTION] [DEBUG] Player ID: {netmaster_client.player_id}")
                print(f"[CONNECTION] [DEBUG] Session ID: {netmaster_client.session_id}")
                
                # CRITICAL: Verificar se listen_for_messages est√° realmente ativo
                task_exists = hasattr(netmaster_client, '_message_listener_task') and netmaster_client._message_listener_task is not None
                task_running = task_exists and not netmaster_client._message_listener_task.done()
                
                print(f"[CONNECTION] [DEBUG] Listen task exists: {task_exists}")
                print(f"[CONNECTION] [DEBUG] Listen task running: {task_running}")
                
                # Se a task n√£o est√° rodando, for√ßar reconex√£o
                if not task_running:
                    print(f"[CONNECTION] [CRITICAL] *** LISTEN_FOR_MESSAGES N√ÉO EST√Å ATIVO! ***")
                    print(f"[CONNECTION] [CRITICAL] *** FOR√áANDO RECONEX√ÉO IMEDIATA ***")
                    
                    async def emergency_reconnect():
                        try:
                            # Limpar estado
                            if netmaster_client.websocket:
                                try:
                                    await netmaster_client.websocket.close()
                                except:
                                    pass
                                netmaster_client.websocket = None
                                netmaster_client.connected = False
                            
                            # Reconectar
                            success = await netmaster_client.connect()
                            print(f"[CONNECTION] [CRITICAL] Reconex√£o emergencial: {success}")
                            
                            if success:
                                print(f"[CONNECTION] [CRITICAL] *** LISTEN_FOR_MESSAGES RESTAURADO! ***")
                            
                        except Exception as e:
                            print(f"[CONNECTION] [CRITICAL] Erro na reconex√£o emergencial: {e}")
                    
                    # Executar reconex√£o usando threading para evitar problemas de loop
                    def run_emergency_reconnect():
                        print(f"[CONNECTION] [CRITICAL] Iniciando reconex√£o em thread separada")
                        import threading
                        import asyncio
                        
                        def async_reconnect():
                            # Criar novo loop de eventos para esta thread
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            
                            try:
                                loop.run_until_complete(emergency_reconnect())
                                print(f"[CONNECTION] [CRITICAL] Reconex√£o conclu√≠da com sucesso")
                            except Exception as e:
                                print(f"[CONNECTION] [CRITICAL] Erro na reconex√£o: {e}")
                            finally:
                                loop.close()
                        
                        # Executar em thread separada
                        thread = threading.Thread(target=async_reconnect, daemon=True)
                        thread.start()
                    
                    # Executar a partir do main thread
                    self.root.after(100, run_emergency_reconnect)
                
                # Verificar novamente em 3 segundos
                self.root.after(3000, check_connection_periodically)
        
        # CRITICAL: Watchdog para garantir que mensagens est√£o sendo recebidas
        self._last_message_time = time.time()
        self._message_watchdog_active = True
        
        def message_watchdog():
            """Verifica se mensagens est√£o sendo recebidas e for√ßa reconex√£o se necess√°rio"""
            if not hasattr(self, '_message_watchdog_active') or not self._message_watchdog_active:
                return
                
            current_time = time.time()
            time_since_last_message = current_time - getattr(self, '_last_message_time', current_time)
            
            print(f"[WATCHDOG] Verificando atividade de mensagens...")
            print(f"[WATCHDOG] Tempo desde √∫ltima mensagem: {time_since_last_message:.1f}s")
            print(f"[WATCHDOG] Connected: {netmaster_client.connected}")
            print(f"[WATCHDOG] WebSocket: {netmaster_client.websocket is not None}")
            
            # CORRE√á√ÉO CR√çTICA: N√ÉO for√ßar reconex√£o durante jogos multiplayer
            # Durante gameplay multiplayer √© normal n√£o receber mensagens por longos per√≠odos
            multiplayer_active = getattr(self, 'multiplayer_mode', False)
            in_waiting_room = getattr(self, 'in_waiting_room', False)
            
            if multiplayer_active and not in_waiting_room:
                print(f"[WATCHDOG] Jogo multiplayer ativo - watchdog DESATIVADO (n√£o for√ßa reconex√£o)")
                print(f"[WATCHDOG] √â normal n√£o receber mensagens durante gameplay")
                # Durante jogo multiplayer, n√£o verificar timeout - apenas manter heartbeat
                self.root.after(10000, message_watchdog)  # Verificar novamente em 10s
                return
            
            # CORRE√á√ÉO: Durante a waiting room, usar timeout mais longo
            if in_waiting_room:
                print(f"[WATCHDOG] Na waiting room - heartbeat autom√°tico mant√©m conex√£o")
                timeout_seconds = 120.0  # Mais tolerante na waiting room (2 minutos)
            else:
                timeout_seconds = 60.0  # Normal fora da waiting room (apenas single player)
            
            if time_since_last_message > timeout_seconds:
                print(f"[WATCHDOG] *** SEM MENSAGENS H√Å {time_since_last_message:.1f}s - FOR√áANDO RECONEX√ÉO ***")
                
                def emergency_reconnect_watchdog():
                    import threading
                    import asyncio
                    
                    def do_reconnect():
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        
                        async def reconnect():
                            try:
                                # Fechar conex√£o atual
                                if netmaster_client.websocket:
                                    try:
                                        await netmaster_client.websocket.close()
                                    except:
                                        pass
                                    netmaster_client.websocket = None
                                    netmaster_client.connected = False
                                
                                print(f"[WATCHDOG] Aguardando antes da reconex√£o...")
                                await asyncio.sleep(2)
                                
                                # Reconectar
                                success = await netmaster_client.connect()
                                print(f"[WATCHDOG] Reconex√£o: {success}")
                                
                                if success:
                                    # Atualizar timestamp
                                    self._last_message_time = time.time()
                                    print(f"[WATCHDOG] *** RECONEX√ÉO CONCLU√çDA - TIMESTAMP RESETADO ***")
                                
                            except Exception as e:
                                print(f"[WATCHDOG] Erro na reconex√£o: {e}")
                        
                        try:
                            loop.run_until_complete(reconnect())
                        finally:
                            loop.close()
                    
                    thread = threading.Thread(target=do_reconnect, daemon=True)
                    thread.start()
                
                self.root.after(100, emergency_reconnect_watchdog)
            
            # Reagendar watchdog para pr√≥xima verifica√ß√£o (verificar menos frequentemente na waiting room)
            if hasattr(self, '_message_watchdog_active') and self._message_watchdog_active:
                check_interval = 20000 if getattr(self, 'in_waiting_room', False) else 10000  # 20s na waiting room, 10s normal
                self.root.after(check_interval, message_watchdog)
        
        # Atualizar timestamp quando mensagens s√£o recebidas
        def update_message_timestamp():
            self._last_message_time = time.time()
        
        # Registrar callback para atualizar timestamp
        netmaster_client._update_message_timestamp = update_message_timestamp
        
        # Iniciar watchdog
        self.root.after(10000, message_watchdog)  # Primeira verifica√ß√£o em 10s
        
        # Fallback: Se ap√≥s tempo significativo n√£o recebemos game_started, verificar se o jogo j√° come√ßou
        def fallback_check():
            if hasattr(self, 'countdown_active') and self.countdown_active:
                # Verificar se sou o host da sess√£o
                host_player_id = session_data.get('host_player_id')
                my_player_id = netmaster_client.player_id
                
                if host_player_id == my_player_id:
                    print(f"[TARGET] [DEBUG] FALLBACK: Sou o HOST - n√£o preciso de fallback, devo mostrar Start Game")
                    # O host n√£o precisa de fallback, deve mostrar Start Game
                    return
                
                print(f"[WARNING] [DEBUG] FALLBACK: N√£o recebi game_started em muito tempo, verificando se jogo j√° come√ßou...")
                # Tentar verificar estado da sess√£o
                try:
                    # APENAS fazer transi√ß√£o se realmente houver evid√™ncia de que o jogo come√ßou
                    # Por agora, n√£o for√ßar mais a transi√ß√£o autom√°tica
                    print(f"[FALLBACK] [DEBUG] Mantendo-me na waiting room at√© receber game_started do servidor")
                except Exception as e:
                    print(f"[ERROR] [DEBUG] Erro no fallback check: {e}")
        
        # Agendar fallback para tempo muito maior (2 minutos) ou desativar
        # self.root.after(120000, fallback_check)  # 2 minutos em vez de 8 segundos
    
    def update_waiting_countdown(self, time_left, countdown_id=None):
        """Atualiza o countdown do tempo de espera"""
        try:
            # Verificar se a anima√ß√£o ainda deve estar ativa
            if not getattr(self, 'countdown_active', True):
                print("[DEBUG] Countdown cancelado - timeout acionado")
                return
            
            # Se countdown_id n√£o foi fornecido, usar o ID atual (para novos countdowns)
            if countdown_id is None:
                countdown_id = getattr(self, '_current_countdown_id', 0)
            
            # Verificar se este countdown ainda √© v√°lido
            if getattr(self, '_current_countdown_id', 0) != countdown_id:
                print(f"[DEBUG] Countdown invalidado - ID atual: {getattr(self, '_current_countdown_id', 0)}, countdown ID: {countdown_id}")
                return
                
            if hasattr(self, 'waiting_time_label') and self.waiting_time_label and hasattr(self.waiting_time_label, 'winfo_exists'):
                if self.waiting_time_label.winfo_exists() and time_left > 0:
                    minutes = time_left // 60
                    seconds = time_left % 60
                    if minutes > 0:
                        time_text = f"Time left: {minutes}m {seconds}s"
                    else:
                        time_text = f"Time left: {seconds}s"
                    
                    # Mudar cor conforme tempo restante
                    if time_left <= 10:
                        color = "#f44336"  # Vermelho
                    elif time_left <= 30:
                        color = "#ff9800"  # Laranja
                    else:
                        color = "#ffeb3b"  # Amarelo
                    
                    self.waiting_time_label.configure(text=time_text, fg=color)
                    
                    # Agendar pr√≥xima atualiza√ß√£o apenas se countdown ainda est√° ativo E este √© o countdown atual
                    if (getattr(self, 'countdown_active', True) and 
                        getattr(self, '_current_countdown_id', 0) == countdown_id):
                        self.root.after(1000, lambda: self.update_waiting_countdown(time_left - 1, countdown_id))
                elif self.waiting_time_label.winfo_exists():
                    self.waiting_time_label.configure(text="Tempo esgotado!", fg="#f44336")
        except (tk.TclError, AttributeError):
            # Widget foi destru√≠do ou n√£o existe mais, parar countdown
            print("[WARNING] [DEBUG] Widget countdown destru√≠do")
            pass
    
    def animate_waiting_dots(self):
        """Animar os pontos na waiting room para jogadores n√£o-host"""
        if not getattr(self, 'waiting_animation_active', False):
            return
            
        if hasattr(self, 'waiting_dots_label') and self.waiting_dots_label:
            try:
                if self.waiting_dots_label.winfo_exists():
                    current = self.waiting_dots_label.cget('text')
                    if current == "...":
                        self.waiting_dots_label.configure(text=".")
                    elif current == ".":
                        self.waiting_dots_label.configure(text="..")
                    else:
                        self.waiting_dots_label.configure(text="...")
                    
                    # Continuar anima√ß√£o se ainda est√° ativa
                    if getattr(self, 'waiting_animation_active', False):
                        self.root.after(500, self.animate_waiting_dots)
            except tk.TclError:
                # Widget foi destru√≠do
                self.waiting_animation_active = False
    
    def start_multiplayer_game(self):
        """Iniciar jogo multiplayer (apenas host)"""
        def start_game():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                success = loop.run_until_complete(netmaster_client.start_game())
                if not success:
                    print("[ERROR] Falha ao iniciar jogo")
                    
            except Exception as e:
                print(f"[ERROR] Erro ao iniciar jogo: {e}")
        
        threading.Thread(target=start_game, daemon=True).start()
    
    def on_player_joined(self, data):
        """Callback quando jogador se junta √† sess√£o"""
        print(f"[USERS] Jogador entrou: {data}")
        session_data = data.get('session', {})
        
            # CORRE√á√ÉO: Verificar se o tempo de espera foi estendido
        new_waiting_time = session_data.get('waiting_time_left', 0)
        
        # Se j√° estamos na waiting room e o tempo foi estendido significativamente (>45s), 
        # atualizar apenas o countdown em vez de recriar toda a interface
        if (hasattr(self, 'waiting_time_label') and 
            hasattr(self, 'countdown_active') and 
            self.countdown_active and
            new_waiting_time > 45):
            
            print(f"[DEBUG] Tempo estendido detectado: {new_waiting_time}s - sincronizando countdown")
            
            # Mostrar notifica√ß√£o ao host sobre extens√£o do tempo
            if netmaster_client.player_id == session_data.get('host_player_id'):
                # Criar uma notifica√ß√£o tempor√°ria
                def show_extension_notification():
                    try:
                        # Encontrar um local para mostrar a notifica√ß√£o
                        notification = tk.Label(self.root, 
                                               text="[TIMEOUT] Waiting time increased to +1 minute!", 
                                               font=("Helvetica", 12, "bold"), 
                                               bg="#4CAF50", fg="white", relief="solid", bd=2)
                        notification.place(relx=0.5, rely=0.15, anchor="center")
                        
                        # Remover notifica√ß√£o ap√≥s 3 segundos
                        self.root.after(3000, lambda: notification.destroy())
                    except Exception as e:
                        print(f"[DEBUG] Erro ao mostrar notifica√ß√£o: {e}")
                
                self.root.after(100, show_extension_notification)
            
            # NOVA ABORDAGEM: Sincronizar countdown sem parar/reiniciar
            def sync_countdown():
                if hasattr(self, 'waiting_time_label') and self.waiting_time_label:
                    try:
                        if self.waiting_time_label.winfo_exists():
                            # Atualizar imediatamente para o novo tempo
                            minutes = new_waiting_time // 60
                            seconds = new_waiting_time % 60
                            if minutes > 0:
                                time_text = f"Time left: {minutes}m {seconds}s"
                            else:
                                time_text = f"Time left: {seconds}s"
                            
                            self.waiting_time_label.configure(text=time_text, fg="#4CAF50")
                            
                            # Incrementar countdown ID para invalidar countdowns antigos
                            self._current_countdown_id = getattr(self, '_current_countdown_id', 0) + 1
                            
                            # Iniciar novo countdown sincronizado
                            self.update_waiting_countdown(new_waiting_time)
                    except tk.TclError:
                        pass
            
            self.root.after(100, sync_countdown)  # Sincronizar rapidamente
            
            # Atualizar apenas a lista de jogadores sem recriar tudo
            self.update_players_list(session_data)
        else:
            # Caso normal: recriar interface completa
            self.root.after(0, lambda: self.show_session_waiting_room(session_data))
    
    def update_players_list(self, session_data):
        """Atualiza apenas a lista de jogadores sem recriar toda a interface"""
        try:
            # Encontrar o frame dos jogadores existente
            for widget in self.root.winfo_children():
                if isinstance(widget, tk.Frame):
                    for child in widget.winfo_children():
                        if isinstance(child, tk.Label) and "Players in Session:" in child.cget('text'):
                            # Encontrou o frame dos jogadores, atualizar
                            parent_frame = widget
                            
                            # Remover lista atual de jogadores (manter apenas o header)
                            for subchild in parent_frame.winfo_children()[1:]:  # Skip header
                                subchild.destroy()
                            
                            # Recriar lista de jogadores
                            color_map = {
                                'red': '#ff4444',
                                'green': '#44ff44', 
                                'blue': '#4444ff',
                                'yellow': '#ffff44'
                            }
                            
                            for player_id, player_data in session_data.get('players', {}).items():
                                player_color = player_data.get('color', 'white')
                                display_color = color_map.get(player_color, 'white')
                                
                                # Frame para cada jogador
                                player_frame = tk.Frame(parent_frame, bg="black")
                                player_frame.pack(pady=2)
                                
                                # Nome do jogador com cor
                                tk.Label(player_frame, text=f"‚Ä¢ {player_data['name']}", 
                                        font=("Helvetica", 14, "bold"), bg="black", fg=display_color).pack()
                            
                            print(f"[DEBUG] Lista de jogadores atualizada com {len(session_data.get('players', {}))} jogadores")
                            
                            # CR√çTICO: Atualizar o bot√£o Start Game tamb√©m
                            self.update_start_game_button(session_data)
                            return
        except Exception as e:
            print(f"[DEBUG] Erro ao atualizar lista de jogadores: {e}")
            # Se houver erro, fazer fallback para recriar interface completa
            self.show_session_waiting_room(session_data)
    
    def update_start_game_button(self, session_data):
        """Atualiza apenas o bot√£o Start Game sem recriar toda a interface"""
        try:
            host_player_id = session_data.get('host_player_id')
            current_player_id = netmaster_client.player_id
            current_players = session_data.get('current_players', 0)
            
            print(f"[START_GAME] [DEBUG] Atualizando bot√£o Start Game:")
            print(f"[START_GAME] [DEBUG] - Host player ID: {host_player_id}")
            print(f"[START_GAME] [DEBUG] - Current player ID: {current_player_id}")
            print(f"[START_GAME] [DEBUG] - √â host?: {current_player_id == host_player_id}")
            print(f"[START_GAME] [DEBUG] - Current players: {current_players}")
            
            if current_player_id == host_player_id:
                # Procurar por bot√£o Start Game existente
                start_button_found = False
                for widget in self.root.winfo_children():
                    if isinstance(widget, tk.Frame):
                        for child in widget.winfo_children():
                            if isinstance(child, tk.Button) and "Start Game" in child.cget('text'):
                                # Encontrou o bot√£o, atualizar estado
                                if current_players < 2:
                                    print(f"[START_GAME] [DEBUG] Desabilitando bot√£o existente - apenas {current_players} jogadores")
                                    child.configure(state='disabled', text="Need at least 2 players...")
                                else:
                                    print(f"[START_GAME] [DEBUG] Habilitando bot√£o existente - {current_players} jogadores")
                                    child.configure(state='normal', text="Start Game")
                                start_button_found = True
                                break
                        if start_button_found:
                            break
                
                if not start_button_found:
                    print(f"[START_GAME] [DEBUG] Bot√£o n√£o encontrado - recriando interface completa")
                    self.show_session_waiting_room(session_data)
            else:
                print(f"[START_GAME] [DEBUG] N√£o √© host - bot√£o n√£o deveria existir")
                
        except Exception as e:
            print(f"[DEBUG] Erro ao atualizar bot√£o Start Game: {e}")
            # Se houver erro, fazer fallback para recriar interface completa
            self.show_session_waiting_room(session_data)
    
    def on_receive_action_event_card(self, data):
        """Handler para receber cartas Actions/Events de outros jogadores"""
        try:
            sender = data.get('sender')
            card_type = data.get('card_type')
            card_data = data.get('card_data', {})
            
            print(f"[CARD_TRANSMISSION] üì¨ Recebendo carta de {sender}")
            print(f"[CARD_TRANSMISSION] Tipo: {card_type}, Dados: {card_data}")
            
            # Obter informa√ß√µes da carta
            card_id = card_data.get('id')
            card_path = card_data.get('card_path')
            from_player = card_data.get('from_player')
            
            if not all([card_id, card_path, card_type]):
                print(f"[CARD_TRANSMISSION] ‚ùå Dados incompletos: id={card_id}, path={card_path}, type={card_type}")
                return
            
            # Adicionar carta ao invent√°rio correto
            success = False
            if card_type.lower() in ['actions', 'action']:
                success = self.adicionar_carta_inventario('Actions', card_path, card_id)
                print(f"[CARD_TRANSMISSION] Actions - Sucesso: {success}")
            elif card_type.lower() in ['events', 'event']:
                success = self.adicionar_carta_inventario('Events', card_path, card_id)
                print(f"[CARD_TRANSMISSION] Events - Sucesso: {success}")
            else:
                print(f"[CARD_TRANSMISSION] Tipo de carta desconhecido: {card_type}")
                return
            
            if success:
                print(f"[CARD_TRANSMISSION] ‚úì Carta {card_id} de {from_player} adicionada ao invent√°rio {card_type}")
                
                # Opcional: Mostrar notifica√ß√£o visual (n√£o implementado por solicita√ß√£o do usu√°rio)
                # self.show_card_received_notification(from_player, card_type, card_id)
            else:
                print(f"[CARD_TRANSMISSION] ‚ùå Falha ao adicionar carta {card_id} ao invent√°rio")
                
        except Exception as e:
            print(f"[CARD_TRANSMISSION] ‚ùå Erro ao processar carta recebida: {e}")
    
    def on_player_left(self, data):
        """Callback quando jogador sai da sess√£o"""
        print(f" Jogador saiu: {data}")
        # Atualizar interface da sala de espera
        session_data = data.get('session', {})
        self.root.after(0, lambda: self.show_session_waiting_room(session_data))
    
    def on_players_info_sync(self, data):
        """
        *** NOVO HANDLER: BROADCAST AUTOM√ÅTICO DE JOGADORES ***
        Recebe atualiza√ß√µes da lista de jogadores do servidor
        """
        players_data = data.get('players', {})
        total_players = data.get('total_players', 0)
        session_id = data.get('session_id', 'unknown')
        
        print(f"[PLAYERS_SYNC] *** BROADCAST DE JOGADORES RECEBIDO ***")
        print(f"[PLAYERS_SYNC] Session ID: {session_id}")
        print(f"[PLAYERS_SYNC] Total jogadores: {total_players}")
        print(f"[PLAYERS_SYNC] Dados recebidos: {players_data}")
        
        # Atualizar dados locais
        self.session_players = players_data
        self.other_players = []
        
        # Filtrar outros jogadores (excluir pr√≥prio)
        my_color = getattr(self, 'player_color', '').lower()
        for player_id, info in players_data.items():
            if info['color'].lower() != my_color:  # N√£o √© o pr√≥prio jogador
                self.other_players.append({
                    'id': player_id,
                    'color': info['color'],
                    'name': info['name'],
                    'is_active': info['is_active']
                })
        
        print(f"[PLAYERS_SYNC] ‚úì Other players atualizados: {len(self.other_players)} jogadores")
        for player in self.other_players:
            print(f"[PLAYERS_SYNC]   - {player['name']} ({player['color']}) - Ativo: {player['is_active']}")
        
        # *** ATUALIZAR INTERFACE SE NECESS√ÅRIO ***
        try:
            self._update_players_display()
        except Exception as e:
            print(f"[PLAYERS_SYNC] Erro ao atualizar display: {e}")
    
    def _update_players_display(self):
        """Atualiza displays que mostram outros jogadores"""
        # Atualizar √≠cones de jogadores na interface principal
        if hasattr(self, '_players_icons_frame'):
            print(f"[PLAYERS_SYNC] Atualizando √≠cones de jogadores")
            self._refresh_players_icons()
        
        # Atualizar qualquer overlay de sele√ß√£o de jogador ativo
        if hasattr(self, 'active_player_overlay'):
            print(f"[PLAYERS_SYNC] Atualizando overlay de sele√ß√£o de jogador")
            self._refresh_player_selection_overlay()
        
        print(f"[PLAYERS_SYNC] ‚úì Display de jogadores atualizado com sucesso")
    
    def on_game_started(self, data):
        """Callback quando jogo √© iniciado"""
        import time
        current_timestamp = time.time()
        print(f"[ON_GAME_STARTED] *** HANDLER on_game_started EXECUTADO! ***")
        print(f"[ON_GAME_STARTED] *** TIMESTAMP: {current_timestamp} ***")
        print(f"[ON_GAME_STARTED] *** TIME STRING: {time.strftime('%H:%M:%S')} ***")
        print(f"[ON_GAME_STARTED] *** PLAYER ID: {getattr(netmaster_client, 'player_id', 'NONE')} ***")
        print(f"[ON_GAME_STARTED] *** SESSION ID: {getattr(netmaster_client, 'session_id', 'NONE')} ***")
        print(f"[ON_GAME_STARTED] *** DATA RECEIVED: {data} ***")
        print(f"[ON_GAME_STARTED] *** DATA TYPE: {type(data)} ***")
        print(f"[ON_GAME_STARTED] *** DATA KEYS: {list(data.keys()) if isinstance(data, dict) else 'NOT_DICT'} ***")
        print(f"[ON_GAME_STARTED] *** CURRENT STATE - IN_WAITING_ROOM: {getattr(self, 'in_waiting_room', 'UNDEFINED')} ***")
        print(f"[ON_GAME_STARTED] *** CURRENT STATE - MULTIPLAYER_MODE: {getattr(self, 'multiplayer_mode', 'UNDEFINED')} ***")
        
        print(f"[GAME_STARTED] *** MENSAGEM RECEBIDA! ***")
        print(f"[GAME_STARTED] Time: {time.strftime('%H:%M:%S')}")
        print(f"[GAME_STARTED] CRITICAL: on_game_started FOI CHAMADO!")
        print(f"[GAME_STARTED] Data type: {type(data)}")
        print(f"[GAME_STARTED] Data keys: {list(data.keys()) if isinstance(data, dict) else 'NOT_DICT'}")
        print(f"[TARGET] Jogo iniciado: {data}")
        print(f"[TARGET] [DEBUG] *** GAME_STARTED RECEBIDO NO SEGUNDO JOGADOR! ***")
        print(f"[TARGET] [DEBUG] Data completa do game_started: {data}")
        print(f"[TARGET] [DEBUG] on_game_started foi chamado no menu system!")
        print(f"[TARGET] [DEBUG] Player ID: {getattr(netmaster_client, 'player_id', 'NONE')}")
        print(f"[TARGET] [DEBUG] Session ID: {getattr(netmaster_client, 'session_id', 'NONE')}")
        
        # *** CRITICAL FIX: ATUALIZAR session_data COM DADOS ATUALIZADOS ***
        session_data = data.get('session', {})
        if session_data:
            print(f"[CARD_STORAGE_FIX] *** ATUALIZANDO netmaster_client.session_data COM DADOS DO GAME_STARTED ***")
            print(f"[CARD_STORAGE_FIX] Session data anterior: {getattr(netmaster_client, 'session_data', None)}")
            print(f"[CARD_STORAGE_FIX] Session data nova: {session_data}")
            netmaster_client.session_data = session_data
            print(f"[CARD_STORAGE_FIX] ‚úì session_data atualizada com sucesso!")
            
            # DEBUG: Verificar jogadores na session_data atualizada
            players = session_data.get('players', {})
            print(f"[CARD_STORAGE_FIX] Jogadores na session_data atualizada: {list(players.keys())}")
            for player_id, player_data in players.items():
                player_name = player_data.get('name', 'Unknown')
                player_color = player_data.get('color', 'unknown')
                print(f"[CARD_STORAGE_FIX]   - {player_id}: {player_name} ({player_color})")
        else:
            print(f"[CARD_STORAGE_FIX] Sem session_data no game_started!")
        
        # SAIR DA WAITING ROOM
        self.in_waiting_room = False
        
        # *** CRITICAL FIX: DEFINIR MULTIPLAYER_MODE PARA PREVENIR VOLTA √Ä WAITING ROOM ***
        self.multiplayer_mode = True
        print(f"[GAME_STARTED] *** MULTIPLAYER_MODE DEFINIDO COMO TRUE ***")
        
        # *** NOVO: EXTRAIR DURA√á√ÉO DA SESS√ÉO E INICIAR TIMER ***
        duration_minutes = session_data.get('duration_minutes', 15)  # Default 15 minutos
        expires_at = session_data.get('expires_at')
        
        print(f"[GAME_TIMER] *** INICIANDO TIMER DE SESS√ÉO ***")
        print(f"[GAME_TIMER] Dura√ß√£o: {duration_minutes} minutos")
        print(f"[GAME_TIMER] Expires at: {expires_at}")
        
        # SEMPRE usar dura√ß√£o total em minutos para simplicidade
        time_remaining_seconds = duration_minutes * 60
        print(f"[GAME_TIMER] Usando dura√ß√£o total: {time_remaining_seconds} segundos ({duration_minutes} minutos)")
            
        # Iniciar timer global de sess√£o
        self.start_session_timer(time_remaining_seconds)
        
        # Parar anima√ß√µes da waiting room
        self.waiting_animation_active = False
        self.countdown_active = False
        
        def start_dashboard():
            # Extrair informa√ß√µes do turno
            session_data = data.get('session', {})
            current_player_id = session_data.get('current_player_id')
            player_order = session_data.get('player_order', [])
            current_turn_index = session_data.get('current_turn_index', 0)
            
            print(f"[TARGET] [GAME_STARTED] Jogador atual: {current_player_id}")
            print(f"[TARGET] [GAME_STARTED] Meu ID: {netmaster_client.player_id}")
            print(f"[TARGET] [GAME_STARTED] Ordem dos jogadores: {player_order}")
            print(f"[TARGET] [GAME_STARTED] √çndice do turno: {current_turn_index}")
            
            # DEBUG ADICIONAL
            print(f"[TARGET] [GAME_STARTED] Type of current_player_id: {type(current_player_id)}")
            print(f"[TARGET] [GAME_STARTED] Type of netmaster_client.player_id: {type(netmaster_client.player_id)}")
            print(f"[TARGET] [GAME_STARTED] Compara√ß√£o direta: {current_player_id == netmaster_client.player_id}")
            print(f"[TARGET] [GAME_STARTED] Players na sess√£o: {session_data.get('players', {}).keys()}")
            
            # Verificar se √© o meu turno
            is_my_turn = False
            host_player_id = session_data.get('host_player_id')
            
            # L√ìGICA SIMPLIFICADA: Apenas usar current_player_id do servidor
            if current_player_id and current_player_id == netmaster_client.player_id:
                is_my_turn = True
                print("‚úì [GAME_STARTED] Turno detectado por player_id match com servidor")
            # FALLBACK: Se current_player_id √© None, usar primeira posi√ß√£o na ordem
            elif current_player_id is None and len(player_order) > 0 and netmaster_client.player_id == player_order[0]:
                is_my_turn = True
                print("‚úì [GAME_STARTED] Turno detectado por primeira posi√ß√£o na ordem (fallback)")
            # FALLBACK 2: Se n√£o h√° current_player_id nem player_order, host come√ßa
            elif current_player_id is None and len(player_order) == 0 and host_player_id and netmaster_client.player_id == host_player_id:
                is_my_turn = True
                print("‚úì [GAME_STARTED] Turno detectado por ser host (fallback 2)")
            else:
                is_my_turn = False
                print("[WAITING] [GAME_STARTED] N√£o √© o meu turno conforme definido pelo servidor")
            
            # Verificar se √© o meu turno
            if is_my_turn:
                print("‚úì [GAME_STARTED] √â o meu turno - indo para dice roll")
                # Iniciar PlayerDashboard multiplayer
                self.launch_multiplayer_dashboard(session_data)
            else:
                print("[WAITING] [GAME_STARTED] N√£o √© o meu turno - mostrando tela de espera")
                # Encontrar dados do jogador atual
                players = session_data.get('players', {})
                current_player_data = players.get(current_player_id, {})
                current_player_name = current_player_data.get('name', 'Unknown')
                current_player_color = current_player_data.get('color', 'white')
                
                print(f"[TARGET] [GAME_STARTED] Mostrando waiting para: {current_player_name} ({current_player_color})")
                
                # Criar PlayerDashboard em modo waiting
                self.launch_multiplayer_dashboard_waiting(current_player_name, current_player_color, session_data)
        
        self.root.after(0, start_dashboard)
    
    def start_game_started_polling(self):
        """Inicia polling ativo para detectar quando jogo foi iniciado"""
        print(f"[GAME_STARTED_POLLING] *** INICIANDO POLLING ATIVO ***")
        
        def check_game_started():
            try:
                # S√≥ fazer polling se ainda estamos na waiting room e n√£o somos o host
                if (getattr(self, 'in_waiting_room', False) and 
                    getattr(self, 'multiplayer_mode', False) and
                    netmaster_client.player_id != getattr(self, '_host_player_id', None)):
                    
                    print(f"[GAME_STARTED_POLLING] Verificando status do jogo...")
                    
                    # Solicitar lista de sess√µes para ver se nossa sess√£o ainda est√° "waiting"
                    async def async_check():
                        try:
                            if netmaster_client.connected and netmaster_client.websocket:
                                # Enviar list_sessions para verificar status
                                await netmaster_client.send_message({
                                    'type': 'list_sessions'
                                })
                                print(f"[GAME_STARTED_POLLING] Lista de sess√µes solicitada")
                        except Exception as e:
                            print(f"[GAME_STARTED_POLLING] Erro no check: {e}")
                    
                    # Executar check ass√≠ncrono
                    if netmaster_client.connected:
                        try:
                            # Usar thread para evitar problemas de loop
                            import threading
                            import asyncio
                            
                            def run_async_check():
                                loop = asyncio.new_event_loop()
                                asyncio.set_event_loop(loop)
                                try:
                                    loop.run_until_complete(async_check())
                                except Exception as e:
                                    print(f"[GAME_STARTED_POLLING] Erro no loop: {e}")
                                finally:
                                    loop.close()
                            
                            thread = threading.Thread(target=run_async_check, daemon=True)
                            thread.start()
                            
                        except Exception as e:
                            print(f"[GAME_STARTED_POLLING] Erro criando thread: {e}")
                    
                    # Continuar polling a cada 3 segundos
                    self.root.after(3000, check_game_started)
                else:
                    print(f"[GAME_STARTED_POLLING] Parando polling - n√£o na waiting room ou √© host")
                    
            except Exception as e:
                print(f"[GAME_STARTED_POLLING] Erro geral: {e}")
                # Tentar novamente em 5 segundos
                self.root.after(5000, check_game_started)
        
        # Iniciar primeiro check em 2 segundos
        self.root.after(2000, check_game_started)
    
    def start_session_timer(self, time_remaining_seconds):
        """Iniciar timer de contagem decrescente da sess√£o"""
        print(f"[SESSION_TIMER] *** TIMER INICIADO ***")
        print(f"[SESSION_TIMER] Tempo inicial: {time_remaining_seconds:.1f} segundos")
        
        # Converter para minutos e segundos
        minutes = int(time_remaining_seconds // 60)
        seconds = int(time_remaining_seconds % 60)
        
        print(f"[SESSION_TIMER] Tempo formatado: {minutes:02d}:{seconds:02d}")
        
        # Armazenar tempo restante
        self.session_time_remaining = time_remaining_seconds
        self.session_timer_active = True
        
        # CORRE√á√ÉO: TODOS os jogadores (HOST e JOINEE) agora aguardam updates do servidor
        is_host = self.is_session_host()
        
        if is_host:
            print(f"[SESSION_TIMER] Este jogador √© HOST - aguardando timer updates do SERVIDOR")
        else:
            print(f"[SESSION_TIMER] Este jogador √© JOINEE - aguardando timer updates do SERVIDOR")
        
        # Nenhum jogador inicia countdown local - servidor controla tudo
        print(f"[SESSION_TIMER] Timer local desativado - servidor controlar√° o countdown")
    
    def update_session_timer(self):
        """Atualizar o timer a cada segundo - DESATIVADO: Agora todos recebem updates do servidor"""
        if not getattr(self, 'session_timer_active', False):
            return
            
        if self.session_time_remaining <= 0:
            print(f"[SESSION_TIMER] *** TEMPO ESGOTADO! ***")
            self.session_timer_active = False
            # Fim de jogo - mostrar p√°gina de ranking
            self._handle_game_time_ended()
            return
        
        # CORRE√á√ÉO: DESATIVAR countdown local - TODOS recebem updates do servidor
        print(f"[SESSION_TIMER] Timer local desativado - aguardando updates do servidor")
        print(f"[SESSION_TIMER] Tempo atual recebido do servidor: {self.session_time_remaining:.1f}s")
        
        # Apenas atualizar display com o valor recebido do servidor
        self.update_timer_display()
        
        # N√ÉO AGENDAR mais countdown local - servidor controla tudo
        # self.root.after(1000, self.update_session_timer) # REMOVIDO
    
    def update_timer_display(self):
        """Atualizar display do timer na interface"""
        if not hasattr(self, 'session_time_remaining'):
            return
            
        # Converter para minutos e segundos
        minutes = int(self.session_time_remaining // 60)
        seconds = int(self.session_time_remaining % 60)
        
        # Formato do timer
        timer_text = f"{minutes:02d}:{seconds:02d}"
        
        # Cor baseada no tempo restante
        if minutes < 2:  # Menos de 2 minutos - vermelho
            timer_color = "#FF4444"
        elif minutes < 5:  # Menos de 5 minutos - amarelo
            timer_color = "#FFAA00"
        else:  # Mais de 5 minutos - verde
            timer_color = "#44FF44"
        
        # Atualizar label se existir E se ainda √© v√°lido
        if hasattr(self, 'session_timer_label') and self.session_timer_label:
            try:
                # CORRE√á√ÉO: Verificar se o widget ainda existe antes de tentar actualizar
                if self.session_timer_label.winfo_exists():
                    self.session_timer_label.configure(text=timer_text, fg=timer_color)
                else:
                    print(f"[SESSION_TIMER] DEBUG: Widget timer n√£o existe mais - limpando refer√™ncia")
                    self.session_timer_label = None
            except Exception as e:
                print(f"[SESSION_TIMER] Erro ao atualizar label: {e}")
                # Se h√° erro, limpar a refer√™ncia para evitar tentativas futuras
                self.session_timer_label = None
        else:
            # NOVO: Log quando n√£o h√° timer vis√≠vel mas tempo continua a passar
            print(f"[SESSION_TIMER] DEBUG: Timer a contar em background: {timer_text} (sem display)")
    
    def _handle_game_time_ended(self):
        """Handler quando o tempo de jogo termina - mostrar p√°gina de ranking"""
        print(f"[GAME_END] *** TEMPO DE JOGO TERMINADO ***")
        
        # Verificar se somos o host da sess√£o
        is_host = self.is_session_host()
        
        if is_host:
            print(f"[GAME_END] Este jogador √© HOST - notificando servidor sobre fim de jogo")
            
            # Notificar servidor que o jogo terminou
            try:
                message = {
                    'type': 'game_finished',
                    'session_id': getattr(netmaster_client, 'session_id', None),
                    'reason': 'time_expired'
                }
                
                if netmaster_client and hasattr(netmaster_client, 'send_message'):
                    netmaster_client.send_message(message)
                    print(f"[GAME_END] Mensagem enviada ao servidor: {message}")
                else:
                    print(f"[GAME_END] ERRO: NetMaster client n√£o dispon√≠vel")
            except Exception as e:
                print(f"[GAME_END] Erro ao notificar servidor: {e}")
        else:
            print(f"[GAME_END] Este jogador √© JOINEE - aguardando instru√ß√µes do servidor")

    def create_session_timer_display(self, parent_widget):
        """Criar display do timer de sess√£o numa interface"""
        import tkinter as tk
        
        # Na tela de espera, sempre mostrar o timer se estivermos em modo multiplayer
        is_waiting_screen = hasattr(self, 'waiting_for_turn') and getattr(self, 'waiting_for_turn', False)
        has_session_data = hasattr(netmaster_client, 'session_data') and netmaster_client.session_data is not None
        
        if not is_waiting_screen:
            # Na interface principal, verificar se timer est√° ativo
            if not (hasattr(self, 'session_timer_active') and self.session_timer_active):
                print(f"[SESSION_TIMER] DEBUG: Timer n√£o est√° ativo ao criar display (interface principal)")
                return
        else:
            # Na tela de espera, sempre mostrar se h√° dados de sess√£o
            if not has_session_data:
                print(f"[SESSION_TIMER] DEBUG: Sem dados de sess√£o na tela de espera")
                return
            print(f"[SESSION_TIMER] DEBUG: Criando timer na tela de espera (modo servidor)")
            
        # Evitar cria√ß√£o duplicada
        if hasattr(self, 'session_timer_label') and self.session_timer_label:
            print(f"[SESSION_TIMER] DEBUG: Timer label j√° existe")
            return
        
        try:
            print(f"[SESSION_TIMER] DEBUG: Criando timer display no parent widget...")
            
            # Criar label do timer SEM EMOJI - TAMANHO REDUZIDO e posicionado acima do nome do jogador
            self.session_timer_label = tk.Label(
                parent_widget,
                text="--:--",
                font=("Arial", 14, "bold"),  # Reduzido de 18 para 14
                fg="#44FF44",
                bg="black"
            )
            
            # Posicionar o timer de forma apropriada dependendo do contexto
            if is_waiting_screen:
                # Na tela de espera, posicionar abaixo da TopBar e acima do nome do jogador
                self.session_timer_label.place(relx=0.5, y=65, anchor="n")  # y=65 para ficar abaixo da TopBar (60px)
                print(f"[SESSION_TIMER] DEBUG: Timer posicionado na tela de espera (y=65)")
            else:
                # Na interface principal, posicionar no topo
                self.session_timer_label.place(relx=0.5, y=0, anchor="n")
                print(f"[SESSION_TIMER] DEBUG: Timer posicionado na interface principal (y=0)")
            
            print(f"[SESSION_TIMER] DEBUG: Display criado com sucesso")
            
            # Atualizar imediatamente
            self.update_timer_display()
            
        except Exception as e:
            print(f"[SESSION_TIMER] Erro ao criar display: {e}")
            import traceback
            traceback.print_exc()
            self.session_timer_label = None
    
    def launch_multiplayer_dashboard(self, session_data=None):
        """Lan√ßar PlayerDashboard para jogo multiplayer"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        # Obter a cor do jogador atual do cliente netmaster
        current_player_color = getattr(netmaster_client, 'player_color', self.host_color.lower())
        current_player_name = getattr(netmaster_client, 'player_name', self.host_name)
        
        print(f"[TARGET] [DASHBOARD] Criando dashboard para: {current_player_name} ({current_player_color})")
        
        # LIMPAR HANDLERS ANTIGOS DO JOIN PROCESS ANTES DE CRIAR DASHBOARD
        print(f"[DASHBOARD_LAUNCH] *** LIMPANDO HANDLERS ANTIGOS DO JOIN ***")
        old_handlers = list(netmaster_client.message_handlers.keys())
        print(f"[DASHBOARD_LAUNCH] Handlers antigos: {old_handlers}")
        print(f"[DASHBOARD_LAUNCH] *** LIMPEZA CR√çTICA: Salvando timer_sync se existir ***")
        timer_sync_handler = netmaster_client.message_handlers.get('timer_sync', None)
        if timer_sync_handler:
            print(f"[DASHBOARD_LAUNCH] ‚úì timer_sync salvo para re-registo")
        else:
            print(f"[DASHBOARD_LAUNCH] ‚úó timer_sync n√£o encontrado para salvar")
        netmaster_client.message_handlers.clear()
        print(f"[DASHBOARD_LAUNCH] ‚úì Handlers antigos limpos")
        
        # CR√çTICO: Re-registrar handlers globais que foram limpos
        print(f"[DASHBOARD_LAUNCH] *** RE-REGISTRANDO HANDLERS GLOBAIS ***")
        for handler_type, handler_func in NetMasterClient._global_handlers.items():
            netmaster_client.message_handlers[handler_type] = handler_func
            print(f"[DASHBOARD_LAUNCH] ‚úì Handler global re-registrado: {handler_type}")
        
        # Criar PlayerDashboard com suporte multiplayer
        dashboard = PlayerDashboard(
            self.root,
            player_color=current_player_color,
            saldo=1000,
            other_players=[c for c in ["red", "green", "blue", "yellow"] if c != current_player_color],
            player_name=current_player_name
        )
        
        # Se temos session_data, configurar informa√ß√µes de multiplayer
        if session_data:
            dashboard.player_order = session_data.get('player_order', [])
            dashboard.current_turn_index = session_data.get('current_turn_index', 0)
            netmaster_client.session_data = session_data
        
        # *** NOVO: TRANSFERIR TIMER PARA O DASHBOARD ***
        # CORRE√á√ÉO: Verificar se h√° timer ativo OU se h√° session_data com dura√ß√£o
        has_active_timer = hasattr(self, 'session_timer_active') and self.session_timer_active
        has_session_time = hasattr(self, 'session_time_remaining') and self.session_time_remaining > 0
        session_data_available = session_data and session_data.get('duration_minutes')
        
        if has_active_timer or has_session_time or session_data_available:
            # Transferir timer existente ou criar novo baseado na sess√£o
            if has_session_time:
                dashboard.session_time_remaining = self.session_time_remaining
                dashboard.session_timer_active = True
                print(f"[SESSION_TIMER] Timer transferido para dashboard: {self.session_time_remaining:.1f}s restantes")
            elif session_data_available:
                # Criar timer baseado na dura√ß√£o da sess√£o se n√£o existe timer ativo
                duration_minutes = session_data.get('duration_minutes', 15)
                dashboard.session_time_remaining = duration_minutes * 60
                dashboard.session_timer_active = True
                print(f"[SESSION_TIMER] Timer criado no dashboard baseado na sess√£o: {duration_minutes} minutos")
            
            # Parar timer no menu e continuar no dashboard
            self.session_timer_active = False
            
            # CORRE√á√ÉO: N√£o iniciar timer local - aguardar updates do servidor
            # dashboard.after(500, lambda: dashboard.update_session_timer()) # REMOVIDO
            print(f"[SESSION_TIMER] Timer transferido para dashboard - aguardando updates do servidor")
        else:
            print(f"[SESSION_TIMER] Nenhum timer ativo para transferir")
    
    def launch_multiplayer_dashboard_waiting(self, current_player_name, current_player_color, session_data):
        """Lan√ßar PlayerDashboard em modo waiting quando n√£o √© o turno do jogador"""
        print(f"[WAITING] [DEBUG] Lan√ßando dashboard em modo waiting")
        print(f"[WAITING] [DEBUG] Jogador atual: {current_player_name} ({current_player_color})")
        
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        # Criar PlayerDashboard com suporte multiplayer
        # Criar objetos de jogadores com base nos dados da sess√£o
        other_players_list = []
        for player_id, player_data in session_data.get('players', {}).items():
            if player_data.get('name') != current_player_name:
                # Criar objeto de jogador simples
                class PlayerInfo:
                    def __init__(self, name, color):
                        self.name = name
                        self.color = color
                other_players_list.append(PlayerInfo(player_data.get('name'), player_data.get('color')))
        
        dashboard = PlayerDashboard(
            self.root,
            player_color=self.host_color.lower(),
            saldo=1000,
            other_players=other_players_list,
            player_name=self.host_name
        )
        
        # For√ßar modo waiting imediatamente
        dashboard.waiting_for_turn = True
        dashboard.current_turn_player_id = session_data.get('current_player_id')
        dashboard.player_order = session_data.get('player_order', [])
        dashboard.current_turn_index = session_data.get('current_turn_index', 0)
        
        # Garantir que o multiplayer_client tenha acesso aos dados da sess√£o
        netmaster_client.session_data = session_data
        
        # *** CRITICAL FIX: REGISTRAR HANDLERS NECESS√ÅRIOS NO DASHBOARD ***
        print(f"[WAITING_DASHBOARD] *** CONFIGURANDO HANDLERS PARA DASHBOARD EM WAITING ***")
        try:
            # LIMPAR HANDLERS ANTIGOS DO JOIN PROCESS PRIMEIRO
            print(f"[WAITING_DASHBOARD] *** LIMPANDO HANDLERS ANTIGOS DO JOIN ***")
            old_handlers = list(netmaster_client.message_handlers.keys())
            print(f"[WAITING_DASHBOARD] Handlers antigos: {old_handlers}")
            print(f"[WAITING_DASHBOARD] *** LIMPEZA CR√çTICA: Salvando timer_sync se existir ***")
            timer_sync_handler = netmaster_client.message_handlers.get('timer_sync', None)
            if timer_sync_handler:
                print(f"[WAITING_DASHBOARD] ‚úì timer_sync salvo para re-registo")
            else:
                print(f"[WAITING_DASHBOARD] ‚úó timer_sync n√£o encontrado para salvar")
            netmaster_client.message_handlers.clear()
            print(f"[WAITING_DASHBOARD] ‚úì Handlers antigos limpos")
            
            # CR√çTICO: Re-registrar handlers globais que foram limpos
            print(f"[WAITING_DASHBOARD] *** RE-REGISTRANDO HANDLERS GLOBAIS ***")
            for handler_type, handler_func in NetMasterClient._global_handlers.items():
                netmaster_client.message_handlers[handler_type] = handler_func
                print(f"[WAITING_DASHBOARD] ‚úì Handler global re-registrado: {handler_type}")
            
            # FOR√áA REGISTO DOS HANDLERS CR√çTICOS PARA TURN MANAGEMENT
            print(f"[WAITING_DASHBOARD] *** FOR√áANDO REGISTO DE HANDLERS CR√çTICOS ***")
            netmaster_client.set_message_handler('turn_changed', dashboard.on_multiplayer_turn_changed)
            netmaster_client.set_message_handler('player_joined', dashboard.on_player_joined)
            netmaster_client.set_message_handler('player_left', dashboard.on_player_left)
            netmaster_client.set_message_handler('heartbeat_ack', dashboard.on_heartbeat_ack)
            # CORRE√á√ÉO: Adicionar handler timer_sync para sincroniza√ß√£o do timer
            netmaster_client.set_message_handler('timer_sync', dashboard.on_timer_sync)
            # CR√çTICO: Adicionar handler pending_cards localmente
            netmaster_client.set_message_handler('pending_cards', dashboard.on_pending_cards_received)
            
            # Manter handlers universais
            if hasattr(self, 'on_any_message_debug'):
                netmaster_client.set_message_handler('ALL_MESSAGES_DEBUG', self.on_any_message_debug)
            
            print(f"[WAITING_DASHBOARD] *** HANDLERS CONFIGURADOS COM SUCESSO ***")
            print(f"[WAITING_DASHBOARD] Handlers ativos ap√≥s registo: {list(netmaster_client.message_handlers.keys())}")
            
            # VERIFICA√á√ÉO IMEDIATA - handlers est√£o mesmo registados?
            if 'turn_changed' in netmaster_client.message_handlers:
                print(f"[WAITING_DASHBOARD] ‚úì turn_changed handler CONFIRMADO")
            else:
                print(f"[WAITING_DASHBOARD] ‚ùå ERROR: turn_changed handler N√ÉO REGISTADO!")
                
            if 'pending_cards' in netmaster_client.message_handlers:
                print(f"[WAITING_DASHBOARD] ‚úì pending_cards handler CONFIRMADO")
            else:
                print(f"[WAITING_DASHBOARD] ‚ùå ERROR: pending_cards handler N√ÉO REGISTADO!")
                
        except Exception as e:
            print(f"[WAITING_DASHBOARD] ERRO ao configurar handlers: {e}")
        
        # RE-REGISTAR HANDLERS AP√ìS UM DELAY PARA GARANTIR
        def reregister_handlers():
            try:
                print(f"[WAITING_DASHBOARD] *** RE-REGISTO DE SEGURAN√áA DOS HANDLERS ***")
                netmaster_client.set_message_handler('turn_changed', dashboard.on_multiplayer_turn_changed)
                netmaster_client.set_message_handler('player_joined', dashboard.on_player_joined)
                netmaster_client.set_message_handler('player_left', dashboard.on_player_left)
                netmaster_client.set_message_handler('heartbeat_ack', dashboard.on_heartbeat_ack)
                # CORRE√á√ÉO: Adicionar handler timer_sync no re-registo tamb√©m
                netmaster_client.set_message_handler('timer_sync', dashboard.on_timer_sync)
                # CR√çTICO: Adicionar handler pending_cards no re-registo tamb√©m
                netmaster_client.set_message_handler('pending_cards', dashboard.on_pending_cards_received)
                print(f"[WAITING_DASHBOARD] ‚úì Handlers re-registados com sucesso!")
                print(f"[WAITING_DASHBOARD] Handlers finais: {list(netmaster_client.message_handlers.keys())}")
            except Exception as e:
                print(f"[WAITING_DASHBOARD] ERRO no re-registo: {e}")
        
        # Re-registar ap√≥s 100ms para garantir
        self.root.after(100, reregister_handlers)
        
        # Mostrar tela de waiting imediatamente
        dashboard.show_waiting_for_turn_screen(current_player_name, current_player_color)
    
    def leave_session(self):
        """Sair da sess√£o atual"""
        def leave():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                if netmaster_client.connected:
                    loop.run_until_complete(netmaster_client.disconnect())
                
            except Exception as e:
                print(f"[ERROR] Erro ao sair: {e}")
        
        threading.Thread(target=leave, daemon=True).start()
        
        # Voltar ao menu principal
        self.show_main_menu()
    
    def show_waiting_for_turn(self):
        """Mostra tela de espera pela vez de jogar"""
        print(f"[RELOAD] [FALLBACK] Mostrando 'Waiting for your turn to play...'")
        
        # Limpar tela
        for widget in self.root.winfo_children():
            widget.destroy()
        
        # Obter dimens√µes da tela
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        self.root.geometry(f"{screen_width}x{screen_height}+0+0")
        self.root.configure(bg="black")
        
        # Adicionar decora√ß√µes de rede
        self.add_network_pattern_decorations(self.root)
        
        # TopBar com cor do jogador
        topbar_color = self.player_color if hasattr(self, 'player_color') else 'red'
        topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{topbar_color}.png")
        try:
            topbar_img = Image.open(topbar_img_path)
            topbar_img = topbar_img.resize((screen_width, 80), Image.Resampling.LANCZOS)
            topbar_photo = ImageTk.PhotoImage(topbar_img)
            topbar_label = tk.Label(self.root, image=topbar_photo, bg="black")
            topbar_label.image = topbar_photo
            topbar_label.place(x=0, y=0, width=screen_width, height=80)
        except Exception as e:
            print(f"Erro ao carregar TopBar: {e}")
            # Fallback com cor s√≥lida
            topbar_fallback = tk.Frame(self.root, bg=topbar_color, height=80)
            topbar_fallback.place(x=0, y=0, width=screen_width, height=80)
        
        # Saldo e picoin no canto superior direito
        saldo_value = getattr(self, 'saldo', 1000)
        try:
            coin_img = Image.open(COIN_IMG)
            coin_img = coin_img.resize((40, 40), Image.Resampling.LANCZOS)
            coin_photo = ImageTk.PhotoImage(coin_img)
            
            # Frame para saldo
            saldo_frame = tk.Frame(self.root, bg="black")
            saldo_frame.place(x=screen_width-200, y=10, width=180, height=60)
            
            # √çcone da moeda
            coin_label = tk.Label(saldo_frame, image=coin_photo, bg="black")
            coin_label.image = coin_photo
            coin_label.pack(side=tk.RIGHT, padx=(10, 10))
            
            # Texto do saldo
            saldo_label = tk.Label(
                saldo_frame,
                text=str(saldo_value),
                font=("Helvetica", 24, "bold"),
                fg="white",
                bg="black"
            )
            saldo_label.pack(side=tk.RIGHT, padx=(0, 5))
            
        except Exception as e:
            print(f"Erro ao carregar coin/saldo: {e}")
            # Fallback sem imagem
            saldo_label = tk.Label(
                self.root,
                text=f"Saldo: {saldo_value}",
                font=("Helvetica", 20, "bold"),
                fg="white",
                bg="black"
            )
            saldo_label.place(x=screen_width-180, y=20)
        
        # √çcones dos outros jogadores no canto superior esquerdo
        try:
            if hasattr(self, 'other_players') and self.other_players:
                icons_frame = tk.Frame(self.root, bg="black")
                icons_frame.place(x=20, y=10, width=300, height=60)
                
                x_offset = 0
                for i, player in enumerate(self.other_players):
                    if i >= 3:  # M√°ximo 3 √≠cones para n√£o sobrecarregar
                        break
                    
                    # Buscar √≠cone do jogador por cor
                    if isinstance(player, str):
                        # player √© uma string de cor
                        player_color = player
                        player_name = f"Player {i+1}"
                    else:
                        # player √© um objeto com atributos color e name
                        player_color = player.color if hasattr(player, 'color') else 'red'
                        player_name = player.name if hasattr(player, 'name') else f"Player {i+1}"
                    icon_path = os.path.join(IMG_DIR, f"{player_color}_user_icon.png")
                    
                    try:
                        icon_img = Image.open(icon_path)
                        icon_img = icon_img.resize((50, 50), Image.Resampling.LANCZOS)
                        icon_photo = ImageTk.PhotoImage(icon_img)
                        
                        icon_label = tk.Label(icons_frame, image=icon_photo, bg="black")
                        icon_label.image = icon_photo
                        icon_label.place(x=x_offset, y=5)
                        
                        # Nome do jogador abaixo do √≠cone
                        name_label = tk.Label(
                            icons_frame,
                            text=player_name[:8],  # Limitar tamanho do nome
                            font=("Helvetica", 10),
                            fg="white",
                            bg="black"
                        )
                        name_label.place(x=x_offset, y=55)
                        
                        x_offset += 70
                        
                    except Exception as e:
                        print(f"Erro ao carregar √≠cone do jogador {player_color}: {e}")
                        
        except Exception as e:
            print(f"Erro ao criar √≠cones de outros jogadores: {e}")
        
        # Container principal para conte√∫do central
        main_frame = tk.Frame(self.root, bg="black")
        main_frame.place(x=0, y=100, width=screen_width, height=screen_height-100)
        
        # T√≠tulo
        title_label = tk.Label(
            main_frame,
            text="NetMaster",
            font=("Helvetica", 32, "bold"),
            fg="white",
            bg="black"
        )
        title_label.pack(pady=50)
        
        # Mensagem de espera
        wait_label = tk.Label(
            main_frame,
            text="Waiting for your turn to play...",
            font=("Helvetica", 24),
            fg="#00ff00",
            bg="black"
        )
        wait_label.pack(pady=30)
        
        # Anima√ß√£o de dots
        self.waiting_animation_active = True
        
        def animate_waiting_dots():
            if hasattr(self, 'waiting_animation_active') and self.waiting_animation_active:
                try:
                    if wait_label.winfo_exists():
                        current_text = wait_label.cget("text")
                        if current_text.endswith("..."):
                            wait_label.config(text="Waiting for your turn to play")
                        elif current_text.endswith(".."):
                            wait_label.config(text="Waiting for your turn to play...")
                        elif current_text.endswith("."):
                            wait_label.config(text="Waiting for your turn to play..")
                        else:
                            wait_label.config(text="Waiting for your turn to play.")
                        
                        self.root.after(500, animate_waiting_dots)
                except:
                    self.waiting_animation_active = False
        
        # Iniciar anima√ß√£o
        animate_waiting_dots()
        
        # Bot√£o para voltar ao menu
        back_button = tk.Button(
            main_frame,
            text="Back to Menu",
            font=("Helvetica", 16),
            bg="#333333",
            fg="white",
            command=self.show_main_menu,
            padx=20,
            pady=10
        )
        back_button.pack(pady=50)
    
    def cancel_connection(self, name):
        """Cancelar conex√£o e voltar ao menu"""
        self.loading_animation_active = False
        
        # Desconectar se necess√°rio
        def disconnect():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                
                if netmaster_client.connected:
                    loop.run_until_complete(netmaster_client.disconnect())
                    
            except Exception as e:
                print(f"[ERROR] Erro ao desconectar: {e}")
        
        threading.Thread(target=disconnect, daemon=True).start()
        
        # Voltar √† sele√ß√£o de tipo de jogo (sempre do fluxo search)
        self.show_game_type_page_search(name)

    def start_selected_game(self, color, name, game_type):
        """Iniciar jogo ap√≥s todas as sele√ß√µes"""
        self.host_color = color
        self.host_name = name
        self.jogador = MenuPlayer(self.host_name, self.host_color.lower(), START_POSITIONS[self.host_color.lower()])
        
        if game_type == "local":
            # Para Local Game, conectar ao servidor e criar sess√£o multiplayer
            self.show_connection_loading(name, game_type)
        else:
            # Para Remote Game ou outros tipos, lan√ßar PlayerDashboard diretamente
            self.launch_player_dashboard(game_type)

    def is_session_host(self):
        """Verificar se este jogador √© o Host da sess√£o"""
        try:
            # Verificar se h√° session_data
            if not hasattr(netmaster_client, 'session_data') or not netmaster_client.session_data:
                return False
                
            session_data = netmaster_client.session_data
            my_player_id = getattr(netmaster_client, 'player_id', None)
            host_id = session_data.get('host_player_id', None)  # CORRE√á√ÉO: usar host_player_id
            
            is_host = (my_player_id == host_id)
            print(f"[SESSION_TIMER] Verifica√ß√£o Host: my_id={my_player_id}, host_id={host_id}, is_host={is_host}")
            
            return is_host
        except Exception as e:
            print(f"[SESSION_TIMER] Erro ao verificar se √© Host: {e}")
            return False
    
    def send_timer_sync(self):
        """Enviar sincroniza√ß√£o do timer para todos os jogadores (apenas Host)"""
        try:
            if 'netmaster_client' in globals() and netmaster_client:
                sync_data = {
                    'type': 'timer_sync',
                    'time_remaining': self.session_time_remaining,
                    'timer_active': self.session_timer_active,
                    'timestamp': time.time()
                }
                
                print(f"[TIMER_SYNC] HOST enviando: {self.session_time_remaining:.1f}s")
                
                # Enviar a mensagem de forma ass√≠ncrona
                async def send_async():
                    try:
                        await netmaster_client.send_message(sync_data)
                        print(f"[TIMER_SYNC] ‚úì Mensagem timer_sync enviada com sucesso")
                    except Exception as e:
                        print(f"[TIMER_SYNC] ‚úó Erro ao enviar timer_sync: {e}")
                
                # Executar de forma ass√≠ncrona
                asyncio.create_task(send_async())
                
        except Exception as e:
            print(f"[TIMER_SYNC] Erro ao enviar sincroniza√ß√£o: {e}")
    
    def on_timer_sync(self, data):
        """Handler para sincroniza√ß√£o do timer de sess√£o - apenas aceita atualiza√ß√µes do servidor"""
        try:
            # Verificar se a atualiza√ß√£o vem do servidor
            source = data.get('source')
            if source != 'server':
                print(f"[TIMER_SYNC] Ignorando timer_sync n√£o-servidor (source: {source})")
                return
            
            # Receber atualiza√ß√£o do timer do servidor
            time_remaining = data.get('time_remaining', 0)
            
            print(f"[TIMER_SYNC] Recebida atualiza√ß√£o do timer do SERVIDOR: {time_remaining:.1f}s")
            
            # Atualizar estado local do timer (mas n√£o executar countdown pr√≥prio)
            self.session_time_remaining = time_remaining
            self.session_timer_active = True  # Timer sempre ativo se vem do servidor
            
            # Atualizar display imediatamente se existir
            if hasattr(self, 'session_timer_label') and self.session_timer_label:
                self.update_timer_display()
                
        except Exception as e:
            print(f"[TIMER_SYNC] Erro ao processar sincroniza√ß√£o do timer: {e}")

    def launch_player_dashboard(self, game_type):
        """Lan√ßar o PlayerDashboard"""
        # Limpar root
        for widget in self.root.winfo_children():
            widget.destroy()
        
        # Criar PlayerDashboard
        PlayerDashboard(
            self.root,
            player_color=self.host_color.lower(),
            saldo=1000,
            other_players=[c for c in ["red", "green", "blue", "yellow"] if c != self.host_color.lower()],
            player_name=self.host_name
        )

class PlayerDashboard(tk.Toplevel):
    def __init__(self, root, player_color, saldo, other_players, player_name="Player", selected_card_idx=0):
        super().__init__(root)
        self.player_color = player_color 
        self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        self.selected_card_idx = selected_card_idx
        self.progress_bars = {}
        self.title("")
        self.configure(bg="black")
        self.player_name = player_name
        self.saldo = saldo
        self.other_players = other_players
        self.card_idx = 0

        # Garantir flags de intera√ß√£o desbloqueadas ao iniciar um novo turno/interface
        self._final_phase_active = False
        self._next_phase_active = False
        self._final_phase_gestao_ativa = False
        
        # Flags para controlar quando carta foi removida e pr√≥xima deve ficar virada para baixo
        self._action_recently_removed = False
        self._event_recently_removed = False
        
        # Vari√°veis para controlar a casa atual (para o bot√£o Store)
        self.current_casa_tipo = "neutral"
        self.current_casa_cor = "neutral"
        self.current_other_player_house = False  # Se est√° numa casa de outro jogador
        
        self.cards = [
        # Carrossel inicial: cartas viradas para baixo, cor do jogador
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        ]
        self.card_stats = [
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
        ]
        
        # NOVA FUNCIONALIDADE: Sistema de flags para rastrear estado das cartas no carrossel
        # True = carta virada para cima (ativa), False = carta virada para baixo (inativa/back_card)
        self.card_face_up_flags = [False, False, False, False]
        print(f"DEBUG: [INIT] Sistema de flags de cartas inicializado: {self.card_face_up_flags}")
        
        # CORRE√á√ÉO: Restaurar estat√≠sticas preservadas do turno anterior (se existirem)
        if hasattr(root, '_backup_card_stats') and hasattr(root, '_backup_cards'):
            print("DEBUG: [INIT] Encontradas estat√≠sticas preservadas do turno anterior")
            
            # Restaurar estat√≠sticas
            if len(root._backup_card_stats) == len(self.card_stats):
                for i, backup_stats in enumerate(root._backup_card_stats):
                    self.card_stats[i] = {
                        'To send': backup_stats['To send'],
                        'Rxd': backup_stats['Rxd'],
                        'Lost': backup_stats['Lost']
                    }
                    print(f"DEBUG: [INIT] Carta {i} estat√≠sticas restauradas: To send={backup_stats['To send']}, Rxd={backup_stats['Rxd']}, Lost={backup_stats['Lost']}")
            
            # Restaurar caminhos das cartas
            if len(root._backup_cards) == len(self.cards):
                for i, backup_path in enumerate(root._backup_cards):
                    self.cards[i] = backup_path
                    print(f"DEBUG: [INIT] Carta {i} path restaurado: {os.path.basename(backup_path) if backup_path else 'None'}")
            
            # CORRE√á√ÉO CR√çTICA: Restaurar mapeamento de Activities preservadas
            if hasattr(root, '_activity_preserved_stats'):
                self._activity_preserved_stats = root._activity_preserved_stats.copy()
                print(f"DEBUG: [INIT] Mapeamento de Activities preservadas restaurado: {len(self._activity_preserved_stats)} entries")
                for activity_path, stats in self._activity_preserved_stats.items():
                    print(f"DEBUG: [INIT] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # N√£o limpar j√° aqui: ser√£o atualizados no end_turn e preservados entre interfaces
            print("DEBUG: [INIT] Backups preservados para consist√™ncia entre interfaces")
        else:
            print("DEBUG: [INIT] Nenhuma estat√≠stica preservada encontrada - usando valores padr√£o")
        
        self.inventario = {
            "users": [],
            "equipments": [],
            "services": [],
            "actions": [],
            "events": [],
            "challenges": [], 
            "activities": [],
        }

        # CORRE√á√ÉO CR√çTICA: Inicializar carrossel para evitar erros em adicionar_carta_carrossel
        self.carrossel = []
        print("DEBUG: [INIT] self.carrossel inicializado como lista vazia")

        # Vari√°vel para controlar se o bot√£o Store deve estar desabilitado
        self._store_button_disabled = False
        
        # Vari√°vel para controlar se um Challenge foi aceite (esconde Next Phase)
        self._challenge_accepted = False
        
        # Inicializar base de dados integrada para valores das cartas
        try:
            if IntegratedCardDatabase:
                self.card_database = IntegratedCardDatabase(".")
                print("DEBUG: Base de dados de cartas inicializada com sucesso")
            else:
                self.card_database = None
                print("DEBUG: Base de dados de cartas n√£o dispon√≠vel")
        except Exception as e:
            print(f"DEBUG: ERRO ao inicializar base de dados: {e}")
            self.card_database = None
        
        # Vari√°vel para controlar se Next Phase est√° ativo (desabilita vendas)
        self._next_phase_active = False
        
        # Vari√°vel para controlar se Next Phase foi ativado manualmente pelo jogador (esconde bot√£o Store)
        self._next_phase_manually_activated = False
        
        # Vari√°vel para controlar se Final Phase est√° ativo (bloqueia ativa√ß√£o/desativa√ß√£o de cartas)
        self._final_phase_active = False
        
        # Vari√°vel para controlar se o bot√£o End Turn deve ser mostrado (s√≥ ap√≥s clicar Final Phase)
        self._show_end_turn_button = False
        
        # NOVA VARI√ÅVEL: Flag para controlar se Final Phase foi clicado NESTE turno espec√≠fico
        # Evita restaura√ß√£o autom√°tica de gest√£o de pacotes em turnos subsequentes
        self._final_phase_clicked_this_turn = False
        
        # NOVO: ID do turno em que Final Phase foi clicado (para evitar cross-turn contamination)
        self._final_phase_turn_id = None

        # SISTEMA DE CONTROLE DE RATE_MAX POR TURNO
        # Vari√°veis que resetam a cada turno para controlar quantos pacotes foram processados
        self._rxd_processed_this_turn = {}    # {carta_path: quantidade_processada}
        self._lost_processed_this_turn = {}   # {carta_path: quantidade_processada}
        self._current_turn_id = 1             # ID do turno atual para controle

        # PROTE√á√ÉO CONTRA LOOP: Flag para evitar abrir invent√°rio recursivamente
        self._inventory_opening = False
        
        # Flag para controlar se overlay de completion est√° ativo
        self._completion_overlay_active = False
        
        # Cache de User IDs para controlo do carrossel durante Next Phase
        self._cached_user_ids = []

        # SISTEMA DE TRACKING TEMPORAL PARA CHALLENGES
        # CORRE√á√ÉO CR√çTICA: N√£o inicializar vazio se j√° existe tracking preservado
        # Isto evita perder o tracking durante reconstru√ß√µes da interface
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}  # {carta_path: turno_inicio}
            print(f"DEBUG: [CHALLENGE_INIT] Challenge tracking inicializado vazio")
        else:
            print(f"DEBUG: [CHALLENGE_INIT] Challenge tracking j√° existe: {self._challenge_start_turns}")
        
        # SUPER BACKUP CR√çTICO: Sistema de backup m√∫ltiplas camadas para Raspberry Pi
        # Garante que o tracking nunca seja perdido, independentemente do ambiente
        if not hasattr(self.master, '_super_challenge_backup'):
            self.master._super_challenge_backup = {}
            print("DEBUG: [SUPER_BACKUP] Super backup inicializado no master")
        if not hasattr(root, '_super_challenge_backup'):
            root._super_challenge_backup = {}
            print("DEBUG: [SUPER_BACKUP] Super backup inicializado no root")
        
        # Backup global adicional (para casos extremos)
        if not hasattr(self, '_challenge_backup_registry'):
            self._challenge_backup_registry = {}
            print("DEBUG: [SUPER_BACKUP] Backup registry inicializado na inst√¢ncia")
        
        # SISTEMA DE TRACKING DE INTERA√á√ïES DO JOGADOR COM CARTAS
        # Registra quando jogador clica em bot√µes +, independente dos valores escolhidos
        self._cartas_interagidas_jogador = set()  # {carta_path} - cartas que tiveram intera√ß√£o do jogador
        
        # CORRE√á√ÉO CR√çTICA: Flag para controlar incrementa√ß√£o de turnos
        self._coming_from_end_turn = False  # True apenas quando vindo de end_turn
        
        # CORRE√á√ÉO CR√çTICA: Preservar contadores de turnos entre sess√µes
        # Restaurar contadores de turnos preservados ou inicializar em 1
        
        # Detectar ambiente para debug espec√≠fico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        print(f"DEBUG: [TURN_INIT] ======= INICIALIZA√á√ÉO DOS CONTADORES DE TURNO =======")
        print(f"DEBUG: [TURN_INIT] AMBIENTE: {ambiente}")
        print(f"DEBUG: [TURN_INIT] Universal paths: {universal_paths}")
        print(f"DEBUG: [TURN_INIT] Verificando se h√° contadores preservados no root...")
        print(f"DEBUG: [TURN_INIT] Root object: {root}")
        print(f"DEBUG: [TURN_INIT] Root type: {type(root)}")
        print(f"DEBUG: [TURN_INIT] hasattr(root, '_backup_turn_counters'): {hasattr(root, '_backup_turn_counters')}")
        if hasattr(root, '_backup_turn_counters'):
            print(f"DEBUG: [TURN_INIT] _backup_turn_counters found: {root._backup_turn_counters}")
        print(f"DEBUG: [TURN_INIT] hasattr(root, '_backup_challenge_tracking'): {hasattr(root, '_backup_challenge_tracking')}")
        if hasattr(root, '_backup_challenge_tracking'):
            print(f"DEBUG: [TURN_INIT] _backup_challenge_tracking found: {root._backup_challenge_tracking}")
        
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            print(f"DEBUG: [TURN_INIT] Contadores encontrados: {backup_counters}")
            self._current_turn_number = backup_counters.get('_current_turn_number', 1)
            self._current_turn = backup_counters.get('_current_turn', 1)
            self._current_turn_id = backup_counters.get('_current_turn_id', 1)
            print(f"DEBUG: [TURN_RESTORE] Contadores de turnos restaurados:")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_number (Challenges): {self._current_turn_number}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn (Events): {self._current_turn}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_id (Processing): {self._current_turn_id}")
            
            # CORRE√á√ÉO CR√çTICA: Restaurar tracking de Challenges do backup de reconstru√ß√£o
            print(f"DEBUG: [CHALLENGE_TRACKING] === RESTAURANDO TRACKING DE CHALLENGES DO BACKUP ===")
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking atual na inst√¢ncia: {getattr(self, '_challenge_start_turns', {})}")
            backup_challenge_tracking = backup_counters.get('_challenge_start_turns', {})
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking encontrado no backup: {backup_challenge_tracking}")
            
            # PRIORIDADE: Se j√° h√° tracking na inst√¢ncia atual, preservar e mesclar com backup
            if hasattr(self, '_challenge_start_turns') and self._challenge_start_turns:
                print(f"DEBUG: [CHALLENGE_TRACKING] PRESERVANDO tracking existente na inst√¢ncia")
                # Mesclar backup com tracking existente (existente tem prioridade)
                for path, turn in backup_challenge_tracking.items():
                    if path not in self._challenge_start_turns:
                        self._challenge_start_turns[path] = turn
                        print(f"DEBUG: [CHALLENGE_TRACKING] Adicionado do backup: {os.path.basename(path)} -> turno {turn}")
                    else:
                        print(f"DEBUG: [CHALLENGE_TRACKING] Preservado existente: {os.path.basename(path)} -> turno {self._challenge_start_turns[path]}")
            else:
                # Se n√£o h√° tracking existente, restaurar do backup
                self._challenge_start_turns = backup_challenge_tracking.copy()
                print(f"DEBUG: [CHALLENGE_TRACKING] Tracking restaurado do backup: {self._challenge_start_turns}")
            
            # CORRE√á√ÉO CR√çTICA: Restaurar turnos reais de Services do backup
            backup_service_turns = backup_counters.get('_service_real_activation_turns', {})
            print(f"DEBUG: [SERVICE_TRACKING] === RESTAURANDO TURNOS REAIS DE SERVICES DO BACKUP ===")
            print(f"DEBUG: [SERVICE_TRACKING] Turnos reais encontrados no backup: {backup_service_turns}")
            
            if backup_service_turns:
                self._service_real_activation_turns = backup_service_turns.copy()
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais de Services restaurados: {self._service_real_activation_turns}")
                for path, turn in self._service_real_activation_turns.items():
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(path)} -> turno real {turn}")
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Nenhum turno real de Service encontrado no backup")
            
            # CORRE√á√ÉO CR√çTICA: Sincronizar root._backup_challenge_tracking ap√≥s restaurar
            if self._challenge_start_turns:
                root._backup_challenge_tracking = self._challenge_start_turns.copy()
                print(f"DEBUG: [CHALLENGE_TRACKING] root._backup_challenge_tracking sincronizado: {self._challenge_start_turns}")
                print(f"DEBUG: [CHALLENGE_TRACKING] NOTA: Limpeza √≥rf√£ ser√° executada no pr√≥ximo reset de turno")
        else:
            self._current_turn_number = 1     # Contador de turnos do jogador
            self._current_turn = 1           # Contador de turnos para o sistema de Events (come√ßa em 1)
            self._current_turn_id = 1        # ID do turno atual para controle
            print(f"DEBUG: [TURN_INIT] Contadores de turnos inicializados em 1 (primeiro jogo)")
            
            # CORRE√á√ÉO CR√çTICA: Inicializar turnos reais de Services vazios se n√£o h√° backup
            print(f"DEBUG: [SERVICE_TRACKING] === INICIALIZANDO TURNOS REAIS DE SERVICES (SEM BACKUP) ===")
            if not hasattr(self, '_service_real_activation_turns'):
                self._service_real_activation_turns = {}
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais de Services inicializados vazios")
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais j√° existem: {self._service_real_activation_turns}")
            
            # CORRE√á√ÉO CR√çTICA: Restaurar tracking de Challenges se existir no root (n√£o backup)
            print(f"DEBUG: [CHALLENGE_TRACKING] === RESTAURANDO TRACKING DE CHALLENGES (SEM BACKUP) ===")
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking atual na inst√¢ncia: {getattr(self, '_challenge_start_turns', {})}")
            
            # PRIORIDADE: Se j√° h√° tracking na inst√¢ncia atual, preservar
            if hasattr(self, '_challenge_start_turns') and self._challenge_start_turns:
                print(f"DEBUG: [CHALLENGE_TRACKING] PRESERVANDO tracking existente na inst√¢ncia: {self._challenge_start_turns}")
                # Ainda assim verificar se h√° backup no root para mesclar
                if hasattr(root, '_backup_challenge_tracking'):
                    root_backup = root._backup_challenge_tracking
                    print(f"DEBUG: [CHALLENGE_TRACKING] Mesclando com backup do root: {root_backup}")
                    for path, turn in root_backup.items():
                        if path not in self._challenge_start_turns:
                            self._challenge_start_turns[path] = turn
                            print(f"DEBUG: [CHALLENGE_TRACKING] Adicionado do root: {os.path.basename(path)} -> turno {turn}")
            else:
                # Se n√£o h√° tracking existente, tentar restaurar do root
                if hasattr(root, '_backup_challenge_tracking'):
                    self._challenge_start_turns = root._backup_challenge_tracking.copy()
                    print(f"DEBUG: [CHALLENGE_TRACKING] Tracking restaurado do root: {self._challenge_start_turns}")
                else:
                    self._challenge_start_turns = {}
                    print(f"DEBUG: [CHALLENGE_TRACKING] Nenhum tracking encontrado - inicializando vazio")
            
        print(f"DEBUG: [TURN_INIT] ======= CONTADORES FINAIS =======")
        print(f"DEBUG: [TURN_INIT] _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [TURN_INIT] _current_turn: {self._current_turn}")
        print(f"DEBUG: [TURN_INIT] _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [TURN_INIT] _challenge_start_turns: {self._challenge_start_turns}")
        print(f"DEBUG: [TURN_INIT] ======= FIM INICIALIZA√á√ÉO =======")
        
        # SISTEMA DE TRACKING TEMPORAL PARA EVENTS
        # CORRE√á√ÉO CR√çTICA: Restaurar tracking de Events do backup se existir
        print(f"DEBUG: [EVENT_TRACKING] === INICIALIZANDO TRACKING DE EVENTS ===")
        
        # Inicializar estruturas b√°sicas
        self._event_start_turns = {}     # {carta_path: turno_inicio}
        self._event_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # NOVO: Sistema de backup para Events (similar aos Challenges)
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            
            # Restaurar tracking de Events do backup
            backup_event_tracking = backup_counters.get('_event_duration_tracking', {})
            backup_event_start_turns = backup_counters.get('_event_start_turns', {})
            
            print(f"DEBUG: [EVENT_TRACKING] Tracking de Events encontrado no backup:")
            print(f"DEBUG: [EVENT_TRACKING]   _event_duration_tracking: {backup_event_tracking}")
            print(f"DEBUG: [EVENT_TRACKING]   _event_start_turns: {backup_event_start_turns}")
            
            if backup_event_tracking:
                self._event_duration_tracking = backup_event_tracking.copy()
                print(f"DEBUG: [EVENT_TRACKING] ‚úì _event_duration_tracking restaurado do backup")
                
                # Log detalhado do tracking restaurado
                for path, tracking in self._event_duration_tracking.items():
                    print(f"DEBUG: [EVENT_TRACKING]   {os.path.basename(path)}:")
                    print(f"DEBUG: [EVENT_TRACKING]     start_turn: {tracking.get('start_turn')}")
                    print(f"DEBUG: [EVENT_TRACKING]     duration_turns: {tracking.get('duration_turns')}")
                    print(f"DEBUG: [EVENT_TRACKING]     expires_turn: {tracking.get('expires_turn')}")
                    print(f"DEBUG: [EVENT_TRACKING]     is_active: {tracking.get('is_active')}")
            
            if backup_event_start_turns:
                self._event_start_turns = backup_event_start_turns.copy()
                print(f"DEBUG: [EVENT_TRACKING] ‚úì _event_start_turns restaurado do backup")
        else:
            print(f"DEBUG: [EVENT_TRACKING] Nenhum backup encontrado - tracking inicializado vazio")
        
        # SISTEMA DE TRACKING TEMPORAL PARA SERVICES TEMPORARY
        self._service_start_turns = {}   # {carta_path: turno_inicio}
        self._service_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # NOVO: SISTEMA DE PRESERVA√á√ÉO DO TURNO REAL DE ATIVA√á√ÉO DE SERVICES
        # Esta vari√°vel preserva o turno em que o Service foi REALMENTE ativado pelo jogador
        # Diferente de _service_start_turns que pode ser recriado durante reconstru√ß√µes da interface
        self._service_real_activation_turns = {}  # {carta_path: turno_real_de_ativacao}
        
        # SUPER BACKUP CR√çTICO PARA SERVICES (similar aos Challenges)
        # Garante que o tracking de Services nunca seja perdido durante reconstru√ß√µes
        if not hasattr(self.master, '_super_service_backup'):
            self.master._super_service_backup = {}
        if not hasattr(root, '_super_service_backup'):
            root._super_service_backup = {}
        
        # Backup global adicional para Services (para casos extremos)
        if not hasattr(self, '_service_backup_registry'):
            self._service_backup_registry = {}
        
        # Restaurar tracking de Services consolidado de m√∫ltiplos backups
        print(f"DEBUG: [SERVICE_TRACKING] === INICIALIZANDO TRACKING ROBUSTO DE SERVICES ===")
        
        # Consolidar Services de todos os backups tempor√°rios
        service_tracking_consolidado = {}
        service_duration_consolidado = {}
        
        # 1. Backup imediato do master
        if hasattr(self.master, '_service_tracking_backup_imediato'):
            backup_data = self.master._service_tracking_backup_imediato
            if backup_data:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando do master_imediato: {len(backup_data)} itens")
                service_tracking_consolidado.update(backup_data)
        
        # 2. Backup do root
        if hasattr(root, '_backup_service_tracking'):
            backup_data = root._backup_service_tracking
            if backup_data:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando do root_backup: {len(backup_data)} itens")
                service_tracking_consolidado.update(backup_data)
        
        # 3. Backup de duration tracking
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            backup_service_duration = backup_counters.get('_service_duration_tracking', {})
            if backup_service_duration:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando duration tracking: {len(backup_service_duration)} itens")
                service_duration_consolidado.update(backup_service_duration)
        
        # Aplicar consolida√ß√£o
        if service_tracking_consolidado:
            self._service_start_turns = service_tracking_consolidado.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ‚úì Service tracking consolidado restaurado: {len(self._service_start_turns)} itens")
        
        if service_duration_consolidado:
            self._service_duration_tracking = service_duration_consolidado.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ‚úì Service duration tracking consolidado restaurado: {len(self._service_duration_tracking)} itens")
        
        # Sincronizar backup principal
        if service_tracking_consolidado or service_duration_consolidado:
            root._backup_service_tracking = self._service_start_turns.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ‚úì Backup principal de Services sincronizado")
        
        print(f"DEBUG: [SERVICE_TRACKING] === FIM INICIALIZA√á√ÉO ROBUSTA DE SERVICES ===")
        
        # SUPER BACKUP CR√çTICO PARA EVENTS (similar aos Challenges)
        # Garante que o tracking de Events nunca seja perdido durante reconstru√ß√µes
        if not hasattr(self.master, '_super_event_backup'):
            self.master._super_event_backup = {}
        if not hasattr(root, '_super_event_backup'):
            root._super_event_backup = {}
        
        # Backup global adicional para Events (para casos extremos)
        if not hasattr(self, '_event_backup_registry'):
            self._event_backup_registry = {}
        
        # Consolidar Events de todos os backups tempor√°rios
        event_tracking_consolidado = {}
        event_duration_consolidado = {}
        
        print(f"DEBUG: [EVENT_TRACKING] === MELHORANDO TRACKING ROBUSTO DE EVENTS ===")
        
        # 1. Backup imediato do master
        if hasattr(self.master, '_event_tracking_backup_imediato'):
            backup_data = self.master._event_tracking_backup_imediato
            if backup_data:
                print(f"DEBUG: [EVENT_TRACKING] Consolidando do master_imediato: {len(backup_data)} itens")
                event_tracking_consolidado.update(backup_data)
        
        # 2. Backup do root
        if hasattr(root, '_backup_event_tracking'):
            backup_data = root._backup_event_tracking
            if backup_data:
                print(f"DEBUG: [EVENT_TRACKING] Consolidando do root_backup: {len(backup_data)} itens")
                event_tracking_consolidado.update(backup_data)
        
        # 3. Backup de duration tracking (j√° implementado mas melhorado)
        backup_counters = getattr(root, '_backup_turn_counters', {})
        backup_event_duration = backup_counters.get('_event_duration_tracking', {})
        backup_event_start_turns = backup_counters.get('_event_start_turns', {})
        
        if backup_event_duration:
            print(f"DEBUG: [EVENT_TRACKING] Consolidando duration tracking: {len(backup_event_duration)} itens")
            event_duration_consolidado.update(backup_event_duration)
        
        if backup_event_start_turns:
            print(f"DEBUG: [EVENT_TRACKING] Consolidando start turns: {len(backup_event_start_turns)} itens")
            event_tracking_consolidado.update(backup_event_start_turns)
        
        # Aplicar consolida√ß√£o melhorada
        if event_tracking_consolidado:
            self._event_start_turns.update(event_tracking_consolidado)
            print(f"DEBUG: [EVENT_TRACKING] ‚úì Event tracking consolidado melhorado: {len(self._event_start_turns)} itens")
        
        if event_duration_consolidado:
            self._event_duration_tracking.update(event_duration_consolidado)
            print(f"DEBUG: [EVENT_TRACKING] ‚úì Event duration tracking consolidado melhorado: {len(self._event_duration_tracking)} itens")
        
        # Sincronizar backup principal
        if event_tracking_consolidado or event_duration_consolidado:
            root._backup_event_tracking = self._event_start_turns.copy()
            print(f"DEBUG: [EVENT_TRACKING] ‚úì Backup principal de Events sincronizado")
        
        print(f"DEBUG: [EVENT_TRACKING] === FIM MELHORAMENTO ROBUSTO DE EVENTS ===")
        
        # NOVO: SISTEMA DE TRACKING DE DATA VOLUME PARA SERVICES
        print(f"DEBUG: [DATA_VOLUME] === INICIALIZANDO TRACKING DE DATA VOLUME ===")
        
        # Sistema de tracking de pacotes restantes para Services Data Volume
        self._service_data_volume_tracking = {}  # {carta_path: {'packets_remaining': int, 'original_packets': int}}
        
        # Sistema de overlays de expira√ß√£o pendentes para Data Volume
        self._pending_data_volume_expiry_overlays = []  # Lista de cartas que devem mostrar overlay no pr√≥ximo turno
        
        # Backup consolidado para Data Volume
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            backup_data_volume = backup_counters.get('_service_data_volume_tracking', {})
            if backup_data_volume:
                self._service_data_volume_tracking = backup_data_volume.copy()
                print(f"DEBUG: [DATA_VOLUME] ‚úì Tracking restaurado do backup: {len(self._service_data_volume_tracking)} itens")
                for path, tracking in self._service_data_volume_tracking.items():
                    print(f"DEBUG: [DATA_VOLUME]   {os.path.basename(path)}: {tracking['packets_remaining']}/{tracking['original_packets']} pacotes")
            
            # Restaurar overlays pendentes
            backup_pending_overlays = backup_counters.get('_pending_data_volume_expiry_overlays', [])
            if backup_pending_overlays:
                self._pending_data_volume_expiry_overlays = backup_pending_overlays.copy()
                print(f"DEBUG: [DATA_VOLUME] ‚úì Overlays pendentes restaurados: {len(self._pending_data_volume_expiry_overlays)} itens")
                for path in self._pending_data_volume_expiry_overlays:
                    print(f"DEBUG: [DATA_VOLUME]   Overlay pendente: {os.path.basename(path)}")
            else:
                print(f"DEBUG: [DATA_VOLUME] Nenhum overlay pendente no backup")
        else:
            print(f"DEBUG: [DATA_VOLUME] Nenhum backup encontrado - inicializando tracking vazio")
        
        print(f"DEBUG: [DATA_VOLUME] === FIM INICIALIZA√á√ÉO DE DATA VOLUME ===")
        
        # INICIALIZA√á√ÉO DAS LISTAS DE CARTAS ATIVAS (movido do playerdashboard_interface)
        self.active_challenge = None  # S√≥ pode haver 1 challenge ativo
        self.active_users = []        # Lista de users ativos (m√°x 4)
        self.active_equipments = []   # Lista de equipments ativos (sem limite)
        self.active_services = []     # Lista de services ativos (sem limite)
        self.max_users = 4
        # Equipments e Services n√£o t√™m limite ap√≥s Next Phase

        # CONTROLE DE SELE√á√ÉO DO CARROSSEL
        self.selected_carousel_card = None  # Carta atualmente selecionada
        self.selected_carousel_index = None  # √çndice da carta selecionada

        # ADICIONA ISTO:
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        self.screen_width = screen_width
        self.screen_height = screen_height

        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)
        self.attributes("-fullscreen", True)        
        
        # Definir bar_color para bot√µes e barra inferior
        color_map = {
            "green": "#70AD47",
            "yellow": "#F2BA0D",
            "red": "#EE6F68",
            "blue": "#43BEF2"
        }
        self.bar_color = color_map.get(self.player_color.lower(), "#AAAAAA")
        
        self.selected_card_idx = selected_card_idx
        self.store_window = None
        
        # Cargas de cartas usando a nova estrutura: cartas/[tipo]/Residential-level/[cor]/
        def load_cards_from_new_structure(card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Tentar m√∫ltiplas estruturas de pastas
            possible_paths = []
            
            # Para cartas que t√™m cores espec√≠ficas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estruturas poss√≠veis:
                for color_var in color_variants:
                    # 1. cartas/[tipo]/Residential-level/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level", color_var))
                    # 2. cartas/Residential-[tipo]-[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}-{color_var}"))
                    # 3. cartas/[tipo]/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, color_var))
            else:
                # Para cartas sem cor espec√≠fica (challenges, events, actions)
                possible_paths = [
                    # 1. cartas/[tipo]/Residential-level/
                    os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level"),
                    # 2. cartas/Residential-[tipo]/
                    os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}"),
                    # 3. cartas/[tipo]/
                    os.path.join(CARTAS_BASE_DIR, card_type)
                ]
            
            # Tentar encontrar cartas em qualquer uma das estruturas poss√≠veis
            for path in possible_paths:
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            break  # Para no primeiro caminho que funcionar
                    except Exception as e:
                        continue
            
            return cards
        
        print("DEBUG: [PlayerDashboard] Iniciando carregamento de cartas do invent√°rio...")
        
        # INVENT√ÅRIO INICIAL: O jogador deve come√ßar com invent√°rio vazio ou apenas algumas cartas b√°sicas
        # As cartas s√£o adicionadas quando compradas na Store, n√£o carregadas de pastas externas
        
        # Verificar se h√° cartas do invent√°rio do jogador nas pastas do NetMaster
        def load_player_inventory_cards(card_type, player_color):
            """Carrega cartas do invent√°rio do jogador (n√£o da loja)"""
            cards = []
            # Usar a detec√ß√£o autom√°tica para Raspberry Pi e desenvolvimento local
            base_path = detect_player_inventory_base_dir()
            
            # Para cartas que t√™m cores espec√≠ficas
            if card_type in ["equipments", "services", "users", "activities"]:
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estrutura: NetMaster/[Tipo]/Residential-level/[Cor]/
                folder_mapping = {
                    "users": "Users",
                    "equipments": "Equipments", 
                    "services": "Services",
                    "activities": "Activities"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                
                for color_var in color_variants:
                    path = os.path.join(base_path, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: [PlayerDashboard] Cartas do invent√°rio encontradas em: {path}")
                                break
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor espec√≠fica (challenges, events, actions)
                folder_mapping = {
                    "challenges": "Challenges",
                    "actions": "Actions",
                    "events": "Events"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                path = os.path.join(base_path, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: [PlayerDashboard] Cartas do invent√°rio encontradas em: {path}")
                    except Exception as e:
                        print(f"DEBUG: [PlayerDashboard] Erro ao carregar {card_type}: {e}")
            
            return cards
        
        # INVENT√ÅRIO INICIAL VAZIO - o jogador come√ßa sem cartas
        # As cartas s√≥ s√£o adicionadas quando compradas na Store
        print("DEBUG: [PlayerDashboard] Inicializando invent√°rio vazio - cartas ser√£o adicionadas via compras na Store")
        
        # OPCIONAL: Se quiseres dar algumas cartas iniciais ao jogador, descomenta isto:
        print("DEBUG: [PlayerDashboard] CHAMANDO add_starter_cards()...")
        self.add_starter_cards()  # ATIVADO - adicionar cartas de exemplo
        print("DEBUG: [PlayerDashboard] add_starter_cards() TERMINADO")

        print(f"DEBUG: [PlayerDashboard] Invent√°rio inicial:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")

        # REGISTAR HANDLERS MULTIPLAYER PARA A INST√ÇNCIA PlayerDashboard
        print("[DASHBOARD_HANDLERS] *** REGISTANDO ESTA INST√ÇNCIA COMO ATIVA ***")
        if 'netmaster_client' in globals() and netmaster_client:
            try:
                # Registar esta inst√¢ncia como ativa nos handlers globais
                if hasattr(netmaster_client, 'set_active_dashboard'):
                    netmaster_client.set_active_dashboard(self)
                
                # Registar handlers espec√≠ficos da inst√¢ncia (substitui globais se necess√°rio)
                netmaster_client.set_message_handler('turn_changed', self.on_multiplayer_turn_changed)
                netmaster_client.set_message_handler('player_joined', self.on_player_joined)
                netmaster_client.set_message_handler('player_left', self.on_player_left)
                netmaster_client.set_message_handler('heartbeat_ack', self.on_heartbeat_ack)
                # NOVO: Handler para sincroniza√ß√£o do timer
                netmaster_client.set_message_handler('timer_sync', self.on_timer_sync)
                # CR√çTICO: Registar pending_cards localmente para garantir disponibilidade
                netmaster_client.set_message_handler('pending_cards', self.on_pending_cards_received)
                
                print("[DASHBOARD_HANDLERS] ‚úì Inst√¢ncia PlayerDashboard registada como ativa")
                print("[DASHBOARD_HANDLERS] ‚úì Handlers da inst√¢ncia registados:")
                print("[DASHBOARD_HANDLERS]   - turn_changed")
                print("[DASHBOARD_HANDLERS]   - player_joined") 
                print("[DASHBOARD_HANDLERS]   - player_left")
                print("[DASHBOARD_HANDLERS]   - heartbeat_ack")
                print("[DASHBOARD_HANDLERS]   - timer_sync")
                print("[DASHBOARD_HANDLERS]   - pending_cards (local)")
                print("[DASHBOARD_HANDLERS] INFO: card_returned_to_store usa handler global inteligente")
            except Exception as e:
                print(f"[DASHBOARD_HANDLERS] ERROR: Erro ao registar inst√¢ncia: {e}")
        else:
            print("[DASHBOARD_HANDLERS] WARNING: netmaster_client n√£o dispon√≠vel")

        # --- BARRA SUPERIOR COM IMAGEM ---
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            print(f"DEBUG: Tentando carregar TopBar de: {topbar_img_path}")
            
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar criada com sucesso!")
            else:
                print(f"DEBUG: Arquivo TopBar n√£o encontrado, criando fallback")
                # Fallback: criar uma barra colorida simples
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: TopBar fallback criada!")
        except Exception as e:
            print(f"DEBUG: ERRO ao criar TopBar: {e}")
            # Fallback: criar uma barra colorida simples
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
            self.topbar_label = topbar_frame
            print("DEBUG: TopBar fallback criada ap√≥s erro!")

        # *** NOVO: INICIALIZAR TIMER DE SESS√ÉO ***
        self.session_timer_active = False
        self.session_time_remaining = 0
        self.session_timer_label = None
        print("DEBUG: [SESSION_TIMER] Timer de sess√£o inicializado")

        # *** VERIFICAR SE DEVE INICIAR TIMER EM MODO MULTIPLAYER ***
        print(f"DEBUG: [SESSION_TIMER] Verificando modo multiplayer...")
        print(f"DEBUG: [SESSION_TIMER] hasattr multiplayer_mode: {hasattr(self, 'multiplayer_mode')}")
        print(f"DEBUG: [SESSION_TIMER] multiplayer_mode value: {getattr(self, 'multiplayer_mode', None)}")
        print(f"DEBUG: [SESSION_TIMER] hasattr netmaster_client.session_data: {hasattr(netmaster_client, 'session_data')}")
        print(f"DEBUG: [SESSION_TIMER] netmaster_client.session_data: {getattr(netmaster_client, 'session_data', None)}")
        
        # FOR√áA DETEC√á√ÉO DE MULTIPLAYER baseada na presen√ßa de session_data
        is_multiplayer = (hasattr(netmaster_client, 'session_data') and 
                         netmaster_client.session_data is not None)
        
        if is_multiplayer:
            print("DEBUG: [SESSION_TIMER] Modo multiplayer detectado via session_data - verificando se deve iniciar timer")
            # Tentar obter dura√ß√£o da sess√£o do cliente netmaster
            session_data = netmaster_client.session_data
            duration_minutes = session_data.get('duration_minutes', 15)
            print(f"DEBUG: [SESSION_TIMER] Dados de sess√£o encontrados - iniciando timer de {duration_minutes} minutos")
            # Iniciar timer ap√≥s interface estar criada
            self.after(3000, lambda: self.start_session_timer(duration_minutes * 60))
        else:
            print("DEBUG: [SESSION_TIMER] Modo single player ou sem dados de sess√£o")

        # Chama a tela de lan√ßamento de dado
        print("DEBUG: [PlayerDashboard] Chamando show_dice_roll_screen...")
        # CORRE√á√ÉO: Usar jogadores da sess√£o em vez de todos os outros jogadores
        session_players = self.get_session_players_icons()
        self.show_dice_roll_screen(player_name, saldo, session_players, screen_width, screen_height)
    
    def _capturar_estado_botoes_imediato(self):
        """Captura o estado atual dos bot√µes + e seta no momento exato"""
        print("DEBUG: [CAPTURA_IMEDIATA] === CAPTURA NO MOMENTO DO CLIQUE ===")
        
        # CORRE√á√ÉO CR√çTICA: Durante Final Phase gest√£o ativa, preservar o estado dos bot√µes
        # baseado na l√≥gica de gest√£o, n√£o na exist√™ncia f√≠sica dos widgets
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_ativo = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CAPTURA_IMEDIATA] gestao_ativa: {gestao_ativa}, final_phase_ativo: {final_phase_ativo}")
        
        if gestao_ativa and final_phase_ativo:
            print("DEBUG: [CAPTURA_IMEDIATA] MODO GEST√ÉO ATIVA - Determinando estado baseado na l√≥gica de gest√£o")
            
            # Durante gest√£o ativa, determinar que bot√µes DEVEM estar vis√≠veis
            # baseado no estado atual da carta e valores das barras
            estado = self._determinar_estado_gestao_logico()
            
            print(f"DEBUG: [CAPTURA_IMEDIATA] Estado determinado logicamente: {estado}")
            
        else:
            print("DEBUG: [CAPTURA_IMEDIATA] Modo normal - verificando estado f√≠sico dos widgets")
            
            # LIMPAR qualquer estado antigo primeiro para evitar interfer√™ncia
            if hasattr(self, '_estado_botoes_imediato'):
                print("DEBUG: [CAPTURA_IMEDIATA] WARNING: Limpando estado antigo antes de capturar novo")
                self._estado_botoes_imediato = None
            
            print("DEBUG: [CAPTURA_IMEDIATA] Capturando estado dos bot√µes AGORA...")
            
            estado = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            try:
                # NOVA L√ìGICA MAIS ROBUSTA: Verificar se bot√£o existe E est√° vis√≠vel na tela
                print("DEBUG: [CAPTURA_IMEDIATA] === VERIFICA√á√ÉO DETALHADA DOS BOT√ïES ===")
                
                # Verificar bot√£o + Rxd
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando bot√£o + Rxd...")
                rxd_existe = hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_rxd existe? {rxd_existe}")
                
                if rxd_existe:
                    try:
                        rxd_winfo_exists = self._btn_plus_rxd.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {rxd_winfo_exists}")
                        
                        if rxd_winfo_exists:
                            # VERIFICA√á√ÉO ADICIONAL: Verificar se est√° mapeado (vis√≠vel)
                            rxd_ismapped = self._btn_plus_rxd.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {rxd_ismapped}")
                            
                            if rxd_ismapped:
                                estado['btn_plus_rxd_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Bot√£o + Rxd est√° VIS√çVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Rxd existe mas n√£o est√° mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Rxd foi destru√≠do")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no + Rxd: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no + Rxd: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Rxd n√£o existe")
                    
                # Verificar bot√£o + Lost
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando bot√£o + Lost...")
                lost_existe = hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_lost existe? {lost_existe}")
                
                if lost_existe:
                    try:
                        lost_winfo_exists = self._btn_plus_lost.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {lost_winfo_exists}")
                        
                        if lost_winfo_exists:
                            # VERIFICA√á√ÉO ADICIONAL: Verificar se est√° mapeado (vis√≠vel)
                            lost_ismapped = self._btn_plus_lost.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {lost_ismapped}")
                            
                            if lost_ismapped:
                                estado['btn_plus_lost_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Bot√£o + Lost est√° VIS√çVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Lost existe mas n√£o est√° mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Lost foi destru√≠do")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no + Lost: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no + Lost: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o + Lost n√£o existe")
                    
                # Verificar bot√£o seta
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando bot√£o seta...")
                seta_existe = hasattr(self, '_btn_seta') and self._btn_seta is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_seta existe? {seta_existe}")
                
                if seta_existe:
                    try:
                        seta_winfo_exists = self._btn_seta.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {seta_winfo_exists}")
                        
                        if seta_winfo_exists:
                            # VERIFICA√á√ÉO ADICIONAL: Verificar se est√° mapeado (vis√≠vel)
                            seta_ismapped = self._btn_seta.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {seta_ismapped}")
                            
                            if seta_ismapped:
                                estado['btn_seta_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Bot√£o seta est√° VIS√çVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o seta existe mas n√£o est√° mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o seta foi destru√≠do")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no seta: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no seta: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Bot√£o seta n√£o existe")
                    
            except Exception as e:
                print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro durante captura: {e}")
        
        # Guardar estado capturado
        self._estado_botoes_imediato = estado
        print(f"DEBUG: [CAPTURA_IMEDIATA] === RESULTADO FINAL ===")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado capturado: {estado}")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado armazenado com timestamp √∫nico para evitar conflitos")
    
    def _reset_turn_processing_counters(self):
        """
        Reseta os contadores de processamento por turno para todas as cartas.
        Deve ser chamado no in√≠cio de cada turno (dice roll screen).
        CORRE√á√ÉO: N√ÉO incrementar contador aqui - contadores j√° v√™m incrementados do end_turn anterior
        """
        print("DEBUG: [TURN_RESET] === RESETANDO CONTADORES DE PROCESSAMENTO ===")
        print(f"DEBUG: [TURN_RESET] Contadores preservados do end_turn anterior (SINCRONIZADOS):")
        print(f"DEBUG: [TURN_RESET]   _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TURN_RESET]   _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TURN_RESET]   _current_turn_id (Processing): {self._current_turn_id}")
        
        # VERIFICA√á√ÉO CR√çTICA: Garantir sincroniza√ß√£o de todos os contadores
        if not (self._current_turn_number == self._current_turn == self._current_turn_id):
            print(f"DEBUG: [TURN_RESET] [WARNING]  WARNING: CONTADORES DESSINCRONIZADOS!")
            # Corre√ß√£o autom√°tica para o maior valor
            max_turn = max(self._current_turn_number, self._current_turn, self._current_turn_id)
            self._current_turn_number = max_turn
            self._current_turn = max_turn
            self._current_turn_id = max_turn
            print(f"DEBUG: [TURN_RESET] ‚úì CONTADORES SINCRONIZADOS para turno {max_turn}")
        
        # Resetar APENAS os contadores de processamento por turno (n√£o os contadores de turno)
        old_rxd_counters = self._rxd_processed_this_turn.copy()
        old_lost_counters = self._lost_processed_this_turn.copy()
        old_interacoes = getattr(self, '_cartas_interagidas_jogador', set()).copy()
        
        self._rxd_processed_this_turn = {}
        self._lost_processed_this_turn = {}
        self._cartas_interagidas_jogador = set()  # Reset intera√ß√µes do jogador
        
        print(f"DEBUG: [TURN_RESET] Contadores Rxd anteriores: {old_rxd_counters}")
        print(f"DEBUG: [TURN_RESET] Contadores Lost anteriores: {old_lost_counters}")
        print(f"DEBUG: [TURN_RESET] Intera√ß√µes jogador anteriores: {len(old_interacoes)} cartas")
        print(f"DEBUG: [TURN_RESET] SUCCESS: Contadores de processamento resetados - bot√µes + dispon√≠veis")
        print(f"DEBUG: [TURN_RESET] SUCCESS: Intera√ß√µes do jogador resetadas - novo turno limpo")
        
        # NOVA FUNCIONALIDADE: Limpar tracking √≥rf√£o de Challenges que n√£o est√£o mais no carrossel
        self._cleanup_orphaned_challenge_tracking()
        
        print("DEBUG: [TURN_RESET] === FIM RESET CONTADORES ===")

    def _get_processed_this_turn(self, carta_path, tipo):
        """
        Retorna quantos pacotes foram processados neste turno para uma carta espec√≠fica.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost'
        
        Returns:
            int: Quantidade processada neste turno
        """
        if tipo == 'rxd':
            return self._rxd_processed_this_turn.get(carta_path, 0)
        elif tipo == 'lost':
            return self._lost_processed_this_turn.get(carta_path, 0)
        else:
            return 0

    def _increment_processed_this_turn(self, carta_path, tipo, quantidade=1):
        """
        Incrementa o contador de processamento para este turno.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost' 
            quantidade (int): Quantidade a incrementar (default: 1)
        """
        print(f"DEBUG: [PROCESSED] Incrementando {tipo} para {os.path.basename(carta_path)}: +{quantidade}")
        
        if tipo == 'rxd':
            current = self._rxd_processed_this_turn.get(carta_path, 0)
            self._rxd_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Rxd processado neste turno: {current} -> {current + quantidade}")
        elif tipo == 'lost':
            current = self._lost_processed_this_turn.get(carta_path, 0)
            self._lost_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Lost processado neste turno: {current} -> {current + quantidade}")

    def _determinar_estado_gestao_logico(self):
        """
        Durante gest√£o ativa, determina logicamente que bot√µes devem estar vis√≠veis
        baseado no estado das barras e progresso da gest√£o
        CORRE√á√ÉO: Verificar corretamente os pacotes processados neste turno
        """
        print("DEBUG: [GESTAO_LOGICA] === DETERMINANDO ESTADO L√ìGICO DOS BOT√ïES ===")
        
        estado = {
            'btn_plus_rxd_visivel': False,
            'btn_plus_lost_visivel': False,
            'btn_seta_visivel': False
        }
        
        try:
            # Obter carta atual da gest√£o
            carta_atual = self._get_current_actual_card()
            if not carta_atual:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Nenhuma carta atual encontrada")
                return estado
            
            # Obter valores atuais das barras de progresso
            if self.selected_carousel_index is not None and self.selected_carousel_index < len(self.card_stats):
                stats = self.card_stats[self.selected_carousel_index]
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print("DEBUG: [GESTAO_LOGICA] WARNING: Usando valores padr√£o para barras")
                rxd_atual = 0
                lost_atual = 0
            
            # Obter dados da carta
            rate_max = self._obter_rate_carta(carta_atual)
            carta_dados = self._obter_dados_carta(carta_atual)
            message_size = carta_dados.get('message_size', rate_max) if carta_dados else rate_max
            
            carta_basename = os.path.basename(carta_atual).lower()
            is_challenge = "challenge" in carta_basename
            is_activity = "activity" in carta_basename
            
            print(f"DEBUG: [GESTAO_LOGICA] Carta atual: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [GESTAO_LOGICA] Tipo: {'Challenge' if is_challenge else 'Activity'}")
            print(f"DEBUG: [GESTAO_LOGICA] Rate m√°ximo (por turno): {rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA] Message size (limite total): {message_size}")
            print(f"DEBUG: [GESTAO_LOGICA] Rxd atual: {rxd_atual}, Lost atual: {lost_atual}")
            
            # CORRE√á√ÉO CR√çTICA: Durante gest√£o de pacotes, verificar contadores POR CARTA
            # O rate_max aplica-se POR CARTA, n√£o globalmente durante gest√£o
            print(f"DEBUG: [GESTAO_LOGICA] ===== VERIFICA√á√ÉO DETALHADA DE PROCESSAMENTO =====")
            
            # Durante gest√£o de pacotes, verificar contadores da carta ESPEC√çFICA
            if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                print("DEBUG: [GESTAO_LOGICA] MODO GEST√ÉO ATIVA - Verificando contadores da carta espec√≠fica")
                # Verificar contadores apenas para a carta atual sendo gerenciada
                rxd_processed = self._get_processed_this_turn(carta_atual, 'rxd')
                lost_processed = self._get_processed_this_turn(carta_atual, 'lost')
                
                print(f"DEBUG: [GESTAO_LOGICA] Carta espec√≠fica: {os.path.basename(carta_atual)}")
                print(f"DEBUG: [GESTAO_LOGICA]   Rxd processado: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Lost processado: {lost_processed}")
            else:
                print("DEBUG: [GESTAO_LOGICA] MODO NORMAL - Verificando contadores globais")
                # Fora da gest√£o, verificar o m√°ximo global (comportamento anterior)
                max_rxd_processed = 0
                max_lost_processed = 0
                
                if hasattr(self, '_rxd_processed_this_turn'):
                    for carta_path, count in self._rxd_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Rxd processados")
                        max_rxd_processed = max(max_rxd_processed, count)
                
                if hasattr(self, '_lost_processed_this_turn'):
                    for carta_path, count in self._lost_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Lost processados")
                        max_lost_processed = max(max_lost_processed, count)
                
                rxd_processed = max_rxd_processed
                lost_processed = max_lost_processed
                
                print(f"DEBUG: [GESTAO_LOGICA] M√ÅXIMO GLOBAL processado neste turno:")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Rxd: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Lost: {lost_processed}")
            
            print(f"DEBUG: [GESTAO_LOGICA] ===== FIM VERIFICA√á√ÉO PROCESSAMENTO =====")
            
            # Verificar se Rxd pode ser incrementado
            pode_incrementar_rxd = (rxd_atual < message_size) and (rxd_processed < rate_max)
            print(f"DEBUG: [GESTAO_LOGICA] Rxd permitido:")
            print(f"DEBUG: [GESTAO_LOGICA]   atual ({rxd_atual}) < message_size ({message_size}): {rxd_atual < message_size}")
            print(f"DEBUG: [GESTAO_LOGICA]   processado ({rxd_processed}) < rate_max ({rate_max}): {rxd_processed < rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_rxd}")
            
            if pode_incrementar_rxd:
                estado['btn_plus_rxd_visivel'] = True
                print("DEBUG: [GESTAO_LOGICA] Bot√£o + Rxd deve estar vis√≠vel")
            else:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Bot√£o + Rxd N√ÉO deve estar vis√≠vel")
                if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Carta j√° processou {rxd_processed}/{rate_max} pacotes Rxd neste turno")
                else:
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: J√° processou {rxd_processed}/{rate_max} pacotes Rxd neste turno (GLOBALMENTE)")
            
            # Verificar se Lost pode ser incrementado
            if carta_dados:
                drops_allowed = carta_dados.get('drops_allowed', True)
                penalty_per_packet = carta_dados.get('penalty_per_packet', None)
                
                # Determinar se Lost √© permitido para esta carta
                if is_challenge:
                    lost_permitido = drops_allowed or (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Challenge - Lost permitido: drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
                else:
                    lost_permitido = (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Activity - Lost permitido: penalty_per_packet existe ({penalty_per_packet is not None})")
                
                print(f"DEBUG: [GESTAO_LOGICA] Verificando bot√£o Lost:")
                print(f"DEBUG: [GESTAO_LOGICA]   drops_allowed: {drops_allowed}")
                print(f"DEBUG: [GESTAO_LOGICA]   penalty_per_packet: {penalty_per_packet}")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                
                pode_incrementar_lost = (lost_permitido and 
                                       lost_atual < message_size and 
                                       lost_processed < rate_max)
                print(f"DEBUG: [GESTAO_LOGICA] Lost incremento permitido:")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                print(f"DEBUG: [GESTAO_LOGICA]   atual ({lost_atual}) < message_size ({message_size}): {lost_atual < message_size}")
                print(f"DEBUG: [GESTAO_LOGICA]   processado ({lost_processed}) < rate_max ({rate_max}): {lost_processed < rate_max}")
                print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_lost}")
                
                if pode_incrementar_lost:
                    estado['btn_plus_lost_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] Bot√£o + Lost deve estar vis√≠vel")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ERROR: Bot√£o + Lost N√ÉO deve estar vis√≠vel")
                    if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost n√£o permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Carta j√° processou {lost_processed}/{rate_max} pacotes Lost neste turno")
                    else:
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost n√£o permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: J√° processou {lost_processed}/{rate_max} pacotes Lost neste turno (GLOBALMENTE)")
            
            # Verificar se bot√£o seta deve estar vis√≠vel
            if not estado['btn_plus_rxd_visivel'] and not estado['btn_plus_lost_visivel']:
                # Verificar se h√° mais cartas para gerir
                total_cartas = len(getattr(self, '_cartas_gestao', []))
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                if carta_atual_idx + 1 < total_cartas:
                    estado['btn_seta_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] Bot√£o seta deve estar vis√≠vel (h√° mais cartas)")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ERROR: N√£o h√° mais cartas para gerir - sem bot√£o seta")
            else:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Bot√µes + ainda dispon√≠veis - bot√£o seta N√ÉO deve estar vis√≠vel")
                    
        except Exception as e:
            print(f"DEBUG: [GESTAO_LOGICA] ERROR: Erro geral: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: [GESTAO_LOGICA] Estado l√≥gico determinado: {estado}")
        print("DEBUG: [GESTAO_LOGICA] === FIM DETERMINA√á√ÉO L√ìGICA ===")
        
        return estado
    
    def _get_current_actual_card(self):
        """
        Retorna a carta atual baseada na posi√ß√£o real no carrossel, n√£o na vari√°vel cached
        CORRE√á√ÉO CR√çTICA: Durante gest√£o de pacotes, usar sempre a carta da posi√ß√£o atual
        """
        try:
            print(f"DEBUG: [CURRENT_CARD] ===== DIAGN√ìSTICO DETALHADO _get_current_actual_card =====")
            print(f"DEBUG: [CURRENT_CARD] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(_carta_atual_gestao): {hasattr(self, '_carta_atual_gestao')}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(cards): {hasattr(self, 'cards')}")
            print(f"DEBUG: [CURRENT_CARD] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
            print(f"DEBUG: [CURRENT_CARD] len(cards): {len(self.cards) if hasattr(self, 'cards') else 'N/A'}")
            print(f"DEBUG: [CURRENT_CARD] selected_carousel_index: {getattr(self, 'selected_carousel_index', 'N/A')}")
            
            # CORRE√á√ÉO CR√çTICA: Durante gest√£o de pacotes, priorizar selected_carousel_index
            gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            tem_cards = hasattr(self, 'cards') and self.cards
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [CURRENT_CARD] gestao_ativa: {gestao_ativa}")
            print(f"DEBUG: [CURRENT_CARD] tem_cards: {tem_cards}")
            print(f"DEBUG: [CURRENT_CARD] selected_index: {selected_index}")
            
            # Se estamos em gest√£o e h√° um √≠ndice selecionado v√°lido, usar esse
            if gestao_ativa and tem_cards and selected_index is not None:
                if selected_index < len(self.cards):
                    carta_real = self.cards[selected_index]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] Gest√£o ativa - usando selected_carousel_index {selected_index}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ERROR: selected_carousel_index {selected_index} fora dos limites ({len(self.cards)})")
            
            # Se estamos em gest√£o de pacotes mas sem selected_index, usar _carta_atual_gestao
            if gestao_ativa and tem_cards and hasattr(self, '_carta_atual_gestao'):
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                print(f"DEBUG: [CURRENT_CARD] carta_atual_idx: {carta_atual_idx}, len(cards): {len(self.cards)}")
                if carta_atual_idx < len(self.cards):
                    carta_real = self.cards[carta_atual_idx]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] Gest√£o ativa - usando _carta_atual_gestao {carta_atual_idx}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ERROR: _carta_atual_gestao {carta_atual_idx} fora dos limites ({len(self.cards)})")
            
            # Se n√£o estamos em gest√£o mas h√° √≠ndice selecionado v√°lido, usar esse
            if tem_cards and selected_index is not None and selected_index < len(self.cards):
                carta_real = self.cards[selected_index]
                carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                print(f"DEBUG: [CURRENT_CARD] Usando selected_carousel_index normal {selected_index}: {carta_nome}")
                return carta_real
            
            # Fallback para selected_carousel_card se ainda √© v√°lida
            carta_cached = getattr(self, 'selected_carousel_card', None)
            carta_cached_nome = carta_cached.split('/')[-1] if carta_cached else 'None'
            print(f"DEBUG: [CURRENT_CARD] carta_cached: {carta_cached_nome}")
            if carta_cached:
                print(f"DEBUG: [CURRENT_CARD] Fallback para carta cached: {carta_cached_nome}")
                return carta_cached
            
            print("DEBUG: [CURRENT_CARD] ERROR: Nenhuma carta atual encontrada")
            print(f"DEBUG: [CURRENT_CARD] ===== FIM DIAGN√ìSTICO =====")
            return None
            
        except Exception as e:
            print(f"DEBUG: [CURRENT_CARD] ERRO CR√çTICO na fun√ß√£o: {e}")
            import traceback
            print(f"DEBUG: [CURRENT_CARD] Stack trace: {traceback.format_exc()}")
            return getattr(self, 'selected_carousel_card', None)
    
    def _save_dashboard_state(self):
        """Salva o estado atual da interface principal do dashboard"""
        # PROTE√á√ÉO: N√£o salvar estado se estivermos numa p√°gina especial
        if getattr(self, '_in_router_selection_page', False):
            print("DEBUG: [ESTADO] WARNING: Salvamento de estado cancelado - estamos numa p√°gina de sele√ß√£o de router")
            return
            
        print("DEBUG: [ESTADO] Salvando estado da interface principal...")
        
        # CORRE√á√ÉO CR√çTICA: Preservar valores das barras ANTES de salvar estado
        # Isto √© especialmente importante durante gest√£o de pacotes
        if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa and
            hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None):
            try:
                # Capturar valores das barras vis√≠veis e preservar em card_stats
                if hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    idx = self.selected_carousel_index
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual,
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [ESTADO] Valores preservados antes de salvar estado:")
                        print(f"DEBUG: [ESTADO]   Carta √≠ndice {idx}: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            except Exception as e:
                print(f"DEBUG: [ESTADO] ERROR: Erro ao preservar valores antes de salvar: {e}")
        
        # CORRE√á√ÉO CR√çTICA: N√ÉO modificar _final_phase_gestao_ativa durante navega√ß√£o
        # Os widgets s√£o destru√≠dos durante navega√ß√£o, mas isso n√£o significa que a gest√£o foi finalizada
        gestao_pretende_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        if gestao_pretende_ativa:
            print("DEBUG: [ESTADO] === PRESERVANDO ESTADO DE GEST√ÉO DURANTE NAVEGA√á√ÉO ===")
            print("DEBUG: [ESTADO] _final_phase_gestao_ativa permanece True - apenas navega√ß√£o tempor√°ria")
            print("DEBUG: [ESTADO] Widgets podem estar destru√≠dos mas gest√£o n√£o foi finalizada pelo usu√°rio")

        state = {
            # Estado do carrossel - CORRE√á√ÉO: Usar carta atual real
            'selected_carousel_card': self._get_current_actual_card(),
            'selected_carousel_index': getattr(self, 'selected_carousel_index', None),
            'destaque_roxo_index': getattr(self, '_carta_atual_gestao', getattr(self, 'selected_carousel_index', None)),  # NOVO: preserva √≠ndice do destaque roxo
            'cards': self.cards[:] if hasattr(self, 'cards') else [],
            'card_stats': [stats.copy() for stats in self.card_stats] if hasattr(self, 'card_stats') else [],
            
            # Estado das barras de progresso
            'progress_bar_values': {},
            
            # Estados dos bot√µes e fases
            '_final_phase_active': getattr(self, '_final_phase_active', False),
            '_next_phase_active': getattr(self, '_next_phase_active', False),
            '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
            '_show_end_turn_button': getattr(self, '_show_end_turn_button', False),
            '_challenge_accepted': getattr(self, '_challenge_accepted', False),
            '_store_button_disabled': getattr(self, '_store_button_disabled', False),
            '_next_phase_manually_activated': getattr(self, '_next_phase_manually_activated', False),
            
            # Estado da gest√£o de pacotes
            '_cartas_gestao': getattr(self, '_cartas_gestao', []),
            '_carta_atual_gestao': getattr(self, '_carta_atual_gestao', 0),
            '_valores_pacotes': getattr(self, '_valores_pacotes', {}),
            
            # Estados de controles vis√≠veis
            'controles_gestao_visiveis': False,
            'botao_seta_visivel': False,
            'final_phase_turn_id': getattr(self, '_final_phase_turn_id', None)  # NOVO: ID do turno
        }
        
        # Salvar valores das barras de progresso se existirem
        if hasattr(self, 'progress_bars'):
            for nome, barra in self.progress_bars.items():
                try:
                    state['progress_bar_values'][nome] = barra.get()
                except:
                    state['progress_bar_values'][nome] = 0
        
        # Verificar se controles de gest√£o est√£o vis√≠veis
        print("DEBUG: [ESTADO] === VERIFICA√á√ÉO DETALHADA DOS CONTROLES ===")
        print(f"DEBUG: [ESTADO] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # Sistema de flags espec√≠ficas para cada bot√£o - DETEC√á√ÉO SIMPLES E DIRETA
        state['btn_plus_rxd_visivel'] = False
        state['btn_plus_lost_visivel'] = False
        state['btn_seta_visivel'] = False
        
        print(f"DEBUG: [ESTADO] === VERIFICANDO ESTADO IMEDIATO ===")
        
        # CORRE√á√ÉO CR√çTICA: Usar estado imediato se dispon√≠vel e N√ÉO DELETAR ainda
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] SUCCESS: USANDO ESTADO IMEDIATO CAPTURADO ANTES DO CLIQUE:")
            print(f"DEBUG: [ESTADO] Estado original capturado: {self._estado_botoes_imediato}")
            
            # USAR EXATAMENTE o que foi capturado - sem modifica√ß√µes
            state['btn_plus_rxd_visivel'] = self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False)
            state['btn_plus_lost_visivel'] = self._estado_botoes_imediato.get('btn_plus_lost_visivel', False)
            state['btn_seta_visivel'] = self._estado_botoes_imediato.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [ESTADO] Estado usado para save:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {state['btn_seta_visivel']}")
            
            # CR√çTICO: N√ÉO deletar ainda - preservar para debug e restaura√ß√£o
            print("DEBUG: [ESTADO] SUCCESS: Estado imediato preservado - ser√° limpo apenas ap√≥s restaura√ß√£o completa")
        else:
            print("DEBUG: [ESTADO] WARNING: Nenhum estado imediato dispon√≠vel - usando detec√ß√£o fallback")
            print(f"DEBUG: [ESTADO] === DETEC√á√ÉO SIMPLES DOS BOT√ïES ===")
            
            # M√âTODO SIMPLES: Verificar apenas os atributos de classe diretamente
            try:
                # Verificar bot√£o + Rxd
                if (hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None):
                    try:
                        if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                            state['btn_plus_rxd_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Bot√£o + Rxd DETECTADO (vis√≠vel e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Bot√£o + Rxd existe mas n√£o est√° mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar + Rxd: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_plus_rxd n√£o existe ou √© None")
                    
                # Verificar bot√£o + Lost  
                if (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None):
                    try:
                        if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                            state['btn_plus_lost_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Bot√£o + Lost DETECTADO (vis√≠vel e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Bot√£o + Lost existe mas n√£o est√° mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar + Lost: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_plus_lost n√£o existe ou √© None")
                    
                # Verificar bot√£o seta
                if (hasattr(self, '_btn_seta') and self._btn_seta is not None):
                    try:
                        if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                            state['btn_seta_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Bot√£o seta DETECTADO (vis√≠vel e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Bot√£o seta existe mas n√£o est√° mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar seta: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_seta n√£o existe ou √© None")
                    
            except Exception as e:
                print(f"DEBUG: [ESTADO] ERROR: Erro geral na detec√ß√£o: {e}")
        
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETEC√á√ÉO ===")
        
        # Atualizar flags legadas para compatibilidade
        if state['btn_plus_rxd_visivel'] or state['btn_plus_lost_visivel']:
            state['controles_gestao_visiveis'] = True
        if state['btn_seta_visivel']:
            state['botao_seta_visivel'] = True
        
        # Relat√≥rio final da detec√ß√£o
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETEC√á√ÉO ===")
        print(f"DEBUG: [ESTADO] btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
        print(f"DEBUG: [ESTADO] btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
        print(f"DEBUG: [ESTADO] btn_seta_visivel: {state['btn_seta_visivel']}")
        print(f"DEBUG: [ESTADO] controles_gestao_visiveis: {state.get('controles_gestao_visiveis', False)}")
        print(f"DEBUG: [ESTADO] botao_seta_visivel: {state.get('botao_seta_visivel', False)}")
        
        # CR√çTICO: Preservar tracking de Challenges no estado salvo
        state['_challenge_start_turns'] = self._challenge_start_turns.copy()
        
        self._saved_dashboard_state = state
        print(f"DEBUG: [ESTADO] SUCCESS: Estado salvo com sucesso!")
        print(f"DEBUG: [ESTADO] Carta selecionada: {state.get('selected_carousel_card')}")
        print(f"DEBUG: [ESTADO] √çndice selecionado: {state.get('selected_carousel_index')}")
        print(f"DEBUG: [ESTADO] √çndice destaque roxo: {state.get('destaque_roxo_index')}")
        print(f"DEBUG: [ESTADO] Final phase active: {state.get('_final_phase_active')}")
        print(f"DEBUG: [ESTADO] Gest√£o ativa: {state.get('_final_phase_gestao_ativa')}")
        print(f"DEBUG: [ESTADO] Challenge tracking preservado: {state.get('_challenge_start_turns')}")
        print(f"DEBUG: [ESTADO] Bot√µes preservados: rxd={state.get('btn_plus_rxd_visivel')}, lost={state.get('btn_plus_lost_visivel')}, seta={state.get('btn_seta_visivel')}")
        
        # GARANTIA ADICIONAL: Tamb√©m salvar no estado imediato para fallback
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print(f"DEBUG: [ESTADO] SUCCESS: Estado imediato tamb√©m dispon√≠vel como backup")
        else:
            print(f"DEBUG: [ESTADO] WARNING: Estado imediato n√£o dispon√≠vel")
            # Criar backup baseado no estado atual
            self._estado_botoes_imediato = {
                'btn_plus_rxd_visivel': state.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': state.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': state.get('btn_seta_visivel', False)
            }
            print(f"DEBUG: [ESTADO] SUCCESS: Estado imediato criado como backup")
    
    def _restore_gestao_buttons_specifically(self, btn_plus_rxd_visivel, btn_plus_lost_visivel, btn_seta_visivel):
        """
        M√©todo espec√≠fico para restaurar apenas os bot√µes de gest√£o que estavam vis√≠veis.
        Este m√©todo √© chamado ap√≥s voltar de p√°ginas de invent√°rio ou fullscreen.
        """
        print("DEBUG: [RESTORE_BUTTONS] === RESTAURA√á√ÉO ESPEC√çFICA DE BOT√ïES ===")
        print(f"DEBUG: [RESTORE_BUTTONS] Bot√µes a restaurar:")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Rxd: {btn_plus_rxd_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Lost: {btn_plus_lost_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   Seta: {btn_seta_visivel}")
        
        # CORRE√á√ÉO CR√çTICA: Se estamos em gest√£o de pacotes ativa, sempre restaurar o destaque roxo
        # mesmo que n√£o hajam bot√µes espec√≠ficos para restaurar
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        # Verificar se h√° pelo menos um bot√£o para restaurar OU se gest√£o est√° ativa
        algum_botao_para_restaurar = btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel
        
        if not algum_botao_para_restaurar and not gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] ERROR: Nenhum bot√£o para restaurar e gest√£o n√£o ativa")
            return
        
        if not algum_botao_para_restaurar and gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] WARNING: Gest√£o ativa mas nenhum bot√£o espec√≠fico para restaurar - determinando bot√µes corretos")
            # CORRE√á√ÉO CR√çTICA: Se gest√£o est√° ativa mas n√£o h√° flags espec√≠ficas,
            # redeterminar que bot√µes devem estar vis√≠veis baseado na carta atual
            estado_logico = self._determinar_estado_gestao_logico()
            btn_plus_rxd_visivel = estado_logico.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_visivel = estado_logico.get('btn_plus_lost_visivel', False) 
            btn_seta_visivel = estado_logico.get('btn_seta_visivel', False)
            print(f"DEBUG: [RESTORE_BUTTONS] Estado redeterminado: rxd={btn_plus_rxd_visivel}, lost={btn_plus_lost_visivel}, seta={btn_seta_visivel}")
            
            # Se ainda n√£o h√° nenhum bot√£o para restaurar, n√£o h√° nada a fazer
            if not (btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel):
                print("DEBUG: [RESTORE_BUTTONS] ERROR: Redetermina√ß√£o tamb√©m n√£o encontrou bot√µes - cancelando restaura√ß√£o")
                return
        
        # Garantir que a gest√£o est√° ativa se h√° bot√µes para restaurar
        self._final_phase_gestao_ativa = True
        self._final_phase_active = True
        
        # CORRE√á√ÉO FUNDAMENTAL: Restaurar para a carta que ESTAVA sendo gerenciada antes do fullscreen
        # A gest√£o estava na carta 1 (Challenge_9.png), n√£o na carta 0 (back_card_red.png)
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            carta_gestao_original = self._saved_dashboard_state.get('selected_carousel_index', 1)
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: CORRE√á√ÉO FUNDAMENTAL:")
            print(f"DEBUG: [RESTORE_BUTTONS]   Carta que estava sendo gerenciada: {carta_gestao_original}")
            print(f"DEBUG: [RESTORE_BUTTONS]   Restaurando gest√£o para esta carta")
            self.selected_carousel_index = carta_gestao_original
            self._carta_atual_gestao = carta_gestao_original
            
            # Atualizar selected_carousel_card se poss√≠vel
            if (hasattr(self, 'cards') and self.cards and 
                carta_gestao_original < len(self.cards)):
                self.selected_carousel_card = self.cards[carta_gestao_original]
                print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        else:
            # CORRE√á√ÉO PROBLEMA 2: Preservar a posi√ß√£o correta do destaque roxo
            # N√ÉO redefinir selected_carousel_index se j√° est√° definido corretamente
            posicao_destaque_roxo = getattr(self, '_carta_atual_gestao', 1)  # Default para 1, n√£o 0
            
            print(f"DEBUG: [RESTORE_BUTTONS] WARNING: Usando fallback - posi√ß√£o gest√£o: {posicao_destaque_roxo}")
            self.selected_carousel_index = posicao_destaque_roxo
            self._carta_atual_gestao = posicao_destaque_roxo
            
            # Atualizar selected_carousel_card se poss√≠vel
            if (hasattr(self, 'cards') and self.cards and 
                posicao_destaque_roxo < len(self.cards)):
                self.selected_carousel_card = self.cards[posicao_destaque_roxo]
                print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        
        print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: POSI√á√ÉO GEST√ÉO CORRIGIDA:")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_index: {self.selected_carousel_index}")
        print(f"DEBUG: [RESTORE_BUTTONS]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_card: {os.path.basename(self.selected_carousel_card) if self.selected_carousel_card else 'None'}")
        
        # CORRE√á√ÉO FUNDAMENTAL: Recriar _cartas_gestao se estiver vazia ou inconsistente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print("DEBUG: [RESTORE_BUTTONS] WARNING: _cartas_gestao vazia - recriando com cartas ativas do carrossel")
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            self._cartas_gestao = cartas_ativas
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: _cartas_gestao recriada: {[os.path.basename(c) for c in cartas_ativas]}")
            
            # Ajustar _carta_atual_gestao se est√° fora de range
            if self._carta_atual_gestao >= len(self._cartas_gestao):
                self._carta_atual_gestao = len(self._cartas_gestao) - 1 if self._cartas_gestao else 0
                print(f"DEBUG: [RESTORE_BUTTONS] WARNING: _carta_atual_gestao ajustada para: {self._carta_atual_gestao}")
        
        # CORRE√á√ÉO CR√çTICA: Aplicar destaque roxo na posi√ß√£o correta
        if self.selected_carousel_index is not None:
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Aplicando destaque roxo na posi√ß√£o: {self.selected_carousel_index}")
            self._adicionar_destaque_roxo(self.selected_carousel_index)
            self._update_carousel_selection_highlights()
        
        # CORRE√á√ÉO CR√çTICA: Remover controles existentes SEM criar bot√£o seta automaticamente
        print("DEBUG: [RESTORE_BUTTONS] Limpando controles existentes sem criar bot√£o seta...")
        self._remover_controles_gestao_silencioso()
        
        # CORRE√á√ÉO FUNDAMENTAL: Obter rate da carta CORRETA (n√£o da fallback)
        carta_para_gestao = self.selected_carousel_card or self._get_current_actual_card()
        rate_max = self._obter_rate_carta(carta_para_gestao)
        dados_carta = self._obter_dados_carta(carta_para_gestao)
        rate_options = dados_carta.get('rate_options', [0, 1])
        print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Rate obtido da carta correta {os.path.basename(carta_para_gestao)}: rate_max={rate_max}, rate_options={rate_options}")
        
        # Restaurar bot√£o + Rxd se estava vis√≠vel
        if btn_plus_rxd_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando bot√£o + Rxd roxo...")
            
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gest√£o de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            self._btn_plus_rxd.lift()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Bot√£o + Rxd roxo restaurado")
        
        # Restaurar bot√£o + Lost se estava vis√≠vel
        if btn_plus_lost_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando bot√£o + Lost roxo...")
            
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gest√£o de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            self._btn_plus_lost.lift()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Bot√£o + Lost roxo restaurado")
        
        # Restaurar bot√£o seta se estava vis√≠vel
        if btn_seta_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando bot√£o seta...")
            self._mostrar_botao_seta()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Bot√£o seta restaurado")
        
        # Garantir que End Turn est√° disabled
        if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
            self.end_turn_btn.config(state="disabled")
            print("DEBUG: [RESTORE_BUTTONS] End Turn mantido disabled")
        
        # Atualizar barras para a carta atual
        try:
            if self.selected_carousel_index is not None:
                self._atualizar_barras_gestao_carta_atual()
        except Exception as e:
            print(f"DEBUG: [RESTORE_BUTTONS] WARNING: Erro ao atualizar barras: {e}")
        
        print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Restaura√ß√£o espec√≠fica conclu√≠da")

    def _restore_dashboard_state(self):
        """Restaura o estado salvo da interface principal do dashboard"""
        # CORRE√á√ÉO CR√çTICA: Verificar m√∫ltiplos locais onde o estado pode estar salvo
        state = None
        
        # 1. Verificar se h√° estado salvo normal
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            state = self._saved_dashboard_state
            print("DEBUG: [ESTADO] Estado encontrado em _saved_dashboard_state")
        
        # 2. Verificar se h√° estado capturado imediatamente (NOVO)
        elif hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] Usando estado imediato capturado como fallback")
            # Criar estado m√≠nimo baseado na captura imediata
            state = {
                'btn_plus_rxd_visivel': self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': self._estado_botoes_imediato.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': self._estado_botoes_imediato.get('btn_seta_visivel', False),
                '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
                '_final_phase_active': getattr(self, '_final_phase_active', False),
                'selected_carousel_card': getattr(self, 'selected_carousel_card', None),
                'selected_carousel_index': getattr(self, 'selected_carousel_index', None)
            }
        
        # 3. Se n√£o h√° estado, n√£o h√° nada para restaurar
        if not state:
            print("DEBUG: [ESTADO] Nenhum estado salvo encontrado - pular restaura√ß√£o")
            return
        print("DEBUG: [ESTADO] Restaurando estado da interface principal...")
        
        # Restaurar estado do carrossel
        self.selected_carousel_card = state.get('selected_carousel_card')
        self.selected_carousel_index = state.get('selected_carousel_index')
        
        # Restaurar cards e stats se necess√°rio
        if state.get('cards'):
            self.cards = state['cards'][:]
        if state.get('card_stats'):
            self.card_stats = [stats.copy() for stats in state['card_stats']]
        
        # Restaurar estados dos bot√µes e fases
        self._final_phase_active = state.get('_final_phase_active', False)
        self._next_phase_active = state.get('_next_phase_active', False)
        self._final_phase_gestao_ativa = state.get('_final_phase_gestao_ativa', False)
        self._show_end_turn_button = state.get('_show_end_turn_button', False)
        self._challenge_accepted = state.get('_challenge_accepted', False)
        self._store_button_disabled = state.get('_store_button_disabled', False)
        self._next_phase_manually_activated = state.get('_next_phase_manually_activated', False)
        
        # Restaurar estado da gest√£o de pacotes
        self._cartas_gestao = state.get('_cartas_gestao', [])
        self._carta_atual_gestao = state.get('_carta_atual_gestao', 0)
        self._valores_pacotes = state.get('_valores_pacotes', {})
        
        # CR√çTICO: Restaurar tracking de Challenges
        if '_challenge_start_turns' in state:
            self._challenge_start_turns = state['_challenge_start_turns'].copy()
            print(f"DEBUG: [ESTADO] Challenge tracking restaurado: {self._challenge_start_turns}")
        else:
            print(f"DEBUG: [ESTADO] WARNING: Nenhum challenge tracking no estado salvo")
        
        print(f"DEBUG: [ESTADO] Estado restaurado: carta_selecionada={self.selected_carousel_card}, "
              f"final_phase_active={self._final_phase_active}, "
              f"gestao_ativa={self._final_phase_gestao_ativa}, "
              f"controles_visiveis={state.get('controles_gestao_visiveis')}")
        
        # NOVO: Utilizar flags espec√≠ficas dos bot√µes para restaura√ß√£o precisa
        gestao_ativa = self._final_phase_gestao_ativa
        btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
        btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
        btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
        
        print(f"DEBUG: [ESTADO] Flags espec√≠ficas detectadas:")
        print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_seta_visivel: {btn_seta_estava_visivel}")
        
        # Executar restaura√ß√£o ap√≥s a interface estar pronta
        def restore_gestao_state():
            if gestao_ativa:
                print("DEBUG: [ESTADO] Gest√£o de pacotes estava ativa - restaurando bot√µes espec√≠ficos...")
                
                # Verificar se h√° bot√µes para restaurar
                algum_botao_estava_visivel = btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel or btn_seta_estava_visivel
                
                if algum_botao_estava_visivel:
                    print("DEBUG: [ESTADO] SUCCESS: Bot√µes estavam vis√≠veis - chamando restaura√ß√£o espec√≠fica")
                    self._restore_gestao_buttons_specifically(
                        btn_plus_rxd_estava_visivel,
                        btn_plus_lost_estava_visivel, 
                        btn_seta_estava_visivel
                    )
                else:
                    print("DEBUG: [ESTADO] WARNING: Gest√£o ativa mas sem bot√µes vis√≠veis - mantendo gest√£o e verificando necessidade")
                    # Manter gest√£o ativa mas verificar se precisa de bot√µes
                    self._final_phase_gestao_ativa = True
                    self._final_phase_active = True
                    
                    # Aplicar destaque roxo se h√° carta selecionada
                    if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                        print(f"DEBUG: [ESTADO] SUCCESS: Aplicando destaque roxo na posi√ß√£o {self.selected_carousel_index}")
                        self._adicionar_destaque_roxo(self.selected_carousel_index)
                        self._update_carousel_selection_highlights()
                        
                        # Verificar se precisa de bot√µes baseado no estado atual
                        self.after(300, self._verificar_e_mostrar_botao_seta_se_necessario)
                    else:
                        print("DEBUG: [ESTADO] ERROR: Nenhuma carta selecionada para destaque roxo")
            else:
                print("DEBUG: [ESTADO] Gest√£o n√£o estava ativa - verificando se End Turn deve estar enabled")
                
                # CORRE√á√ÉO CR√çTICA: Se Final Phase est√° ativo mas gest√£o n√£o est√° ativa,
                # significa que a gest√£o foi finalizada e End Turn deve estar enabled
                if self._final_phase_active and not gestao_ativa:
                    print("DEBUG: [ESTADO] SUCCESS: Final Phase ativo sem gest√£o - ativando End Turn")
                    self.after(150, self._ativar_botao_end_turn)
                else:
                    print("DEBUG: [ESTADO] Final Phase n√£o ativo - End Turn deve permanecer disabled")
        
        # Executar restaura√ß√£o ap√≥s a interface estar pronta (delay menor para restaura√ß√£o r√°pida)
        def restore_and_cleanup():
            # PROTE√á√ÉO: N√£o executar se estivermos numa p√°gina especial
            if getattr(self, '_in_router_selection_page', False):
                print("DEBUG: [ESTADO] WARNING: Restaura√ß√£o cancelada - estamos numa p√°gina de sele√ß√£o de router")
                return
                
            restore_gestao_state()
            
            # LIMPEZA FINAL: Remover estado imediato ap√≥s restaura√ß√£o completa
            print("DEBUG: [ESTADO] SUCCESS: LIMPEZA FINAL: Removendo estado imediato ap√≥s restaura√ß√£o completa")
            if hasattr(self, '_estado_botoes_imediato'):
                self._estado_botoes_imediato = None
                print("DEBUG: [ESTADO] SUCCESS: Estado imediato limpo - sistema pronto para pr√≥xima captura")
        
        self.after(100, restore_and_cleanup)
    
    def debug_click_events(self, event=None):
        """Debug para clicks que n√£o s√£o processados"""
        print(f"DEBUG: [debug_click_events] Click detectado na coordenada: x={event.x if event else 'N/A'}, y={event.y if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Widget: {event.widget if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Estado da interface: widgets={len(self.winfo_children())}")
        return "break"  # Impede propaga√ß√£o do evento
    
    def add_starter_cards(self):
        """
        Fun√ß√£o para dar cartas iniciais espec√≠ficas ao jogador.
        """
        print("DEBUG: [PlayerDashboard] Adicionando cartas iniciais espec√≠ficas...")
        
        # Usar a detec√ß√£o autom√°tica para Raspberry Pi e desenvolvimento local
        base_path = detect_player_inventory_base_dir()
        print(f"DEBUG: [add_starter_cards] Base path detectado: {base_path}")
        print(f"DEBUG: [add_starter_cards] Player color: {self.player_color}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar se player_color est√° correto
        print(f"DEBUG: [add_starter_cards] Player color atual: '{self.player_color}'")
        print(f"DEBUG: [add_starter_cards] Tipo do player_color: {type(self.player_color)}")
        
        # Definir cartas espec√≠ficas para cada tipo de invent√°rio
        starter_cards_config = {
            "users": ["User_2.png"],
            "equipments": ["Equipment_1.png", "Equipment_7.png"], 
            "services": ["Service_1.png", "Service_2.png", "Service_5.png"],
            "activities": ["Activity_1.png"],
            "challenges": ["Challenge_1.png"]
        }
        
        # CORRE√á√ÉO: Garantir que a cor est√° normalizada corretamente
        player_color_lower = str(self.player_color).lower().strip()
        
        # Mapeamento correto de cores
        if player_color_lower == "red":
            color_variants = ["Red", "red"]
        elif player_color_lower == "blue":
            color_variants = ["Blue", "blue"] 
        elif player_color_lower == "green":
            color_variants = ["Green", "green"]
        elif player_color_lower == "yellow":
            color_variants = ["Yellow", "yellow"]
        else:
            print(f"DEBUG: [add_starter_cards] ERRO: Cor n√£o reconhecida: '{self.player_color}'")
            print(f"DEBUG: [add_starter_cards] For√ßando cor vermelha como fallback")
            color_variants = ["Red", "red"]  # Fallback para vermelho
        
        print(f"DEBUG: [add_starter_cards] Color variants a usar: {color_variants}")
        
        # Processar cartas por cor do jogador (users, equipments, services, activities)
        for card_type, target_cards in starter_cards_config.items():
            if card_type == "challenges":
                continue  # Processar challenges separadamente
                
            print(f"DEBUG: [add_starter_cards] Processando {card_type}: {target_cards}")
            
            for card_filename in target_cards:
                card_found = False
                
                # Testar ambas as varia√ß√µes de cor
                for color_variant in color_variants:
                    # Poss√≠veis estruturas de pastas
                    possible_paths = [
                        # Estrutura desenvolvimento local
                        os.path.join(base_path, card_type.capitalize(), "Residential-level", color_variant, card_filename),
                        # Estrutura Raspberry Pi 
                        os.path.join(base_path, card_type.lower(), "Residential-level", color_variant, card_filename),
                        # Estrutura alternativa
                        os.path.join(base_path, "cartas", card_type.lower(), "Residential-level", color_variant, card_filename)
                    ]
                    
                    print(f"DEBUG: [add_starter_cards] Procurando {card_filename} cor {color_variant}:")
                    for path_attempt in possible_paths:
                        print(f"DEBUG: [add_starter_cards]   Testando: {path_attempt}")
                        if os.path.exists(path_attempt):
                            print(f"DEBUG: [add_starter_cards]   ‚úì ENCONTRADO: {path_attempt}")
                            
                            # VERIFICA√á√ÉO ADICIONAL: Confirmar que a carta √© realmente da cor correta
                            if color_variant.lower() in path_attempt.lower():
                                if path_attempt not in self.inventario.get(card_type, []):
                                    self.inventario.setdefault(card_type, []).append(path_attempt)
                                    print(f"DEBUG: [add_starter_cards]   ‚úì ADICIONADO ao invent√°rio {card_type}")
                                else:
                                    print(f"DEBUG: [add_starter_cards]   - J√° existe no invent√°rio")
                                card_found = True
                                break
                            else:
                                print(f"DEBUG: [add_starter_cards]   ‚úó Cor incorreta no caminho")
                    
                    if card_found:
                        break
                
                if not card_found:
                    print(f"DEBUG: [add_starter_cards]   ‚úó N√ÉO ENCONTRADO: {card_filename} para {card_type} cor {self.player_color}")
        
        # Processar challenges (neutros) separadamente
        challenges_to_add = starter_cards_config["challenges"]
        print(f"DEBUG: [add_starter_cards] Processando challenges neutros: {challenges_to_add}")
        
        for challenge_filename in challenges_to_add:
            # Tentar estrutura do desenvolvimento local e Raspberry Pi
            possible_challenge_paths = [
                os.path.join(base_path, "Challenges", "Residential-level", challenge_filename),
                os.path.join(base_path, "challenges", "Residential-level", challenge_filename),
                os.path.join(base_path, "cartas", "challenges", "Residential-level", challenge_filename)
            ]
            
            challenge_found = False
            for path_attempt in possible_challenge_paths:
                print(f"DEBUG: [add_starter_cards] Testando challenge: {path_attempt}")
                if os.path.exists(path_attempt):
                    print(f"DEBUG: [add_starter_cards] ‚úì ENCONTRADO challenge: {path_attempt}")
                    if path_attempt not in self.inventario.get("challenges", []):
                        self.inventario.setdefault("challenges", []).append(path_attempt)
                        print(f"DEBUG: [add_starter_cards] ‚úì Challenge adicionado ao invent√°rio")
                    challenge_found = True
                    break
            
            if not challenge_found:
                print(f"DEBUG: [add_starter_cards] ‚úó Challenge n√£o encontrado: {challenge_filename}")
        
        print(f"DEBUG: [PlayerDashboard] Resumo final do invent√°rio:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")
            if tipo == "equipments":
                for carta in cartas:
                    print(f"DEBUG: [PlayerDashboard]     - {os.path.basename(carta)} -> {carta}")
        
        print("DEBUG: [PlayerDashboard] Cartas iniciais adicionadas com verifica√ß√£o de cor!")
    
    def _get_card_message_size(self, carta_path):
        """
        Extrai o message_size de uma carta Activity ou Challenge usando a base de dados
        """
        try:
            if not self.card_database:
                print("DEBUG: Base de dados n√£o est√° dispon√≠vel")
                return 0
            
            # Tentar determinar se √© Activity ou Challenge pelo nome do arquivo
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: Analisando carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair ID da carta Activity
                # Assumindo formato Activity_X.png onde X √© o n√∫mero
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    # Usar o formato correto da base de dados: activity_X_cor
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        print(f"DEBUG: Found activity {activity_id} with message_size: {activity_card.message_size}")
                        return activity_card.message_size
                    else:
                        print(f"DEBUG: Activity {activity_id} n√£o encontrada na base de dados")
                            
            elif "challenge" in carta_basename:
                # Extrair ID da carta Challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        print(f"DEBUG: Found challenge {challenge_id} with message_size: {challenge_card.message_size}")
                        return challenge_card.message_size
                    else:
                        print(f"DEBUG: Challenge {challenge_id} n√£o encontrada na base de dados")
            
            print(f"DEBUG: Could not find message_size for card: {carta_basename}")
            return 0
            
        except Exception as e:
            print(f"DEBUG: Error getting message_size for {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def _get_card_message_size_from_database(self, carta_path):
        """
        CORRE√á√ÉO 2: Fun√ß√£o dedicada para obter message_size sempre da base de dados
        Garante que os valores s√£o sempre obtidos da base de dados integrada
        """
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print("DEBUG: [DATABASE] Base de dados n√£o est√° dispon√≠vel")
                return 20  # fallback padr√£o
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [DATABASE] Analisando carta para message_size: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair n√∫mero da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [DATABASE] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        message_size = getattr(activity_card, 'message_size', 20)
                        print(f"DEBUG: [DATABASE] Activity {activity_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Activity {activity_id} n√£o encontrada")
            
            elif "challenge" in carta_basename:
                # Extrair n√∫mero do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [DATABASE] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        message_size = getattr(challenge_card, 'message_size', 25)
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} n√£o encontrado")
            
            print(f"DEBUG: [DATABASE] Usando fallback para carta: {carta_basename}")
            return 20  # fallback padr√£o
            
        except Exception as e:
            print(f"DEBUG: [DATABASE] Erro ao obter message_size para {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 20  # fallback em caso de erro
    
    def _select_carousel_card(self, card_index, carta_path):
        """
        Seleciona uma carta no carrossel (primeiro clique) ou abre fullscreen (segundo clique)
        """
        print(f"DEBUG: ===== _select_carousel_card CHAMADA =====")
        print(f"DEBUG: card_index={card_index}, carta_path={os.path.basename(carta_path)}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar bloqueio tempor√°rio ap√≥s clique no bot√£o seta
        if getattr(self, '_bloqueio_temporario_carrossel', False):
            print("DEBUG: ERROR: Clique bloqueado temporariamente ap√≥s bot√£o seta - evitando fullscreen acidental")
            return
        
        # CORRE√á√ÉO: Verificar se estamos em Final Phase com gest√£o de pacotes ativa
        # APENAS bloquear se estivermos em gest√£o ativa, n√£o em qualquer Final Phase
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        print(f"DEBUG: Estado atual - gestao_pacotes_ativa: {gestao_pacotes_ativa}, final_phase_normal: {final_phase_normal}")
        
        if gestao_pacotes_ativa:
            print("DEBUG: Gest√£o de pacotes ativa - verificando se carta tem destaque roxo")
            
            # S√≥ permitir clique na carta que tem destaque roxo
            if hasattr(self, '_carta_destacada_posicao') and self._carta_destacada_posicao == card_index:
                print("DEBUG: Clique permitido - carta tem destaque roxo")
                
                # CAPTURAR ESTADO DOS BOT√ïES IMEDIATAMENTE ANTES DO FULLSCREEN
                self._capturar_estado_botoes_imediato()
                
                # Permitir apenas fullscreen da carta destacada
                self.show_card_fullscreen_carrossel(carta_path)
                return
            else:
                print("DEBUG: Clique bloqueado - carta n√£o tem destaque roxo")
                return
        
        # Verificar se √© uma carta virada para baixo (n√£o pode ser selecionada)
        if os.path.basename(carta_path).startswith("back_card_"):
            print(f"DEBUG: Carta virada para baixo n√£o pode ser selecionada")
            return
        
        # CORRE√á√ÉO: Permitir cliques normais em Final Phase (quando n√£o est√° em gest√£o de pacotes)
        # S√≥ verificar Next Phase se realmente estiver ativo
        if getattr(self, '_next_phase_active', False) and not final_phase_normal:
            if not self._can_access_carousel_position(card_index):
                print(f"DEBUG: Clique bloqueado - sem permiss√£o durante Next Phase para posi√ß√£o {card_index}")
                return
        
        # Verificar se √© Activity ou Challenge
        carta_basename = os.path.basename(carta_path).lower()
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: Carta {carta_basename} n√£o √© Activity nem Challenge")
            return
        
        # Se clicar na mesma carta j√° selecionada, abrir fullscreen
        if (self.selected_carousel_index == card_index and 
            self.selected_carousel_card == carta_path):
            print(f"DEBUG: Segundo clique na carta {card_index} - abrindo fullscreen")
            
            # CORRE√á√ÉO CR√çTICA: Detectar estado dos bot√µes IMEDIATAMENTE antes do fullscreen
            print("DEBUG: [ESTADO] === DETEC√á√ÉO IMEDIATA DOS BOT√ïES ===")
            estado_imediato = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            # Detectar estado atual dos bot√µes AGORA
            if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                try:
                    if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                        estado_imediato['btn_plus_rxd_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Bot√£o + Rxd DETECTADO como vis√≠vel")
                except:
                    pass
            
            if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                try:
                    if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                        estado_imediato['btn_plus_lost_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Bot√£o + Lost DETECTADO como vis√≠vel")
                except:
                    pass
            
            if hasattr(self, '_btn_seta') and self._btn_seta:
                try:
                    if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                        estado_imediato['btn_seta_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Bot√£o seta DETECTADO como vis√≠vel")
                except:
                    pass
            
            print(f"DEBUG: [ESTADO] RESULTADO DETEC√á√ÉO IMEDIATA:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {estado_imediato['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {estado_imediato['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {estado_imediato['btn_seta_visivel']}")
            
            # Salvar o estado detectado IMEDIATAMENTE
            self._estado_botoes_imediato = estado_imediato
            
            # CORRE√á√ÉO CR√çTICA: Salvar estado da dashboard antes de abrir fullscreen
            self._save_dashboard_state()
            self.show_card_fullscreen_carrossel(carta_path)
            return
        
        # Primeiro clique: selecionar carta
        print(f"DEBUG: Primeiro clique - Selecionando carta {card_index}: {os.path.basename(carta_path)}")
        
        # Atualizar sele√ß√£o
        self.selected_carousel_card = carta_path
        self.selected_carousel_index = card_index
        
        # Atualizar destaques visuais
        print(f"DEBUG: Atualizando destaques visuais...")
        self._update_carousel_selection_highlights()
        
        # CORRE√á√ÉO: Verificar se h√° valores preservados para esta carta antes de atualizar barras
        print(f"DEBUG: ===== VERIFICANDO VALORES PRESERVADOS =====")
        carta_index_in_carrossel = card_index
        if carta_index_in_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[carta_index_in_carrossel]
            print(f"DEBUG: Stats preservadas para carta {carta_index_in_carrossel}: {preserved_stats}")
            
            # CORRE√á√ÉO PROBLEMA 1: SEMPRE atualizar barras diretamente da base de dados primeiro
            # Depois aplicar valores preservados apenas se diferentes de zero
            print(f"DEBUG: UPDATING: ATUALIZANDO BARRAS DA BASE DE DADOS - ANTES FINAL PHASE")
            self._update_progress_bars_from_card(carta_path)
            
            # NOVA L√ìGICA: Aplicar valores preservados apenas se diferentes dos defaults
            message_size = self._get_card_message_size_from_database(carta_path)
            rxd_preservado = preserved_stats.get('Rxd', 0)
            lost_preservado = preserved_stats.get('Lost', 0)
            to_send_preservado = preserved_stats.get('To send', message_size)
            
            # Se valores preservados diferem dos defaults da base de dados, aplicar
            if rxd_preservado > 0 or lost_preservado > 0 or to_send_preservado != message_size:
                print(f"DEBUG: STATS: APLICANDO VALORES PRESERVADOS - ANTES FINAL PHASE")
                self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_path)
            else:
                print(f"DEBUG: SUCCESS: VALORES PRESERVADOS S√ÉO DEFAULTS - MANTENDO BASE DE DADOS")
        else:
            print(f"DEBUG: WARNING: √çndice {carta_index_in_carrossel} fora do range de card_stats")
            print(f"DEBUG: UPDATING: ATUALIZANDO BARRAS DIRETAMENTE DA BASE DE DADOS")
            self._update_progress_bars_from_card(carta_path)
        
        print(f"DEBUG: ===== FIM _select_carousel_card =====\n")
    
    def _update_carousel_selection_highlights(self):
        """
        Atualiza os destaques das cartas no carrossel baseado na sele√ß√£o atual
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: WARNING: card_labels n√£o existe ou est√° vazio - pulando atualiza√ß√£o de destaques")
            return
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights INICIADA =====")
        print(f"DEBUG: selected_carousel_index: {getattr(self, 'selected_carousel_index', None)}")
        print(f"DEBUG: _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        print(f"DEBUG: _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar se todos os widgets est√£o v√°lidos ANTES de processar
        widgets_destruidos = 0
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: WARNING: Widget carta {i} foi destru√≠do, pulando configura√ß√£o")
                    widgets_destruidos += 1
                    continue
            except tk.TclError:
                print(f"DEBUG: WARNING: Widget carta {i} n√£o √© v√°lido (TclError), pulando configura√ß√£o")
                widgets_destruidos += 1
                continue
        
        # Se muitos widgets foram destru√≠dos, cancelar atualiza√ß√£o
        if widgets_destruidos >= len(self.card_labels) // 2:
            print(f"DEBUG: WARNING: Muitos widgets destru√≠dos ({widgets_destruidos}/{len(self.card_labels)}) - cancelando atualiza√ß√£o")
            print(f"DEBUG: ===== _update_carousel_selection_highlights CANCELADA =====\n")
            return
        
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # CORRE√á√ÉO: Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: WARNING: Widget carta {i} foi destru√≠do, pulando configura√ß√£o")
                    continue
            except tk.TclError:
                print(f"DEBUG: WARNING: Widget carta {i} n√£o √© v√°lido (TclError), pulando configura√ß√£o")
                continue
            
            carta_path = self.cards[i]
            is_back_card = os.path.basename(carta_path).startswith("back_card_")
            next_phase_active = getattr(self, '_next_phase_active', False)
            final_phase_active = getattr(self, '_final_phase_active', False)
            gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            
            # CORRE√á√ÉO: L√≥gica de destaques mais clara e espec√≠fica
            highlight_color = "black"
            border_width = 0
            border_color = "black"
            
            # PRIORIDADE 1: Gest√£o de pacotes (destaque roxo espec√≠fico) - PRIORIDADE M√ÅXIMA
            if gestao_pacotes_ativa:
                # CORRE√á√ÉO CR√çTICA: Usar selected_carousel_index como fonte da verdade durante gest√£o
                # Em vez de confiar apenas em _carta_atual_gestao, usar a posi√ß√£o realmente selecionada
                posicao_gestao_atual = getattr(self, 'selected_carousel_index', None)
                
                # VALIDA√á√ÉO DUPLA: Verificar tamb√©m _carta_atual_gestao como backup
                carta_atual_gestao = getattr(self, '_carta_atual_gestao', None)
                
                # Se n√£o temos posi√ß√£o selecionada mas temos gest√£o ativa, usar a gest√£o
                if posicao_gestao_atual is None and carta_atual_gestao is not None:
                    if hasattr(self, '_cartas_gestao') and carta_atual_gestao < len(self._cartas_gestao):
                        carta_path_atual = self._cartas_gestao[carta_atual_gestao]
                        # Encontrar posi√ß√£o desta carta no carrossel
                        for idx, carta in enumerate(self.cards):
                            if carta == carta_path_atual:
                                posicao_gestao_atual = idx
                                print(f"DEBUG: Carta gest√£o encontrada na posi√ß√£o {idx}: {os.path.basename(carta_path_atual)}")
                                break
                
                # APLICAR DESTAQUE: Apenas a posi√ß√£o selecionada/atual deve ter destaque roxo
                if posicao_gestao_atual is not None and i == posicao_gestao_atual:
                    # VERIFICA√á√ÉO ADICIONAL: Garantir que a carta n√£o √© back_card
                    carta_na_posicao = self.cards[i] if i < len(self.cards) else None
                    if carta_na_posicao:
                        carta_basename = os.path.basename(carta_na_posicao).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            highlight_color = "#800080"  # Roxo
                            border_width = 3
                            border_color = "#800080"
                            print(f"DEBUG: Carta {i} - destaque ROXO (gest√£o de pacotes ativa) - carta atual: {os.path.basename(carta_na_posicao)}")
                        else:
                            highlight_color = "black"
                            border_width = 0
                            border_color = "black"
                            print(f"DEBUG: Carta {i} - sem destaque (gest√£o ativa mas carta inv√°lida: {carta_basename})")
                    else:
                        highlight_color = "black"
                        border_width = 0
                        border_color = "black"
                        print(f"DEBUG: Carta {i} - sem destaque (gest√£o ativa mas carta n√£o encontrada)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (gest√£o de pacotes ativa, n√£o √© carta atual)")
            
            # PRIORIDADE 2: Final Phase normal (sem gest√£o de pacotes)
            elif final_phase_active and not gestao_pacotes_ativa:
                # CORRE√á√ÉO CR√çTICA: Durante Final Phase SEM gest√£o ativa, N√ÉO aplicar QUALQUER destaque
                # Ap√≥s finalizar gest√£o de pacotes, limpar TODOS os destaques
                # As cartas devem voltar ao estado visual normal (sem destaque)
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - SEM DESTAQUE (Final Phase, gest√£o finalizada - limpeza completa)")
                
                # CORRE√á√ÉO CR√çTICA: N√ÉO limpar selected_carousel_index durante Final Phase
                # O √≠ndice deve ser preservado para permitir navega√ß√£o e gest√£o de pacotes
                # Removida a limpeza autom√°tica do selected_carousel_index
            
            # PRIORIDADE 3: Next Phase (cartas viradas para baixo com destaque roxo)
            elif next_phase_active and is_back_card:
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"
                    print(f"DEBUG: Carta {i} - destaque ROXO (Next Phase, pode selecionar)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (Next Phase, n√£o pode selecionar)")
            
            # PRIORIDADE 4: Estado normal (destaque da cor do jogador)
            elif i == self.selected_carousel_index and not is_back_card:
                highlight_color = self.bar_color
                border_width = 3
                border_color = self.player_color.lower()
                print(f"DEBUG: Carta {i} - destaque COR DO JOGADOR (estado normal)")
            
            # PRIORIDADE 5: Sem destaque
            else:
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - sem destaque (estado normal)")
            
            try:
                lbl.config(bg=highlight_color, borderwidth=border_width, relief="solid" if border_width > 0 else "flat",
                          highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
                print(f"DEBUG: SUCCESS: Carta {i} configurada: bg={highlight_color}, border={border_width}")
            except tk.TclError as e:
                print(f"DEBUG: ERROR: Widget carta {i} inv√°lido (TclError): {e}")
                continue
            except Exception as e:
                print(f"DEBUG: ERROR: Erro ao configurar carta {i}: {e}")
                continue
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights TERMINADA =====\n")
    
    def _update_progress_bars_from_card(self, carta_path):
        """
        Atualiza as barras de progresso com base nos dados da carta selecionada
        CORRE√á√ÉO: Considera valores preservados para comportamento din√¢mico correto
        """
        try:
            print(f"DEBUG: ===== UPDATING: _update_progress_bars_from_card INICIADA =====")
            print(f"DEBUG: CLIPBOARD: Carta selecionada: {os.path.basename(carta_path)}")
            print(f"DEBUG: TARGET: CONTEXTO: Atualizando barras ANTES do Final Phase (comportamento din√¢mico)")
            
            # Verificar se as barras de progresso est√£o inicializadas
            print(f"DEBUG: Verificando inicializa√ß√£o...")
            print(f"DEBUG: hasattr(self, 'progress_bars'): {hasattr(self, 'progress_bars')}")
            print(f"DEBUG: hasattr(self, 'progress_labels'): {hasattr(self, 'progress_labels')}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ERROR: Barras de progresso n√£o inicializadas")
                return
                
            print(f"DEBUG: SUCCESS: Barras de progresso inicializadas")
            print(f"DEBUG: progress_bars keys: {list(self.progress_bars.keys())}")
            print(f"DEBUG: progress_labels keys: {list(self.progress_labels.keys())}")
                
            # Obter message_size da base de dados
            print(f"DEBUG: Extraindo message_size da base de dados...")
            message_size = self._get_card_message_size_from_database(carta_path)
            print(f"DEBUG: STATS: Message size extra√≠do da base de dados: {message_size}")
            
            # CORRE√á√ÉO CR√çTICA: Verificar se existem valores preservados para esta carta
            carta_idx = None
            if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                carta_idx = self.selected_carousel_index
            elif hasattr(self, 'cards') and self.cards:
                # Procurar o √≠ndice da carta no carrossel
                for i, carta_carrossel in enumerate(self.cards):
                    if carta_carrossel and os.path.basename(carta_carrossel) == os.path.basename(carta_path):
                        carta_idx = i
                        break
            
            # Verificar se existem valores preservados
            preserved_stats = None
            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats)):
                preserved_stats = self.card_stats[carta_idx]
                print(f"DEBUG: STATS: VALORES PRESERVADOS ENCONTRADOS para carta {carta_idx}: {preserved_stats}")
            else:
                print(f"DEBUG: STATS: Nenhum valor preservado encontrado - usando valores padr√£o")
                print(f"DEBUG: STATS: Debug info: carta_idx={carta_idx}, card_stats_len={len(getattr(self, 'card_stats', []))}")
            
            # Verificar se "To send" existe nas barras
            if "To send" not in self.progress_bars:
                print("DEBUG: ERROR: 'To send' n√£o encontrado em progress_bars")
                return
                
            if "To send" not in self.progress_labels:
                print("DEBUG: ERROR: 'To send' n√£o encontrado em progress_labels")
                return
            
            print(f"DEBUG: SUCCESS: 'To send' encontrado em ambas as estruturas")
            
            # Configurar barra "To send"
            try:
                print(f"DEBUG: Atualizando barras de progresso...")
                
                # CORRE√á√ÉO: Definir o message_size como m√°ximo para TODAS as barras (To send, Rxd, Lost)
                # Isso garante precis√£o visual - barras com mesmo valor ficar√£o alinhadas
                for bar_name in ["To send", "Rxd", "Lost"]:
                    if bar_name in self.progress_bars:
                        self.progress_bars[bar_name]["maximum"] = message_size
                        print(f"DEBUG: SUCCESS: M√°ximo da barra '{bar_name}' definido para {message_size}")
                
                # CORRE√á√ÉO: Usar valores preservados se dispon√≠veis, sen√£o usar valor padr√£o
                if preserved_stats and 'To send' in preserved_stats:
                    to_send_value = preserved_stats['To send']
                    print(f"DEBUG: STATS: USANDO VALOR PRESERVADO para To send: {to_send_value}")
                else:
                    to_send_value = message_size  # Valor padr√£o (barra cheia)
                    print(f"DEBUG: STATS: USANDO VALOR PADR√ÉO para To send: {to_send_value}")
                
                # Configurar valor da barra To send
                self.progress_bars["To send"]["value"] = to_send_value
                self.progress_labels["To send"]["text"] = str(to_send_value)
                
                print(f"DEBUG: SUCCESS: Barra 'To send' configurada:")
                print(f"DEBUG:   - M√°ximo: {message_size}")
                print(f"DEBUG:   - Valor: {to_send_value}")
                print(f"DEBUG:   - Label: '{to_send_value}'")
                
                # CORRE√á√ÉO: Atualizar todas as outras barras (Rxd e Lost) com mesmo m√°ximo e valores preservados
                for bar_name in ['Rxd', 'Lost']:
                    if bar_name in self.progress_bars and bar_name in self.progress_labels:
                        # IMPORTANTE: As barras j√° foram configuradas com maximum=message_size acima
                        if preserved_stats and bar_name in preserved_stats:
                            # Usar valor preservado
                            preserved_value = preserved_stats[bar_name]
                            self.progress_bars[bar_name]["value"] = preserved_value
                            self.progress_labels[bar_name]["text"] = str(preserved_value)
                            print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor preservado: {preserved_value} (m√°x: {message_size})")
                        else:
                            # NOVO: Usar valor padr√£o (buscar no card_stats se dispon√≠vel)
                            carta_idx = getattr(self, 'selected_carousel_index', None)
                            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats) and
                                bar_name in self.card_stats[carta_idx]):
                                # Usar valor atual do card_stats se dispon√≠vel
                                current_value = self.card_stats[carta_idx][bar_name]
                                self.progress_bars[bar_name]["value"] = current_value
                                self.progress_labels[bar_name]["text"] = str(current_value)
                                print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor do card_stats: {current_value} (m√°x: {message_size})")
                            else:
                                # √öltimo recurso: valor padr√£o 0
                                self.progress_bars[bar_name]["value"] = 0
                                self.progress_labels[bar_name]["text"] = "0"
                                print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor padr√£o: 0 (m√°x: {message_size})")
                
                # For√ßar atualiza√ß√£o visual
                try:
                    for stat_name in ["To send", "Rxd", "Lost"]:
                        if stat_name in self.progress_bars:
                            widget = self.progress_bars[stat_name]
                            widget.update_idletasks()
                            widget.update()
                        if stat_name in self.progress_labels:
                            widget = self.progress_labels[stat_name]
                            widget.update_idletasks()
                            widget.update()
                    
                    # For√ßar atualiza√ß√£o da janela principal e master
                    self.update_idletasks()
                    self.update()
                    
                    if hasattr(self, 'master') and self.master:
                        self.master.update_idletasks()
                        self.master.update()
                    
                    self.after_idle(lambda: self._force_visual_refresh())
                    print(f"DEBUG: SUCCESS: Atualiza√ß√£o visual completa realizada")
                    
                except Exception as visual_error:
                    print(f"DEBUG: WARNING: Erro durante atualiza√ß√£o visual: {visual_error}")
                
                # Verifica√ß√£o final
                final_value = self.progress_bars["To send"]["value"]
                final_max = self.progress_bars["To send"]["maximum"]
                final_label = self.progress_labels["To send"]["text"]
                print(f"DEBUG: ===== VERIFICA√á√ÉO FINAL =====")
                print(f"DEBUG: M√°ximo final da barra: {final_max}")
                print(f"DEBUG: Valor final da barra: {final_value}")
                print(f"DEBUG: Texto final do label: '{final_label}'")
                print(f"DEBUG: Percentagem da barra: {(final_value/final_max)*100:.1f}%")
                print(f"DEBUG: SUCCESS: SUCESSO - Barra configurada com valores {'preservados' if preserved_stats else 'padr√£o'}!")
                
            except Exception as update_error:
                print(f"DEBUG: ERROR: Erro ao configurar progress bar: {update_error}")
                import traceback
                traceback.print_exc()
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro geral ao atualizar barras de progresso: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: ===== _update_progress_bars_from_card TERMINADA =====\n")

    def _force_visual_refresh(self):
        """
        For√ßa um refresh visual adicional das barras de progresso
        """
        try:
            print("DEBUG: UPDATING: _force_visual_refresh executando...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if (hasattr(self, 'progress_bars') and stat_name in self.progress_bars and
                    hasattr(self, 'progress_labels') and stat_name in self.progress_labels):
                    
                    # For√ßar redesenho dos widgets
                    self.progress_bars[stat_name].update()
                    self.progress_labels[stat_name].update()
            
            self.update()
            print("DEBUG: SUCCESS: _force_visual_refresh conclu√≠do")
        except Exception as e:
            print(f"DEBUG: WARNING: Erro em _force_visual_refresh: {e}")

    def _apply_preserved_stats_to_progress_bars(self, preserved_stats, carta_path=None):
        """
        Aplica estat√≠sticas preservadas diretamente √†s barras de progresso
        CORRE√á√ÉO FUNDAMENTAL: Sempre usar a carta que est√° na posi√ß√£o do carrossel
        """
        try:
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars INICIADA =====")
            print(f"DEBUG: Aplicando stats preservadas: {preserved_stats}")
            print(f"DEBUG: Carta parametro: {os.path.basename(carta_path) if carta_path else 'N/A'}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ERROR: Barras de progresso n√£o inicializadas")
                return
            
            # CORRE√á√ÉO CR√çTICA: SEMPRE usar a carta que est√° realmente no carrossel
            carta_real_para_valores = None
            if (hasattr(self, 'selected_carousel_index') and 
                self.selected_carousel_index is not None and 
                hasattr(self, 'cards') and self.cards):
                
                carrossel_index = self.selected_carousel_index
                if carrossel_index < len(self.cards):
                    carta_real_para_valores = self.cards[carrossel_index]
                    carta_nome = os.path.basename(carta_real_para_valores)
                    
                    print(f"DEBUG: WARNING: IMPORTANTE - Carta REAL no carrossel posi√ß√£o {carrossel_index}: {carta_nome}")
                    print(f"DEBUG: WARNING: IMPORTANTE - Aplicando valores √Ä CARTA DO CARROSSEL, n√£o √† preservada")
                    
                    # Obter message_size da carta que est√° REALMENTE no carrossel
                    correct_message_size = self._get_card_message_size_from_database(carta_real_para_valores)
                    print(f"DEBUG: Message size da carta REAL do carrossel: {correct_message_size}")
                else:
                    print(f"DEBUG: WARNING: √çndice carrossel inv√°lido: {carrossel_index}")
                    carta_real_para_valores = carta_path
                    correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
            else:
                # Fallback para carta_path se n√£o h√° carrossel v√°lido
                carta_real_para_valores = carta_path
                correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
                print(f"DEBUG: WARNING: Sem sele√ß√£o carrossel v√°lida, usando carta_path fallback")
            
            print(f"DEBUG: DEFINITIVO - Carta para aplicar valores: {os.path.basename(carta_real_para_valores) if carta_real_para_valores else 'N/A'}")
            print(f"DEBUG: DEFINITIVO - Message size: {correct_message_size}")
            
            # CORRE√á√ÉO CR√çTICA: Validar consist√™ncia dos valores preservados
            to_send_preservado = preserved_stats.get("To send", 0)
            rxd_preservado = preserved_stats.get("Rxd", 0)
            lost_preservado = preserved_stats.get("Lost", 0)
            
            # CORRE√á√ÉO FUNDAMENTAL: Sempre recalcular To send baseado em message_size - (Rxd + Lost)
            # Isso garante que To send seja sempre consistente independentemente dos valores preservados
            to_send_correto = max(correct_message_size - (rxd_preservado + lost_preservado), 0)
            
            print(f"DEBUG: VALIDA√á√ÉO DE CONSIST√äNCIA:")
            print(f"DEBUG:   Message size: {correct_message_size}")
            print(f"DEBUG:   Rxd preservado: {rxd_preservado}")
            print(f"DEBUG:   Lost preservado: {lost_preservado}")
            print(f"DEBUG:   To send preservado: {to_send_preservado}")
            print(f"DEBUG:   To send CORRETO calculado: {to_send_correto}")
            
            # CORRE√á√ÉO: Se To send preservado n√£o est√° correto, corrigir automaticamente
            if to_send_preservado != to_send_correto:
                print(f"DEBUG: CORRE√á√ÉO AUTOM√ÅTICA: To send inconsistente!")
                print(f"DEBUG:   Preservado: {to_send_preservado}")
                print(f"DEBUG:   Correto: {to_send_correto}")
                print(f"DEBUG:   Aplicando corre√ß√£o autom√°tica...")
                
                # Corrigir os stats preservados
                preserved_stats = preserved_stats.copy()
                preserved_stats["To send"] = to_send_correto
                print(f"DEBUG: SUCCESS: To send corrigido automaticamente: {to_send_correto}")
            else:
                print(f"DEBUG: SUCCESS: To send est√° consistente: {to_send_preservado}")
            
            # Aplicar cada valor preservado (possivelmente corrigido)
            for stat_name, value in preserved_stats.items():
                if stat_name in self.progress_bars and stat_name in self.progress_labels:
                    try:
                        # CORRE√á√ÉO: Para TODAS as barras, usar o message_size correto da carta atual como m√°ximo
                        # Isso garante precis√£o visual - barras com mesmo valor ficam alinhadas
                        if correct_message_size is not None:
                            # Primeiro definir o m√°ximo correto para TODAS as barras
                            self.progress_bars[stat_name]["maximum"] = correct_message_size
                            print(f"DEBUG: SUCCESS: M√°ximo da barra '{stat_name}' corrigido para carta REAL: {correct_message_size}")
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, m√°ximo={correct_message_size}")
                        else:
                            # Fallback para m√°ximo atual
                            current_max = self.progress_bars[stat_name]["maximum"]
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, m√°ximo={current_max} (fallback)")
                        
                        # Aplicar valores
                        self.progress_bars[stat_name]["value"] = value
                        self.progress_labels[stat_name]["text"] = str(value)
                        
                        # For√ßar atualiza√ß√£o
                        self.progress_bars[stat_name].update()
                        self.progress_labels[stat_name].update()
                        
                        print(f"DEBUG: SUCCESS: {stat_name} aplicado com sucesso: {value}")
                    except Exception as e:
                        print(f"DEBUG: ERROR: Erro ao aplicar {stat_name}: {e}")
                else:
                    print(f"DEBUG: WARNING: {stat_name} n√£o encontrado nas barras de progresso")
            
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars TERMINADA =====")
            
            # CORRE√á√ÉO: For√ßar atualiza√ß√£o visual ap√≥s aplicar valores preservados
            print(f"DEBUG: For√ßando atualiza√ß√£o visual ap√≥s aplicar valores preservados...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    self.progress_bars[stat_name].update_idletasks()
                    self.progress_bars[stat_name].update()
                if stat_name in self.progress_labels:
                    self.progress_labels[stat_name].update_idletasks()
                    self.progress_labels[stat_name].update()
            
            # For√ßar atualiza√ß√£o da janela principal
            self.update_idletasks()
            print(f"DEBUG: SUCCESS: Atualiza√ß√£o visual de valores preservados realizada")
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro geral em _apply_preserved_stats_to_progress_bars: {e}")
            import traceback
            traceback.print_exc()

    def _sync_card_stats_with_progress_bars(self):
        """
        Sincroniza os valores atuais das barras de progresso com card_stats
        Deve ser chamado sempre que as barras s√£o modificadas
        """
        try:
            if (not hasattr(self, 'selected_carousel_index') or 
                self.selected_carousel_index is None or
                not hasattr(self, 'progress_bars') or 
                not hasattr(self, 'progress_labels')):
                return
            
            carta_index = self.selected_carousel_index
            if carta_index >= len(self.card_stats):
                return
            
            print(f"DEBUG: Sincronizando card_stats[{carta_index}] com barras de progresso")
            
            # Capturar valores atuais das barras
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    current_value = self.progress_bars[stat_name]["value"]
                    old_value = self.card_stats[carta_index][stat_name]
                    
                    # Atualizar card_stats
                    self.card_stats[carta_index][stat_name] = current_value
                    
                    print(f"DEBUG: {stat_name}: {old_value} -> {current_value}")
            
            print(f"DEBUG: SUCCESS: card_stats[{carta_index}] sincronizado: {self.card_stats[carta_index]}")
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro ao sincronizar card_stats: {e}")
            import traceback
            traceback.print_exc()

    def decrement_to_send_progress(self, packets_sent=1):
        """
        Decrementa a barra 'To send' quando pacotes s√£o enviados.
        Esta fun√ß√£o deve ser chamada pelo sistema de jogo quando pacotes s√£o efetivamente enviados.
        
        Args:
            packets_sent (int): N√∫mero de pacotes enviados (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "To send" not in self.progress_bars:
                print("DEBUG: Barra 'To send' n√£o dispon√≠vel para decremento")
                return
            
            current_value = self.progress_bars["To send"]["value"]
            new_value = max(0, current_value - packets_sent)  # N√£o pode ser negativo
            
            print(f"DEBUG: Decrementando 'To send': {current_value} - {packets_sent} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["To send"]["value"] = new_value
            self.progress_labels["To send"]["text"] = str(new_value)
            
            # For√ßar atualiza√ß√£o da interface
            self.progress_bars["To send"].update()
            self.progress_labels["To send"].update()
            
            # CORRE√á√ÉO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            # Verificar se todos os pacotes foram enviados
            if new_value == 0:
                print("DEBUG: SUCCESS: Todos os pacotes da mensagem foram enviados! Barra vazia.")
            else:
                percentage = (new_value / self.progress_bars["To send"]["maximum"]) * 100
                print(f"DEBUG: Restam {new_value} pacotes para enviar ({percentage:.1f}% da barra)")
                
        except Exception as e:
            print(f"DEBUG: Erro ao decrementar barra 'To send': {e}")
            import traceback
            traceback.print_exc()

    def increment_rxd_progress(self, packets_received=1):
        """
        Incrementa a barra 'Rxd' quando pacotes s√£o recebidos.
        
        Args:
            packets_received (int): N√∫mero de pacotes recebidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Rxd" not in self.progress_bars:
                print("DEBUG: Barra 'Rxd' n√£o dispon√≠vel para incremento")
                return
            
            current_value = self.progress_bars["Rxd"]["value"]
            new_value = current_value + packets_received
            
            print(f"DEBUG: Incrementando 'Rxd': {current_value} + {packets_received} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Rxd"]["value"] = new_value
            self.progress_labels["Rxd"]["text"] = str(new_value)
            
            # For√ßar atualiza√ß√£o da interface
            self.progress_bars["Rxd"].update()
            self.progress_labels["Rxd"].update()
            
            # CORRE√á√ÉO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            # NOVO: Data Volume packet consumption logic
            self._consume_data_volume_packets(packets_received)
            
            print(f"DEBUG: SUCCESS: 'Rxd' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Rxd': {e}")
            import traceback
            traceback.print_exc()

    def increment_lost_progress(self, packets_lost=1):
        """
        Incrementa a barra 'Lost' quando pacotes s√£o perdidos.
        
        Args:
            packets_lost (int): N√∫mero de pacotes perdidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Lost" not in self.progress_bars:
                print("DEBUG: Barra 'Lost' n√£o dispon√≠vel para incremento")
                return
            
            current_value = self.progress_bars["Lost"]["value"]
            new_value = current_value + packets_lost
            
            print(f"DEBUG: Incrementando 'Lost': {current_value} + {packets_lost} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Lost"]["value"] = new_value
            self.progress_labels["Lost"]["text"] = str(new_value)
            
            # For√ßar atualiza√ß√£o da interface
            self.progress_bars["Lost"].update()
            self.progress_labels["Lost"].update()
            
            # CORRE√á√ÉO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            print(f"DEBUG: SUCCESS: 'Lost' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Lost': {e}")
            import traceback
            traceback.print_exc()

    def _extrair_valor_venda_carta(self, carta_path):
        """
        Extrai o valor de venda da carta usando a base de dados integrada
        Similar ao _extrair_valor_carta do Store_v2.py mas retorna sell_cost
        """
        # CORRE√á√ÉO: Verifica√ß√£o adicional para garantir que Services sempre retornam 0
        path_lower = carta_path.lower()
        nome = os.path.basename(carta_path)
        if "/services/" in path_lower or "service_" in nome.lower():
            print(f"DEBUG: Service detectada - for√ßando valor de venda 0: {nome}")
            return 0
        
        if not self.card_database:
            print("DEBUG: Base de dados n√£o dispon√≠vel, usando extra√ß√£o por nome de arquivo")
            return self._extrair_valor_fallback(carta_path)
        
        try:
            # Determinar tipo da carta pelo caminho
            carta_tipo = self._get_card_type_from_path(carta_path)
            if not carta_tipo:
                print(f"DEBUG: Tipo de carta n√£o identificado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Mapear arquivo para ID da base de dados
            card_id = self._map_file_to_card_id(carta_path, carta_tipo)
            if not card_id:
                print(f"DEBUG: ID da carta n√£o mapeado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Obter carta da base de dados
            if carta_tipo == "users":
                card = self.card_database.get_user(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "equipments":
                card = self.card_database.get_equipment(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "services":
                card = self.card_database.get_service(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "activities":
                card = self.card_database.get_activity(card_id)
                valor = card.sell_cost if card else None  # Activities t√™m sell_cost = 0
            elif carta_tipo == "actions":
                card = self.card_database.get_action(card_id)
                valor = 0 if card else None  # Actions n√£o podem ser vendidas
            else:
                print(f"DEBUG: Tipo de carta n√£o suportado para venda: {carta_tipo}")
                return self._extrair_valor_fallback(carta_path)
            
            if valor is not None:
                print(f"DEBUG: Valor de venda encontrado na base de dados: {valor} para {card_id}")
                return valor
            else:
                print(f"DEBUG: Carta n√£o encontrada na base de dados: {card_id}")
                return self._extrair_valor_fallback(carta_path)
                
        except Exception as e:
            print(f"DEBUG: Erro ao extrair valor da base de dados: {e}")
            return self._extrair_valor_fallback(carta_path)
    
    def _extrair_valor_fallback(self, carta_path):
        """M√©todo fallback para extrair valor do nome do arquivo"""
        try:
            import re
            nome = os.path.basename(carta_path)
            path_lower = carta_path.lower()
            
            # CORRE√á√ÉO: Services sempre t√™m valor de venda 0, independentemente do fallback
            if "/services/" in path_lower or "service_" in nome.lower():
                print(f"DEBUG: Service detectada no fallback - retornando 0: {nome}")
                return 0
            
            # Para outros tipos, extrair do nome do arquivo
            match = re.search(r'_(\d+)\.', nome)
            if match:
                valor = int(match.group(1))
                print(f"DEBUG: Valor extra√≠do por fallback: {valor}")
                return valor
        except Exception as e:
            print(f"DEBUG: Erro no fallback: {e}")
        return 1  # Valor padr√£o
    
    def _get_card_type_from_path(self, carta_path):
        """Determina o tipo da carta pelo caminho"""
        path_lower = carta_path.lower()
        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
            return "users"
        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
            return "equipments"
        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
            return "services"
        elif "/activities/" in path_lower or "activity_" in os.path.basename(path_lower):
            return "activities"
        elif "/actions/" in path_lower or "action_" in os.path.basename(path_lower):
            return "actions"
        return None
    
    def _map_file_to_card_id(self, carta_path, carta_tipo):
        """Mapeia arquivo para ID da base de dados"""
        nome = os.path.basename(carta_path)
        cor = self._get_color_from_path(carta_path)
        
        # Fallback para cor se n√£o detectada no caminho
        if not cor:
            cor = self.player_color  # Usar cor do jogador como padr√£o aqui
        
        if carta_tipo == "users":
            # User_1.png -> contract_red, User_2.png -> 1_red, User_3.png -> 2_red, etc.
            match = re.search(r'User_(\d+)\.', nome)
            if match:
                user_num = int(match.group(1))
                if user_num == 1:  # User_1.png = Residential Contract
                    return f"contract_{cor}"
                elif user_num >= 2:  # User_2.png = user ID 1, User_3.png = user ID 2, etc.
                    return f"{user_num - 1}_{cor}"
        
        elif carta_tipo == "equipments":
            # Equipment_1.png -> small_router_1_red, etc.
            match = re.search(r'Equipment_(\d+)\.', nome)
            if match:
                eq_num = int(match.group(1))
                if 1 <= eq_num <= 3:
                    return f"small_router_{eq_num}_{cor}"
                elif 4 <= eq_num <= 6:
                    return f"medium_router_{eq_num - 3}_{cor}"
                elif 7 <= eq_num <= 9:
                    return f"short_link_{eq_num - 6}_{cor}"
                elif 10 <= eq_num <= 12:
                    return f"long_link_{eq_num - 9}_{cor}"
        
        elif carta_tipo == "services":
            # Service_1.png -> Service_1, Service_2.png -> Service_2, etc.
            # Usar ID direto sem mapeamento complexo
            match = re.search(r'Service_(\d+)\.', nome)
            if match:
                service_num = match.group(1)
                return f"Service_{service_num}"
        
        elif carta_tipo == "activities":
            # Activity_1.png -> activity_1_red, etc.
            match = re.search(r'Activity_(\d+)\.', nome)
            if match:
                activity_num = int(match.group(1))
                return f"activity_{activity_num}_{cor}"
        
        elif carta_tipo == "actions":
            # Action_1.png -> action_1, etc.
            match = re.search(r'Action_(\d+)\.', nome)
            if match:
                action_num = int(match.group(1))
                return f"action_{action_num}"
        
        return None
    
    def _extract_event_id_from_path(self, carta_path):
        """Extrai o ID do Event a partir do caminho da carta"""
        try:
            nome = os.path.basename(carta_path)
            # Event_123.png -> event_123
            import re
            match = re.search(r'Event_(\d+)\.', nome)
            if match:
                event_num = int(match.group(1))
                return f"event_{event_num}"
        except Exception as e:
            print(f"DEBUG: [_extract_event_id_from_path] Erro ao extrair ID do Event: {e}")
        return None
    
    def _get_color_from_path(self, carta_path):
        """Extrai a cor do caminho da carta"""
        path_lower = carta_path.lower()
        if "/red/" in path_lower or "-red" in path_lower:
            return "red"
        elif "/blue/" in path_lower or "-blue" in path_lower:
            return "blue"
        elif "/green/" in path_lower or "-green" in path_lower:
            return "green"
        elif "/yellow/" in path_lower or "-yellow" in path_lower:
            return "yellow"
        return self.player_color  # Usar cor do jogador como padr√£o
        
    # Cargas de cartas usando a nova estrutura: [tipo]/Residential-level/[cor]/
    def load_cards_from_new_structure(self, card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Mapear tipo para nome da pasta
            folder_mapping = {
                "users": "Users",
                "equipments": "Equipments", 
                "services": "Services",
                "activities": "Activities",
                "challenges": "Challenges",
                "actions": "Actions",
                "events": "Events"
            }
            
            folder_name = folder_mapping.get(card_type, card_type)
            
            # Para cartas que t√™m cores espec√≠ficas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Tentar encontrar cartas na estrutura: [tipo]/Residential-level/[cor]/
                for color_var in color_variants:
                    path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                                break  # Para no primeiro caminho que funcionar
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor espec√≠fica (challenges, events, actions)
                path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar {card_type}: {e}")
            
            return cards

    def animate_typing(self, label, text, delay=50, callback=None):
        def _type(i=0):
            if i <= len(text):
                label.config(text=text[:i])
                label.after(delay, _type, i + 1)
            elif callback:
                callback()
        _type()

    def show_dice_roll_screen(self, player_name, saldo, other_players, screen_width, screen_height):
        # Reset da flag de Action removida - novo turno, cartas podem ficar viradas para cima novamente
        # Reset flags de cartas removidas no in√≠cio de cada turno
        self._action_recently_removed = False
        self._event_recently_removed = False
        print("DEBUG: [DICE_ROLL] Flags _action_recently_removed e _event_recently_removed resetadas para False - novo turno")
        
        # VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES EXPIRADOS NO IN√çCIO DO TURNO
        print("DEBUG: [DICE_ROLL] === VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES EXPIRADOS NO TURNO ===")
        services_expirados_encontrados = self._verificar_services_expirados_automaticamente()
        print("DEBUG: [DICE_ROLL] === FIM VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES ===")
        
        # NOVO: Mostrar overlay de Services expirados se encontrados
        if services_expirados_encontrados:
            print("DEBUG: [DICE_ROLL] === SERVICES EXPIRADOS ENCONTRADOS - OVERLAY SER√Å MOSTRADO ===")
            # Mostrar overlay ap√≥s a tela de dice estar criada
            self.after(1000, self._mostrar_overlay_services_expirados_apos_interface)
        
        # Ativar cartas que estavam pendentes de ativa√ß√£o devido ao sequenciamento
        self._activate_pending_cards()
        
        # NOVO: Resetar contadores de processamento por turno
        self._reset_turn_processing_counters()
        
        # Limpa widgets abaixo da barra superior
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), fg="black", bg=self.bar_color)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Saldo (direita)
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
        coin_lbl.image = coin_img
        coin_lbl.place(x=screen_width-100, y=30)
        saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, y=30)

        # √çcones dos outros jogadores (esquerda)
        print(f"DEBUG: [DICE_ICONS] Criando √≠cones dos outros jogadores")
        print(f"DEBUG: [DICE_ICONS] Total de other_players: {len(other_players)}")
        print(f"DEBUG: [DICE_ICONS] self.player_color: '{self.player_color}'")
        
        for idx, p in enumerate(other_players):
            try:
                # Determinar cor do jogador
                if isinstance(p, str):
                    # p √© uma string de cor
                    player_color = p
                    player_name = f"Player {idx+1}"
                elif isinstance(p, dict):
                    # p √© um dicion√°rio com dados do jogador
                    player_color = p.get('color', 'red')
                    player_name = p.get('name', f'Player {idx+1}')
                else:
                    # p √© um objeto com atributo color
                    player_color = p.color if hasattr(p, 'color') else 'red'
                    player_name = p.name if hasattr(p, 'name') else f'Player {idx+1}'
                
                # Mapear cor para √≠cone espec√≠fico
                color_icon_map = {
                    "red": "red_user_icon.png",
                    "blue": "blue_user_icon.png", 
                    "green": "green_user_icon.png",
                    "yellow": "yellow_user_icon.png"
                }
                
                icon_filename = color_icon_map.get(player_color.lower(), "red_user_icon.png")
                icon_path = os.path.join(IMG_DIR, icon_filename)
                
                print(f"DEBUG: [DICE_ICONS] Jogador {idx}: {player_name} ({player_color}) -> {icon_filename}")
                
                if os.path.exists(icon_path):
                    icon_img = ImageTk.PhotoImage(Image.open(icon_path).resize((30,30)))
                    lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                    lbl.image = icon_img  # type: ignore[attr-defined]
                    lbl.place(x=5+idx*40, y=20)
                else:
                    print(f"DEBUG: [DICE_ICONS] Icon not found: {icon_path}")
            except Exception as e:
                print(f"DEBUG: [DICE_ICONS] Error loading player icon {idx}: {e}")
                # Fallback to original logic if error
                if idx < len(USER_ICONS):
                    icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                    lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                    lbl.image = icon_img  # type: ignore[attr-defined]
                    lbl.place(x=5+idx*40, y=20)
                    print(f"DEBUG: [DICE_ICONS] Fallback: usou USER_ICONS[{idx}]")

        # Frame central para o dado e frases
        center_frame = tk.Frame(self, bg="black")
        center_frame.place(relx=0.5, rely=0.5, anchor="center")

        lbl1 = tk.Label(center_frame, text="", font=("Helvetica", 22, "bold"), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl1.pack(pady=(0, 10))
        lbl2 = tk.Label(center_frame, text="", font=("Helvetica", 18), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl2.pack(pady=(0, 30))

        dice_btn = None
        go_btn = None


        if not hasattr(self, "player_pos"):
            self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        player_pos = self.player_pos

        def after_texts():
            nonlocal dice_btn, go_btn
            blank_img_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
            dice_img = ImageTk.PhotoImage(Image.open(blank_img_path).resize((100,100)))
            dice_btn = tk.Label(center_frame, image=dice_img, bg="black")
            dice_btn.image = dice_img  # type: ignore[attr-defined]
            dice_btn.pack(pady=20)

            go_btn = tk.Button(center_frame, text="Go!", font=("Helvetica", 16, "bold"), bg="#005c75", fg="white")

            def roll_animation():
                # CORRE√á√ÉO CR√çTICA: Incrementar turno AQUI quando o jogador lan√ßa o dado
                # Apenas incrementar se estivermos vindo de um End Turn (n√£o primeiro turno do jogo)
                # A flag coming_from_end_turn indica que acabamos de terminar um turno
                
                # Detectar ambiente para debug espec√≠fico
                universal_paths = get_universal_paths()
                ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
                
                coming_from_end_turn = hasattr(self, '_coming_from_end_turn') and self._coming_from_end_turn
                print(f"DEBUG: [DICE_ROLL] AMBIENTE: {ambiente}")
                print(f"DEBUG: [DICE_ROLL] Verificando flag _coming_from_end_turn...")
                print(f"DEBUG: [DICE_ROLL] hasattr(self, '_coming_from_end_turn'): {hasattr(self, '_coming_from_end_turn')}")
                if hasattr(self, '_coming_from_end_turn'):
                    print(f"DEBUG: [DICE_ROLL] self._coming_from_end_turn: {self._coming_from_end_turn}")
                print(f"DEBUG: [DICE_ROLL] coming_from_end_turn: {coming_from_end_turn}")
                
                if coming_from_end_turn:
                    print("DEBUG: [DICE_ROLL] Vindo de END TURN - contadores j√° foram incrementados no backup!")
                    print(f"DEBUG: [DICE_ROLL] Contadores atuais (j√° incrementados na inicializa√ß√£o):")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_number: {self._current_turn_number}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn: {self._current_turn}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_id: {self._current_turn_id}")
                    
                    # CR√çTICO: Verificar Challenges que atingiram o tempo limite ap√≥s incremento
                    try:
                        print(f"DEBUG: [DICE_ROLL] Verificando Challenges que atingiram tempo limite...")
                        self._verificar_challenges_tempo_limite()
                        print(f"DEBUG: [DICE_ROLL] SUCCESS: Verifica√ß√£o de tempo limite executada")
                    except Exception as e:
                        print(f"DEBUG: [DICE_ROLL] ERROR: Erro na verifica√ß√£o de tempo limite: {e}")
                    
                    # NOVO: Verificar Events que expiraram no in√≠cio do turno
                    try:
                        print(f"DEBUG: [DICE_ROLL] Verificando Events expirados no in√≠cio do turno {self._current_turn}...")
                        self._verificar_events_expirados()
                        print(f"DEBUG: [DICE_ROLL] SUCCESS: Verifica√ß√£o de Events expirados executada")
                    except Exception as e:
                        print(f"DEBUG: [DICE_ROLL] ERROR: Erro na verifica√ß√£o de Events expirados: {e}")
                    
                    # CORRE√á√ÉO: Limpar flag ap√≥s processar
                    self._coming_from_end_turn = False
                    print("DEBUG: [DICE_ROLL] Flag _coming_from_end_turn limpa ap√≥s processar incremento do backup")
                else:
                    print(f"DEBUG: [DICE_ROLL] AMBIENTE: {ambiente}")
                    print("DEBUG: [DICE_ROLL] CRITICAL: Contadores N√ÉO foram incrementados!")
                    print("DEBUG: [DICE_ROLL] Raz√£o: Primeiro turno ou _coming_from_end_turn = False")
                    print(f"DEBUG: [DICE_ROLL] Estado atual dos contadores (SEM INCREMENTO):")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_number: {self._current_turn_number}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn: {self._current_turn}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_id: {self._current_turn_id}")
                    # GARANTIR que a flag est√° limpa no in√≠cio do jogo
                    self._coming_from_end_turn = False
                
                # CORRE√á√ÉO CR√çTICA: Verificar se go_btn ainda existe antes de manipular
                try:
                    if go_btn.winfo_exists():
                        go_btn.pack_forget()
                    else:
                        print("DEBUG: [DICE_ROLL] go_btn foi destru√≠do - ignorando pack_forget")
                except tk.TclError as e:
                    print(f"DEBUG: [DICE_ROLL] WARNING: Erro ao ocultar go_btn (widget destru√≠do): {e}")
                except Exception as e:
                    print(f"DEBUG: [DICE_ROLL] WARNING: Erro inesperado ao ocultar go_btn: {e}")
                
                frames = 25
                results = [random.randint(1,6) for _ in range(frames)]
                final = random.randint(1,6)
                results.append(final)

                def animate(i=0,player_color=self.player_color):
                    
                    color_map = {
                    "green": "#70AD47",
                    "yellow": "#F2BA0D",
                    "red": "#EE6F68",
                    "blue": "#43BEF2"
                    }
                    
                    self.bar_color = color_map.get(player_color.lower(), "#AAAAAA")
                    
                    if i < len(results):
                        n = results[i]
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]
                        center_frame.after(100, animate, i+1)
                    else:
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{final}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]

                        # Esconde as frases imediatamente
                        lbl1.pack_forget()
                        lbl2.pack_forget()

                        steps = final
                        old = self.player_pos
                        new_pos = (old + steps) % NUM_CASAS
                        tipo, casa_cor = BOARD[new_pos]
                        self.player_pos = new_pos
                        
                        # Atualizar vari√°veis da casa atual para o bot√£o Store
                        self.current_casa_tipo = tipo
                        self.current_casa_cor = casa_cor
                        # Verificar se √© casa de outro jogador
                        self.current_other_player_house = (casa_cor != self.player_color.lower() and casa_cor != "neutral")

                        # CORRE√á√ÉO CR√çTICA: Limpar estado Challenge se n√£o estivermos numa casa Challenge
                        if tipo != "challenges":
                            print(f"DEBUG: [MOVIMENTO] Mudou para casa {tipo} {casa_cor} - limpando estado Challenge antigo")
                            self.limpar_estado_challenge_pendente(force_clean=True)
                            print("DEBUG: [MOVIMENTO] Estado Challenge limpo pois n√£o estamos numa casa Challenge")

                        # IMPORTANTE: Reativar bot√£o Store se n√£o for casa Actions/Events/Challenges neutra
                        if not (tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                            self.enable_store_button()
                            print(f"DEBUG: Bot√£o Store reativado - mudou para casa {tipo} {casa_cor}")

                        def mostrar_nome_casa(tipo, casa_cor):
                            # Esconde o dado s√≥ agora
                            dice_btn.pack_forget()
                            cor_map = {
                                "green": "#70AD47",
                                "yellow": "#F2BA0D",
                                "red": "#EE6F68",
                                "blue": "#43BEF2",
                                "neutral": "#AAAAAA"
                            }
                            cor = cor_map.get(casa_cor, "#FFFFFF")
                            # Corrigir nome 'equipment' para 'EQUIPMENTS'
                            nome_tipo = tipo.upper()
                            if nome_tipo == "EQUIPMENT":
                                nome_tipo = "EQUIPMENTS"
                            nome_lbl = tk.Label(center_frame, text=nome_tipo, font=("Helvetica", 22, "bold"), fg=cor, bg="black")
                            nome_lbl.pack(pady=10)

                            def depois_nome():
                                nome_lbl.pack_forget()
                                
                                # VERIFICAR SE √â CASA START - vai diretamente para interface principal
                                if tipo == "start":
                                    print("DEBUG: [depois_nome] Casa START detectada - indo para interface principal do PlayerDashboard")
                                    # Marcar que est√° numa casa start (sem bot√£o Store e sem vendas)
                                    self.current_casa_tipo = "start"
                                    self.current_casa_cor = "neutral"
                                    self.current_other_player_house = False
                                    
                                    # IMPORTANTE: Reativar bot√£o Store na casa START (n√£o √© Actions/Events neutra)
                                    self.enable_store_button()
                                    print("DEBUG: Bot√£o Store reativado - est√° na casa START")
                                    
                                    # Ir diretamente para a interface principal sem bot√£o Store
                                    center_frame.destroy()
                                    self.playerdashboard_interface(player_name, saldo, self.other_players, show_store_button=False)
                                    return
                                
                                # VERIFICAR se j√° existe uma Store antes de criar nova
                                if (hasattr(self, 'store_window') and self.store_window and 
                                    hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                    print("DEBUG: [depois_nome] Store j√° existe, a reutilizar existente")
                                    print(f"DEBUG: [depois_nome] ID da Store existente: {id(self.store_window)}")
                                    print(f"DEBUG: [depois_nome] Estado fullscreen da Store existente: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                                    
                                    # CR√çTICO: Limpar estado obsoleto da Store antes de reutilizar
                                    if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                        self.store_window._limpar_estado_completo_store()
                                        print("DEBUG: [depois_nome] Estado da Store limpo antes da reutiliza√ß√£o")
                                    
                                    # CORRE√á√ÉO: Atualizar informa√ß√µes da casa atual na Store
                                    self.store_window.casa_tipo = tipo
                                    self.store_window.casa_cor = casa_cor
                                    print(f"DEBUG: [depois_nome] Casa atualizada na Store: {tipo} {casa_cor}")
                                    
                                    # CORRE√á√ÉO CR√çTICA: Reconstruir interface da Store ap√≥s limpeza
                                    if hasattr(self.store_window, 'rebuild_store_interface'):
                                        print("DEBUG: [depois_nome] Reconstruindo interface da Store ap√≥s reutiliza√ß√£o")
                                        self.store_window.rebuild_store_interface()
                                    
                                    # Restaurar Store existente em vez de criar nova
                                    self.store_window.deiconify()
                                    self.store_window.state('normal')
                                    self.store_window.lift()
                                    self.store_window.focus_force()
                                    return
                                
                                if casa_cor == self.player_color.lower() or casa_cor == "neutral":
                                    # Casa pr√≥pria ou neutra - Store normal
                                    print("DEBUG: [depois_nome] Criando nova Store para casa pr√≥pria/neutra")
                                    self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self)
                                    print(f"DEBUG: [depois_nome] Nova Store criada com ID: {id(self.store_window)}")
                                    if hasattr(self.store_window, '_store_id'):
                                        print(f"DEBUG: [depois_nome] Store ID √∫nico: {self.store_window._store_id}")
                                else:
                                    # Casa de outro jogador - mostra mensagem e depois Store apenas para venda
                                    other_player_lbl = tk.Label(center_frame, text="Square of other player", font=("Helvetica", 18, "bold"), fg="white", bg="black")
                                    other_player_lbl.pack(pady=10)
                                    
                                    def abrir_store_outro_jogador():
                                        other_player_lbl.pack_forget()
                                        
                                        # VERIFICAR se j√° existe uma Store antes de criar nova (tamb√©m para outro jogador)
                                        if (hasattr(self, 'store_window') and self.store_window and 
                                            hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                            print("DEBUG: [abrir_store_outro_jogador] Store j√° existe, a reutilizar existente")
                                            
                                            # CR√çTICO: Limpar estado obsoleto da Store antes de reutilizar
                                            if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                                self.store_window._limpar_estado_completo_store()
                                                print("DEBUG: [abrir_store_outro_jogador] Estado da Store limpo antes da reutiliza√ß√£o")
                                            
                                            # CORRE√á√ÉO: Atualizar informa√ß√µes da casa atual na Store
                                            self.store_window.casa_tipo = tipo
                                            self.store_window.casa_cor = casa_cor
                                            self.store_window.other_player_house = True
                                            print(f"DEBUG: [abrir_store_outro_jogador] Casa atualizada na Store: {tipo} {casa_cor} (outro jogador)")
                                            
                                            # CORRE√á√ÉO CR√çTICA: Reconstruir interface da Store ap√≥s limpeza
                                            if hasattr(self.store_window, 'rebuild_store_interface'):
                                                print("DEBUG: [abrir_store_outro_jogador] Reconstruindo interface da Store ap√≥s reutiliza√ß√£o")
                                                self.store_window.rebuild_store_interface()
                                            
                                            # Restaurar Store existente em vez de criar nova
                                            self.store_window.deiconify()
                                            self.store_window.state('normal')
                                            self.store_window.lift()
                                            self.store_window.focus_force()
                                            center_frame.destroy()
                                            return
                                        
                                        # Para casa de outro jogador, sempre abre a Store mas com restri√ß√µes
                                        print("DEBUG: [abrir_store_outro_jogador] Criando nova Store para casa de outro jogador")
                                        self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self, other_player_house=True)
                                        center_frame.destroy()
                                    
                                    # Espera 2 segundos e depois abre a Store
                                    center_frame.after(2000, abrir_store_outro_jogador)
                            
                            # Espera 2 segundos DEPOIS de mostrar o nome da casa
                            center_frame.after(2000, depois_nome)

                        # Espera 2 segundos ANTES de esconder o dado e mostrar o nome da casa
                        center_frame.after(2000, lambda: mostrar_nome_casa(tipo, casa_cor))

                animate()

            go_btn.config(command=roll_animation)
            go_btn.pack(pady=(0, 5))

        self.animate_typing(lbl1, "It's your turn!", delay=60,
            callback=lambda: self.animate_typing(lbl2, "Roll the dice to start your adventure.", delay=60, callback=after_texts)
        )
        
        # *** NOVO: ADICIONAR TIMER DE SESS√ÉO NA TELA DE DADOS ***
        if getattr(self, 'session_timer_active', False):
            print(f"[SESSION_TIMER] Criando display na tela de dados - timer est√° activo")
            # Usar delay para garantir que a interface est√° pronta
            self.after(500, lambda: self.create_session_timer_display(self))
        else:
            # FOR√áA DETEC√á√ÉO DE MULTIPLAYER baseada na presen√ßa de session_data
            is_multiplayer = (hasattr(netmaster_client, 'session_data') and 
                             netmaster_client.session_data is not None)
            
            if is_multiplayer:
                print(f"[SESSION_TIMER] Modo multiplayer detectado na tela de dados - tentando iniciar timer")
                session_data = netmaster_client.session_data
                duration_minutes = session_data.get('duration_minutes', 15)
                print(f"[SESSION_TIMER] Iniciando timer tardio de {duration_minutes} minutos")
                self.after(1000, lambda: self.start_session_timer(duration_minutes * 60))
                self.after(1500, lambda: self.create_session_timer_display(self))
            else:
                print(f"[SESSION_TIMER] Sem dados de sess√£o dispon√≠veis para iniciar timer na tela de dados")
        
        # *** NOVO: ADICIONAR BELOWBAR NA TELA DE DICE ROLL ***
        try:
            belowbar_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            if os.path.exists(belowbar_path):
                belowbar_img = Image.open(belowbar_path)
                belowbar_img = belowbar_img.resize((screen_width, int(belowbar_img.height * screen_width / belowbar_img.width)))
                self.belowbar_photo_dice = ImageTk.PhotoImage(belowbar_img)
                
                belowbar_label = tk.Label(self, image=self.belowbar_photo_dice, bg="black")
                belowbar_label.pack(side=tk.BOTTOM, fill=tk.X)
                print(f"DEBUG: [DICE_ROLL] BelowBar criado com sucesso: {belowbar_path}")
            else:
                print(f"DEBUG: [DICE_ROLL] WARNING: BelowBar n√£o encontrado: {belowbar_path}")
        except Exception as e:
            print(f"DEBUG: [DICE_ROLL] Erro ao criar BelowBar: {e}")
        
    def atualizar_carrossel(self):
        # Junta todas as cartas de Activities e Challenges do invent√°rio, sem duplicar
        novas_cartas = []
        for tipo in ["activities", "challenges"]:
            novas_cartas += self.inventario.get(tipo, [])
        # Se n√£o houver cartas, mostra backs
        if not novas_cartas:
            novas_cartas = [CARD_IMG] * 4
        self.cards = novas_cartas
        self.card_idx = 0
        self.selected_card_idx = 0
        
        # NOVA FUNCIONALIDADE: Atualizar flags das cartas baseado no estado atual
        nova_flags = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - flag True (virada para cima)
                nova_flags.append(True)
                print(f"DEBUG: [atualizar_carrossel] Posi√ß√£o {i}: {os.path.basename(carta_path)} -> Flag True (virada para cima)")
            else:
                # Carta back ou vazia - flag False (virada para baixo)
                nova_flags.append(False)
                print(f"DEBUG: [atualizar_carrossel] Posi√ß√£o {i}: back card -> Flag False (virada para baixo)")
        
        # Garantir que temos 4 flags
        while len(nova_flags) < 4:
            nova_flags.append(False)
        
        if not hasattr(self, 'card_face_up_flags'):
            self.card_face_up_flags = [False, False, False, False]
        self.card_face_up_flags = nova_flags[:4]  # Limitar a 4 posi√ß√µes
        print(f"DEBUG: [atualizar_carrossel] card_face_up_flags atualizado: {self.card_face_up_flags}")
        
        # CORRE√á√ÉO CR√çTICA: Inicializar card_stats com valores corretos da base de dados
        print("DEBUG: [atualizar_carrossel] Inicializando card_stats com valores da base de dados...")
        novo_card_stats = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - obter message_size da base de dados
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    carta_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    print(f"DEBUG: [atualizar_carrossel] Carta {i}: {os.path.basename(carta_path)} -> To send: {message_size}")
                except Exception as e:
                    print(f"DEBUG: [atualizar_carrossel] Erro ao obter message_size para {carta_path}: {e}")
                    carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
            else:
                # Carta back ou vazia
                carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
                print(f"DEBUG: [atualizar_carrossel] Carta {i}: back card -> valores 0")
            novo_card_stats.append(carta_stats)
        
        # Garantir que temos 4 posi√ß√µes
        while len(novo_card_stats) < 4:
            novo_card_stats.append({"To send": 0, "Rxd": 0, "Lost": 0})
        
        self.card_stats = novo_card_stats[:4]  # Limitar a 4 posi√ß√µes
        print(f"DEBUG: [atualizar_carrossel] card_stats atualizado: {self.card_stats}")
        
        # CORRE√á√ÉO: Preservar sele√ß√£o do carrossel se ainda √© v√°lida
        # Verificar se a carta selecionada ainda existe no carrossel atualizado
        carta_selecionada_preservada = None
        indice_selecionado_preservado = None
        
        if (hasattr(self, 'selected_carousel_card') and self.selected_carousel_card and 
            self.selected_carousel_card in novas_cartas):
            # A carta ainda existe, preservar sele√ß√£o
            carta_selecionada_preservada = self.selected_carousel_card
            indice_selecionado_preservado = novas_cartas.index(self.selected_carousel_card)
            print(f"DEBUG: [atualizar_carrossel] Preservando sele√ß√£o: {os.path.basename(carta_selecionada_preservada)} (√≠ndice {indice_selecionado_preservado})")
        else:
            print("DEBUG: [atualizar_carrossel] Carta selecionada n√£o existe mais ou n√£o havia sele√ß√£o - resetando")
        
        # Limpar sele√ß√£o do carrossel temporariamente para atualiza√ß√£o
        self.selected_carousel_card = carta_selecionada_preservada
        self.selected_carousel_index = indice_selecionado_preservado
        
        # Atualizar destaques
        if hasattr(self, 'card_labels') and self.card_labels:
            self._update_carousel_selection_highlights()

    def disable_store_button(self):
        """Desativa o bot√£o Store permanentemente at√© ser reativado E esconde o bot√£o Next Phase"""
        self._store_button_disabled = True
        # NOVA FUNCIONALIDADE: Esconder bot√£o Next Phase quando Challenge √© aceite
        self._challenge_accepted = True
        print("DEBUG: [PlayerDashboard] Bot√£o Store desativado e Challenge aceite - Next Phase ser√° escondido")

    def enable_store_button(self):
        """Reativa o bot√£o Store e reset da flag Challenge"""
        self._store_button_disabled = False
        self._challenge_accepted = False
        print("DEBUG: [PlayerDashboard] Bot√£o Store reativado e flag Challenge resetada")

    def limpar_estado_challenge_pendente(self, force_clean=False):
        """
        Fun√ß√£o auxiliar para limpar completamente o estado Challenge pendente.
        Deve ser chamada quando voltamos de uma carta Challenge via bot√£o Player.
        CORRE√á√ÉO: N√£o limpa _challenge_accepted se um Challenge foi realmente aceite OU se h√° Challenge pendente.
        Se force_clean=True, limpa sempre independentemente do contexto.
        """
        print("DEBUG: [limpar_estado_challenge_pendente] Iniciando limpeza de estado Challenge")
        print(f"DEBUG: [limpar_estado_challenge_pendente] force_clean: {force_clean}")
        
        # CORRE√á√ÉO: Verificar se Challenge foi aceite antes de limpar flag
        # Se Challenge foi aceite (store_button_disabled = True), N√ÉO limpar _challenge_accepted
        challenge_foi_aceite = getattr(self, '_store_button_disabled', False)
        
        # NOVA VERIFICA√á√ÉO: Verificar se h√° Challenge pendente na Store (via transfer√™ncia de estado)
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # Se force_clean=True, sempre limpar tudo
        if force_clean:
            print("DEBUG: [limpar_estado_challenge_pendente] LIMPEZA FOR√áADA - removendo todos os estados Challenge")
            self._challenge_accepted = False
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FOR√áADO - _store_challenge_carta_path limpo: {old_path} -> None")
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FOR√áADO - _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        else:
            # L√≥gica normal baseada no contexto
            if challenge_foi_aceite:
                print("DEBUG: [limpar_estado_challenge_pendente] Challenge foi aceite - preservando _challenge_accepted = True")
                # N√£o mexer na flag _challenge_accepted quando Challenge foi aceite
                # IMPORTANTE: Preservar tamb√©m ap√≥s substitui√ß√£o Challenge->Activity
            elif challenge_pendente_transferido:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Challenge pendente transferido ({self._store_challenge_carta_path}) - N√ÉO limpando _challenge_accepted")
                # Tamb√©m n√£o limpar quando h√° Challenge pendente transferido via bot√£o Player
            else:
                # CORRE√á√ÉO: Verificar se houve substitui√ß√£o recente Challenge->Activity
                substituicao_recente = getattr(self, '_substituicao_challenge_activity_concluida', False)
                if substituicao_recente:
                    print("DEBUG: [limpar_estado_challenge_pendente] Substitui√ß√£o Challenge->Activity recente - preservando _challenge_accepted = True")
                    # N√£o resetar _challenge_accepted ap√≥s substitui√ß√£o Challenge->Activity
                    # Limpar flag de substitui√ß√£o ap√≥s uso
                    self._substituicao_challenge_activity_concluida = False
                else:
                    # Limpar flag Challenge apenas quando n√£o foi aceite E n√£o h√° Challenge pendente E n√£o houve substitui√ß√£o
                    self._challenge_accepted = False
                    print("DEBUG: [limpar_estado_challenge_pendente] Nenhum Challenge pendente - limpando _challenge_accepted = False")
            
            # CORRE√á√ÉO CR√çTICA: Sempre limpar vari√°veis de Challenge pendente para evitar que persistam entre turnos
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_path limpo: {old_path} -> None")
            
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        
        # Verificar e limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar estado fullscreen Challenge na Store
                    if hasattr(self.store_window, 'fullscreen_carta_path'):
                        old_path = self.store_window.fullscreen_carta_path
                        self.store_window.fullscreen_carta_path = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_path limpo: {old_path} -> None")
                    if hasattr(self.store_window, 'fullscreen_carta_tipo'):
                        old_tipo = self.store_window.fullscreen_carta_tipo
                        self.store_window.fullscreen_carta_tipo = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_tipo limpo: {old_tipo} -> None")
                    
                    # Limpar backups adicionais se existirem
                    backup_attrs = ['_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                   '_original_carta_path', '_original_carta_tipo']
                    for attr in backup_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: [limpar_estado_challenge_pendente] Store {attr} limpo")
                else:
                    print("DEBUG: [limpar_estado_challenge_pendente] Store n√£o existe mais")
            except Exception as e:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Erro ao verificar Store: {e}")
        else:
            print("DEBUG: [limpar_estado_challenge_pendente] Nenhuma Store ativa para limpar")
        
        print("DEBUG: [limpar_estado_challenge_pendente] Limpeza de estado Challenge conclu√≠da")

    def _criar_botao_next_phase(self):
        """Cria o bot√£o Next Phase com toda a l√≥gica necess√°ria"""
        def next_phase_action():
            # MARCAR: Next Phase foi ativado manualmente pelo jogador
            self._next_phase_manually_activated = True
            # Esconde o bot√£o Store
            if hasattr(self, 'btn_store') and self.btn_store:
                self.btn_store.place_forget()
                print("DEBUG: Bot√£o Store escondido")
            # Ativa flag para desativar vendas nas p√°ginas de invent√°rio
            self._next_phase_active = True
            # Atualiza cache dos User IDs para controlo do carrossel
            self._check_user_inventory_for_carousel_access()
            # Atualiza destaques roxos do carrossel
            self._update_carousel_highlights()
            
            # MANTER BARRAS ATUALIZADAS: Atualizar barras de progresso quando Next Phase √© ativado
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                print(f"DEBUG: Next Phase - Atualizando barras para carta selecionada: {os.path.basename(self.selected_carousel_card)}")
                self._update_progress_bars_from_card(self.selected_carousel_card)
            else:
                print("DEBUG: Next Phase - Nenhuma carta selecionada para atualizar barras")
            
            print("DEBUG: Next Phase ativado - Store escondido, vendas desativadas, User IDs verificados, destaques e barras atualizadas")
            
            # Esconder o bot√£o Next Phase e criar o bot√£o Final Phase na mesma posi√ß√£o
            if hasattr(self, 'next_phase_btn') and self.next_phase_btn:
                self.next_phase_btn.place_forget()
                print("DEBUG: Bot√£o Next Phase escondido")
            
            # Criar bot√£o Final Phase diretamente aqui em vez de chamar fun√ß√£o externa
            self._criar_botao_final_phase()

        def final_phase_action():
            print("DEBUG: Final Phase ativado")
            
            # NOVA FLAG CR√çTICA: Marcar que Final Phase foi clicado NESTE turno
            self._final_phase_clicked_this_turn = True
            self._final_phase_turn_id = getattr(self, '_current_turn_number', 1)  # Associar ao turno atual
            print(f"DEBUG: [FINAL PHASE] Flag _final_phase_clicked_this_turn definida como True para turno {self._final_phase_turn_id}")
            
            # CORRE√á√ÉO CR√çTICA: PRESERVAR valores atuais das barras ANTES de iniciar gest√£o
            self._preservar_valores_atuais_barras()
            
            # Ativar flag Final Phase para bloquear todas as a√ß√µes de cartas
            self._final_phase_active = True
            # NOVA FLAG: Ativar flag para mostrar bot√£o End Turn
            self._show_end_turn_button = True
            print("DEBUG: Final Phase ativado - ativa√ß√£o/desativa√ß√£o de cartas bloqueada")
            
            # CORRE√á√ÉO: Verificar se existem cartas ativas ANTES de aplicar destaque roxo
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            print(f"DEBUG: [FINAL PHASE] Cartas ativas encontradas: {len(cartas_ativas)}")
            
            if cartas_ativas:
                # Se h√° cartas ativas, aplicar destaque roxo na primeira carta ativa
                print("DEBUG: [FINAL PHASE] Ativando destaque roxo na primeira carta ativa")
                self._final_phase_gestao_ativa = True  # Ativar gest√£o de pacotes
                self._carta_destacada_posicao = 0      # Destacar posi√ß√£o 0
                self.selected_carousel_index = None    # Limpar sele√ß√£o da cor do jogador
                
                # Atualizar destaques visuais ANTES de iniciar gest√£o de pacotes
                self._update_carousel_selection_highlights()
                print("DEBUG: [FINAL PHASE] Destaque roxo aplicado na posi√ß√£o 0")
            else:
                # Se n√£o h√° cartas ativas, n√£o ativar gest√£o de pacotes nem destaque roxo
                print("DEBUG: [FINAL PHASE] Nenhuma carta ativa - sem destaque roxo")
                self._final_phase_gestao_ativa = False
                self.selected_carousel_index = None    # Limpar sele√ß√£o da cor do jogador
                
                # Atualizar destaques visuais (sem destaque roxo)
                self._update_carousel_selection_highlights()
            
            # INICIAR SISTEMA DE GEST√ÉO DE PACOTES
            print("DEBUG: Final Phase - Iniciando sistema de gest√£o de pacotes")
            
            # Esconder o bot√£o Final Phase e criar End Turn ANTES de iniciar gest√£o
            try:
                if hasattr(self, 'final_phase_btn') and self.final_phase_btn:
                    self.final_phase_btn.place_forget()
                    print("DEBUG: Bot√£o Final Phase escondido")
            except Exception as e:
                print(f"DEBUG: Erro ao esconder bot√£o Final Phase: {e}")
            
            # Criar bot√£o End Turn ANTES de iniciar gest√£o de pacotes
            self._criar_botao_end_turn()
            
            # Agora sim iniciar gest√£o de pacotes (que pode ativar o bot√£o End Turn se necess√°rio)
            self._iniciar_gestao_pacotes()

        # Armazenar as fun√ß√µes como atributos da classe para acesso posterior
        self._next_phase_action = next_phase_action
        self._final_phase_action = final_phase_action

        self.next_phase_btn = tk.Button(
            self,
            text="Next Phase",
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Cinza
            fg="black",
            command=next_phase_action,
            width=10,
        )
        # Posi√ß√£o igual aos bot√µes Back das p√°ginas de invent√°rio
        self.next_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.next_phase_btn.lift()
        print("DEBUG: Bot√£o Next Phase recriado na interface principal")
    
    def _criar_botao_final_phase(self):
        """Cria o bot√£o Final Phase ou End Turn baseado no estado dos Services TEMPORARY e Data Volume"""
        # Verificar se h√° Services TEMPORARY ativos
        has_temporary_services = self._has_active_temporary_services()
        
        # NOVO: Verificar se h√° Data Volume services com pacotes dispon√≠veis
        has_data_volume_packets = self._has_active_data_volume_services_with_packets()
        
        if has_temporary_services:
            # Se h√° Services TEMPORARY ativos, mostrar "Final Phase"
            button_text = "Final Phase"
            print("DEBUG: Services TEMPORARY ativos encontrados - criando bot√£o 'Final Phase'")
        elif has_data_volume_packets:
            # Se h√° Data Volume services com pacotes, mostrar "Final Phase"
            button_text = "Final Phase"
            print("DEBUG: Data Volume services com pacotes encontrados - criando bot√£o 'Final Phase'")
        else:
            # Se n√£o h√° Services TEMPORARY ativos nem Data Volume com pacotes, mostrar "End Turn"
            button_text = "End Turn"
            print("DEBUG: Nenhum Service TEMPORARY ativo nem Data Volume com pacotes - criando bot√£o 'End Turn'")
        
        # Determinar se deve usar Final Phase action ou End Turn direto
        use_final_phase_action = has_temporary_services or has_data_volume_packets
        
        self.final_phase_btn = tk.Button(
            self,
            text=button_text,
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Mesmo cinza do Next Phase
            fg="black",
            command=self._final_phase_action if use_final_phase_action else self._end_turn_direct_action,
            width=10,
        )
        # Mesma posi√ß√£o do bot√£o Next Phase
        self.final_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.final_phase_btn.lift()
        print(f"DEBUG: Bot√£o '{button_text}' criado na mesma posi√ß√£o")
    
    def _end_turn_direct_action(self):
        """A√ß√£o direta para End Turn quando n√£o h√° Services TEMPORARY ativos"""
        print("DEBUG: [END_TURN_DIRECT] === BOT√ÉO END TURN DIRETO CLICADO ===")
        
        try:
            # Desabilitar bot√£o imediatamente para evitar duplo clique
            if hasattr(self, 'final_phase_btn') and self.final_phase_btn:
                try:
                    self.final_phase_btn.config(state="disabled", bg="#CCCCCC")
                    print("DEBUG: [END_TURN_DIRECT] Bot√£o End Turn direto desabilitado")
                except tk.TclError:
                    print("DEBUG: [END_TURN_DIRECT] WARNING: Bot√£o j√° destru√≠do")
            
            # Chamar o m√©todo principal end_turn() que faz tudo corretamente
            print("DEBUG: [END_TURN_DIRECT] Chamando self.end_turn()...")
            self.end_turn()
            print("DEBUG: [END_TURN_DIRECT] self.end_turn() executado com sucesso")
            
            # Resetar flags de fase para come√ßar novo turno limpo
            self._next_phase_active = False
            self._final_phase_active = False
            self._final_phase_gestao_ativa = False
            self._challenge_accepted = False
            self._show_end_turn_button = False
            self._next_phase_manually_activated = False
            
            # RESETAR SELE√á√ÉO: Limpar sele√ß√£o do carrossel para pr√≥ximo turno
            self.selected_carousel_index = None
            self.selected_carousel_card = None
            self._carta_destacada_posicao = None
            print("DEBUG: [END_TURN_DIRECT] Flags e sele√ß√µes resetadas")
            
            # Aguardar um frame para garantir que end_turn() terminou completamente
            self.after(50, self._continue_end_turn_transition)
            
        except Exception as e:
            print(f"DEBUG: [END_TURN_DIRECT] ERROR: Erro em _end_turn_direct_action: {e}")
            import traceback
            traceback.print_exc()
    
    def _gerenciar_botao_end_turn(self, command):
        """Fun√ß√£o centralizada para gerenciar cria√ß√£o/atualiza√ß√£o do bot√£o End Turn"""
        try:
            # Verificar se bot√£o j√° existe e est√° v√°lido
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                try:
                    if self.end_turn_btn.winfo_exists():
                        # Bot√£o existe e √© v√°lido, apenas atualizar comando
                        self.end_turn_btn.config(command=command)
                        print("DEBUG: Bot√£o End Turn - comando atualizado")
                        return
                except tk.TclError:
                    # Widget foi destru√≠do, precisamos recriar
                    print("DEBUG: Bot√£o End Turn destru√≠do, recriando...")
                    pass
            
            # Criar novo bot√£o
            self.end_turn_btn = tk.Button(
                self,
                text="End Turn",
                font=("Helvetica", 14, "bold"),
                bg="#808080",
                fg="black",
                command=command,
                width=10,
                state="disabled"  # Sempre come√ßar disabled
            )
            # Mesma posi√ß√£o do bot√£o Final Phase
            self.end_turn_btn.place(relx=0.5, rely=0.98, anchor="s")
            self.end_turn_btn.lift()
            print("DEBUG: Bot√£o End Turn criado com sucesso")
            
        except Exception as e:
            print(f"DEBUG: Erro ao gerenciar bot√£o End Turn: {e}")

    def _criar_botao_end_turn(self):
        """Cria o bot√£o End Turn"""
        def end_turn_action():
            print("DEBUG: [END_TURN_ACTION] === BOT√ÉO END TURN CLICADO ===")
            
            try:
                # PROTE√á√ÉO: Desabilitar bot√£o imediatamente para evitar duplo clique
                if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                    try:
                        self.end_turn_btn.config(state="disabled", bg="#CCCCCC")
                        print("DEBUG: [END_TURN_ACTION] Bot√£o End Turn desabilitado")
                    except tk.TclError:
                        print("DEBUG: [END_TURN_ACTION] WARNING: Bot√£o j√° destru√≠do")
                
                # CORRE√á√ÉO CR√çTICA: Chamar o m√©todo principal end_turn() que faz tudo corretamente
                print("DEBUG: [END_TURN_ACTION] Chamando self.end_turn()...")
                self.end_turn()
                print("DEBUG: [END_TURN_ACTION] self.end_turn() executado com sucesso")
                
                # Resetar flags de fase para come√ßar novo turno limpo
                self._next_phase_active = False
                self._final_phase_active = False
                self._final_phase_gestao_ativa = False
                self._challenge_accepted = False
                self._show_end_turn_button = False
                self._next_phase_manually_activated = False
                
                # RESETAR SELE√á√ÉO: Limpar sele√ß√£o do carrossel para pr√≥ximo turno
                self.selected_carousel_index = None
                self.selected_carousel_card = None
                self._carta_destacada_posicao = None
                print("DEBUG: [END_TURN_ACTION] Flags e sele√ß√µes resetadas")
                
                # CORRE√á√ÉO CR√çTICA: Verificar aplica√ß√£o de forma mais robusta
                try:
                    # Aguardar um frame para garantir que end_turn() terminou completamente
                    self.after(50, self._continue_end_turn_transition)
                except Exception as e:
                    print(f"DEBUG: [END_TURN_ACTION] ERROR: Erro ao agendar transi√ß√£o: {e}")
                    
            except Exception as e:
                print(f"DEBUG: [END_TURN_ACTION] ERROR: Erro em end_turn_action: {e}")
                import traceback
                traceback.print_exc()

        # Usar o m√©todo centralizado para gerenciar o bot√£o
        self._gerenciar_botao_end_turn(end_turn_action)
        print("DEBUG: [CRIAR_END_TURN] Bot√£o End Turn criado com comando configurado")
        
    def _continue_end_turn_transition(self):
        """Continua a transi√ß√£o do End Turn ap√≥s um delay"""
        print("DEBUG: [END_TURN_TRANSITION] === CONTINUANDO TRANSI√á√ÉO ===")
        try:
            # Verificar se aplica√ß√£o ainda existe
            if not (hasattr(self, 'winfo_exists') and self.winfo_exists()):
                print("DEBUG: [END_TURN_TRANSITION] WARNING: Aplica√ß√£o destru√≠da - abortando transi√ß√£o")
                return
            
            # MELHOR DETEC√á√ÉO DE MODO MULTIPLAYER
            multiplayer_mode_flag = getattr(self, 'multiplayer_mode', False)
            has_session_data = hasattr(self, 'session_data') and self.session_data
            has_netmaster_session = hasattr(netmaster_client, 'session_id') and netmaster_client.session_id
            is_connected = hasattr(netmaster_client, 'connected') and netmaster_client.connected
            
            # √â multiplayer se qualquer uma destas condi√ß√µes for verdadeira
            is_multiplayer = multiplayer_mode_flag or has_session_data or has_netmaster_session
            
            print(f"DEBUG: [END_TURN_TRANSITION] Verificando modo multiplayer:")
            print(f"DEBUG: [END_TURN_TRANSITION]   multiplayer_mode flag = {multiplayer_mode_flag}")
            print(f"DEBUG: [END_TURN_TRANSITION]   has_session_data = {has_session_data}")
            print(f"DEBUG: [END_TURN_TRANSITION]   has_netmaster_session = {has_netmaster_session}")
            print(f"DEBUG: [END_TURN_TRANSITION]   is_connected = {is_connected}")
            print(f"DEBUG: [END_TURN_TRANSITION]   RESULTADO: is_multiplayer = {is_multiplayer}")
            
            # CORRE√á√ÉO CR√çTICA: Em modo multiplayer, N√ÉO ir automaticamente para dice roll
            # O servidor √© que decide quem tem o pr√≥ximo turno via turn_changed
            if is_multiplayer:
                print("DEBUG: [END_TURN_TRANSITION] Modo multiplayer detectado - aguardando turn_changed do servidor")
                print("DEBUG: [END_TURN_TRANSITION] N√ÉO chamando show_dice_roll_screen automaticamente")
                return
                
            # S√≥ em modo single player √© que vai automaticamente para dice roll
            print("DEBUG: [END_TURN_TRANSITION] Modo single player - continuando para dice roll")
            
            # Obter dimens√µes da tela
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            
            print("DEBUG: [END_TURN_TRANSITION] Chamando show_dice_roll_screen...")
            # CORRE√á√ÉO: Usar jogadores da sess√£o em vez de todos os outros jogadores
            session_players = self.get_session_players_icons()
            self.show_dice_roll_screen(self.player_name, self.saldo, session_players, screen_width, screen_height)
            print("DEBUG: [END_TURN_TRANSITION] SUCCESS: Transi√ß√£o para dice roll screen completa")
            
        except tk.TclError as e:
            print(f"DEBUG: [END_TURN_TRANSITION] WARNING: TclError: {e}")
        except Exception as e:
            print(f"DEBUG: [END_TURN_TRANSITION] ERROR: Erro na transi√ß√£o: {e}")
            import traceback
            traceback.print_exc()



    def playerdashboard_interface(self, player_name, saldo, other_players, show_store_button=None):
        try:
            print(f"DEBUG: [INTERFACE] ===== playerdashboard_interface IN√çCIO =====")
            print(f"DEBUG: [INTERFACE] player_name: {player_name}, saldo: {saldo}")
            print(f"DEBUG: [INTERFACE] show_store_button: {show_store_button}")
            print(f"DEBUG: [INTERFACE] self existe? {hasattr(self, 'player_name')}")
            
            # CORRE√á√ÉO CR√çTICA: Restaurar contadores de turno se foram feitos backups
            # Isto resolve o problema dos contadores voltarem ao turno 1 ap√≥s substitui√ß√µes
            self._restore_turn_counters_after_reconstruction()
            
            # NOVO SISTEMA: Verificar cartas pendentes armazenadas no servidor
            # Chamado quando √© a vez do jogador jogar (interface principal)
            print("DEBUG: [INTERFACE] === VERIFICA√á√ÉO DE CARTAS PENDENTES NO SERVIDOR ===")
            self._verificar_cartas_pendentes()
            print("DEBUG: [INTERFACE] === FIM VERIFICA√á√ÉO DE CARTAS PENDENTES ===")
            
            # VERIFICA√á√ÉO AUTOM√ÅTICA DE EVENTS EXPIRADOS
            # Verificar se h√° Events expirados e mostrar overlay automaticamente POR CIMA da interface
            print("DEBUG: [INTERFACE] === VERIFICA√á√ÉO AUTOM√ÅTICA DE EVENTS EXPIRADOS ===")
            events_expirados_encontrados = self._verificar_events_expirados_automaticamente()
            print("DEBUG: [INTERFACE] === FIM VERIFICA√á√ÉO AUTOM√ÅTICA ===")
            
            # VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES EXPIRADOS
            # Verificar se h√° Services TEMPORARY expirados e mostrar overlay automaticamente POR CIMA da interface
            print("DEBUG: [INTERFACE] === VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES EXPIRADOS ===")
            services_expirados_encontrados = self._verificar_services_expirados_automaticamente()
            print("DEBUG: [INTERFACE] === FIM VERIFICA√á√ÉO AUTOM√ÅTICA DE SERVICES ===")
            
            # NOVO: N√ÉO interromper cria√ß√£o da interface - overlay aparece por cima
            # Interface principal continua a ser criada normalmente
            if events_expirados_encontrados:
                print("DEBUG: [INTERFACE] === EVENTS EXPIRADOS ENCONTRADOS - OVERLAY SER√Å MOSTRADO POR CIMA ===")
                # Usar after() para mostrar overlay ap√≥s a interface estar criada
                self.after(500, self._mostrar_overlay_events_expirados_apos_interface)
            
            if services_expirados_encontrados:
                print("DEBUG: [INTERFACE] === SERVICES EXPIRADOS ENCONTRADOS - OVERLAY SER√Å MOSTRADO POR CIMA ===")
                # Usar after() para mostrar overlay ap√≥s a interface estar criada
                # Delay maior para que apare√ßa ap√≥s os events (se houver)
                delay = 800 if events_expirados_encontrados else 500
                self.after(delay, self._mostrar_overlay_services_expirados_apos_interface)
            
            # NOVA FUNCIONALIDADE: Limpar tracking √≥rf√£o sempre ao entrar na interface principal
            # Isto garante que Challenges completados/expirados n√£o permanecem no tracking
            print("DEBUG: [INTERFACE] === LIMPEZA √ìRF√É NA INTERFACE ===")
            self._cleanup_orphaned_challenge_tracking()
            print("DEBUG: [INTERFACE] === FIM LIMPEZA √ìRF√É ===")
            
            # PROTE√á√ÉO CONTRA LOOP: Limpar flag quando entra na interface principal
            self._inventory_opening = False
            print(f"DEBUG: [INTERFACE] Flag inventory_opening limpa")
            
            # LIMPEZA: Limpar flags de contexto especial quando volta ao dashboard
            if hasattr(self, '_in_remove_router_context'):
                self._in_remove_router_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_remove_router_context limpa")
            
            if hasattr(self, '_in_router_upgrade_context'):
                self._in_router_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_upgrade_context limpa")
            
            if hasattr(self, '_in_link_upgrade_context'):
                self._in_link_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_upgrade_context limpa")
            
            if hasattr(self, '_in_link_downgrade_context'):
                self._in_link_downgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_downgrade_context limpa")
            
            if hasattr(self, '_in_router_selection_page'):
                self._in_router_selection_page = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_selection_page limpa")
            
            # DETEC√á√ÉO AUTOM√ÅTICA DE FASE: Verificar se o jogador deve estar numa fase avan√ßada
            # com base no estado do jogo (cartas selecionadas, User IDs no invent√°rio, etc.)
            # IMPORTANTE: Apenas aplicar quando N√ÉO est√° a vir da p√°gina de lan√ßamento de dado
            
            # CORRE√á√ÉO CR√çTICA: _turn_number deve ser sempre sincronizado com _current_turn_number
            # Remover l√≥gica de incremento independente que causava dessincroniza√ß√£o
            self._turn_number = getattr(self, '_current_turn_number', 1)
            print(f"DEBUG: [INTERFACE] Turn number sincronizado com _current_turn_number: {self._turn_number}")
            
            # FLUXO CORRETO: Sempre come√ßar com p√°gina de dado, independentemente do turno
            # A detec√ß√£o de fase s√≥ deve acontecer quando vem diretamente de uma Store/invent√°rio
            coming_from_dice_page = getattr(self, '_coming_from_dice', False)
            print(f"DEBUG: [INTERFACE] Coming from dice page: {coming_from_dice_page}")
            
            if coming_from_dice_page:
                # Reset da flag para evitar loops
                self._coming_from_dice = False
                print(f"DEBUG: [INTERFACE] Vindo da p√°gina de dado - turno correto: {self._turn_number}")
            else:
                # CORRE√á√ÉO: N√ÉO incrementar _turn_number aqui - apenas sincronizar
                # O incremento real acontece no end_turn() via _increment_turn_counter()
                print(f"DEBUG: [INTERFACE] Navega√ß√£o entre p√°ginas - turno atual: {self._turn_number}")
            
            print(f"DEBUG: [INTERFACE] Preparando para limpar widgets...")
            
        except Exception as e:
            print(f"DEBUG: [INTERFACE] ERRO CR√çTICO no in√≠cio da playerdashboard_interface: {e}")
            import traceback
            print(f"DEBUG: [INTERFACE] Traceback: {traceback.format_exc()}")
            return
            # NOTA: Restaura√ß√£o autom√°tica de fase DESATIVADA para permitir controlo manual
            # O jogador deve clicar explicitamente nos bot√µes Next Phase e Final Phase
            print(f"DEBUG: [FASE] Restaura√ß√£o autom√°tica desativada - flags controladas manualmente")
        
        # CORRE√á√ÉO: Distinguir entre NOVO TURNO e navega√ß√£o dentro do mesmo turno
        # IMPORTANTE: S√≥ limpar estado Challenge em NOVOS TURNOS para evitar persist√™ncia entre turnos
        # Para navega√ß√£o dentro do turno (via bot√£o Player), preservar estado Challenge
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # DETEC√á√ÉO DE NOVO TURNO: Verificar se est√° a vir da p√°gina de lan√ßamento de dado
        coming_from_dice_page = getattr(self, '_coming_from_dice', False)
        
        print(f"DEBUG: [INTERFACE] === AN√ÅLISE DE ESTADO CHALLENGE ===")
        print(f"DEBUG: [INTERFACE] coming_from_dice_page: {coming_from_dice_page}")
        print(f"DEBUG: [INTERFACE] challenge_pendente_transferido: {challenge_pendente_transferido}")
        if challenge_pendente_transferido:
            print(f"DEBUG: [INTERFACE] Challenge path: {getattr(self, '_store_challenge_carta_path', 'None')}")
        
        if coming_from_dice_page:
            # NOVO TURNO: Sempre limpar estado Challenge antigo para evitar persist√™ncia entre turnos
            # Isto resolve o problema relatado onde Challenge do turno 1 aparecia no turno 2
            print("DEBUG: [INTERFACE] NOVO TURNO detectado - limpeza autom√°tica de estado Challenge antigo")
            self.limpar_estado_challenge_pendente(force_clean=True)
            print("DEBUG: [INTERFACE] Estado Challenge antigo limpo FOR√áADAMENTE - in√≠cio de novo turno")
        elif challenge_pendente_transferido:
            # NAVEGA√á√ÉO NO MESMO TURNO: Verificar se estamos ainda numa casa Challenge
            casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
            if casa_atual_tipo == "challenges":
                # Preservar estado Challenge transferido via bot√£o Player apenas se ainda estivermos numa casa Challenge
                print(f"DEBUG: [INTERFACE] NAVEGA√á√ÉO NO TURNO EM CASA CHALLENGE - preservando Challenge transferido: {self._store_challenge_carta_path}")
                print("DEBUG: [INTERFACE] Estado Challenge preservado para permitir voltar √† Store")
            else:
                # Se n√£o estivermos numa casa Challenge, limpar o estado
                print(f"DEBUG: [INTERFACE] NAVEGA√á√ÉO NO TURNO FORA DE CASA CHALLENGE (casa atual: {casa_atual_tipo}) - limpando Challenge transferido")
                self.limpar_estado_challenge_pendente(force_clean=True)
                print("DEBUG: [INTERFACE] Estado Challenge limpo pois n√£o estamos numa casa Challenge")
        else:
            # SEM CHALLENGE PENDENTE: Limpeza normal (equivalente ao comportamento anterior)
            print("DEBUG: [INTERFACE] Sem Challenge pendente - limpeza normal")
            self.limpar_estado_challenge_pendente()
            print("DEBUG: [INTERFACE] Estado Challenge limpo via fun√ß√£o auxiliar - limpeza normal")
        
        print(f"DEBUG: [INTERFACE] === FIM AN√ÅLISE DE ESTADO CHALLENGE ===")
        
        # TESTE: Adicionar User cards para testar o sistema de controlo do carrossel
        # Esta linha pode ser removida em produ√ß√£o
        self._teste_adicionar_user_cards()
        
        # LIMPEZA: Remover cartas Actions/Events que foram incorretamente adicionadas ao invent√°rio
        # (cartas destinadas a outros jogadores que n√£o deveriam ficar no invent√°rio do remetente)
        print("DEBUG: [INTERFACE] Iniciando limpeza de cartas Actions/Events incorretas...")
        self._limpar_cartas_actions_events_incorretas()
        print("DEBUG: [INTERFACE] Limpeza de cartas Actions/Events conclu√≠da")
        
        # CORRE√á√ÉO CR√çTICA: Se h√° Challenge pendente transferido, SEMPRE mostrar bot√£o Store
        # Isto tem prioridade sobre qualquer par√¢metro show_store_button
        if challenge_pendente_transferido and hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path:
            show_store_button = True
            print("DEBUG: Challenge pendente detectado - for√ßando bot√£o Store para permitir voltar")
            # N√ÉO atualizar _store_button_disabled quando h√° Challenge pendente
        elif show_store_button is None:
            # Se show_store_button n√£o for especificado, usar o estado atual
            show_store_button = not self._store_button_disabled
        else:
            # Atualizar o estado baseado no par√¢metro fornecido APENAS se n√£o h√° Challenge pendente
            self._store_button_disabled = not show_store_button
            
        self.atualizar_carrossel()
        # Limpar todos os widgets existentes (exceto a barra superior se existir)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue  # Manter a barra superior
            widget.destroy()
        
        # Barra superior com imagem
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)  # Remove barra de t√≠tulo
        self.attributes("-fullscreen", True)  # Garante fullscreen (opcional)
        
        # Criar TopBar se n√£o existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [playerdashboard_interface] Tentando carregar TopBar de: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [playerdashboard_interface] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [playerdashboard_interface] Arquivo TopBar n√£o encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [playerdashboard_interface] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [playerdashboard_interface] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [playerdashboard_interface] TopBar fallback criada ap√≥s erro!")
        
        # √çcones dos outros jogadores (esquerda) - CORRIGIDO: mostrar apenas jogadores da sess√£o
        session_players = self.get_session_players_icons()
        for idx, player_info in enumerate(session_players):
            if idx < len(USER_ICONS):
                try:
                    # Usar √≠cone baseado na cor do jogador da sess√£o
                    color_icon_map = {
                        "red": "red_user_icon.png",
                        "blue": "blue_user_icon.png", 
                        "green": "green_user_icon.png",
                        "yellow": "yellow_user_icon.png"
                    }
                    
                    icon_name = color_icon_map.get(player_info.get('color', 'red'), "red_user_icon.png")
                    icon_path = os.path.join(IMG_DIR, icon_name)
                    
                    if os.path.exists(icon_path):
                        icon_img = ImageTk.PhotoImage(Image.open(icon_path).resize((30,30)))
                        lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                        lbl.image = icon_img  # type: ignore[attr-defined]
                        lbl.place(x=5+idx*40, y=20)
                        print(f"DEBUG: [ICONS] √çcone criado para {player_info.get('name')} ({player_info.get('color')})")
                    else:
                        print(f"DEBUG: [ICONS] √çcone n√£o encontrado: {icon_path}")
                except Exception as e:
                    print(f"DEBUG: [ICONS] Erro ao criar √≠cone {idx}: {e}")
                    # Fallback para √≠cone padr√£o se houver erro
                    if idx < len(USER_ICONS):
                        icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                        lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                        lbl.image = icon_img  # type: ignore[attr-defined]
                        lbl.place(x=5+idx*40, y=20)

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Bot√£o da Store no canto superior direito para ir √† Store (apenas se show_store_button for True)
        self._store_btn_widget = None
        # CORRE√á√ÉO: N√£o esconder bot√£o Store apenas porque Next Phase foi detectado automaticamente
        # S√≥ esconder se Next Phase foi ativado explicitamente pelo jogador
        next_phase_manually_activated = getattr(self, '_next_phase_manually_activated', False)
        
        # CORRE√á√ÉO CR√çTICA: Se h√° Challenge pendente, SEMPRE mostrar bot√£o Store
        # Isto tem prioridade sobre qualquer estado de Next Phase
        has_challenge_pendente = (challenge_pendente_transferido and 
                                hasattr(self, '_store_challenge_carta_path') and 
                                self._store_challenge_carta_path)
        
        if show_store_button and (not next_phase_manually_activated or has_challenge_pendente):
            # Debug da decis√£o
            if has_challenge_pendente:
                print("DEBUG: Bot√£o Store criado devido a Challenge pendente (prioridade sobre Next Phase)")
            elif not next_phase_manually_activated:
                print("DEBUG: Bot√£o Store criado - condi√ß√µes normais atendidas")
            
            def abrir_store():
                """Abre a Store seguindo o mesmo padr√£o do bot√£o Player"""
                print("DEBUG: Bot√£o Store pressionado - abrindo Store")
                print(f"DEBUG: [abrir_store] Verificando se Store existe...")
                print(f"DEBUG: [abrir_store] hasattr store_window: {hasattr(self, 'store_window')}")
                if hasattr(self, 'store_window'):
                    print(f"DEBUG: [abrir_store] store_window n√£o √© None: {self.store_window is not None}")
                    if self.store_window:
                        print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                        print(f"DEBUG: [abrir_store] tem fullscreen_carta_path: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                        if hasattr(self.store_window, 'fullscreen_carta_path'):
                            print(f"DEBUG: [abrir_store] fullscreen_carta_path valor: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                
                try:
                    # CORRE√á√ÉO IMPORTANTE: S√≥ restaurar carta Challenge se estivermos numa casa Challenge
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo):
                        print(f"DEBUG: [abrir_store] Carta Challenge encontrada no PlayerDashboard: {self._store_challenge_carta_path}")
                        print(f"DEBUG: [abrir_store] Casa atual: tipo={casa_tipo}, cor={casa_cor}")
                        
                        # S√ì restaurar Challenge se estivermos numa casa Challenge
                        if casa_tipo == "challenges":
                            print("DEBUG: [abrir_store] Estamos numa casa Challenge - restaurando carta Challenge")
                            
                            # Verificar se Store existe e pode ser restaurada
                            if (hasattr(self, 'store_window') and self.store_window and 
                                hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                print("DEBUG: [abrir_store] Store existente encontrada - transferindo estado Challenge")
                                # Transferir estado de volta para a Store
                                self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._original_carta_path = self._store_challenge_carta_path
                                self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                                
                                # Restaurar Store com carta Challenge
                                self.store_window.voltar_para_store()
                                self.withdraw()
                                
                                # Limpar estado do PlayerDashboard
                                self._store_challenge_carta_path = None
                                self._store_challenge_carta_tipo = None
                                print("DEBUG: [abrir_store] Store restaurada com carta Challenge")
                                return
                            else:
                                print("DEBUG: [abrir_store] Store n√£o existe - criando nova com estado Challenge")
                                # Store n√£o existe, criar nova com estado Challenge j√° definido
                                # (continua para cria√ß√£o abaixo)
                        else:
                            print(f"DEBUG: [abrir_store] N√ÉO estamos numa casa Challenge (estamos em {casa_tipo}) - LIMPANDO estado Challenge")
                            # Limpar estado Challenge pois n√£o estamos numa casa Challenge
                            self._store_challenge_carta_path = None
                            self._store_challenge_carta_tipo = None
                            print("DEBUG: [abrir_store] Estado Challenge limpo - continuando cria√ß√£o normal da Store")
                    
                    # Verificar se j√° existe uma Store com estado de fullscreen guardado
                    elif (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists() and
                        hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print(f"DEBUG: Store existente encontrada com estado fullscreen - restaurando carta: {self.store_window.fullscreen_carta_path}")
                        print(f"DEBUG: [abrir_store] ID da Store existente: {id(self.store_window)}")
                        if hasattr(self.store_window, '_store_id'):
                            print(f"DEBUG: [abrir_store] Store ID √∫nico: {self.store_window._store_id}")
                        print(f"DEBUG: [abrir_store] Chamando voltar_para_store() na Store existente...")
                        # Restaurar Store existente com estado de fullscreen
                        self.store_window.voltar_para_store()
                        # Esconder PlayerDashboard enquanto Store est√° aberta
                        self.withdraw()
                        print("DEBUG: Store existente restaurada com sucesso")
                        return
                    else:
                        # Debug das condi√ß√µes que falharam
                        print("DEBUG: [abrir_store] Condi√ß√µes de Store existente com fullscreen:")
                        print(f"DEBUG: [abrir_store] hasattr(self, 'store_window'): {hasattr(self, 'store_window')}")
                        if hasattr(self, 'store_window'):
                            print(f"DEBUG: [abrir_store] self.store_window is not None: {self.store_window is not None}")
                            if self.store_window:
                                print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                                print(f"DEBUG: [abrir_store] tem fullscreen_carta_path attr: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                                if hasattr(self.store_window, 'fullscreen_carta_path'):
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path value: {self.store_window.fullscreen_carta_path}")
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path is truthy: {bool(self.store_window.fullscreen_carta_path)}")
                        print("DEBUG: [abrir_store] Store existente N√ÉO tem estado fullscreen v√°lido - criando nova")
                    
                    # Verificar se existe Store sem estado fullscreen
                    if (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                        print("DEBUG: [abrir_store] Store existe mas sem estado fullscreen - reutilizando")
                        self.store_window.voltar_para_store()
                        self.withdraw()
                        return
                    
                    # Importar Store aqui para evitar imports circulares
                    from Store import StoreWindow
                    # Usar as mesmas informa√ß√µes da casa atual (se dispon√≠vel)
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    current_other_player_house = getattr(self, 'current_other_player_house', False)
                    
                    print(f"DEBUG: Criando nova Store - casa_tipo: {casa_tipo}, casa_cor: {casa_cor}, other_player_house: {current_other_player_house}")
                    
                    # IMPORTANTE: Reativar bot√£o Store se n√£o estiver numa casa Actions/Events/Challenges neutra
                    if not (casa_tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                        self.enable_store_button()
                        print("DEBUG: Bot√£o Store reativado - n√£o est√° numa casa Actions/Events/Challenges neutra")
                    
                    # Criar nova janela da Store
                    self.store_window = StoreWindow(
                        self.master,
                        self.player_color,
                        self.player_name,
                        self.saldo,
                        casa_tipo=casa_tipo,
                        casa_cor=casa_cor,
                        inventario=self.inventario,
                        dashboard=self,
                        other_player_house=current_other_player_house
                    )
                    print(f"DEBUG: Nova Store criada via bot√£o Store com ID: {id(self.store_window)}")
                    if hasattr(self.store_window, '_store_id'):
                        print(f"DEBUG: Store ID √∫nico (bot√£o Store): {self.store_window._store_id}")
                    
                    # CORRE√á√ÉO: S√≥ transferir carta Challenge se estivermos numa casa Challenge
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo and
                        casa_tipo == "challenges"):
                        print(f"DEBUG: Transferindo estado Challenge para nova Store (casa Challenge): {self._store_challenge_carta_path}")
                        self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._original_carta_path = self._store_challenge_carta_path
                        self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                        
                        # Limpar estado do PlayerDashboard
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                        print("DEBUG: Estado Challenge transferido para nova Store")
                    elif (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                          casa_tipo != "challenges"):
                        print(f"DEBUG: Limpando estado Challenge pois n√£o estamos numa casa Challenge (estamos em {casa_tipo})")
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                    
                    # Esconder PlayerDashboard enquanto Store est√° aberta
                    self.withdraw()
                    
                    # Se h√° estado Challenge, restaurar carta imediatamente
                    if (hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print("DEBUG: Restaurando carta Challenge na nova Store")
                        self.store_window.voltar_para_store()  # Vai ativar restaurar_carta_fullscreen_pendente()
                    
                    print("DEBUG: Nova Store criada com sucesso")
                except Exception as e:
                    print(f"DEBUG: Erro ao abrir Store: {e}")
                    import traceback
                    traceback.print_exc()

            try:
                # Carregar √≠cone da Store
                store_icon_path = os.path.join(IMG_DIR, "Store_button_icon.png")
                store_icon_img = ImageTk.PhotoImage(Image.open(store_icon_path).resize((30, 30)))
                self.btn_store = tk.Button(self, image=store_icon_img, bg=self.bar_color, relief="flat", borderwidth=0, 
                                     command=abrir_store, cursor="hand2", activebackground=self.bar_color,
                                     highlightthickness=0)
                self.btn_store.image = store_icon_img  # Manter refer√™ncia para evitar garbage collection
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")  # Mesma posi√ß√£o do bot√£o Player na Store
                print("DEBUG: Bot√£o Store criado com √≠cone Store_button_icon.png")
            except Exception as e:
                print(f"DEBUG: Erro ao carregar Store_button_icon.png: {e}")
                # Fallback para bot√£o de texto se n√£o conseguir carregar a imagem
                self.btn_store = tk.Button(self, text="STORE", font=("Helvetica", 20), bg=self.bar_color, fg="black", 
                                     relief="flat", borderwidth=0, command=abrir_store, cursor="hand2",
                                     activebackground=self.bar_color, activeforeground="black", highlightthickness=0)
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")
                print("DEBUG: Bot√£o Store criado com √≠cone de fallback")
        else:
            # Debug melhorado para explicar porque n√£o foi criado
            if not show_store_button:
                print(f"DEBUG: Bot√£o Store N√ÉO criado - show_store_button=False")
            elif next_phase_manually_activated and not has_challenge_pendente:
                print(f"DEBUG: Bot√£o Store N√ÉO criado - Next Phase ativo e sem Challenge pendente")
            else:
                print(f"DEBUG: Bot√£o Store N√ÉO criado - raz√£o desconhecida (show_store_button={show_store_button}, next_phase_manually_activated={next_phase_manually_activated}, has_challenge_pendente={has_challenge_pendente})")
            self.btn_store = None  # Inicializar como None quando n√£o √© criado

        # --- NOVO LAYOUT ---

        # Espa√ßo extra antes dos bot√µes
        self.after(0, lambda: self.update())  # Garante update do layout antes de calcular altura
        tk.Frame(self, height=5, bg="black").pack()  # reduzido para menos espa√ßo

        # 1. Bot√µes grandes (layout igual ao carrossel)
        btns_frame = tk.Frame(self, bg="black")
        btns_frame.pack(pady=(12, 18))  # Reduz espa√ßo acima, mant√©m abaixo
        card_width, card_height = 85, 120  # Igual ao carrossel

        btn_info = [
            ("Users", self.bar_color, "users"),
            ("Equip.", self.bar_color, "equipments"),
            ("Services", self.bar_color, "services"),
            ("Actions/\nEvents", self.bar_color, "actions_events")
        ]

        self.action_buttons = []
        for text, color, inv_key in btn_info:
            btn_font = ("Helvetica", 13, "bold")
            if text.startswith("Services"):
                btn_font = ("Helvetica", 12, "bold")  # Fonte menor s√≥ para "Services"
            btn = tk.Button(
                btns_frame, text=text, font=btn_font,
                wraplength=70,
                bg=color, fg="black", activebackground="white", activeforeground="black",
                bd=0, highlightthickness=0
            )
            btn.pack(side=tk.LEFT, padx=2, ipady=22, expand=True, fill="both")
            self.action_buttons.append(btn)
            # Associar invent√°rio correto - CORRE√á√ÉO: usar default parameter para evitar closure problem
            if inv_key == "actions_events":
                print(f"DEBUG: Configurando bot√£o '{text}' para Actions/Events")
                def actions_events_handler():
                    print(f"DEBUG: *** BOT√ÉO ACTIONS/EVENTS CLICADO ***")
                    # CAPTURAR ESTADO DOS BOT√ïES IMEDIATAMENTE ANTES DE PROCESSAR
                    self._capturar_estado_botoes_imediato()
                    
                    # NOVO: Verificar se h√° TODOS os events expirados primeiro
                    events_expirados = self._encontrar_todos_events_expirados()
                    if events_expirados:
                        print(f"DEBUG: [ACTIONS_EVENTS_BUTTON] {len(events_expirados)} events expirados encontrados - iniciando overlays sequenciais")
                        self._mostrar_overlays_events_expirados_sequencial(events_expirados, 0)
                    else:
                        print(f"DEBUG: [ACTIONS_EVENTS_BUTTON] Nenhum event expirado, abrindo invent√°rio normal")
                        self.show_inventory_matrix(["actions", "events"])
                btn.config(command=actions_events_handler)
            else:
                print(f"DEBUG: Configurando bot√£o '{text}' para tipo '{inv_key}'")
                if inv_key == "services":
                    # Handler especial para Services - verifica se h√° servi√ßos expirados primeiro
                    def services_handler():
                        print(f"DEBUG: *** BOT√ÉO SERVICES CLICADO ***")
                        # CAPTURAR ESTADO DOS BOT√ïES IMEDIATAMENTE ANTES DE PROCESSAR
                        self._capturar_estado_botoes_imediato()
                        
                        # NOVO: Verificar se h√° TODOS os servi√ßos expirados primeiro
                        services_expirados = self._encontrar_todos_services_expirados()
                        if services_expirados:
                            print(f"DEBUG: [SERVICE_BUTTON] {len(services_expirados)} servi√ßos expirados encontrados - iniciando overlays sequenciais")
                            self._mostrar_overlays_services_expirados_sequencial(services_expirados, 0)
                        else:
                            print(f"DEBUG: [SERVICE_BUTTON] Nenhum servi√ßo expirado, abrindo invent√°rio normal")
                            self.show_inventory_matrix(["services"])
                    btn.config(command=services_handler)
                else:
                    def handler(tipo_carta=inv_key):
                        print(f"DEBUG: *** BOT√ÉO {tipo_carta.upper()} CLICADO ***")
                        # CAPTURAR ESTADO DOS BOT√ïES IMEDIATAMENTE ANTES DE IR PARA INVENT√ÅRIO
                        self._capturar_estado_botoes_imediato()
                        self.show_inventory_matrix([tipo_carta])
                    btn.config(command=handler)

        # 2. Carrossel de cartas (agora abaixo dos bot√µes)
        carousel_frame = tk.Frame(self, bg="black")
        carousel_frame.pack(pady=2)
        cards_container = tk.Frame(carousel_frame, bg="black")
        cards_container.pack()

        card_width, card_height = 85, 120  # Certifique-se que est√° definido antes

        self.card_labels = []
        for i, carta_path in enumerate(self.cards):
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_width, card_height)))
            
            # Durante Next Phase, verificar se esta posi√ß√£o pode ser selecionada
            can_select = True
            highlight_color = "black"  # Cor padr√£o do fundo
            border_width = 0
            border_color = "black"
            
            if getattr(self, '_next_phase_active', False) and os.path.basename(carta_path).startswith("back_card_"):
                # Durante Next Phase, verificar se tem User ID para esta posi√ß√£o
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"  # Roxo mais claro para a borda
                    print(f"DEBUG: Carta {i} destacada em roxo - pode ser selecionada")
                else:
                    print(f"DEBUG: Carta {i} sem destaque - n√£o pode ser selecionada")
            
            # Determinar cursor: sempre hand2 para cartas viradas para baixo
            if os.path.basename(carta_path).startswith("back_card_"):
                cursor = "hand2"  # Sempre clic√°vel para cartas viradas para baixo
            else:
                cursor = "hand2" if can_select else "arrow"
            
            lbl = tk.Label(cards_container, image=img, bg=highlight_color, cursor=cursor,
                          borderwidth=border_width, relief="solid", highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
            lbl.image = img  # type: ignore[attr-defined]
            lbl.grid(row=0, column=i, padx=2, pady=0)
            
            # Se for carta virada para baixo, abre invent√°rio de Activities/Challenges
            # CORRE√á√ÉO: Sempre permitir clique em cartas viradas para baixo, independentemente de can_select
            if os.path.basename(carta_path).startswith("back_card_"):
                lbl.bind("<Button-1>", lambda e, idx=i: self.abrir_inventario_para_carrossel(idx))
            else:
                # Para Activities/Challenges: SEMPRE criar binding para permitir cliques
                # A l√≥gica de controlo ser√° feita dentro de _select_carousel_card
                lbl.bind("<Button-1>", lambda e, idx=i, path=carta_path: self._select_carousel_card(idx, path))
            # lbl.selected = True  # Removido para linter
            # lbl.selected = False  # Removido para linter
            self.card_labels.append(lbl)
            
                # Frame para as barras de progresso
        self.progress_frame = tk.Frame(self, bg="black")
        self.progress_frame.pack(pady=(10, 0))

        self.progress_bars = {}
        self.progress_labels = {}

        stats = ["To send", "Rxd", "Lost"]
        for i, stat in enumerate(stats):
            row = tk.Frame(self.progress_frame, bg="black")
            row.pack(fill="x", pady=2)
            # Label do nome da stat √† esquerda
            stat_lbl = tk.Label(row, text=stat, font=("Helvetica", 12, "bold"), bg="black", fg="white", width=8, anchor="w")
            stat_lbl.pack(side="left")
            # CORRE√á√ÉO: Todas as barras usam o mesmo m√°ximo inicial (ser√° ajustado dinamicamente para message_size)
            # Isso garante precis√£o visual - barras com mesmo valor ficam alinhadas
            bar = ttk.Progressbar(row, orient="horizontal", length=240, mode="determinate", maximum=10)  # Valor inicial, ser√° ajustado para message_size
            bar.pack(side="left", fill="x", expand=True, padx=(4, 4))
            self.progress_bars[stat] = bar
            # Label do valor √† direita da barra
            value_lbl = tk.Label(row, text="0", font=("Helvetica", 12, "bold"), bg="black", fg="white", width=2, anchor="e")
            value_lbl.pack(side="left", padx=(4, 0))
            self.progress_labels[stat] = value_lbl

        #Outra alternativa para mostrar os valores abaixo das cartas
        """ # --- Tabela de valores por baixo das cartas ---
        stats_frame = tk.Frame(self, bg="black")
        stats_frame.pack(pady=(4, 0))

        self.stats_value_labels = []  # <-- Adiciona esta linha ANTES do ciclo

        stats_labels = [("To send", "To\nsend"), ("Rxd", "Rxd"), ("Lost", "Lost")]

        for row, (stat_key, stat_label) in enumerate(stats_labels):
            legend = tk.Label(
                stats_frame,
                text=stat_label,
                font=("Helvetica", 12, "bold"),
                bg="black",
                fg="white",
                width=8,
                height=2 if "\n" in stat_label else 1,
                anchor="w"  # <-- Alinha o texto √† esquerda dentro do label
            )
            # Espa√ßamento extra AP√ìS "To send"
            if stat_key == "To send":
                pady_val = (0, 6)
            elif stat_key == "Rxd":
                pady_val = (0, 6)
            else:
                pady_val = (0, 0)
            legend.grid(row=row, column=0, padx=(0,0), pady=pady_val, sticky="w")  # <-- Alinha o label √† esquerda na c√©lula
            row_labels = []
            for col in range(4):
                value = self.card_stats[col][stat_key]
                # Ajusta o deslocamento horizontal de cada coluna:
                if col == 0:
                    col_padx = (0, 4)   # Mais espa√ßo √† direita da primeira coluna
                elif col == 3:
                    col_padx = (6, 2)   # Mais espa√ßo √† esquerda da √∫ltima coluna
                else:
                    col_padx = (4, 4)   # Espa√ßo igual entre colunas interm√©dias

                val_lbl = tk.Label(
                    stats_frame,
                    text=str(value),
                    font=("Helvetica", 12),
                    bg="black",
                    fg="white",
                    width=card_width//10,
                    anchor="w"
                )
                val_lbl.grid(row=row, column=col+1, padx=col_padx, pady=pady_val, sticky="w")
                row_labels.append(val_lbl)
            self.stats_value_labels.append(row_labels)

        # Ajuste o grid para expandir igualmente
        for col in range(1, 5):
            stats_frame.grid_columnconfigure(col, weight=1)
            cards_container.grid_columnconfigure(col-1, weight=1) """

        # NOTA: Bot√£o End Turn agora √© criado dinamicamente apenas quando necess√°rio
        # N√£o criar bot√£o End Turn aqui para evitar conflitos com o sistema de gest√£o de pacotes

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Saldo no canto inferior direito (sobre a BelowBar) - criado ap√≥s para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, saldo))

        # Bot√£o Next Phase OU Final Phase (cinza) na parte inferior central - criado no final para ficar vis√≠vel
        # Verificar qual bot√£o mostrar baseado no estado atual
        if getattr(self, '_next_phase_active', False) and not getattr(self, '_final_phase_active', False):
            # Next Phase j√° foi ativado mas Final Phase ainda n√£o, mostrar bot√£o Final Phase
            self._criar_botao_final_phase()
        elif getattr(self, '_final_phase_active', False) and getattr(self, '_show_end_turn_button', False):
            # Final Phase j√° foi ativado E o bot√£o Final Phase j√° foi clicado, mostrar bot√£o End Turn
            print("DEBUG: Final Phase ativo e bot√£o Final Phase foi clicado - mostrando bot√£o End Turn")
            
            # CORRE√á√ÉO CR√çTICA: Usar o m√©todo _criar_botao_end_turn() que chama self.end_turn() corretamente
            # Este m√©todo j√° faz tudo: incrementa contadores, preserva estado, reseta flags
            self._criar_botao_end_turn()
            
            # CORRE√á√ÉO CR√çTICA: Usar o m√©todo _criar_botao_end_turn() que chama self.end_turn() corretamente
            # N√ÉO redefinir end_turn_action aqui - usar a implementa√ß√£o correta
            self._criar_botao_end_turn()
        else:
            # Next Phase ainda n√£o foi ativado, verificar se deve mostrar bot√£o Next Phase
            # L√ìGICA CORRETA:
            # - Se Challenge pendente (navega√ß√£o Player) ‚Üí N√ÉO mostrar Next Phase, mostrar Store
            # - Se Challenge aceite (decis√£o Accept/Reject) ‚Üí mostrar Next Phase, N√ÉO mostrar Store  
            # - Se navega√ß√£o normal ‚Üí mostrar Next Phase
            
            challenge_foi_aceite = getattr(self, '_challenge_accepted', False)
            store_button_disabled = getattr(self, '_store_button_disabled', False)
            challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                            hasattr(self, '_store_challenge_carta_tipo') and
                                            self._store_challenge_carta_tipo == "challenges")
            
            print(f"DEBUG: [INTERFACE] Verifica√ß√£o para mostrar Next Phase:")
            print(f"DEBUG: [INTERFACE]   _challenge_accepted: {challenge_foi_aceite}")
            print(f"DEBUG: [INTERFACE]   _store_button_disabled: {store_button_disabled}")
            print(f"DEBUG: [INTERFACE]   challenge_pendente_transferido: {challenge_pendente_transferido}")
            
            # L√ìGICA CORRIGIDA: 
            # - Se Challenge pendente (Player button) ‚Üí N√ÉO mostrar Next Phase
            # - Se Challenge aceite (Accept/Reject) ‚Üí mostrar Next Phase
            # - Caso contr√°rio ‚Üí mostrar Next Phase
            if challenge_pendente_transferido:
                print("DEBUG: Challenge pendente via navega√ß√£o (Player button) - Next Phase N√ÉO mostrado")
            elif challenge_foi_aceite or store_button_disabled:
                print("DEBUG: Challenge aceite via decis√£o (Accept/Reject) - Next Phase mostrado")
                # Mostrar Next Phase quando Challenge foi aceite
                self._criar_botao_next_phase()
            else:
                print("DEBUG: Navega√ß√£o normal - Next Phase mostrado")
                # Mostrar Next Phase em navega√ß√£o normal
                self._criar_botao_next_phase()

        # NOTA: As listas de cartas ativas (active_challenge, active_users, etc.) 
        # j√° est√£o inicializadas no __init__ do PlayerDashboard
        
        # IMPORTANTE: Atualizar destaques do carrossel no final da cria√ß√£o da interface
        # Isso garante que os destaques roxos apare√ßam corretamente quando Next Phase est√° ativo
        # CORRE√á√ÉO: Usar delay para garantir que widgets est√£o completamente criados
        def atualizar_destaques_com_delay():
            if hasattr(self, 'card_labels') and self.card_labels:
                # Verificar se todos os widgets est√£o v√°lidos antes de atualizar
                widgets_validos = True
                for i, lbl in enumerate(self.card_labels):
                    try:
                        if not lbl.winfo_exists():
                            widgets_validos = False
                            break
                    except tk.TclError:
                        widgets_validos = False
                        break
                
                if widgets_validos:
                    self._update_carousel_highlights()
                    print("DEBUG: Destaques do carrossel atualizados no final da cria√ß√£o da interface")
                else:
                    print("DEBUG: WARNING: Widgets ainda n√£o est√£o prontos - pulando atualiza√ß√£o de destaques")
            else:
                print("DEBUG: WARNING: card_labels n√£o existe - pulando atualiza√ß√£o de destaques")
        
        # *** NOVO: ADICIONAR TIMER DE SESS√ÉO NA INTERFACE PRINCIPAL ***
        if getattr(self, 'session_timer_active', False):
            print(f"[SESSION_TIMER] Criando display na interface principal - timer j√° est√° activo")
            # Usar delay para garantir que a interface est√° pronta
            self.after(200, lambda: self.create_session_timer_display(self))
        else:
            # FOR√áA DETEC√á√ÉO DE MULTIPLAYER baseada na presen√ßa de session_data
            is_multiplayer = (hasattr(netmaster_client, 'session_data') and 
                             netmaster_client.session_data is not None)
            
            if is_multiplayer:
                print(f"[SESSION_TIMER] Modo multiplayer detectado na interface principal - verificando se deve iniciar timer")
                session_data = netmaster_client.session_data
                duration_minutes = session_data.get('duration_minutes', 15)
                print(f"[SESSION_TIMER] Iniciando timer de {duration_minutes} minutos na interface principal")
                self.after(500, lambda: self.start_session_timer(duration_minutes * 60))
                self.after(700, lambda: self.create_session_timer_display(self))
            else:
                print(f"[SESSION_TIMER] Modo single player ou sem dados de sess√£o na interface principal")
        
        # Usar delay pequeno para garantir que widgets est√£o estabilizados
        self.after(150, atualizar_destaques_com_delay)
        
        # CORRE√á√ÉO: Restaurar barras de progresso se h√° carta selecionada
        # Isso resolve o problema das barras ficarem zeradas ao voltar de p√°ginas de invent√°rio
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            carta_atual = self.cards[self.selected_carousel_index] 
            carta_index = self.selected_carousel_index
            
            print(f"DEBUG: Restaurando barras para carta REAL do carrossel: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar diferen√ßa se existe
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: WARNING: CORRE√á√ÉO APLICADA:")
                    print(f"DEBUG:   Carta preservada (ERRADA): {carta_preservada}")
                    print(f"DEBUG:   Carta real (CORRETA): {carta_real}")
            
            # CORRE√á√ÉO: Usar √≠ndice correto e verificar valores preservados
            if carta_index < len(self.card_stats):
                preserved_stats = self.card_stats[carta_index]
                print(f"DEBUG: Stats dispon√≠veis para carta {carta_index}: {preserved_stats}")
                
                # CORRE√á√ÉO CR√çTICA: Sempre aplicar valores preservados se existirem
                # Em gest√£o de pacotes, os valores preservados s√£o sempre v√°lidos
                gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
                if gestao_ativa or any(val > 0 for val in preserved_stats.values()):
                    print(f"DEBUG: Aplicando valores preservados para carta {carta_index} (gest√£o_ativa={gestao_ativa})")
                    self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_atual)
                    
                    # FOR√áA refresh visual adicional para garantir que valores aparecem
                    self.after(50, self._force_visual_refresh)
                else:
                    print(f"DEBUG: Valores preservados est√£o todos a zero - usando base de dados")
                    self._update_progress_bars_from_card(carta_atual)
            else:
                print(f"DEBUG: √çndice {carta_index} fora do range de card_stats")
                self._update_progress_bars_from_card(carta_atual)
        else:
            print("DEBUG: Nenhuma carta selecionada no carrossel - barras ficam com valores padr√£o")
    
    def create_coin_saldo_overlay(self, screen_width, screen_height, saldo):
        """Cria o overlay do coin e saldo por cima de todos os outros elementos"""
        try:
            coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
            coin_lbl.image = coin_img  # type: ignore[attr-defined]
            coin_lbl.place(x=screen_width-100, y=screen_height-45)
            coin_lbl.lift()  # Garante que fica por cima
            
            saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
            saldo_lbl.place(x=screen_width-70, y=screen_height-45)
            saldo_lbl.lift()  # Garante que fica por cima
        except Exception as e:
            print(f"DEBUG: Erro ao criar overlay coin/saldo: {e}")
    
    def get_session_players_icons(self):
        """Obt√©m lista de jogadores da sess√£o actual para mostrar √≠cones corretos"""
        try:
            print(f"DEBUG: [ICONS] GET_SESSION_PLAYERS_ICONS - player: {self.player_name} ({self.player_color})")
            
            # Verificar se h√° session_data no netmaster_client global
            if hasattr(netmaster_client, 'session_data') and netmaster_client.session_data:
                session_data = netmaster_client.session_data
                players_list = []
                
                print(f"DEBUG: [ICONS] session_data encontrada com {len(session_data.get('players', {}))} jogadores")
                
                # Obter jogadores da sess√£o, excluindo o pr√≥prio jogador
                for player_id, player_data in session_data.get('players', {}).items():
                    player_name = player_data.get('name', 'Unknown')
                    player_color = player_data.get('color', 'red')
                    
                    # N√£o incluir o pr√≥prio jogador nos √≠cones
                    if player_name != self.player_name:
                        players_list.append({
                            'id': player_id,
                            'name': player_name,
                            'color': player_color
                        })
                        print(f"DEBUG: [ICONS] ‚úì Jogador adicionado: {player_name} ({player_color})")
                    else:
                        print(f"DEBUG: [ICONS] ‚úó Exclu√≠do (√© o pr√≥prio): {player_name} ({player_color})")
                
                print(f"DEBUG: [ICONS] Lista final: {len(players_list)} jogadores")
                return players_list
            else:
                print("DEBUG: [ICONS] Sem session_data - usando fallback para other_players")
                # Fallback: converter other_players existente em formato esperado
                fallback_list = []
                if hasattr(self, 'other_players') and self.other_players:
                    print(f"DEBUG: [ICONS] self.other_players: {self.other_players}")
                    
                    for i, player in enumerate(self.other_players):
                        if hasattr(player, 'name') and hasattr(player, 'color'):
                            # Objeto com atributos name e color
                            if player.color.lower() != self.player_color.lower():
                                fallback_list.append({
                                    'id': f'player_{i}',
                                    'name': player.name,
                                    'color': player.color
                                })
                                print(f"DEBUG: [ICONS] FALLBACK ‚úì Objeto: {player.name} ({player.color})")
                            else:
                                print(f"DEBUG: [ICONS] FALLBACK ‚úó Objeto (mesma cor): {player.name} ({player.color})")
                        elif isinstance(player, str):
                            # Se other_players cont√©m strings (cores), mapear para nomes
                            if player.lower() != self.player_color.lower():
                                fallback_list.append({
                                    'id': f'player_{i}',
                                    'name': f'Player {i+1}',
                                    'color': player
                                })
                                print(f"DEBUG: [ICONS] FALLBACK ‚úì String: Player {i+1} ({player})")
                            else:
                                print(f"DEBUG: [ICONS] FALLBACK ‚úó String (mesma cor): Player {i+1} ({player})")
                
                print(f"DEBUG: [ICONS] Lista final do fallback: {len(fallback_list)} jogadores")
                return fallback_list
        except Exception as e:
            print(f"DEBUG: [ICONS] Erro ao obter jogadores da sess√£o: {e}")
            return []
    
    def update_progress_bars_for_card(self, card_idx):
        """Atualiza as barras de progresso com base nos valores do card_stats"""
        try:
            if not hasattr(self, 'card_stats') or card_idx >= len(self.card_stats):
                print(f"DEBUG: update_progress_bars_for_card - √çndice inv√°lido: {card_idx}")
                return
                
            stats = self.card_stats[card_idx]
            print(f"DEBUG: update_progress_bars_for_card - Atualizando carta {card_idx}: {stats}")
            
            # CORRE√á√ÉO: Obter message_size da carta atual e aplicar como m√°ximo para TODAS as barras
            if hasattr(self, 'cards') and card_idx < len(self.cards):
                carta_path = self.cards[card_idx]
                message_size = self._get_card_message_size_from_database(carta_path)
                print(f"DEBUG: update_progress_bars_for_card - Message size: {message_size}")
                
                # Aplicar message_size como m√°ximo para todas as barras (precis√£o visual)
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        try:
                            # CORRE√á√ÉO CR√çTICA: Verificar se o widget ainda existe antes de configurar
                            if self.progress_bars[stat].winfo_exists():
                                self.progress_bars[stat]["maximum"] = message_size
                                print(f"DEBUG: update_progress_bars_for_card - M√°ximo da barra '{stat}' definido para {message_size}")
                            else:
                                print(f"DEBUG: update_progress_bars_for_card - Widget progress bar '{stat}' foi destru√≠do, pulando")
                        except tk.TclError as e:
                            print(f"DEBUG: update_progress_bars_for_card - Erro TclError na barra '{stat}': {e}")
                            print(f"DEBUG: update_progress_bars_for_card - Widget foi destru√≠do, cancelando atualiza√ß√£o")
                            return
            
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars and stat in self.progress_labels:
                    try:
                        # CORRE√á√ÉO CR√çTICA: Verificar se os widgets ainda existem antes de atualizar
                        if (self.progress_bars[stat].winfo_exists() and 
                            self.progress_labels[stat].winfo_exists()):
                            value = stats[stat]
                            self.progress_bars[stat]["value"] = value
                            self.progress_labels[stat]["text"] = str(value)
                            
                            # For√ßar atualiza√ß√£o visual
                            self.progress_bars[stat].update_idletasks()
                            self.progress_labels[stat].update_idletasks()
                        else:
                            print(f"DEBUG: update_progress_bars_for_card - Widgets '{stat}' foram destru√≠dos, pulando")
                    except tk.TclError as e:
                        print(f"DEBUG: update_progress_bars_for_card - Erro TclError ao atualizar '{stat}': {e}")
                        print(f"DEBUG: update_progress_bars_for_card - Widgets foram destru√≠dos, cancelando resto da atualiza√ß√£o")
                        return
            
            # For√ßar atualiza√ß√£o da interface principal
            self.update_idletasks()
            print(f"DEBUG: update_progress_bars_for_card - Atualiza√ß√£o visual completa")
            
        except Exception as e:
            print(f"DEBUG: Erro em update_progress_bars_for_card: {e}")
            import traceback
            traceback.print_exc()
        

    def update_card_image(self):
        for i, lbl in enumerate(self.card_labels):
            idx = (self.card_idx + i) % len(self.cards)
            img = ImageTk.PhotoImage(Image.open(self.cards[idx]).resize((85,120)))
            lbl.config(image=img)
            lbl.image = img
            # CORRE√á√ÉO: Usar _select_carousel_card em vez de make_card_callback
            # e passar o √≠ndice correto do carrossel
            carousel_index = idx
            carta_path = self.cards[idx]
            lbl.bind("<Button-1>", lambda e, ci=carousel_index, cp=carta_path: self._select_carousel_card(ci, cp))

    def prev_card(self):
        self.card_idx = (self.card_idx - 1) % len(self.cards)
        self.update_card_image()

    def next_card(self):
        self.card_idx = (self.card_idx + 1) % len(self.cards)
        self.update_card_image()

    def add_progress_bar(self, parent, label, value):
        fr = tk.Frame(parent, bg="black")
        fr.pack(pady=2, anchor="w", fill="x", expand=True)
        tk.Label(fr, text=label, font=("Helvetica", 14), bg="black", fg="white", width=8, anchor="w").pack(side=tk.LEFT)
        pb = ttk.Progressbar(fr, length=160, maximum=10, value=value)
        pb.pack(side=tk.LEFT, padx=8, fill="x", expand=True)
        value_lbl = tk.Label(fr, text=str(value), font=("Helvetica", 14), bg="black", fg="white", width=2)
        value_lbl.pack(side=tk.LEFT)
        self.progress_bars[label] = pb  # Guarda refer√™ncia
        if not hasattr(self, "progress_labels"):
            self.progress_labels = {}
        self.progress_labels[label] = value_lbl  # Guarda refer√™ncia √† label do valor

    # *** M√âTODOS DO TIMER DE SESS√ÉO ***
    def start_session_timer(self, time_remaining_seconds):
        """Iniciar timer de contagem decrescente da sess√£o"""
        print(f"[SESSION_TIMER] *** TIMER INICIADO NO PLAYERDASHBOARD ***")
        print(f"[SESSION_TIMER] Tempo inicial: {time_remaining_seconds:.1f} segundos")
        
        # Converter para minutos e segundos
        minutes = int(time_remaining_seconds // 60)
        seconds = int(time_remaining_seconds % 60)
        
        print(f"[SESSION_TIMER] Tempo formatado: {minutes:02d}:{seconds:02d}")
        
        # Armazenar tempo restante
        self.session_time_remaining = time_remaining_seconds
        self.session_timer_active = True
        
        # VERIFICAR SE √â O HOST - apenas Host inicia countdown autom√°tico
        is_host = self.is_session_host()
        
        print(f"[SESSION_TIMER] Timer activado - verificando se √© Host: {is_host}")
        
        if is_host:
            print(f"[SESSION_TIMER] Este jogador √© HOST - iniciando countdown autom√°tico")
            # Iniciar update do timer apenas no Host
            self.update_session_timer()
        else:
            print(f"[SESSION_TIMER] Este jogador √© JOINEE - aguardando sincroniza√ß√£o do Host")
            # Joinees n√£o iniciam countdown - apenas aguardam mensagens do Host

    def update_session_timer(self):
        """Atualizar o timer a cada segundo - DESATIVADO: Agora todos recebem updates do servidor"""
        if not getattr(self, 'session_timer_active', False):
            return
            
        if self.session_time_remaining <= 0:
            print(f"[SESSION_TIMER] *** TEMPO ESGOTADO! ***")
            self.session_timer_active = False
            # Fim de jogo - mostrar p√°gina de ranking
            self._handle_game_time_ended()
            return
        
        # CORRE√á√ÉO: DESATIVAR countdown local - TODOS recebem updates do servidor
        print(f"[SESSION_TIMER] Timer local desativado - aguardando updates do servidor")
        print(f"[SESSION_TIMER] Tempo atual recebido do servidor: {self.session_time_remaining:.1f}s")
        
        # Apenas atualizar display com o valor recebido do servidor
        self.update_timer_display()
        
        # N√ÉO AGENDAR mais countdown local - servidor controla tudo
        # self.after(1000, self.update_session_timer) # REMOVIDO
    
    def is_session_host(self):
        """Verificar se este jogador √© o Host da sess√£o"""
        try:
            # Verificar se h√° session_data
            if not hasattr(netmaster_client, 'session_data') or not netmaster_client.session_data:
                return False
                
            session_data = netmaster_client.session_data
            my_player_id = getattr(netmaster_client, 'player_id', None)
            host_id = session_data.get('host_player_id', None)  # CORRE√á√ÉO: usar host_player_id
            
            is_host = (my_player_id == host_id)
            print(f"[SESSION_TIMER] Verifica√ß√£o Host: my_id={my_player_id}, host_id={host_id}, is_host={is_host}")
            
            return is_host
        except Exception as e:
            print(f"[SESSION_TIMER] Erro ao verificar se √© Host: {e}")
            return False
    
    def send_timer_sync(self):
        """Enviar sincroniza√ß√£o do timer para todos os jogadores (apenas Host)"""
        try:
            if 'netmaster_client' in globals() and netmaster_client:
                sync_data = {
                    'type': 'timer_sync',
                    'time_remaining': self.session_time_remaining,
                    'timer_active': self.session_timer_active,
                    'timestamp': time.time()
                }
                
                print(f"[TIMER_SYNC] HOST enviando: {self.session_time_remaining:.1f}s")
                
                # Enviar a mensagem de forma ass√≠ncrona
                async def send_async():
                    try:
                        await netmaster_client.send_message(sync_data)
                        print(f"[TIMER_SYNC] ‚úì Mensagem timer_sync enviada com sucesso")
                    except Exception as e:
                        print(f"[TIMER_SYNC] ‚úó Erro ao enviar timer_sync: {e}")
                
                # Executar de forma ass√≠ncrona
                asyncio.create_task(send_async())
                
        except Exception as e:
            print(f"[TIMER_SYNC] Erro ao enviar sincroniza√ß√£o: {e}")
    
    def update_timer_display(self):
        """Atualizar display do timer na interface"""
        if not hasattr(self, 'session_time_remaining'):
            print(f"[SESSION_TIMER] DEBUG: session_time_remaining n√£o existe")
            return
            
        # Converter para minutos e segundos
        minutes = int(self.session_time_remaining // 60)
        seconds = int(self.session_time_remaining % 60)
        
        # Formato do timer SEM EMOJI
        timer_text = f"{minutes:02d}:{seconds:02d}"
        
        # Cor baseada no tempo restante
        if minutes < 2:  # Menos de 2 minutos - vermelho
            timer_color = "#FF4444"
        elif minutes < 5:  # Menos de 5 minutos - amarelo
            timer_color = "#FFAA00"
        else:  # Mais de 5 minutos - verde
            timer_color = "#44FF44"
        
        print(f"[SESSION_TIMER] DEBUG: Atualizando timer: {timer_text} (cor: {timer_color})")
        
        # Atualizar label se existir E se ainda √© v√°lido
        if hasattr(self, 'session_timer_label') and self.session_timer_label:
            try:
                # CORRE√á√ÉO: Verificar se o widget ainda existe antes de tentar actualizar
                if self.session_timer_label.winfo_exists():
                    self.session_timer_label.configure(text=timer_text, fg=timer_color)
                    print(f"[SESSION_TIMER] DEBUG: Timer atualizado com sucesso")
                else:
                    print(f"[SESSION_TIMER] DEBUG: Widget timer n√£o existe mais - limpando refer√™ncia")
                    self.session_timer_label = None
            except Exception as e:
                print(f"[SESSION_TIMER] Erro ao atualizar label: {e}")
                # Se h√° erro, limpar a refer√™ncia para evitar tentativas futuras
                self.session_timer_label = None
        else:
            # NOVO: Log quando n√£o h√° timer vis√≠vel mas tempo continua a passar
            print(f"[SESSION_TIMER] DEBUG: Timer a contar em background: {timer_text} (sem display)")
    
    def create_session_timer_display(self, parent_widget):
        """Criar display do timer de sess√£o numa interface"""
        try:
            # CORRE√á√ÉO: Verificar se estamos em modo multiplayer primeiro
            is_multiplayer = (hasattr(netmaster_client, 'session_data') and 
                             netmaster_client.session_data is not None)
            
            # Verificar se o timer est√° ativo OU se estamos em modo multiplayer
            timer_active = getattr(self, 'session_timer_active', False)
            has_timer_time = getattr(self, 'session_time_remaining', 0) > 0
            
            # CORRE√á√ÉO: Se √© multiplayer, sempre criar o timer display
            if not timer_active and not is_multiplayer:
                print(f"[SESSION_TIMER] DEBUG: Timer n√£o est√° ativo e sem dados multiplayer - n√£o criando display")
                print(f"[SESSION_TIMER] DEBUG: timer_active={timer_active}, is_multiplayer={is_multiplayer}, has_timer_time={has_timer_time}")
                return
            
            # Se √© multiplayer mas n√£o tem timer ativo, ativar o timer primeiro
            if is_multiplayer and not timer_active:
                session_data = netmaster_client.session_data
                duration_minutes = session_data.get('duration_minutes', 15)
                print(f"[SESSION_TIMER] Ativando timer para interface principal: {duration_minutes} minutos")
                self.session_time_remaining = duration_minutes * 60
                self.session_timer_active = True
                # CORRE√á√ÉO: N√£o iniciar timer local - aguardar updates do servidor
                # if self.is_session_host():
                #     self.after(1000, self.update_session_timer) # REMOVIDO
                print(f"[SESSION_TIMER] Timer ativado - aguardando updates do servidor")
            
            # Evitar cria√ß√£o duplicada
            if hasattr(self, 'session_timer_label') and self.session_timer_label:
                print(f"[SESSION_TIMER] DEBUG: Timer label j√° existe - atualizando posi√ß√£o")
                # Apenas reposicionar se j√° existe
                self.update_timer_display()
                return
            
            print(f"[SESSION_TIMER] DEBUG: Criando timer display na interface principal...")
            
            # Criar label do timer SEM EMOJI - TAMANHO REDUZIDO e posicionado acima do nome do jogador
            self.session_timer_label = tk.Label(
                parent_widget,
                text="--:--",
                font=("Arial", 14, "bold"),  # Reduzido de 18 para 14
                fg="#44FF44",
                bg="black"
            )
            
            # Posicionar acima do nome do jogador (no topo da interface)
            self.session_timer_label.place(relx=0.5, y=0, anchor="n")
            
            print(f"[SESSION_TIMER] DEBUG: Segunda inst√¢ncia do display criada acima do nome do jogador")
            
            # Atualizar imediatamente
            self.update_timer_display()
            
        except Exception as e:
            print(f"[SESSION_TIMER] Erro ao criar display (segunda inst√¢ncia): {e}")
            import traceback
            traceback.print_exc()
            self.session_timer_label = None
    # *** FIM M√âTODOS DO TIMER DE SESS√ÉO ***

    def try_mostrar_carta(self, path):
        try:
            print("CLICOU!", path)
            idx = self.cards.index(path)
            mostrar_carta_fullscreen_root(self.master, path, selected_card_idx=idx)
        except Exception as ex:
            print("ERRO AO ABRIR FULLSCREEN:", ex)

    def activate_card(self, card_type, card_path):
        # CORRE√á√ÉO: Permitir ativa√ß√£o de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser ativadas antes de Next Phase e permanecem ativas entre turnos
        
        # IMPORTANTE: N√£o pode ativar cartas ap√≥s Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de ativar carta {card_type} BLOQUEADA - Final Phase est√° ativo")
            return
        
        if card_type == "challenge":
            # S√≥ pode haver 1 challenge ativo
            if self.active_challenge:
                self.discard_card(self.active_challenge)
            self.active_challenge = card_path
            self.show_card_active(card_path)
        elif card_type == "user" or card_type == "users":
            # M√°ximo de 4 users ativos (apenas Users t√™m limite)
            if card_path not in self.active_users:
                if len(self.active_users) < self.max_users:
                    self.active_users.append(card_path)
                    self.show_card_active(card_path)
                    print(f"DEBUG: User ativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                    # IMPORTANTE: Atualizar destaques do carrossel quando User √© ativado
                    self._update_carousel_highlights()
                else:
                    # Opcional: feedback ao jogador que j√° tem 4 users
                    print("J√° tens 4 users ativos!")
        elif card_type == "equipment" or card_type == "equipments":
            # SEM LIMITE para equipments ap√≥s Next Phase
            if card_path not in self.active_equipments:
                self.active_equipments.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Equipment ativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type == "service" or card_type == "services":
            # SEM LIMITE para services ap√≥s Next Phase
            if card_path not in self.active_services:
                self.active_services.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Service ativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")
                
                # NOVO: Adicionar tracking para servi√ßos TEMPORARY
                self._register_service_start_turn(card_path)
                
                # NOVO: Inicializar tracking para DATA VOLUME services
                self._register_data_volume_service(card_path)
    
    def is_card_active(self, card_path, card_type):
        """Verifica se uma carta est√° ativa"""
        if card_type == "challenge":
            return self.active_challenge == card_path
        elif card_type in ["user", "users"]:
            return card_path in self.active_users
        elif card_type in ["equipment", "equipments"]:
            return card_path in self.active_equipments
        elif card_type in ["service", "services"]:
            return card_path in self.active_services
        elif card_type == "actions":
            # NOVO: Actions s√≥ est√£o ativos se est√£o na posi√ß√£o 0 da fila cronol√≥gica
            chronological_order = self._get_chronological_actions_events_order()
            if chronological_order:
                first_card = chronological_order[0]
                is_active = (first_card['path'] == card_path and first_card['type'] == 'actions')
                print(f"DEBUG: [IS_ACTIVE_ACTION] {os.path.basename(card_path)} na posi√ß√£o 0? {is_active}")
                return is_active
            return False
        elif card_type == "events":
            # NOVO: Events s√≥ est√£o ativos se est√£o na posi√ß√£o 0 da fila cronol√≥gica
            chronological_order = self._get_chronological_actions_events_order()
            if chronological_order:
                first_card = chronological_order[0]
                is_active = (first_card['path'] == card_path and first_card['type'] == 'events')
                print(f"DEBUG: [IS_ACTIVE_EVENT] {os.path.basename(card_path)} na posi√ß√£o 0? {is_active}")
                return is_active
            return False
        return False
    
    def deactivate_card(self, card_path, card_type):
        """Desativa uma carta"""
        # CORRE√á√ÉO: Permitir desativa√ß√£o de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser desativadas antes de Next Phase e o estado √© preservado entre turnos
        
        # IMPORTANTE: N√£o pode desativar cartas ap√≥s Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de desativar carta {card_type} BLOQUEADA - Final Phase est√° ativo")
            return
        
        if card_type == "challenge":
            if self.active_challenge == card_path:
                self.active_challenge = None
                print(f"DEBUG: Challenge desativado: {os.path.basename(card_path)}")
        elif card_type in ["user", "users"]:
            if card_path in self.active_users:
                self.active_users.remove(card_path)
                print(f"DEBUG: User desativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                # IMPORTANTE: Atualizar destaques do carrossel quando User √© desativado
                self._update_carousel_highlights()
        elif card_type in ["equipment", "equipments"]:
            if card_path in self.active_equipments:
                self.active_equipments.remove(card_path)
                print(f"DEBUG: Equipment desativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type in ["service", "services"]:
            if card_path in self.active_services:
                self.active_services.remove(card_path)
                print(f"DEBUG: Service desativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")
                
                # CORRE√á√ÉO: Limpar tracking do Service quando desativado manualmente
                self._cleanup_expired_service_tracking(card_path)

    def discard_card(self, card_path):
        # Remove visualmente/desativa o challenge anterior
        pass

    def show_card_active(self, card_path):
        # Atualiza visualmente a carta como ativa
        pass
    
    def _limpar_cartas_actions_events_incorretas(self):
        """
        Remove cartas Actions/Events que foram incorretamente adicionadas ao invent√°rio
        quando deveriam ter sido enviadas para outros jogadores.
        
        Cartas que devem ser removidas:
        - Actions com target diferente do jogador atual
        - Events com target_player diferente do jogador atual (exceto player_choice=True)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [_limpar_cartas_incorretas] Base de dados n√£o dispon√≠vel - n√£o √© poss√≠vel limpar")
            return
        
        player_color = self.player_color.lower()
        cartas_para_remover = []
        
        # Verificar cartas Actions
        for carta_path in self.inventario.get("actions", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Action_(\d+)\.', filename)
                if match:
                    card_id = f"action_{match.group(1)}"
                    card_data = self.card_database.get_action(card_id)
                    if card_data:
                        target = getattr(card_data, 'target', None)
                        # Se target n√£o √© None e n√£o √© igual ao jogador atual, remover
                        if target is not None and target != player_color:
                            cartas_para_remover.append(('actions', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Action para remo√ß√£o: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Action {filename}: {e}")
        
        # Verificar cartas Events
        for carta_path in self.inventario.get("events", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Event_(\d+)\.', filename)
                if match:
                    card_id = f"event_{match.group(1)}"
                    card_data = self.card_database.get_event(card_id)
                    if card_data:
                        target = getattr(card_data, 'target_player', None)
                        player_choice = getattr(card_data, 'player_choice', False)
                        # Se target n√£o √© None, n√£o √© igual ao jogador atual e player_choice √© False, remover
                        if target is not None and target != player_color and not player_choice:
                            cartas_para_remover.append(('events', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Event para remo√ß√£o: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Event {filename}: {e}")
        
        # Remover cartas identificadas
        cartas_removidas = 0
        for tipo, carta_path, target in cartas_para_remover:
            try:
                self.inventario[tipo].remove(carta_path)
                cartas_removidas += 1
                print(f"DEBUG: [_limpar_cartas_incorretas] SUCCESS: Removida: {os.path.basename(carta_path)} (tipo={tipo}, target={target})")
            except ValueError:
                print(f"DEBUG: [_limpar_cartas_incorretas] ERROR: Erro: carta n√£o encontrada no invent√°rio: {os.path.basename(carta_path)}")
        
        if cartas_removidas > 0:
            print(f"DEBUG: [_limpar_cartas_incorretas] Total de cartas removidas: {cartas_removidas}")
        else:
            print(f"DEBUG: [_limpar_cartas_incorretas] Nenhuma carta incorreta encontrada para remo√ß√£o")

    def adicionar_carta_inventario(self, carta_path, carta_tipo):
        if carta_tipo in self.inventario:
            print(f"DEBUG: [ADICIONAR_CARTA] === INICIANDO ADI√á√ÉO DE CARTA ===")
            print(f"DEBUG: [ADICIONAR_CARTA] Carta: {os.path.basename(carta_path)}")
            print(f"DEBUG: [ADICIONAR_CARTA] Tipo: {carta_tipo}")
            
            # CORRE√á√ÉO CR√çTICA: Verificar se ser√° primeira na fila ANTES de adicionar ao tracking
            will_be_first_in_queue = False
            if carta_tipo in ["actions", "events"]:
                if not hasattr(self, '_actions_events_order') or not self._actions_events_order:
                    will_be_first_in_queue = True  # Se n√£o h√° fila, ser√° a primeira
                    print(f"DEBUG: [TEMPORAL] Fila vazia - {carta_tipo} ser√° primeira: {os.path.basename(carta_path)}")
                else:
                    will_be_first_in_queue = False  # H√° cartas na fila, esta ir√° para o fim
                    print(f"DEBUG: [TEMPORAL] Fila com {len(self._actions_events_order)} cartas - {carta_tipo} vai para o fim: {os.path.basename(carta_path)}")
            
            self.inventario[carta_tipo].append(carta_path)
            print(f"DEBUG: [ADICIONAR_CARTA] Carta adicionada ao invent√°rio {carta_tipo}")
            
            # SISTEMA FIFO SIMPLES: Nova carta sempre vai para o fim da fila
            if carta_tipo in ["actions", "events"]:
                if not hasattr(self, '_actions_events_order'):
                    self._actions_events_order = []
                
                # CORRE√á√ÉO: Permitir duplicatas - n√£o remover cartas existentes
                # Sempre adicionar no fim, mesmo que a carta j√° exista na fila
                print(f"DEBUG: [FIFO_DUPLICATES] Permitindo duplicatas - carta ser√° adicionada no fim mesmo que j√° exista: {os.path.basename(carta_path)}")
                
                # Determinar pr√≥ximo timestamp (sempre o maior + 1 para garantir ordem FIFO)
                next_timestamp = len(self._actions_events_order)
                if self._actions_events_order:
                    # Garantir que o timestamp √© sempre maior que todos os existentes
                    max_existing = max(entry.get('timestamp', 0) for entry in self._actions_events_order)
                    next_timestamp = max_existing + 1
                
                # Adicionar carta ao fim da fila cronol√≥gica (permitindo duplicatas)
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': carta_tipo,
                    'timestamp': next_timestamp
                })
                print(f"DEBUG: [SIMPLE_FIFO] Carta {carta_tipo} adicionada ao FIM da fila (timestamp {next_timestamp}): {os.path.basename(carta_path)}")
                print(f"DEBUG: [SIMPLE_FIFO] Fila atual: {[os.path.basename(entry['path']) for entry in self._actions_events_order]}")
            
            # Se for uma carta User, atualizar destaques do carrossel
            if carta_tipo == "users":
                # Aguardar um momento para garantir que a carta foi adicionada
                self.after(100, self._update_carousel_highlights)
            
            # Se for uma carta Event, registrar no tracking mas s√≥ ativar se for posi√ß√£o 0
            if carta_tipo == "events":
                # CORRE√á√ÉO CR√çTICA: Garantir que os atributos de tracking existem antes de usar
                if not hasattr(self, '_event_start_turns'):
                    self._event_start_turns = {}
                    print(f"DEBUG: [ADD_EVENT] _event_start_turns inicializado")
                
                if not hasattr(self, '_event_duration_tracking'):
                    self._event_duration_tracking = {}
                    print(f"DEBUG: [ADD_EVENT] _event_duration_tracking inicializado")
                
                current_turn = getattr(self, '_current_turn', 0)
                
                # Obter duration_turns da carta
                from cards_database import get_event_duration
                duration_turns = get_event_duration(carta_path)
                
                # CORRE√á√ÉO: Verificar se duration_turns √© uma string "variable"
                if duration_turns == "variable":
                    # Para events com dura√ß√£o vari√°vel, n√£o converter para n√∫mero - manter como "variable"
                    print(f"DEBUG: [ADD_EVENT] Event com dura√ß√£o vari√°vel - mantendo duration_turns = 'variable'")
                elif isinstance(duration_turns, str):
                    # Tentar converter string para n√∫mero
                    try:
                        duration_turns = int(duration_turns)
                    except (ValueError, TypeError):
                        duration_turns = 3  # Fallback para 3 turnos
                        print(f"DEBUG: [ADD_EVENT] Erro ao converter dura√ß√£o - usando 3 turnos por padr√£o")
                elif duration_turns is None:
                    duration_turns = 3  # Fallback para 3 turnos
                    print(f"DEBUG: [ADD_EVENT] Dura√ß√£o n√£o encontrada - usando 3 turnos por padr√£o")
                
                if duration_turns is not None and (isinstance(duration_turns, int) or duration_turns == "variable"):
                    # NOVA L√ìGICA: Verificar se uma carta foi removida recentemente
                    card_should_be_inactive_initially = False
                    
                    # Se uma Action ou Event foi removido recentemente, pr√≥xima carta deve ficar inativa inicialmente
                    if getattr(self, '_action_recently_removed', False) or getattr(self, '_event_recently_removed', False):
                        card_should_be_inactive_initially = True
                        print(f"DEBUG: [CARD_SEQUENCING] Event {os.path.basename(carta_path)} deve ficar INATIVO inicialmente - carta anterior foi removida")
                    
                    # CORRE√á√ÉO: Usar a verifica√ß√£o feita antes de adicionar ao tracking
                    if will_be_first_in_queue and not card_should_be_inactive_initially:
                        # Event vai para posi√ß√£o 0 e n√£o h√° sequenciamento - ativar imediatamente
                        if duration_turns == "variable":
                            # Event com dura√ß√£o vari√°vel - n√£o definir start_turn nem expires_turn ainda
                            self._event_start_turns[carta_path] = None  # Ser√° definido ap√≥s lan√ßar dado
                            self._event_duration_tracking[carta_path] = {
                                'start_turn': None,  # Ser√° definido ap√≥s lan√ßar dado
                                'duration_turns': duration_turns,  # Manter "variable"
                                'expires_turn': None,  # Ser√° definido ap√≥s lan√ßar dado
                                'is_active': True  # Marcador para indicar que est√° ativo
                            }
                            print(f"DEBUG: [ADD_EVENT] ‚òÖ‚òÖ‚òÖ Event VARI√ÅVEL ATIVADO (posi√ß√£o 0, aguardando dado): {os.path.basename(carta_path)} ‚òÖ‚òÖ‚òÖ")
                            print(f"DEBUG: [ADD_EVENT] - start_turn: None (ser√° definido ap√≥s lan√ßar dado)")
                            print(f"DEBUG: [ADD_EVENT] - duration_turns: variable")
                            print(f"DEBUG: [ADD_EVENT] - expires_turn: None (ser√° definido ap√≥s lan√ßar dado)")
                            print(f"DEBUG: [ADD_EVENT] - is_active: True")
                        else:
                            # Event com dura√ß√£o fixa - ativar normalmente
                            self._event_start_turns[carta_path] = current_turn
                            self._event_duration_tracking[carta_path] = {
                                'start_turn': current_turn,
                                'duration_turns': duration_turns,
                                'expires_turn': current_turn + duration_turns,
                                'is_active': True  # Marcador para indicar que est√° ativo
                            }
                            print(f"DEBUG: [ADD_EVENT] ‚òÖ‚òÖ‚òÖ Event ATIVADO IMEDIATAMENTE (posi√ß√£o 0, sem sequenciamento): {os.path.basename(carta_path)} ‚òÖ‚òÖ‚òÖ")
                            print(f"DEBUG: [ADD_EVENT] - start_turn: {current_turn}")
                            print(f"DEBUG: [ADD_EVENT] - duration_turns: {duration_turns}")
                            print(f"DEBUG: [ADD_EVENT] - expires_turn: {current_turn + duration_turns}")
                            print(f"DEBUG: [ADD_EVENT] - is_active: True")
                    else:
                        # Event vai para fila OU deve ficar inativo devido ao sequenciamento - n√£o ativar ainda
                        self._event_start_turns[carta_path] = None  # N√£o ativo ainda
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': None,  # Ser√° definido quando ativar no pr√≥ximo turno
                            'duration_turns': duration_turns,  # Pode ser "variable" ou n√∫mero
                            'expires_turn': None,  # Ser√° calculado quando ativar
                            'is_active': False,  # Em fila ou inativo por sequenciamento
                            'pending_activation': card_should_be_inactive_initially  # Marca se est√° esperando ativa√ß√£o por sequenciamento
                        }
                        if card_should_be_inactive_initially:
                            print(f"DEBUG: [ADD_EVENT] Event INATIVO por sequenciamento (posi√ß√£o 0): {os.path.basename(carta_path)}")
                            print(f"DEBUG: [ADD_EVENT] - Motivo: carta anterior foi removida")
                            print(f"DEBUG: [ADD_EVENT] - pending_activation: True")
                        else:
                            print(f"DEBUG: [ADD_EVENT] Event INATIVO (vai para fila): {os.path.basename(carta_path)}")
                            print(f"DEBUG: [ADD_EVENT] - Motivo: n√£o √© primeira na fila (will_be_first_in_queue: {will_be_first_in_queue})")
                        print(f"DEBUG: [ADD_EVENT] - is_active: False")
                else:
                    print(f"DEBUG: [ADD_EVENT] ERRO: N√£o foi poss√≠vel obter duration_turns para {os.path.basename(carta_path)} - Event N√ÉO ATIVADO")
                        
                self._ensure_active_event_tracking()

            # NOVA L√ìGICA: Implementar sequenciamento para Actions tamb√©m
            if carta_tipo == "actions":
                # Se uma Action ou Event foi removido recentemente, marcar pr√≥xima Action como inativa inicialmente
                if getattr(self, '_action_recently_removed', False) or getattr(self, '_event_recently_removed', False):
                    if not hasattr(self, '_actions_pending_activation'):
                        self._actions_pending_activation = {}
                    
                    self._actions_pending_activation[carta_path] = True
                    print(f"DEBUG: [CARD_SEQUENCING] Action {os.path.basename(carta_path)} marcada como INATIVA inicialmente - carta anterior foi removida")
            
            print(f"DEBUG: [ADICIONAR_CARTA] === ADI√á√ÉO CONCLU√çDA ===")

    def ensure_events_have_tracking(self):
        """
        Garante que todos os Events no invent√°rio t√™m tracking apropriado.
        Se um Event est√° na posi√ß√£o 0 da fila cronol√≥gica, deve estar ativo.
        """
        print(f"DEBUG: [ENSURE_TRACKING] === VERIFICANDO TRACKING DE EVENTS ===")
        
        # Garantir que todos os atributos necess√°rios existem
        if not hasattr(self, '_event_start_turns'):
            self._event_start_turns = {}
            print(f"DEBUG: [ENSURE_TRACKING] _event_start_turns inicializado")
        
        if not hasattr(self, '_event_duration_tracking'):
            self._event_duration_tracking = {}
            print(f"DEBUG: [ENSURE_TRACKING] _event_duration_tracking inicializado")
        
        if not hasattr(self, '_action_recently_removed'):
            self._action_recently_removed = False
            print(f"DEBUG: [ENSURE_TRACKING] _action_recently_removed inicializado como False")
        
        if not hasattr(self, '_event_recently_removed'):
            self._event_recently_removed = False
            print(f"DEBUG: [ENSURE_TRACKING] _event_recently_removed inicializado como False")
        
        events_no_inventario = self.inventario.get("events", [])
        if not events_no_inventario:
            print(f"DEBUG: [ENSURE_TRACKING] Nenhum Event no invent√°rio")
            return
        
        print(f"DEBUG: [ENSURE_TRACKING] Events no invent√°rio: {[os.path.basename(e) for e in events_no_inventario]}")
        
        # Obter ordem cronol√≥gica
        chronological_order = self._get_chronological_actions_events_order()
        if not chronological_order:
            print(f"DEBUG: [ENSURE_TRACKING] Nenhuma ordem cronol√≥gica encontrada")
            return
        
        # Encontrar primeiro Event na fila cronol√≥gica
        first_event = None
        first_event_position = -1
        for i, entry in enumerate(chronological_order):
            if entry['type'] == 'events':
                first_event = entry['path']
                first_event_position = i
                break
        
        if first_event:
            print(f"DEBUG: [ENSURE_TRACKING] Primeiro Event na fila cronol√≥gica: {os.path.basename(first_event)} (posi√ß√£o {first_event_position})")
            
            # Se o primeiro Event n√£o tem tracking, criar
            if first_event not in self._event_duration_tracking:
                print(f"DEBUG: [ENSURE_TRACKING] PRIMEIRO EVENT SEM TRACKING - CRIANDO ATIVO")
                
                # Obter duration_turns da carta
                from cards_database import get_event_duration
                duration_turns = get_event_duration(first_event)
                current_turn = getattr(self, '_current_turn', 0)
                
                # CORRE√á√ÉO: Verificar se duration_turns √© uma string "variable"
                if duration_turns == "variable":
                    # Para events com dura√ß√£o vari√°vel, n√£o definir expires_turn at√© o dado ser lan√ßado
                    print(f"DEBUG: [ENSURE_TRACKING] Event com dura√ß√£o vari√°vel - expires_turn ser√° definido ap√≥s lan√ßar dado")
                    self._event_start_turns[first_event] = None  # N√£o definir start_turn ainda
                    self._event_duration_tracking[first_event] = {
                        'start_turn': None,  # Ser√° definido quando clicar no ?
                        'duration_turns': duration_turns,
                        'expires_turn': None,  # Ser√° definido ap√≥s o dado
                        'is_active': True  # ATIVO porque √© o primeiro na fila
                    }
                elif isinstance(duration_turns, str):
                    # Tentar converter string para n√∫mero
                    try:
                        duration_turns = int(duration_turns)
                    except (ValueError, TypeError):
                        duration_turns = 3  # Fallback para 3 turnos
                        print(f"DEBUG: [ENSURE_TRACKING] Erro ao converter dura√ß√£o - usando 3 turnos por padr√£o")
                elif duration_turns is None:
                    duration_turns = 3  # Fallback para 3 turnos
                    print(f"DEBUG: [ENSURE_TRACKING] Dura√ß√£o n√£o encontrada - usando 3 turnos por padr√£o")
                
                # Para Events com dura√ß√£o fixa
                if duration_turns != "variable" and duration_turns is not None and isinstance(duration_turns, int):
                    self._event_start_turns[first_event] = current_turn
                    self._event_duration_tracking[first_event] = {
                        'start_turn': current_turn,
                        'duration_turns': duration_turns,
                        'expires_turn': current_turn + duration_turns,
                        'is_active': True  # ATIVO porque √© o primeiro na fila
                    }
                    print(f"DEBUG: [ENSURE_TRACKING] ‚úì TRACKING CRIADO PARA PRIMEIRO EVENT: {os.path.basename(first_event)}")
                    if duration_turns == "variable":
                        print(f"DEBUG: [ENSURE_TRACKING] - start_turn: None (ser√° definido ap√≥s lan√ßar dado)")
                        print(f"DEBUG: [ENSURE_TRACKING] - duration_turns: variable")
                        print(f"DEBUG: [ENSURE_TRACKING] - expires_turn: None (ser√° definido ap√≥s lan√ßar dado)")
                        print(f"DEBUG: [ENSURE_TRACKING] - is_active: True")
                    else:
                        print(f"DEBUG: [ENSURE_TRACKING] - start_turn: {current_turn}")
                        print(f"DEBUG: [ENSURE_TRACKING] - duration_turns: {duration_turns}")
                        print(f"DEBUG: [ENSURE_TRACKING] - expires_turn: {current_turn + duration_turns}")
                        print(f"DEBUG: [ENSURE_TRACKING] - is_active: True")
                else:
                    print(f"DEBUG: [ENSURE_TRACKING] ‚ùå ERRO: N√£o foi poss√≠vel obter duration_turns para {os.path.basename(first_event)}")
            else:
                tracking_data = self._event_duration_tracking[first_event]
                is_active = tracking_data.get('is_active', False)
                print(f"DEBUG: [ENSURE_TRACKING] Primeiro Event tem tracking - is_active: {is_active}")
                
                # Se n√£o est√° ativo, ativar
                if not is_active:
                    print(f"DEBUG: [ENSURE_TRACKING] ATIVANDO PRIMEIRO EVENT QUE ESTAVA INATIVO")
                    tracking_data['is_active'] = True
                    current_turn = getattr(self, '_current_turn', 0)
                    if tracking_data.get('start_turn') is None:
                        tracking_data['start_turn'] = current_turn
                        tracking_data['expires_turn'] = current_turn + tracking_data.get('duration_turns', 2)
                    print(f"DEBUG: [ENSURE_TRACKING] ‚úì PRIMEIRO EVENT ATIVADO: {os.path.basename(first_event)}")
        else:
            print(f"DEBUG: [ENSURE_TRACKING] Nenhum Event na fila cronol√≥gica")
        
        print(f"DEBUG: [ENSURE_TRACKING] === VERIFICA√á√ÉO CONCLU√çDA ===")
        
        # DIAGN√ìSTICO COMPLETO: Verificar todos os Events
        print(f"DEBUG: [ENSURE_TRACKING] === DIAGN√ìSTICO COMPLETO ===")
        for event_path in events_no_inventario:
            if event_path in self._event_duration_tracking:
                tracking = self._event_duration_tracking[event_path]
                print(f"DEBUG: [ENSURE_TRACKING] Event {os.path.basename(event_path)}:")
                print(f"DEBUG: [ENSURE_TRACKING]   - is_active: {tracking.get('is_active', False)}")
                print(f"DEBUG: [ENSURE_TRACKING]   - start_turn: {tracking.get('start_turn')}")
                print(f"DEBUG: [ENSURE_TRACKING]   - duration_turns: {tracking.get('duration_turns')}")
            else:
                print(f"DEBUG: [ENSURE_TRACKING] Event {os.path.basename(event_path)}: SEM TRACKING")

    def test_add_event_to_inventory(self):
        """Teste para reproduzir o problema do Event inativo"""
        print(f"DEBUG: [TEST] === TESTANDO ADI√á√ÉO DE EVENT AO INVENT√ÅRIO ===")
        
        # Simular Event_110.png sendo tirado de uma casa Events
        event_path = "/home/joaorebolo2/netmaster_menu/img/cartas/events/Residential-level/Green/Event_110.png"
        
        # Verificar se o Event existe no invent√°rio antes
        events_antes = self.inventario.get("events", []).copy()
        print(f"DEBUG: [TEST] Events antes: {[os.path.basename(e) for e in events_antes]}")
        
        # Adicionar o Event ao invent√°rio como se fosse tirado de uma casa
        print(f"DEBUG: [TEST] Adicionando Event_110.png ao invent√°rio...")
        self.adicionar_carta_inventario(event_path, "events")
        
        # Verificar estado ap√≥s adi√ß√£o
        events_depois = self.inventario.get("events", []).copy()
        print(f"DEBUG: [TEST] Events depois: {[os.path.basename(e) for e in events_depois]}")
        
        # Verificar tracking
        if hasattr(self, '_event_duration_tracking') and event_path in self._event_duration_tracking:
            tracking = self._event_duration_tracking[event_path]
            print(f"DEBUG: [TEST] Event_110.png tracking:")
            print(f"DEBUG: [TEST]   - is_active: {tracking.get('is_active', False)}")
            print(f"DEBUG: [TEST]   - start_turn: {tracking.get('start_turn')}")
            print(f"DEBUG: [TEST]   - duration_turns: {tracking.get('duration_turns')}")
        else:
            print(f"DEBUG: [TEST] ‚ùå Event_110.png SEM TRACKING")
        
        # Verificar fun√ß√£o get_active_cards_for_type
        cartas_ativas = self.get_active_cards_for_type("events")
        print(f"DEBUG: [TEST] Cartas Events ativas: {len(cartas_ativas)} de {len(events_depois)} total")
        
        # Mostrar o invent√°rio Actions/Events para testar
        print(f"DEBUG: [TEST] Abrindo invent√°rio Actions/Events para verificar...")
        self.show_inventory_matrix(["actions", "events"])
        
        print(f"DEBUG: [TEST] === TESTE CONCLU√çDO ===")

    def _is_first_card_in_actions_events_queue(self, carta_path):
        """Verifica se uma carta √© a primeira na fila cronol√≥gica de Actions/Events"""
        if not hasattr(self, '_actions_events_order') or not self._actions_events_order:
            return True  # Se n√£o h√° fila, ser√° a primeira
        
        # CORRE√á√ÉO: Verificar se a carta √© realmente a primeira na ordem cronol√≥gica
        # N√£o apenas se √© a √∫nica carta a ser adicionada
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            return True
        
        # A carta est√° na posi√ß√£o 0 da fila cronol√≥gica?
        first_card_in_queue = chronological_order[0]['path']
        is_first = (carta_path == first_card_in_queue)
        
        print(f"DEBUG: [IS_FIRST_CHECK] Carta: {os.path.basename(carta_path)}, √â primeira na fila? {is_first}")
        if chronological_order:
            print(f"DEBUG: [IS_FIRST_CHECK] Primeira carta na fila: {os.path.basename(first_card_in_queue)}")
        
        return is_first

    def _get_chronological_actions_events_order(self):
        """Obt√©m a ordem cronol√≥gica das cartas Actions/Events respeitando ordem mista de chegada"""
        print(f"DEBUG: [CHRONOLOGICAL] _get_chronological_actions_events_order chamado")
        
        # CORRE√á√ÉO SIMPLIFICADA: Se j√° existe _actions_events_order, apenas verificar consist√™ncia
        if hasattr(self, '_actions_events_order') and self._actions_events_order:
            print(f"DEBUG: [CHRONOLOGICAL] _actions_events_order J√Å EXISTE - verificando consist√™ncia ({len(self._actions_events_order)} cartas)")
            
            # Verificar se h√° cartas no invent√°rio que n√£o est√£o no tracking
            all_actions = self.inventario.get("actions", [])
            all_events = self.inventario.get("events", [])
            all_inventory_cards = all_actions + all_events
            
            # Cartas que est√£o no tracking cronol√≥gico
            tracked_cards = [entry['path'] for entry in self._actions_events_order]
            
            # Encontrar cartas no invent√°rio que n√£o est√£o no tracking
            missing_from_tracking = [carta for carta in all_inventory_cards if carta not in tracked_cards]
            
            if missing_from_tracking:
                print(f"DEBUG: [CHRONOLOGICAL] INCONSIST√äNCIA DETECTADA: {len(missing_from_tracking)} cartas no invent√°rio n√£o est√£o no tracking")
                
                # SOLU√á√ÉO SIMPLES: Adicionar cartas ausentes no FIM da fila (s√£o cartas antigas hard-coded)
                for carta in missing_from_tracking:
                    carta_tipo = 'actions' if carta in all_actions else 'events'
                    print(f"DEBUG: [CHRONOLOGICAL] Carta ausente (hard-coded): {carta_tipo} - {os.path.basename(carta)}")
                    
                    # Adicionar ao FIM da ordem cronol√≥gica com pr√≥ximo timestamp dispon√≠vel
                    next_timestamp = max([entry.get('timestamp', 0) for entry in self._actions_events_order], default=-1) + 1
                    self._actions_events_order.append({
                        'path': carta,
                        'type': carta_tipo,
                        'timestamp': next_timestamp
                    })
                    print(f"DEBUG: [CHRONOLOGICAL] Carta hard-coded adicionada ao FIM: {carta_tipo} - {os.path.basename(carta)} (timestamp: {next_timestamp})")
            
            # Remover cartas √≥rf√£s (que n√£o est√£o mais no invent√°rio)
            orphaned_cards = [entry['path'] for entry in self._actions_events_order if entry['path'] not in all_inventory_cards]
            if orphaned_cards:
                print(f"DEBUG: [CHRONOLOGICAL] √ìRF√ÉOS DETECTADOS: {len(orphaned_cards)} cartas no tracking n√£o est√£o no invent√°rio")
                for carta in orphaned_cards:
                    print(f"DEBUG: [CHRONOLOGICAL] Carta √≥rf√£: {os.path.basename(carta)}")
                
                self._actions_events_order = [entry for entry in self._actions_events_order if entry['path'] in all_inventory_cards]
                print(f"DEBUG: [CHRONOLOGICAL] Cartas √≥rf√£s removidas do tracking")
            
        else:
            print(f"DEBUG: [CHRONOLOGICAL] N√£o existe _actions_events_order - criando a partir dos invent√°rios atuais")
            # Se n√£o h√° tracking temporal, criar assumindo ordem atual como cronol√≥gica
            self._actions_events_order = []
            
            # FALLBACK: Se n√£o h√° tracking, assumir ordem por tipo (Actions depois Events)
            # Mas isto s√≥ acontece na primeira execu√ß√£o
            for carta_path in self.inventario.get("actions", []):
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': 'actions',
                    'timestamp': len(self._actions_events_order)
                })
                print(f"DEBUG: [CHRONOLOGICAL] Action adicionada: {os.path.basename(carta_path)} (timestamp: {len(self._actions_events_order)-1})")
            
            for carta_path in self.inventario.get("events", []):
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': 'events',
                    'timestamp': len(self._actions_events_order)
                })
                print(f"DEBUG: [CHRONOLOGICAL] Event adicionado: {os.path.basename(carta_path)} (timestamp: {len(self._actions_events_order)-1})")
        
        # Ordenar por timestamp para garantir ordem cronol√≥gica correta
        self._actions_events_order.sort(key=lambda x: x.get('timestamp', 0))
        
        print(f"DEBUG: [CHRONOLOGICAL] Ordem cronol√≥gica MISTA final: {[entry['type'] + '-' + os.path.basename(entry['path']) for entry in self._actions_events_order]}")
        print(f"DEBUG: [CHRONOLOGICAL] Timestamps: {[entry.get('timestamp', 0) for entry in self._actions_events_order]}")
        print(f"DEBUG: [MIXED_FIFO] Ordem FIFO mista garantida - Actions e Events podem estar intercalados conforme ordem de chegada")
        
        return self._actions_events_order

    def get_active_cards_for_type(self, carta_tipo):
        """
        Retorna apenas cartas ativas (viradas para cima) para um tipo espec√≠fico.
        Considera o sistema de sequenciamento para Actions/Events.
        """
        try:
            all_cards = self.inventario.get(carta_tipo, [])
            active_cards = []
            
            for carta_path in all_cards:
                is_active = False  # Por padr√£o, assumir que est√° inativa - carta deve provar que merece estar ativa
                
                # Verificar se a carta est√° ativa baseado no tipo
                if carta_tipo == "actions":
                    # CORRE√á√ÉO: Para Actions, usar a mesma l√≥gica de fila cronol√≥gica que is_card_active()
                    # Action s√≥ est√° ativa se √© a primeira na fila cronol√≥gica
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order:
                        first_card = chronological_order[0]
                        is_active = (first_card['path'] == carta_path and first_card['type'] == 'actions')
                        print(f"DEBUG: [get_active_cards_for_type] Action {os.path.basename(carta_path)} na posi√ß√£o 0 da fila? {is_active}")
                    else:
                        is_active = False
                
                elif carta_tipo == "events":
                    # CORRE√á√ÉO: Para Events, usar a mesma l√≥gica de fila cronol√≥gica que is_card_active()
                    # Events s√≥ est√£o ativos se est√£o na posi√ß√£o 0 da fila cronol√≥gica
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order:
                        first_card = chronological_order[0]
                        is_active = (first_card['path'] == carta_path and first_card['type'] == 'events')
                        print(f"DEBUG: [get_active_cards_for_type] Event {os.path.basename(carta_path)} na posi√ß√£o 0 da fila? {is_active}")
                    else:
                        is_active = False
                
                elif carta_tipo == "equipments":
                    # Para equipments, verificar se est√° no active_equipments
                    if hasattr(self, 'active_equipments'):
                        is_active = carta_path in self.active_equipments
                    else:
                        is_active = False
                
                elif carta_tipo == "services":
                    # Para services, verificar se est√° no active_services  
                    if hasattr(self, 'active_services'):
                        is_active = carta_path in self.active_services
                    else:
                        is_active = False
                
                elif carta_tipo in ["activities", "challenges"]:
                    # Activities e challenges que est√£o no carrossel s√£o consideradas ativas
                    if hasattr(self, 'carrossel'):
                        is_active = carta_path in self.carrossel
                    else:
                        is_active = False
                
                elif carta_tipo == "users":
                    # Users cards s√£o sempre ativas/vis√≠veis 
                    is_active = True
                
                if is_active:
                    active_cards.append(carta_path)
            
            if carta_tipo in ["actions", "events"]:
                print(f"DEBUG: [get_active_cards_for_type] Cartas ativas de {carta_tipo}: {len(active_cards)} de {len(all_cards)} total")
                if len(active_cards) < len(all_cards):
                    inactive_cards = [c for c in all_cards if c not in active_cards]
                    print(f"DEBUG: [get_active_cards_for_type] Cartas INATIVAS de {carta_tipo}: {[os.path.basename(c) for c in inactive_cards]}")
            
            return active_cards
            
        except Exception as e:
            print(f"DEBUG: [get_active_cards_for_type] Erro ao obter cartas ativas para {carta_tipo}: {e}")
            return []

    def _activate_pending_cards(self):
        """
        Ativa cartas que estavam pendentes de ativa√ß√£o devido ao sequenciamento.
        Chamada no in√≠cio de cada turno para ativar cartas que estavam esperando.
        """
        print(f"DEBUG: [CARD_SEQUENCING] === ATIVANDO CARTAS PENDENTES ===")
        
        current_turn = getattr(self, '_current_turn', 0)
        cards_activated = 0
        
        # Ativar Events pendentes
        if hasattr(self, '_event_duration_tracking'):
            for carta_path, tracking_data in list(self._event_duration_tracking.items()):
                if tracking_data.get('pending_activation', False):
                    print(f"DEBUG: [CARD_SEQUENCING] Ativando Event pendente: {os.path.basename(carta_path)}")
                    
                    # Verificar se o Event ainda est√° na posi√ß√£o 0 da fila
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order and chronological_order[0]['path'] == carta_path and chronological_order[0]['type'] == 'events':
                        # Event est√° na posi√ß√£o 0, pode ser ativado
                        duration_turns = tracking_data.get('duration_turns')
                        
                        # Para Events com dura√ß√£o fixa, definir start_turn e expires_turn
                        if duration_turns != "variable":
                            self._event_duration_tracking[carta_path].update({
                                'start_turn': current_turn,
                                'expires_turn': current_turn + duration_turns,
                                'is_active': True,
                                'pending_activation': False
                            })
                            print(f"DEBUG: [CARD_SEQUENCING] Event ativado: {os.path.basename(carta_path)} (dura√ß√£o: {duration_turns} turnos)")
                        else:
                            # Para Events com dura√ß√£o vari√°vel, apenas marcar como ativo mas start_turn permanece None
                            self._event_duration_tracking[carta_path].update({
                                'is_active': True,
                                'pending_activation': False
                            })
                            print(f"DEBUG: [CARD_SEQUENCING] Event vari√°vel ativado: {os.path.basename(carta_path)} (aguardando clique no ?)")
                        
                        cards_activated += 1
                    else:
                        print(f"DEBUG: [CARD_SEQUENCING] Event {os.path.basename(carta_path)} n√£o est√° mais na posi√ß√£o 0, mantendo pendente")
        
        # Ativar Actions pendentes
        if hasattr(self, '_actions_pending_activation'):
            for carta_path in list(self._actions_pending_activation.keys()):
                if self._actions_pending_activation[carta_path]:
                    print(f"DEBUG: [CARD_SEQUENCING] Ativando Action pendente: {os.path.basename(carta_path)}")
                    
                    # Verificar se a Action ainda est√° na posi√ß√£o 0 da fila
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order and chronological_order[0]['path'] == carta_path and chronological_order[0]['type'] == 'actions':
                        # Action est√° na posi√ß√£o 0, ativar
                        self._actions_pending_activation[carta_path] = False
                        print(f"DEBUG: [CARD_SEQUENCING] Action ativada: {os.path.basename(carta_path)}")
                        cards_activated += 1
                    else:
                        print(f"DEBUG: [CARD_SEQUENCING] Action {os.path.basename(carta_path)} n√£o est√° mais na posi√ß√£o 0, mantendo pendente")
        
        if cards_activated > 0:
            print(f"DEBUG: [CARD_SEQUENCING] === {cards_activated} CARTAS ATIVADAS ===")
            
            # Atualizar tracking de Events ativos
            self._ensure_active_event_tracking()
        else:
            print(f"DEBUG: [CARD_SEQUENCING] === NENHUMA CARTA PENDENTE PARA ATIVAR ===")

    def _mark_next_actions_as_pending(self):
        """
        Marca pr√≥ximas Actions na fila como pendentes quando uma Action √© removida.
        Isso faz com que a pr√≥xima Action fique inativa at√© o pr√≥ximo turno.
        """
        print(f"DEBUG: [CARD_SEQUENCING] === MARCANDO PR√ìXIMAS ACTIONS COMO PENDENTES ===")
        
        # Obter ordem cronol√≥gica atual
        chronological_order = self._get_chronological_actions_events_order()
        if not chronological_order:
            print(f"DEBUG: [CARD_SEQUENCING] Nenhuma fila cronol√≥gica - nada para marcar como pendente")
            return
        
        # Inicializar tracking de pendentes se n√£o existir
        if not hasattr(self, '_actions_pending_activation'):
            self._actions_pending_activation = {}
        
        # Encontrar pr√≥ximas Actions na fila e marc√°-las como pendentes
        actions_marked = 0
        events_marked = 0
        
        for item in chronological_order:
            if item['type'] == 'actions':
                carta_path = item['path']
                # Verificar se a Action ainda est√° no invent√°rio
                if carta_path in self.inventario.get('actions', []):
                    self._actions_pending_activation[carta_path] = True
                    print(f"DEBUG: [CARD_SEQUENCING] Action marcada como PENDENTE: {os.path.basename(carta_path)}")
                    actions_marked += 1
            
            elif item['type'] == 'events':
                carta_path = item['path']
                # Verificar se o Event ainda est√° no invent√°rio
                if carta_path in self.inventario.get('events', []):
                    # Inicializar tracking de Events se n√£o existir
                    if not hasattr(self, '_event_duration_tracking'):
                        self._event_duration_tracking = {}
                    
                    # Se Event n√£o tem tracking, criar um b√°sico
                    if carta_path not in self._event_duration_tracking:
                        # Obter dados da base de dados
                        event_id = self._extract_event_id_from_path(carta_path)
                        duration_turns = "variable"  # Padr√£o
                        
                        if event_id and hasattr(self, 'card_database') and self.card_database:
                            try:
                                event_data = self.card_database.get_event(event_id)
                                if event_data:
                                    duration_turns = event_data.duration_turns
                            except Exception as e:
                                print(f"DEBUG: [CARD_SEQUENCING] Erro ao obter dados do Event {event_id}: {e}")
                        
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': None,
                            'duration_turns': duration_turns,
                            'expires_turn': None,
                            'is_active': False,
                            'pending_activation': True  # Marcar como pendente
                        }
                        print(f"DEBUG: [CARD_SEQUENCING] Event marcado como PENDENTE: {os.path.basename(carta_path)} (criando tracking)")
                        events_marked += 1
                    else:
                        # Event j√° tem tracking, apenas marcar como pendente
                        self._event_duration_tracking[carta_path]['pending_activation'] = True
                        self._event_duration_tracking[carta_path]['is_active'] = False
                        print(f"DEBUG: [CARD_SEQUENCING] Event marcado como PENDENTE: {os.path.basename(carta_path)} (atualizando tracking)")
                        events_marked += 1
        
        if actions_marked > 0 or events_marked > 0:
            print(f"DEBUG: [CARD_SEQUENCING] === {actions_marked} ACTIONS e {events_marked} EVENTS MARCADOS COMO PENDENTES ===")
        else:
            print(f"DEBUG: [CARD_SEQUENCING] === NENHUMA CARTA PARA MARCAR COMO PENDENTE ===")

    def _ensure_active_event_tracking(self):
        """
        Garante que apenas o Event na posi√ß√£o 0 est√° ativo e contando tempo.
        Ativa o pr√≥ximo Event na fila quando necess√°rio.
        CORRE√á√ÉO: Cria tracking se n√£o existir.
        """
        if not hasattr(self, '_event_duration_tracking'):
            self._event_duration_tracking = {}
            
        cartas_events = self.inventario.get("events", [])
        if not cartas_events:
            print("DEBUG: [ACTIVATE_EVENT] Nenhum Event no invent√°rio")
            return
            
        current_turn = getattr(self, '_current_turn', 0)
        
        # CORRE√á√ÉO: Determinar o Event do topo baseado na ordem cronol√≥gica, n√£o na posi√ß√£o no array
        chronological_order = self._get_chronological_actions_events_order()
        event_do_topo = None
        
    def _ensure_active_event_tracking(self):
        """
        Garante que apenas o Event na posi√ß√£o 0 da fila cronol√≥gica est√° ativo.
        CR√çTICO: Apenas o primeiro item da fila (posi√ß√£o 0) pode estar ativo, e APENAS se for um Event.
        """
        if not hasattr(self, '_event_duration_tracking'):
            self._event_duration_tracking = {}
            
        cartas_events = self.inventario.get("events", [])
        if not cartas_events:
            print("DEBUG: [ACTIVATE_EVENT] Nenhum Event no invent√°rio")
            return
            
        current_turn = getattr(self, '_current_turn', 0)
        
        # Obter ordem cronol√≥gica
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            print("DEBUG: [ACTIVATE_EVENT] [ERROR] Fila cronol√≥gica vazia")
            return
        
        print(f"DEBUG: [ACTIVATE_EVENT] Verificando se o primeiro item da fila √© um Event...")
        print(f"DEBUG: [ACTIVATE_EVENT] Events no invent√°rio: {[os.path.basename(p) for p in cartas_events]}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar APENAS o primeiro item da fila (posi√ß√£o 0)
        first_item = chronological_order[0]
        print(f"DEBUG: [ACTIVATE_EVENT] Primeiro item da fila (posi√ß√£o 0): {first_item['type']}-{os.path.basename(first_item['path'])}")
        
        # Se o primeiro item N√ÉO for um Event, nenhum Event deve estar ativo
        if first_item['type'] != 'events':
            print(f"DEBUG: [ACTIVATE_EVENT] [ERROR] Primeiro item n√£o √© Event - √© {first_item['type']}")
            print("DEBUG: [ACTIVATE_EVENT] [ERROR] Apenas Events na posi√ß√£o 0 podem estar ativos")
            print("DEBUG: [ACTIVATE_EVENT] [ERROR] Desativando qualquer Event ativo...")
            
            # Desativar todos os Events
            for event_path in list(self._event_duration_tracking.keys()):
                if self._event_duration_tracking[event_path].get('is_active', False):
                    self._event_duration_tracking[event_path]['is_active'] = False
                    print(f"DEBUG: [ACTIVATE_EVENT] Event desativado: {os.path.basename(event_path)}")
            
            return
        
        # Se chegou aqui, o primeiro item √â um Event
        event_do_topo = first_item['path']
        
        if event_do_topo not in cartas_events:
            print(f"DEBUG: [ACTIVATE_EVENT] [ERROR] Event do topo n√£o est√° no invent√°rio: {os.path.basename(event_do_topo)}")
            return
        
        print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Event na posi√ß√£o 0 deve estar ativo: {os.path.basename(event_do_topo)}")
        
        # Verificar todos os outros itens na fila e desativar qualquer Event que n√£o seja da posi√ß√£o 0
        for i, item in enumerate(chronological_order[1:], 1):  # Come√ßar do √≠ndice 1
            if item['type'] == 'events' and item['path'] in self._event_duration_tracking:
                if self._event_duration_tracking[item['path']].get('is_active', False):
                    self._event_duration_tracking[item['path']]['is_active'] = False
                    print(f"DEBUG: [ACTIVATE_EVENT] Event desativado na posi√ß√£o {i}: {os.path.basename(item['path'])}")
        
        print(f"DEBUG: [ACTIVATE_EVENT] === ATIVANDO EVENT DO TOPO ===")
        print(f"DEBUG: [ACTIVATE_EVENT] Event do topo: {os.path.basename(event_do_topo)}")
        print(f"DEBUG: [ACTIVATE_EVENT] Turno atual: {current_turn}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar PRIMEIRO se o Event J√Å EXPIROU antes de qualquer a√ß√£o
        # Se o Event j√° existe no tracking, verificar se j√° deveria ter expirado
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            expires_turn = existing_tracking.get('expires_turn')
            
            # Se o Event j√° tem expires_turn definido e J√Å EXPIROU, remov√™-lo automaticamente
            if expires_turn is not None and current_turn >= expires_turn:
                print(f"DEBUG: [ACTIVATE_EVENT] CRITICAL: Event J√Å EXPIROU - removendo automaticamente")
                print(f"DEBUG: [ACTIVATE_EVENT]   Event: {os.path.basename(event_do_topo)}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Turno atual: {current_turn}, Expira no turno: {expires_turn}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Chamando _mostrar_overlay_event_expirado()")
                
                # Chamar o overlay de expira√ß√£o
                self._mostrar_overlay_event_expirado(event_do_topo)
                return  # Sair da fun√ß√£o sem ativar nada
        
        # CORRE√á√ÉO FUNDAMENTAL: Se o Event tem tracking existente, PRESERVAR e n√£o criar emergencial
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Event do topo J√Å TEM tracking existente - PRESERVANDO:")
            print(f"DEBUG: [ACTIVATE_EVENT]   Event: {os.path.basename(event_do_topo)}")
            print(f"DEBUG: [ACTIVATE_EVENT]   start_turn: {existing_tracking.get('start_turn')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   duration_turns: {existing_tracking.get('duration_turns')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   expires_turn: {existing_tracking.get('expires_turn')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   is_active: {existing_tracking.get('is_active')}")
            
            # CORRE√á√ÉO: Se start_turn for None, definir agora (Event finalmente na posi√ß√£o 0 e ativo)
            # EXCETO para Events com dura√ß√£o 'variable' - esses s√≥ definem start_turn quando clicam no ?
            duration = existing_tracking.get('duration_turns')
            if existing_tracking.get('start_turn') is None and duration != "variable":
                print(f"DEBUG: [ACTIVATE_EVENT] [CONFIG] CORRE√á√ÉO: start_turn era None para Event com dura√ß√£o FIXA, definindo para turno atual: {current_turn}")
                self._event_duration_tracking[event_do_topo]['start_turn'] = current_turn
                
                # Se tamb√©m n√£o tem expires_turn e tem dura√ß√£o fixa, calcular agora
                if (existing_tracking.get('expires_turn') is None and 
                    duration is not None and duration != "variable"):
                    expires_turn = current_turn + duration
                    self._event_duration_tracking[event_do_topo]['expires_turn'] = expires_turn
                    print(f"DEBUG: [ACTIVATE_EVENT] [CONFIG] CORRE√á√ÉO: expires_turn calculado: {expires_turn} (start: {current_turn} + duration: {duration})")
            elif existing_tracking.get('start_turn') is None and duration == "variable":
                print(f"DEBUG: [ACTIVATE_EVENT] [WAITING] Event com dura√ß√£o VARIABLE: start_turn permanece None at√© jogador clicar no ?")
                print(f"DEBUG: [ACTIVATE_EVENT] Event ser√° ativado apenas quando o dado for lan√ßado")
            
            # CORRE√á√ÉO CR√çTICA: N√ÉO for√ßar ativa√ß√£o se Event est√° pendente de ativa√ß√£o
            # Verificar se Event est√° marcado como pendente no sistema de sequenciamento
            is_pending_activation = False
            if hasattr(self, '_event_duration_tracking') and event_do_topo in self._event_duration_tracking:
                is_pending_activation = self._event_duration_tracking[event_do_topo].get('pending_activation', False)
            
            # N√ÉO sobrescrever - apenas garantir que est√° ativo se necess√°rio E n√£o pendente
            if not existing_tracking.get('is_active', False) and not is_pending_activation:
                print(f"DEBUG: [ACTIVATE_EVENT] [RELOAD] Ativando Event com tracking preservado")
                self._event_duration_tracking[event_do_topo]['is_active'] = True
            elif is_pending_activation:
                print(f"DEBUG: [ACTIVATE_EVENT] [PAUSE] Event est√° PENDENTE de ativa√ß√£o - n√£o ativar ainda")
                print(f"DEBUG: [ACTIVATE_EVENT] Event ser√° ativado no pr√≥ximo turno pelo sistema de sequenciamento")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Event j√° est√° ativo - nenhuma a√ß√£o necess√°ria")
            
            # Pular para verifica√ß√£o de ativa√ß√£o (n√£o criar tracking emergencial)
        elif event_do_topo not in self._event_duration_tracking:
            print(f"DEBUG: [ACTIVATE_EVENT] [ERROR] Event do topo SEM tracking - criando com turno de ativa√ß√£o...")
            
            # CORRE√á√ÉO CR√çTICA: Ao criar tracking emergencial, usar uma heur√≠stica para determinar
            # quando o Event foi realmente ativado, n√£o apenas o turno atual
            
            # Se estivermos numa interface de navega√ß√£o (turno 6), mas o Event deveria ter sido
            # ativado antes, tentar recuperar o turno original
            
            # Para Event_55.png, se est√° sendo acessado no turno 6 mas deveria ter expirado,
            # √© porque foi ativado anteriormente - usar backup se dispon√≠vel
            start_turn_to_use = current_turn
            
            # Verificar se h√° informa√ß√µes de backup que podem indicar quando foi ativado
            if hasattr(self, 'master') and hasattr(self.master, '_backup_turn_counters'):
                backup = self.master._backup_turn_counters
                event_backup = backup.get('_event_duration_tracking', {})
                
                if event_do_topo in event_backup:
                    original_start = event_backup[event_do_topo].get('start_turn')
                    if original_start is not None:
                        start_turn_to_use = original_start
                        print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Start turn recuperado do backup: {original_start}")
                    else:
                        print(f"DEBUG: [ACTIVATE_EVENT] [WARNING]  Backup encontrado mas sem start_turn v√°lido")
                else:
                    print(f"DEBUG: [ACTIVATE_EVENT] [WARNING]  Event n√£o encontrado no backup - usando turno atual: {current_turn}")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] [WARNING]  Nenhum backup dispon√≠vel - usando turno atual: {current_turn}")
            
            # Determinar dura√ß√£o baseada no nome do arquivo
            duration_turns = None
            if "Event_55.png" in event_do_topo:
                duration_turns = "variable"
                print(f"DEBUG: [ACTIVATE_EVENT] Event_55.png mapeado como dura√ß√£o VARI√ÅVEL")
            elif "Event_14.png" in event_do_topo:
                duration_turns = 1
                print(f"DEBUG: [ACTIVATE_EVENT] Event_14.png mapeado como dura√ß√£o FIXA: 1")
            else:
                # Tentar obter da base de dados
                try:
                    from cards_database import get_event_duration
                    duration_turns = get_event_duration(event_do_topo)
                    print(f"DEBUG: [ACTIVATE_EVENT] Dura√ß√£o obtida da base de dados: {duration_turns}")
                    
                    # CORRE√á√ÉO: Verificar se duration_turns √© uma string "variable"  
                    if duration_turns == "variable":
                        # Manter como "variable" - ser√° tratado abaixo
                        pass
                    elif isinstance(duration_turns, str):
                        # Tentar converter string para n√∫mero
                        try:
                            duration_turns = int(duration_turns)
                        except (ValueError, TypeError):
                            duration_turns = 3  # Fallback para 3 turnos
                            print(f"DEBUG: [ACTIVATE_EVENT] Erro ao converter dura√ß√£o - usando 3 turnos por padr√£o")
                    elif duration_turns is None:
                        duration_turns = 3  # Fallback para 3 turnos
                        print(f"DEBUG: [ACTIVATE_EVENT] Dura√ß√£o n√£o encontrada - usando 3 turnos por padr√£o")
                except Exception as e:
                    print(f"DEBUG: [ACTIVATE_EVENT] ERROR base de dados: {e}")
                    duration_turns = 3  # Fallback padr√£o
                    print(f"DEBUG: [ACTIVATE_EVENT] Usando dura√ß√£o fallback: {duration_turns}")
            
            # Criar tracking com start_turn correto
            if duration_turns == "variable":
                self._event_duration_tracking[event_do_topo] = {
                    'start_turn': start_turn_to_use,
                    'duration_turns': duration_turns,
                    'expires_turn': None,  # Ser√° definido ap√≥s o dado
                    'is_active': False  # Ser√° ativado abaixo
                }
            else:
                self._event_duration_tracking[event_do_topo] = {
                    'start_turn': start_turn_to_use,
                    'duration_turns': duration_turns,
                    'expires_turn': start_turn_to_use + duration_turns,
                    'is_active': False  # Ser√° ativado abaixo
                }
            print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Tracking criado com start_turn: {start_turn_to_use}")

        
        # NOVA L√ìGICA SIMPLIFICADA: Se h√° tracking (preservado ou emergencial), apenas verificar ativa√ß√£o
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            
            # Se n√£o est√° ativo, ativar (sem alterar outros campos se j√° foram definidos)
            if not existing_tracking.get('is_active', False):
                print(f"DEBUG: [ACTIVATE_EVENT] [RELOAD] Ativando Event: {os.path.basename(event_do_topo)}")
                self._event_duration_tracking[event_do_topo]['is_active'] = True
                
                # Apenas sincronizar _event_start_turns se necess√°rio
                start_turn = existing_tracking.get('start_turn')
                if start_turn is not None:
                    self._event_start_turns[event_do_topo] = start_turn
                    print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Event ativado com tracking preservado: start_turn={start_turn}")
                
                # Log do estado final
                print(f"DEBUG: [ACTIVATE_EVENT] Estado final do Event:")
                print(f"DEBUG: [ACTIVATE_EVENT]   start_turn: {existing_tracking.get('start_turn')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   duration_turns: {existing_tracking.get('duration_turns')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   expires_turn: {existing_tracking.get('expires_turn')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   is_active: {existing_tracking.get('is_active')}")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] ‚úì Event j√° est√° ativo - nenhuma a√ß√£o necess√°ria")
        else:
            print(f"DEBUG: [ACTIVATE_EVENT] [ERROR] ERRO: Event n√£o tem tracking ap√≥s verifica√ß√£o")
        
        # Garantir que Events em outras posi√ß√µes permanecem inativos
        for i, carta_path in enumerate(cartas_events[1:], 1):  # Come√ßar do √≠ndice 1
            if carta_path in self._event_duration_tracking:
                if self._event_duration_tracking[carta_path].get('is_active', False) == True:
                    # Desativar Events que n√£o est√£o na posi√ß√£o 0
                    self._event_duration_tracking[carta_path].update({
                        'start_turn': None,
                        'expires_turn': None,
                        'is_active': False
                    })
                    self._event_start_turns[carta_path] = None
                    print(f"DEBUG: [DEACTIVATE_EVENT] Event desativado na posi√ß√£o {i}: {os.path.basename(carta_path)}")

    def _verificar_events_expirados(self):
        """
        Verifica automaticamente Events expirados e remove-os do invent√°rio,
        devolvendo-os √† Store.
        CORRE√á√ÉO: Tamb√©m verifica Events de dura√ß√£o vari√°vel com expires_turn definido.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return
        
        current_turn = getattr(self, '_current_turn', 0)
        
        print(f"DEBUG: [VERIFICAR_EVENTS] === VERIFICA√á√ÉO DE EVENTS EXPIRADOS ===")
        print(f"DEBUG: [VERIFICAR_EVENTS] Turno atual: {current_turn}")
        print(f"DEBUG: [VERIFICAR_EVENTS] Total Events no tracking: {len(self._event_duration_tracking)}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar TODOS os Events no tracking, n√£o s√≥ os ativos
        # porque Events de dura√ß√£o vari√°vel podem ter expires_turn definido mas is_active=False
        for carta_path, event_data in self._event_duration_tracking.items():
            is_active = event_data.get('is_active', False)
            start_turn = event_data.get('start_turn')
            duration_turns = event_data.get('duration_turns')
            expires_turn = event_data.get('expires_turn')
            
            print(f"DEBUG: [VERIFICAR_EVENTS] Event: {os.path.basename(carta_path)}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   is_active: {is_active}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   start_turn: {start_turn}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   duration_turns: {duration_turns}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   expires_turn: {expires_turn}")
            
            # NOVA L√ìGICA: Se expires_turn est√° definido (dado foi lan√ßado), verificar expira√ß√£o
            # independentemente do status is_active
            if expires_turn is not None and start_turn is not None:
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event com expires_turn definido - verificando expira√ß√£o")
                
                if current_turn >= expires_turn:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   [ERROR] Event EXPIROU: turno {current_turn} >= {expires_turn}")
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Chamando overlay de expira√ß√£o...")
                    
                    # Mostrar overlay de expira√ß√£o
                    self._mostrar_overlay_event_expirado(carta_path)
                    return  # Sair ap√≥s mostrar o primeiro overlay (processar um de cada vez)
                else:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ‚úì Event ainda v√°lido at√© turno {expires_turn}")
            
            # L√ìGICA LEGADA: Para Events ativos com dura√ß√£o fixa (n√£o vari√°vel)
            elif is_active and start_turn is not None and duration_turns is not None:
                # CORRE√á√ÉO CR√çTICA: Verificar se duration_turns √© num√©rico antes de somar
                if duration_turns == "variable":
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Event com dura√ß√£o vari√°vel sem expires_turn - aguardando dado")
                    continue
                    
                # Garantir que duration_turns √© um n√∫mero
                try:
                    duration_turns_int = int(duration_turns)
                    calculated_expires_turn = start_turn + duration_turns_int
                except (ValueError, TypeError) as e:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ERRO: duration_turns inv√°lido: {duration_turns} - {e}")
                    continue
                
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event ativo com dura√ß√£o fixa - calculando expira√ß√£o")
                print(f"DEBUG: [VERIFICAR_EVENTS]   Calculated expires_turn: {calculated_expires_turn}")
                
                if current_turn >= calculated_expires_turn:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   [ERROR] Event EXPIROU: turno {current_turn} >= {calculated_expires_turn}")
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Chamando overlay de expira√ß√£o...")
                    
                    # Mostrar overlay de expira√ß√£o
                    self._mostrar_overlay_event_expirado(carta_path)
                    return  # Sair ap√≥s mostrar o primeiro overlay (processar um de cada vez)
                else:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ‚úì Event ainda v√°lido at√© turno {calculated_expires_turn}")
            else:
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event inativo ou sem dados suficientes - ignorando")
        
        print(f"DEBUG: [VERIFICAR_EVENTS] === FIM VERIFICA√á√ÉO - NENHUM EVENT EXPIRADO ===")
        
        # CORRE√á√ÉO: Garantir que o tracking est√° correto AP√ìS verificar expira√ß√µes
        # Isso evita reativar Events que deveriam ter expirado
        self._ensure_active_event_tracking()
        
    def _verificar_events_expirados_automaticamente(self):
        """
        Vers√£o autom√°tica da verifica√ß√£o de Events expirados para o dashboard principal.
        Verifica Events expirados e mostra overlay automaticamente na interface principal.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return False
        
        current_turn = getattr(self, '_current_turn', 0)
        
        print(f"DEBUG: [AUTO_EXPIRY] === VERIFICA√á√ÉO AUTOM√ÅTICA DE EVENTS EXPIRADOS ===")
        print(f"DEBUG: [AUTO_EXPIRY] Turno atual: {current_turn}")
        print(f"DEBUG: [AUTO_EXPIRY] Total Events no tracking: {len(self._event_duration_tracking)}")
        
        # Verificar Events expirados no invent√°rio
        events_expirados = []
        for carta_path in self.inventario.get("events", []):
            if self._is_event_expired(carta_path):
                events_expirados.append({
                    'file': os.path.basename(carta_path),
                    'data': carta_path,
                    'path': carta_path
                })
                print(f"DEBUG: [AUTO_EXPIRY] Event EXPIRADO encontrado: {os.path.basename(carta_path)}")
        
        # Se h√° Events expirados, armazenar para mostrar no overlay
        if events_expirados:
            print(f"DEBUG: [AUTO_EXPIRY] Total de {len(events_expirados)} Events expirados encontrados")
            # Armazenar para mostrar no overlay
            self.events_expirados_para_overlay = events_expirados
            return True  # Retorna True se h√° Events expirados
        
        print(f"DEBUG: [AUTO_EXPIRY] === NENHUM EVENT EXPIRADO ENCONTRADO ===")
        return False  # Retorna False se n√£o h√° Events expirados
    
    def _mostrar_overlay_events_expirados_apos_interface(self):
        """
        Mostra overlay com events expirados ap√≥s a interface estar criada.
        √â chamado via self.after() para garantir que aparece por cima da interface.
        """
        print("DEBUG: === MOSTRAR OVERLAY EVENTS EXPIRADOS AP√ìS INTERFACE ===")
        
        if hasattr(self, 'events_expirados_para_overlay') and self.events_expirados_para_overlay:
            print(f"DEBUG: [EVENTS] Mostrando overlay para {len(self.events_expirados_para_overlay)} events expirados")
            
            # Pegar o primeiro event expirado da lista
            event_expirado = self.events_expirados_para_overlay[0]
            
            # Remover da lista
            self.events_expirados_para_overlay.pop(0)
            
            # Chamar o m√©todo existente para mostrar o overlay
            self._mostrar_overlay_event_expirado(event_expirado['data'])
            
            # Se ainda h√° mais events expirados, agendar para mostrar o pr√≥ximo
            if self.events_expirados_para_overlay:
                print(f"DEBUG: [EVENTS] Agendando pr√≥ximo event expirado em 3 segundos...")
                self.after(3000, self._mostrar_overlay_events_expirados_apos_interface)
        else:
            print("DEBUG: [EVENTS] Nenhum event expirado para mostrar overlay.")

    def _verificar_services_expirados_automaticamente(self):
        """
        Verifica automaticamente se algum Service expirou.
        Verifica tanto Services TEMPORARY (arquivos .txt) quanto Services do invent√°rio.
        √â chamado durante a cria√ß√£o da interface principal e no in√≠cio de cada turno.
        Retorna True se encontrou services expirados para mostrar overlay.
        """
        print("DEBUG: === VERIFICAR SERVICES EXPIRADOS AUTOMATICAMENTE ===")
        
        services_expirados = []
        
        # PARTE 1: Verificar Services TEMPORARY (arquivos .txt)
        player_color_capitalized = self.player_color.capitalize()
        base_dir = detect_player_inventory_base_dir()
        services_folder = os.path.join(base_dir, "Users", "Residential-level", player_color_capitalized, "Services")
        
        if os.path.exists(services_folder):
            service_files = [f for f in os.listdir(services_folder) if f.endswith('.txt')]
            print(f"DEBUG: [SERVICES] Verificando {len(service_files)} services TEMPORARY na pasta {services_folder}")
            
            for service_file in service_files:
                service_path = os.path.join(services_folder, service_file)
                
                try:
                    with open(service_path, 'r') as file:
                        service_data = json.load(file)
                    
                    # S√≥ verificar services do tipo TEMPORARY
                    if service_data.get('type') != 'TEMPORARY':
                        continue
                        
                    print(f"DEBUG: [SERVICES] Verificando service TEMPORARY: {service_file}")
                    
                    # Verificar se ainda tem duracao > 0
                    duracao_restante = service_data.get('duration', 0)
                    
                    if duracao_restante <= 0:
                        print(f"DEBUG: [SERVICES] *** SERVICE TEMPORARY EXPIRADO: {service_file} ***")
                        services_expirados.append({
                            'file': service_file,
                            'data': service_data,
                            'path': service_path,
                            'tipo': 'TEMPORARY'
                        })
                    else:
                        print(f"DEBUG: [SERVICES] Service TEMPORARY ainda ativo: {service_file} (dura√ß√£o: {duracao_restante})")
                        
                except Exception as e:
                    print(f"DEBUG: [SERVICES] Erro ao ler service TEMPORARY {service_file}: {e}")
                    continue
        else:
            print(f"DEBUG: [SERVICES] Pasta {services_folder} n√£o existe - sem Services TEMPORARY para verificar.")
        
        # PARTE 2: Verificar Services do invent√°rio que expiraram
        print(f"DEBUG: [SERVICES] Verificando Services do invent√°rio que expiraram...")
        
        if hasattr(self, 'inventario') and 'services' in self.inventario:
            services_inventario = self.inventario['services']
            print(f"DEBUG: [SERVICES] Verificando {len(services_inventario)} services no invent√°rio")
            
            for service_carta in services_inventario:
                service_nome = os.path.basename(service_carta)
                
                # Usar a mesma l√≥gica do bot√£o Services para verificar expira√ß√£o
                if self._is_service_expired(service_carta):
                    print(f"DEBUG: [SERVICES] *** SERVICE INVENT√ÅRIO EXPIRADO: {service_nome} ***")
                    services_expirados.append({
                        'file': service_nome,
                        'data': {'service_id': service_nome.replace('.png', '')},
                        'path': service_carta,
                        'tipo': 'INVENTARIO'
                    })
                else:
                    print(f"DEBUG: [SERVICES] Service invent√°rio ainda ativo: {service_nome}")
        else:
            print("DEBUG: [SERVICES] Nenhum service no invent√°rio para verificar.")
        
        # PARTE 3: Verificar Data Volume Services que expiraram por falta de pacotes
        print(f"DEBUG: [SERVICES] Verificando Data Volume Services com overlays pendentes...")
        
        if hasattr(self, '_pending_data_volume_expiry_overlays') and self._pending_data_volume_expiry_overlays:
            print(f"DEBUG: [SERVICES] Encontrados {len(self._pending_data_volume_expiry_overlays)} Data Volume services com overlays pendentes")
            
            for service_carta in self._pending_data_volume_expiry_overlays[:]:  # C√≥pia para evitar modifica√ß√£o durante itera√ß√£o
                service_nome = os.path.basename(service_carta)
                print(f"DEBUG: [SERVICES] *** DATA VOLUME SERVICE EXPIRADO: {service_nome} ***")
                
                services_expirados.append({
                    'file': service_nome,
                    'data': {'service_id': service_nome.replace('.png', '')},
                    'path': service_carta,
                    'tipo': 'DATA_VOLUME'
                })
                
                # Remover da lista de overlays pendentes ap√≥s processamento
                self._pending_data_volume_expiry_overlays.remove(service_carta)
        else:
            print("DEBUG: [SERVICES] Nenhum Data Volume service com overlay pendente.")
        
        if services_expirados:
            print(f"DEBUG: [SERVICES] === TOTAL DE SERVICES EXPIRADOS: {len(services_expirados)} ===")
            # Armazenar para mostrar no overlay
            self.services_expirados_para_overlay = services_expirados
            return True
        else:
            print("DEBUG: [SERVICES] Nenhum service expirado encontrado.")
            return False

    def _mostrar_overlay_services_expirados_apos_interface(self):
        """
        Mostra overlay com services expirados ap√≥s a interface principal estar criada.
        √â chamado via self.after() para garantir que aparece por cima da interface.
        """
        print("DEBUG: === MOSTRAR OVERLAY SERVICES EXPIRADOS AP√ìS INTERFACE ===")
        
        if hasattr(self, 'services_expirados_para_overlay') and self.services_expirados_para_overlay:
            print(f"DEBUG: [SERVICES] Mostrando overlay para {len(self.services_expirados_para_overlay)} services expirados")
            
            # Pegar o primeiro service expirado da lista
            service_expirado = self.services_expirados_para_overlay[0]
            
            # Remover da lista
            self.services_expirados_para_overlay.pop(0)
            
            # Construir o caminho da carta Service usando o service_id
            service_data = service_expirado['data']
            service_tipo = service_expirado.get('tipo', 'TEMPORARY')
            
            if service_tipo == 'TEMPORARY':
                # Service TEMPORARY - usar service_id dos dados do arquivo
                service_id = service_data.get('service_id', '')
                if service_id:
                    player_color_capitalized = self.player_color.capitalize()
                    cartas_base_dir = detect_cartas_base_dir()
                    carta_path = os.path.join(cartas_base_dir, "services", "Residential-level", player_color_capitalized, f"{service_id}.png")
                    print(f"DEBUG: [SERVICES] Mostrando overlay para service TEMPORARY: {carta_path}")
                    self._mostrar_overlay_service_expirado(carta_path)
                else:
                    print(f"DEBUG: [SERVICES] ERRO: service_id n√£o encontrado em service TEMPORARY: {service_data}")
            
            elif service_tipo == 'INVENTARIO':
                # Service do invent√°rio - usar o caminho direto
                carta_path = service_expirado['path']
                print(f"DEBUG: [SERVICES] Mostrando overlay para service INVENT√ÅRIO: {carta_path}")
                self._mostrar_overlay_service_expirado(carta_path)
            
            elif service_tipo == 'DATA_VOLUME':
                # Service Data Volume expirado - usar o caminho direto
                carta_path = service_expirado['path']
                print(f"DEBUG: [SERVICES] Mostrando overlay para service DATA VOLUME expirado: {carta_path}")
                self._mostrar_overlay_service_expirado_data_volume(carta_path)
            
            else:
                print(f"DEBUG: [SERVICES] ERRO: Tipo de service desconhecido: {service_tipo}")
            
            # Se ainda h√° mais services expirados, agendar para mostrar o pr√≥ximo
            if self.services_expirados_para_overlay:
                print(f"DEBUG: [SERVICES] Agendando pr√≥ximo service expirado em 3 segundos...")
                self.after(3000, self._mostrar_overlay_services_expirados_apos_interface)
        else:
            print("DEBUG: [SERVICES] Nenhum service expirado para mostrar overlay.")

    def _has_active_temporary_services(self):
        """
        Verifica se h√° Services TEMPORARY ativos (n√£o expirados).
        Retorna True se houver pelo menos um Service TEMPORARY ativo.
        Usa o sistema de tracking em mem√≥ria em vez de arquivos .txt.
        CORRE√á√ÉO: Service s√≥ √© considerado ativo se estiver no tracking de ativa√ß√£o.
        """
        try:
            print("DEBUG: [TEMPORARY_CHECK] Verificando Services TEMPORARY ativos usando tracking em mem√≥ria")
            
            # Verificar Services no invent√°rio que s√£o TEMPORARY e n√£o expirados
            services_inventory = self.inventario.get("services", [])
            print(f"DEBUG: [TEMPORARY_CHECK] Verificando {len(services_inventory)} services no invent√°rio")
            
            for service_path in services_inventory:
                try:
                    # Verificar se √© TEMPORARY usando a database
                    if hasattr(self, 'card_database') and self.card_database:
                        service_id = self._map_file_to_card_id(service_path, "services")
                        service_data = self.card_database.get_service(service_id)
                        
                        if service_data and service_data.service_type.value == 'temporary':
                            # CORRE√á√ÉO: Service TEMPORARY s√≥ √© ativo se estiver no tracking
                            # Verificar se est√° no tracking de ativa√ß√£o (foi realmente ativado)
                            is_in_tracking = (service_path in self._service_duration_tracking or 
                                            service_path in self._service_real_activation_turns)
                            
                            if is_in_tracking:
                                # Verificar se n√£o expirou usando a fun√ß√£o existente
                                if not self._is_service_expired(service_path):
                                    print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY ativo encontrado: {os.path.basename(service_path)}")
                                    return True
                                else:
                                    print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY expirado: {os.path.basename(service_path)}")
                            else:
                                print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY n√£o ativado (sem tracking): {os.path.basename(service_path)}")
                        else:
                            print(f"DEBUG: [TEMPORARY_CHECK] Service n√£o √© TEMPORARY: {os.path.basename(service_path)}")
                            
                except Exception as e:
                    print(f"DEBUG: [TEMPORARY_CHECK] Erro ao verificar service {os.path.basename(service_path)}: {e}")
                    continue
                    
            print("DEBUG: [TEMPORARY_CHECK] Nenhum Service TEMPORARY ativo encontrado")
            return False
                
        except Exception as e:
            print(f"DEBUG: [TEMPORARY_CHECK] Erro ao verificar Services TEMPORARY: {e}")
            return False

    def _has_active_data_volume_services_with_packets(self):
        """
        Verifica se h√° Services DATA_VOLUME ativos com pacotes restantes.
        Retorna True se houver pelo menos um Service DATA_VOLUME ativo com pacotes > 0.
        """
        try:
            print("DEBUG: [DATA_VOLUME_CHECK] Verificando Data Volume services com pacotes")
            
            # Verificar services ativos que t√™m tracking de Data Volume
            if hasattr(self, '_service_data_volume_tracking'):
                for service_path, tracking_data in self._service_data_volume_tracking.items():
                    # S√≥ considerar services que est√£o realmente ativos
                    if service_path in self.active_services:
                        packets_remaining = tracking_data.get('packets_remaining', 0)
                        
                        if packets_remaining > 0:
                            print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service ativo com pacotes: {os.path.basename(service_path)} ({packets_remaining} pacotes)")
                            return True
                        else:
                            print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service sem pacotes: {os.path.basename(service_path)}")
                    else:
                        print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service n√£o ativo: {os.path.basename(service_path)}")
            
            print("DEBUG: [DATA_VOLUME_CHECK] Nenhum Data Volume service ativo com pacotes")
            return False
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME_CHECK] Erro ao verificar Data Volume services: {e}")
            return False

    def _has_active_bandwidth_services(self):
        """
        Verifica se h√° Services BANDWIDTH ativos.
        Retorna True se houver pelo menos um Service BANDWIDTH ativo.
        Service s√≥ √© considerado ativo se estiver no tracking de ativa√ß√£o.
        """
        try:
            print("DEBUG: [BANDWIDTH_CHECK] Verificando Services BANDWIDTH ativos usando tracking em mem√≥ria")
            
            # Verificar Services no invent√°rio que s√£o BANDWIDTH e est√£o ativos
            services_inventory = self.inventario.get("services", [])
            print(f"DEBUG: [BANDWIDTH_CHECK] Verificando {len(services_inventory)} services no invent√°rio")
            
            for service_path in services_inventory:
                try:
                    # Verificar se √© BANDWIDTH usando a database
                    if hasattr(self, 'card_database') and self.card_database:
                        service_id = self._map_file_to_card_id(service_path, "services")
                        service_data = self.card_database.get_service(service_id)
                        
                        if service_data and service_data.service_type.value == 'bandwidth':
                            # Service BANDWIDTH s√≥ √© ativo se estiver no tracking ou lista de Services ativos
                            is_in_active_list = service_path in self.active_services
                            is_in_tracking = (service_path in self._service_duration_tracking or 
                                            service_path in self._service_real_activation_turns)
                            
                            if is_in_active_list or is_in_tracking:
                                print(f"DEBUG: [BANDWIDTH_CHECK] Service BANDWIDTH ativo encontrado: {os.path.basename(service_path)}")
                                return True
                            else:
                                print(f"DEBUG: [BANDWIDTH_CHECK] Service BANDWIDTH n√£o ativado: {os.path.basename(service_path)}")
                        else:
                            print(f"DEBUG: [BANDWIDTH_CHECK] Service n√£o √© BANDWIDTH: {os.path.basename(service_path)}")
                            
                except Exception as e:
                    print(f"DEBUG: [BANDWIDTH_CHECK] Erro ao verificar service {os.path.basename(service_path)}: {e}")
                    continue
                    
            print("DEBUG: [BANDWIDTH_CHECK] Nenhum Service BANDWIDTH ativo encontrado")
            return False
                
        except Exception as e:
            print(f"DEBUG: [BANDWIDTH_CHECK] Erro ao verificar Services BANDWIDTH: {e}")
            return False

    def _show_bandwidth_error_overlay(self, tipos, page):
        """Mostra overlay de erro BANDWIDTH sequencial (substitui o overlay de ativa√ß√£o) mantendo carta User de fundo"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Criando overlay sequencial de erro BANDWIDTH")
        
        # MANTER A CARTA USER DE FUNDO - remover apenas os widgets do overlay de ativa√ß√£o
        widgets_to_remove = []
        carta_user_label = None
        
        # Encontrar e preservar o Label da carta User
        for widget in self.winfo_children():
            if isinstance(widget, tk.Label) and hasattr(widget, 'image'):
                # Este √© provavelmente o Label da carta User - preservar
                carta_user_label = widget
                print(f"DEBUG: [BANDWIDTH_ERROR] Carta User preservada: {widget}")
            else:
                # Remover os outros widgets (Frame do overlay de ativa√ß√£o, bot√µes, etc.)
                widgets_to_remove.append(widget)
        
        # Remover apenas os widgets que n√£o s√£o a carta
        for widget in widgets_to_remove:
            widget.destroy()
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Carta User mantida de fundo, overlay de ativa√ß√£o removido")
        
        # Frame para a dialog de erro (centro da tela) - igual ao overlay de ativa√ß√£o
        error_frame = tk.Frame(self, bg="black")
        error_frame.pack(expand=True)
        
        # T√≠tulo "Activation Denied" vermelho e maior (font 20)
        tk.Label(error_frame, text="Activation Denied", 
                font=("Helvetica", 20, "bold"), fg="red", bg="black").pack(pady=(40, 20))
        
        # Mensagem de erro (branco, centralizada)
        tk.Label(error_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                font=("Helvetica", 16), fg="white", bg="black", justify="center").pack(pady=(0, 10))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(error_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def voltar_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Voltando ao invent√°rio de Users")
            
            # Recriar a TopBar antes de voltar ao invent√°rio
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada ap√≥s erro")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio de Users
            self.show_inventory_matrix(tipos, page)
        
        # Bot√£o OK (verde, width=8, font 14) - igual aos outros overlays
        btn_ok = tk.Button(btns_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=voltar_inventario)
        btn_ok.pack(pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_inventario())
        self.bind('<Escape>', lambda e: voltar_inventario())
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Overlay sequencial criado - carta User permanece de fundo")
        
        # Force update para garantir que est√° vis√≠vel
        self.update_idletasks()
        self.update()

    def _show_bandwidth_required_message_overlay(self):
        """Mostra overlay de erro BANDWIDTH por cima do overlay de ativa√ß√£o existente - vers√£o Raspberry Pi"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Criando overlay modal RASPBERRY PI por cima do overlay de ativa√ß√£o")
        
        # ABORDAGEM RASPBERRY PI: Frame semi-transparente que deixa ver a carta User por baixo
        # Criar um Frame semi-transparente que ocupa toda a tela
        modal_frame = tk.Frame(self, bg="gray20")  # Cinzento escuro semi-transparente
        modal_frame.place(x=0, y=0, relwidth=1, relheight=1)
        
        # Armazenar refer√™ncia para poder fechar depois
        self._bandwidth_error_modal = modal_frame
        
        # Container central para a mensagem de erro (com fundo opaco)
        content_frame = tk.Frame(modal_frame, bg="black", relief="raised", bd=5)
        content_frame.place(relx=0.5, rely=0.5, anchor="center", width=450, height=350)
        
        # Frame interno para o conte√∫do
        inner_frame = tk.Frame(content_frame, bg="black")
        inner_frame.pack(expand=True, fill="both", padx=25, pady=25)
        
        # T√≠tulo "Activation Denied" vermelho e maior (font 20)
        title_label = tk.Label(inner_frame, text="Activation Denied", 
                              font=("Helvetica", 20, "bold"), fg="red", bg="black")
        title_label.pack(pady=(20, 15))
        
        # Mensagem de erro (branco, centralizada)
        message_label = tk.Label(inner_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                                font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_label.pack(pady=(0, 20))
        
        # Frame para o bot√£o
        btn_frame = tk.Frame(inner_frame, bg="black")
        btn_frame.pack(pady=15)
        
        def voltar_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Fechando modal e voltando ao invent√°rio de Users")
            
            # Fechar o modal
            if hasattr(self, '_bandwidth_error_modal') and self._bandwidth_error_modal:
                self._bandwidth_error_modal.destroy()
                delattr(self, '_bandwidth_error_modal')
            
            # Recriar a TopBar antes de voltar ao invent√°rio (como outras fun√ß√µes fazem)
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada ap√≥s erro BANDWIDTH")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar diretamente para o invent√°rio de Users (p√°gina 0)
            self.show_inventory_matrix(['users'], 0)
        
        # Bot√£o OK (verde, width=10, font 14)
        btn_ok = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=10, command=voltar_inventario)
        btn_ok.pack(pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_inventario())
        self.bind('<Escape>', lambda e: voltar_inventario())
        
        # Focar no frame modal
        modal_frame.focus_set()
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Modal RASPBERRY PI criado - Frame semi-transparente permite ver carta User")
        
        # Force update para garantir que est√° vis√≠vel
        modal_frame.update_idletasks()
        modal_frame.update()

    def _show_bandwidth_required_message(self, tipos, page):
        """Mostra mensagem de erro quando o jogador tenta ativar carta User sem ter BANDWIDTH ativo"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Mostrando tela de erro BANDWIDTH - abordagem h√≠brida")
        
        # ABORDAGEM H√çBRIDA: Limpar TODOS os widgets como confirma√ß√£o (garante visibilidade)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Frame para a dialog de erro (centro da tela) - pack(expand=True) para dimensionamento din√¢mico
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo MELHORADO: "Activation Denied" vermelho e maior (font 20)
        tk.Label(confirm_frame, text="Activation Denied", 
                font=("Helvetica", 20, "bold"), fg="red", bg="black").pack(pady=(40, 20))
        
        # Mensagem de erro (branco, centralizada)
        tk.Label(confirm_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                font=("Helvetica", 16), fg="white", bg="black", justify="center").pack(pady=(0, 10))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def voltar_ao_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Voltando ao invent√°rio - recriando TopBar")
            
            # Recriar a TopBar antes de voltar ao invent√°rio (como confirma√ß√£o de ativa√ß√£o)
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada ap√≥s erro")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio
            self.show_inventory_matrix(tipos, page)
        
        # Bot√£o OK (verde, width=8, font 14)
        btn_ok = tk.Button(btns_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=voltar_ao_inventario)
        btn_ok.pack(side="left", padx=20, pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_ao_inventario())
        self.bind('<Escape>', lambda e: voltar_ao_inventario())
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Tela de erro criada com t√≠tulo 'Activation Denied' vermelho font 20")
        
        # Force update para garantir que est√° vis√≠vel
        self.update_idletasks()
        self.update()

    def show_inventory_page(self, carta_tipo):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        screen_width = self.winfo_screenwidth()
        # T√≠tulo
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"),
                         fg="black", bg=self.bar_color)
        title.place(relx=0.5, y=65, anchor="n")

        # Mostra as cartas desse tipo
        cartas = self.inventario.get(carta_tipo, [])
        if cartas:
            carta_path = cartas[-1]  # Mostra a √∫ltima carta tirada
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((180, 260)))
            carta_lbl = tk.Label(self, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.place(relx=0.5, rely=0.4, anchor="center")

            def abrir_fullscreen(event=None):
                self.show_card_fullscreen(carta_path, carta_tipo)
            carta_lbl.bind("<Button-1>", abrir_fullscreen)
        else:
            tk.Label(self, text="Sem cartas!", font=("Helvetica", 16), bg="black", fg="white").place(relx=0.5, rely=0.5, anchor="center")

        # Bot√£o seta para voltar (usando X_button.png como fallback para arrow_left.png)
        try:
            # Tentar carregar arrow_left.png primeiro
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((48, 48)))
        except FileNotFoundError:
            # Fallback para X_button.png se arrow_left.png n√£o existir
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "X_button.png")).resize((48, 48)))
        seta_btn = tk.Button(
            self,
            image=seta_img,
            bg="black",
            borderwidth=0,
            command=lambda: self.show_dice_roll_screen(
                self.player_name,
                self.saldo,
                self.get_session_players_icons(),
                self.screen_width,
                self.screen_height
            )
        )
        seta_btn.image = seta_img  # type: ignore[attr-defined]
        seta_btn.place(x=10, rely=0.9*self.winfo_screenheight(), anchor="sw")

        # Se Next Phase estiver ativo, desabilitar vendas nesta p√°gina
        if getattr(self, '_next_phase_active', False):
            self._disable_inventory_sales()
    def _disable_inventory_sales(self):
        """Desativa bot√µes ou funcionalidades de venda nas p√°ginas de invent√°rio."""
        # Aqui voc√™ pode implementar a l√≥gica para desabilitar/remover bot√µes de venda
        # Exemplo: desabilitar todos os bot√µes de venda se existirem
        for widget in self.winfo_children():
            if isinstance(widget, tk.Button) and getattr(widget, 'is_sell_button', False):
                widget.config(state='disabled')

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((self.screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada na p√°gina de invent√°rio")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png na p√°gina de invent√°rio: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

    def show_card_fullscreen(self, carta_path, carta_tipo):
        print("DEBUG: PlayerDashboard.show_card_fullscreen chamado")
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black")
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

        # Bot√£o X para fechar
        x_img_path = os.path.join(IMG_DIR, "X_button.png")
        x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
        x_btn = tk.Label(self, image=x_img, bg="black", cursor="hand2")
        x_btn.image = x_img  # type: ignore[attr-defined]
        x_btn.place(relx=0.98, rely=0.02, anchor="ne")

        def fechar():
            # Limpa tudo menos a barra superior
            for widget in self.winfo_children():
                if widget == self.topbar_label:
                    continue
                widget.destroy()
            # Redesenha a interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

        x_btn.bind("<Button-1>", lambda e: fechar())

        # Verificar se √© uma carta Event expirada durante Next Phase
        if (carta_tipo == "events" and 
            getattr(self, '_next_phase_active', False) and 
            carta_path in self._event_duration_tracking):
            
            current_turn = getattr(self, '_current_turn', 0)
            event_data = self._event_duration_tracking[carta_path]
            
            # Se a carta expirou (current_turn >= expires_turn)
            if current_turn >= event_data['expires_turn']:
                # Bot√£o certo vermelho para devolver √† Store (mesmo formato que bot√£o de desativa√ß√£o)
                red_check_btn = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def devolver_event_para_store():
                    print(f"DEBUG: Devolvendo Event {carta_path} para a Store")
                    
                    # Remover da lista de Events no invent√°rio
                    if carta_path in self.inventario.get("events", []):
                        self.inventario["events"].remove(carta_path)
                        
                        # Marcar que um Event foi removido para a pr√≥xima carta ficar virada para baixo
                        self._event_recently_removed = True
                        print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
                    
                    # Remover do tracking
                    if carta_path in self._event_duration_tracking:
                        del self._event_duration_tracking[carta_path]
                    if carta_path in self._event_start_turns:
                        del self._event_start_turns[carta_path]
                    
                    # Adicionar de volta √† Store usando Store_v2
                    try:
                        from Store import adicionar_carta_store
                        adicionar_carta_store(carta_path, "events")
                        print(f"DEBUG: Event {carta_path} devolvido √† Store com sucesso")
                    except ImportError:
                        print("DEBUG: Erro - Store_v2 n√£o encontrado")
                    except Exception as e:
                        print(f"DEBUG: Erro ao devolver Event √† Store: {e}")
                    
                    # Fechar fullscreen e voltar ao invent√°rio
                    fechar()
                
                red_check_btn.config(command=devolver_event_para_store)

        # Verificar se √© uma carta Service expirada
        print(f"DEBUG: [FULLSCREEN_SERVICE] Verificando expira√ß√£o para carta tipo '{carta_tipo}' - {os.path.basename(carta_path)}")
        if carta_tipo == "services":
            print(f"DEBUG: [FULLSCREEN_SERVICE] √â uma carta Service - verificando se est√° expirada...")
            is_expired = self._is_service_expired(carta_path)
            print(f"DEBUG: [FULLSCREEN_SERVICE] Resultado da verifica√ß√£o de expira√ß√£o: {is_expired}")
            
            if is_expired:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service EXPIRADO - criando bot√£o vermelho de expira√ß√£o")
                # Bot√£o certo vermelho para mostrar overlay de expira√ß√£o (mesmo formato que bot√£o de desativa√ß√£o)
                red_check_btn = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def mostrar_overlay_expiracao():
                    print(f"DEBUG: Mostrando overlay de expira√ß√£o para Service {carta_path}")
                    self._mostrar_overlay_service_expirado(carta_path)
                
                red_check_btn.config(command=mostrar_overlay_expiracao)
                return  # N√£o criar outros bot√µes se o Service expirou
            else:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service N√ÉO expirado - continuando com l√≥gica normal")

    # ===============================
    # SISTEMA DE GEST√ÉO DE PACOTES
    # ===============================
    
    def _preservar_valores_atuais_barras(self):
        """
        CORRE√á√ÉO CR√çTICA: Preserva os valores atuais das barras de progresso
        antes de iniciar o Final Phase. Este m√©todo preserva os valores
        espec√≠ficos de cada carta individual, n√£o apenas da carta selecionada.
        """
        print("DEBUG: ===== PRESERVANDO VALORES ATUAIS DAS BARRAS =====")
        
        if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
            print("DEBUG: WARNING: Barras de progresso n√£o encontradas para preserva√ß√£o")
            return
        
        if not hasattr(self, 'card_stats'):
            print("DEBUG: WARNING: card_stats n√£o existe, criando...")
            self.card_stats = [
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
            ]
        
        # CORRE√á√ÉO CR√çTICA: Preservar valores √∫nicos para cada carta ativa
        print("DEBUG: INICIANDO preserva√ß√£o individual de cada carta...")
        
        try:
            # ETAPA 1: Capturar valores da carta atualmente selecionada/vis√≠vel
            carta_selecionada_idx = getattr(self, 'selected_carousel_index', None)
            
            if carta_selecionada_idx is not None:
                # CORRE√á√ÉO PROBLEMA 1: Verificar se barras est√£o v√°lidas antes de capturar
                try:
                    to_send_selecionada = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_selecionada = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_selecionada = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # CORRE√á√ÉO PROBLEMA 1: Se valores s√£o zeros no primeiro turno, obter da base de dados
                    if to_send_selecionada == 0 and rxd_selecionada == 0 and lost_selecionada == 0:
                        carta_path = self.cards[carta_selecionada_idx]
                        message_size = self._get_card_message_size_from_database(carta_path)
                        to_send_selecionada = message_size
                        print(f"DEBUG: CORRE√á√ÉO PROBLEMA 1 - Carta {carta_selecionada_idx} valores zero detectados")
                        print(f"DEBUG: Usando message_size da base de dados: {message_size}")
                    
                    # Preservar para a carta selecionada
                    if carta_selecionada_idx < len(self.card_stats):
                        self.card_stats[carta_selecionada_idx] = {
                            "To send": to_send_selecionada,
                            "Rxd": rxd_selecionada,
                            "Lost": lost_selecionada
                        }
                        print(f"DEBUG: SUCCESS: Carta selecionada {carta_selecionada_idx} preservada:")
                        print(f"DEBUG:   To send: {to_send_selecionada}, Rxd: {rxd_selecionada}, Lost: {lost_selecionada}")
                except Exception as e:
                    print(f"DEBUG: WARNING: Erro ao capturar valores da carta selecionada: {e}")
            
            # ETAPA 2: Para cartas n√£o selecionadas, preservar valores existentes ou calcular padr√µes
            print("DEBUG: Verificando outras cartas do carrossel...")
            
            for i, carta_path in enumerate(self.cards):
                if i < len(self.card_stats):
                    carta_basename = os.path.basename(carta_path)
                    
                    # Pular cartas viradas para baixo
                    if carta_basename.startswith("back_card_"):
                        continue
                    
                    # Se esta carta n√£o √© a selecionada e ainda n√£o tem valores preservados
                    if i != carta_selecionada_idx:
                        stats_atuais = self.card_stats[i]
                        
                        # CORRE√á√ÉO PROBLEMA 1: Se esta carta ainda n√£o tem valores v√°lidos, calcular da base de dados
                        if (stats_atuais["To send"] == 0 and 
                            stats_atuais["Rxd"] == 0 and 
                            stats_atuais["Lost"] == 0):
                            
                            message_size = self._get_card_message_size_from_database(carta_path)
                            
                            # Valores padr√£o: carta n√£o processada ainda
                            self.card_stats[i] = {
                                "To send": message_size,  # CORRE√á√ÉO: Usar message_size correto
                                "Rxd": 0,
                                "Lost": 0
                            }
                            print(f"DEBUG: SUCCESS: Carta {i} inicializada com valores padr√£o da base de dados:")
                            print(f"DEBUG:   To send: {message_size}, Rxd: 0, Lost: 0")
                        else:
                            print(f"DEBUG: SUCCESS: Carta {i} j√° tem valores preservados:")
                            print(f"DEBUG:   To send: {stats_atuais['To send']}, Rxd: {stats_atuais['Rxd']}, Lost: {stats_atuais['Lost']}")
            
            print("DEBUG: ===== PRESERVA√á√ÉO INDIVIDUAL CONCLU√çDA =====")
            print(f"DEBUG: Estado final do card_stats:")
            for i, stats in enumerate(self.card_stats):
                carta_nome = os.path.basename(self.cards[i]) if i < len(self.cards) else "N/A"
                print(f"DEBUG:   Carta {i} ({carta_nome}): {stats}")
                
        except Exception as e:
            print(f"DEBUG: ERROR: Erro ao preservar valores das barras: {e}")
            import traceback
            traceback.print_exc()
    
    def _iniciar_gestao_pacotes(self):
        """Inicia o sistema de gest√£o de pacotes no Final Phase"""
        print("DEBUG: [GEST√ÉO_PACOTES] Iniciando sistema de gest√£o de pacotes")
        
        # Verificar se h√° Services TEMPORARY ativos
        tem_temporary_services = self._has_active_temporary_services()
        print(f"DEBUG: [GEST√ÉO_PACOTES] Services TEMPORARY ativos: {tem_temporary_services}")
        
        # Verificar se h√° Data Volume services com pacotes dispon√≠veis
        tem_data_volume_packets = self._has_active_data_volume_services_with_packets()
        print(f"DEBUG: [GEST√ÉO_PACOTES] Data Volume services com pacotes: {tem_data_volume_packets}")
        
        # DEBUG: Verificar estado do tracking de Challenges antes de iniciar gest√£o
        self._debug_challenge_tracking_state()
        
        # Encontrar cartas ativas no carrossel
        cartas_ativas = self._obter_cartas_ativas_carrossel()
        print(f"DEBUG: [GEST√ÉO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        
        # CORRE√á√ÉO: S√≥ iniciar gest√£o se h√° cartas ativas E (Services TEMPORARY ativos E Data Volume services com pacotes)
        if not cartas_ativas or not tem_temporary_services or not tem_data_volume_packets:
            if not cartas_ativas:
                print("DEBUG: [GEST√ÉO_PACOTES] Nenhuma carta ativa encontrada no carrossel")
            if not tem_temporary_services:
                print("DEBUG: [GEST√ÉO_PACOTES] Nenhum Service TEMPORARY ativo encontrado")
            if not tem_data_volume_packets:
                print("DEBUG: [GEST√ÉO_PACOTES] Nenhum Data Volume service com pacotes dispon√≠veis")
            
            print("DEBUG: [GEST√ÉO_PACOTES] Gest√£o de pacotes N√ÉO iniciada - condi√ß√µes n√£o atendidas")
            # CORRE√á√ÉO: Garantir que gest√£o de pacotes n√£o √© ativada
            self._final_phase_gestao_ativa = False
            print("DEBUG: [GEST√ÉO_PACOTES] Flag _final_phase_gestao_ativa definida como False")
            # Se n√£o atende as condi√ß√µes, ativar bot√£o End Turn imediatamente
            self._ativar_botao_end_turn()
            return
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] {len(cartas_ativas)} cartas ativas encontradas e pacotes Data Volume dispon√≠veis")
        
        # IMPORTANTE: S√≥ ativar gest√£o se realmente h√° cartas ativas E pacotes dispon√≠veis
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GEST√ÉO_PACOTES] Flag _final_phase_gestao_ativa ativada (cartas e pacotes encontrados)")
        
        # Inicializar vari√°veis de controle
        self._cartas_gestao = cartas_ativas
        self._carta_atual_gestao = 0
        self._valores_pacotes = {}  # Armazenar valores enviados/perdidos por carta
        
        # Inicializar valores para cada carta
        for i, carta_path in enumerate(cartas_ativas):
            self._valores_pacotes[i] = {'enviados': 0, 'perdidos': 0}
        
        # Mostrar destaque na primeira carta e controles de gest√£o
        self._mostrar_gestao_carta_atual()
        
        # NOVO: Remover destaques da cor do jogador e bloquear intera√ß√µes
        self._bloquear_interacoes_carrossel()
    
    def _bloquear_interacoes_carrossel(self):
        """Remove destaques da cor do jogador e bloqueia cliques durante Final Phase"""
        print("DEBUG: [GEST√ÉO_PACOTES] Bloqueando intera√ß√µes do carrossel")
        
        # CORRE√á√ÉO 1: Garantir que o destaque roxo seja preservado
        # Verificar qual carta tem destaque roxo antes de remover outros destaques
        carta_roxo_posicao = getattr(self, '_carta_destacada_posicao', None)
        print(f"DEBUG: [GEST√ÉO_PACOTES] Preservando destaque roxo na posi√ß√£o: {carta_roxo_posicao}")
        
        # Remover TODOS os destaques da cor do jogador das cartas
        # EXCETO a carta que tem destaque roxo (carta de gest√£o atual)
        if hasattr(self, 'card_labels') and self.card_labels:
            for i, lbl in enumerate(self.card_labels):
                if lbl and lbl.winfo_exists():
                    # Verificar se esta carta √© a que tem destaque roxo
                    carta_tem_destaque_roxo = (carta_roxo_posicao is not None and i == carta_roxo_posicao)
                    
                    if not carta_tem_destaque_roxo:
                        # Remover TODOS os tipos de destaque da cor do jogador
                        lbl.config(
                            highlightthickness=0,
                            highlightbackground="black",
                            highlightcolor="black",
                            bg="black",
                            borderwidth=0,
                            relief="flat"
                        )
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Destaque removido da carta posi√ß√£o {i}")
                    else:
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Preservando destaque roxo na carta posi√ß√£o {i}")
        
        # Tamb√©m for√ßar atualiza√ß√£o dos destaques atrav√©s da fun√ß√£o normal
        # que agora j√° considera o Final Phase
        self._update_carousel_selection_highlights()
        
        # Marcar que estamos em modo Final Phase (para bloquear cliques)
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GEST√ÉO_PACOTES] Intera√ß√µes do carrossel bloqueadas")
    
    def _desbloquear_interacoes_carrossel(self):
        """Restaura o comportamento normal do carrossel ap√≥s Final Phase"""
        print("DEBUG: [GEST√ÉO_PACOTES] Desbloqueando intera√ß√µes do carrossel")
        
        # Desmarcar flag de Final Phase
        self._final_phase_gestao_ativa = False
        
        # Remover destaque roxo se existir
        if hasattr(self, '_carta_destacada_posicao'):
            delattr(self, '_carta_destacada_posicao')
        
        # Restaurar destaques normais das cartas se necess√°rio
        # (Ser√° feito automaticamente quando o usu√°rio navegar no carrossel)
        
        print("DEBUG: [GEST√ÉO_PACOTES] Intera√ß√µes do carrossel desbloqueadas")
    
    def _restaurar_controles_gestao_apos_fullscreen(self, carta_destacada_posicao):
        """Restaura os controles de gest√£o ap√≥s voltar do fullscreen"""
        print(f"DEBUG: [FULLSCREEN] Restaurando controles de gest√£o ap√≥s fullscreen")
        
        # Verificar se ainda estamos em gest√£o ativa
        if not getattr(self, '_final_phase_gestao_ativa', False):
            print(f"DEBUG: [FULLSCREEN] Gest√£o n√£o est√° mais ativa - n√£o restaurar controles")
            return
        
        # Verificar se temos dados v√°lidos
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [FULLSCREEN] Dados de gest√£o inv√°lidos - n√£o restaurar controles")
            return
        
        # Restaurar destaque roxo na posi√ß√£o correta
        if carta_destacada_posicao is not None:
            print(f"DEBUG: [FULLSCREEN] Restaurando destaque roxo na posi√ß√£o {carta_destacada_posicao}")
            self._adicionar_destaque_roxo(carta_destacada_posicao)
        else:
            # Se n√£o temos posi√ß√£o preservada, usar carta atual da gest√£o
            print(f"DEBUG: [FULLSCREEN] Usando carta atual da gest√£o para destaque")
            self._mostrar_gestao_carta_atual()
            return
        
        # NOVO: Restaurar valores das barras de progresso antes de mostrar controles
        self._atualizar_barras_gestao_carta_atual()
        
        # CORRE√á√ÉO PROBLEMA 3: Usar estado preservado dos bot√µes + em vez de verificar estado atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        rate_carta = self._obter_rate_carta(carta_atual)
        
        print(f"DEBUG: [FULLSCREEN] Verificando estado preservado dos bot√µes +")
        
        # Verificar se temos estado preservado dos bot√µes + e seta
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        botao_seta_estado = getattr(self, '_botao_seta_estado_preservado', False)
        print(f"DEBUG: [FULLSCREEN] Estado preservado bot√µes +: {botoes_plus_estado}")
        print(f"DEBUG: [FULLSCREEN] Estado preservado bot√£o seta: {botao_seta_estado}")
        
        # CORRE√á√ÉO CR√çTICA: Usar valores espec√≠ficos dos bot√µes individuais
        btn_rxd_estava_visivel = botoes_plus_estado.get('rxd_visivel', False)
        btn_lost_estava_visivel = botoes_plus_estado.get('lost_visivel', False)
        
        # Se qualquer bot√£o + estava vis√≠vel antes do fullscreen, restaur√°-los especificamente
        if btn_rxd_estava_visivel or btn_lost_estava_visivel:
            print(f"DEBUG: [FULLSCREEN] Bot√µes + estavam vis√≠veis - restaurar controles espec√≠ficos")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Rxd: {btn_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Lost: {btn_lost_estava_visivel}")
            
            # NOVA FUN√á√ÉO: Restaurar apenas os bot√µes espec√≠ficos que estavam vis√≠veis
            self._mostrar_controles_gestao_especificos(rate_carta, 
                                                     mostrar_rxd=btn_rxd_estava_visivel,
                                                     mostrar_lost=btn_lost_estava_visivel)
            print(f"DEBUG: [FULLSCREEN] Bot√µes + espec√≠ficos restaurados")
        else:
            print(f"DEBUG: [FULLSCREEN] Bot√µes + n√£o estavam vis√≠veis - verificar se bot√£o seta estava vis√≠vel")
            # Se bot√£o seta estava vis√≠vel antes do fullscreen, restaur√°-lo
            if botao_seta_estado:
                print(f"DEBUG: [FULLSCREEN] Bot√£o seta estava vis√≠vel - restaurar apenas bot√£o seta")
                self._mostrar_botao_seta()
            else:
                print(f"DEBUG: [FULLSCREEN] Nem bot√µes + nem bot√£o seta estavam vis√≠veis - n√£o restaurar controles")
            
        # Limpar estado preservado ap√≥s usar
        if hasattr(self, '_botoes_plus_estado_preservado'):
            delattr(self, '_botoes_plus_estado_preservado')
        if hasattr(self, '_botao_seta_estado_preservado'):
            delattr(self, '_botao_seta_estado_preservado')
        
        print(f"DEBUG: [FULLSCREEN] Restaura√ß√£o de controles de gest√£o conclu√≠da")
    
    def _obter_cartas_ativas_carrossel(self):
        """Obt√©m lista de cartas ativas (viradas para cima) no carrossel"""
        cartas_ativas = []
        
        # Verificar cada posi√ß√£o do carrossel usando self.cards
        for i in range(len(self.cards)):
            carta_path = self.cards[i]
            
            # Verificar se n√£o √© uma carta virada para baixo (back_card)
            if carta_path and "back_card" not in carta_path:
                carta_basename = os.path.basename(carta_path).lower()
                
                # CORRE√á√ÉO: Para Activities e Challenges no carrossel, considerar ativas se est√£o viradas para cima
                # Para outros tipos de cartas, verificar as listas de cartas ativas
                carta_esta_ativa = False
                
                if "activity" in carta_basename or "challenge" in carta_basename:
                    # Activities e Challenges no carrossel s√£o consideradas ativas se est√£o viradas para cima
                    carta_esta_ativa = True
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Activity/Challenge virada para cima posi√ß√£o {i}: {os.path.basename(carta_path)}")
                else:
                    # Para outros tipos (Users, Equipments, Services), verificar listas de cartas ativas
                    if (carta_path in getattr(self, 'active_users', []) or
                        carta_path in getattr(self, 'active_equipments', []) or 
                        carta_path in getattr(self, 'active_services', []) or
                        carta_path == getattr(self, 'active_challenge', None)):
                        carta_esta_ativa = True
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Carta ativa nas listas posi√ß√£o {i}: {os.path.basename(carta_path)}")
                
                # S√≥ adicionar se estiver ativa E o jogador puder acessar a posi√ß√£o
                if carta_esta_ativa and self._can_access_carousel_position(i):
                    cartas_ativas.append(carta_path)
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Carta ATIVA posi√ß√£o {i}: {os.path.basename(carta_path)}")
                elif carta_esta_ativa:
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Carta ativa mas sem acesso √† posi√ß√£o {i}: {os.path.basename(carta_path)}")
                else:
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Carta na posi√ß√£o {i} n√£o est√° ativa: {os.path.basename(carta_path)}")
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        return cartas_ativas
    
    def _mostrar_gestao_carta_atual(self):
        """Mostra destaque roxo na carta atual e controles de gest√£o"""
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] === INICIANDO _mostrar_gestao_carta_atual ===")
        
        # VERIFICA√á√ÉO ADICIONAL: Se n√£o h√° cartas em gest√£o, finalizar imediatamente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Lista de cartas gest√£o vazia ou inexistente")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Estado atual da gest√£o:")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   _cartas_gestao: {[os.path.basename(c) if c else 'None' for c in self._cartas_gestao]}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar se √≠ndice atual est√° dentro dos limites
        if not hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: _carta_atual_gestao n√£o existia, inicializado como 0")
            
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            # NOVA FUNCIONALIDADE: Todas as cartas foram processadas - enable End Turn
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Todas as cartas processadas - habilitando End Turn")
            print(f"DEBUG: [GEST√ÉO_PACOTES] √çndice atual ({self._carta_atual_gestao}) >= tamanho da lista ({len(self._cartas_gestao)})")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Mostrando gest√£o para carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)}")
        
        # Encontrar posi√ß√£o da carta atual no carrossel
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        posicao_carta = None
        
        # VERIFICA√á√ÉO ADICIONAL: Se a carta atual √© None ou vazia
        if not carta_atual:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Carta atual na gest√£o √© None ou vazia")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICA√á√ÉO CR√çTICA: Se a carta atual √© um back_card, todas as cartas foram processadas
        carta_basename = os.path.basename(carta_atual).lower()
        if carta_basename.startswith("back_card_"):
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Carta atual √© back_card: {carta_basename}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Isto indica que todas as cartas ativas foram removidas")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICA√á√ÉO CR√çTICA ADICIONAL: Se a carta n√£o √© Activity ou Challenge, finalizar
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Carta atual n√£o √© Activity nem Challenge: {carta_basename}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICA√á√ÉO CR√çTICA ADICIONAL: Se carta n√£o existe no carrossel atual, finalizar
        if hasattr(self, 'cards') and carta_atual not in self.cards:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Carta atual n√£o existe no carrossel atual: {carta_basename}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Procurando carta atual no carrossel: {os.path.basename(carta_atual)}")
        
        # NOVA FUNCIONALIDADE: Verificar flags de estado das cartas
        if hasattr(self, 'card_face_up_flags'):
            print(f"DEBUG: [GEST√ÉO_PACOTES] Estados das cartas (flags): {self.card_face_up_flags}")
        
        for i in range(len(self.cards)):
            if self.cards[i] == carta_atual:
                posicao_carta = i
                print(f"DEBUG: [GEST√ÉO_PACOTES] Carta encontrada na posi√ß√£o {i} do carrossel")
                
                # NOVA FUNCIONALIDADE: Verificar se a carta est√° virada para cima usando flags
                if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                    is_face_up = self.card_face_up_flags[i]
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Carta na posi√ß√£o {i} virada para cima: {is_face_up}")
                    
                    if not is_face_up:
                        print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Carta na posi√ß√£o {i} est√° virada para baixo")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Isto indica que a carta foi completada e removida")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Removendo carta inv√°lida da gest√£o e continuando")
                        
                        # Remover carta inv√°lida da lista de gest√£o
                        self._cartas_gestao.remove(carta_atual)
                        
                        # Se n√£o h√° mais cartas, finalizar
                        if not self._cartas_gestao:
                            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o - nenhuma carta v√°lida restante")
                            self._finalizar_gestao_pacotes()
                        else:
                            # Ajustar √≠ndice se necess√°rio e continuar com pr√≥xima carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                self._carta_atual_gestao = 0
                            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Continuando com pr√≥xima carta v√°lida")
                            self._mostrar_gestao_carta_atual()
                        return
                break
        
        if posicao_carta is None:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Carta {os.path.basename(carta_atual)} n√£o encontrada no carrossel")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Removendo carta inv√°lida da gest√£o e continuando")
            
            # Remover carta inv√°lida da lista de gest√£o
            self._cartas_gestao.remove(carta_atual)
            
            # Se n√£o h√° mais cartas, finalizar
            if not self._cartas_gestao:
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o - nenhuma carta v√°lida restante")
                self._finalizar_gestao_pacotes()
                return
            
            # Tentar pr√≥xima carta
            self._mostrar_gestao_carta_atual()
            return
        
        # CORRE√á√ÉO CR√çTICA: Verificar se a carta atual √© uma carta virada para baixo
        if posicao_carta is not None and carta_atual:
            carta_basename = os.path.basename(carta_atual).lower()
            if carta_basename.startswith("back_card_"):
                print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO CR√çTICO: Tentativa de aplicar gest√£o √† carta virada para baixo: {carta_basename}")
                print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Isto indica que todas as cartas ativas foram processadas")
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Finalizando gest√£o de pacotes automaticamente")
                self._finalizar_gestao_pacotes()
                return
        
        # NOVA FUNCIONALIDADE: Garantir que End Turn permanece disabled enquanto h√° cartas para processar
        print(f"DEBUG: [GEST√ÉO_PACOTES] Ainda h√° cartas para processar - mantendo End Turn disabled")
        self._manter_end_turn_disabled()
        
        # Remover destaque anterior
        self._remover_destaque_roxo()
        
        if posicao_carta is not None:
            # CORRE√á√ÉO 1: Adicionar destaque roxo ANTES de qualquer outra opera√ß√£o
            self._adicionar_destaque_roxo(posicao_carta)
            
            # CORRE√á√ÉO CR√çTICA: Ajustar selected_carousel_index para corresponder √† carta com destaque roxo
            # Isso garante que ao voltar do fullscreen, a sele√ß√£o esteja correta
            print(f"DEBUG: [GEST√ÉO_PACOTES] Ajustando selected_carousel_index para posi√ß√£o {posicao_carta}")
            self.selected_carousel_index = posicao_carta
            self.selected_carousel_card = carta_atual
            
            # CORRE√á√ÉO CR√çTICA: For√ßar atualiza√ß√£o dos destaques ap√≥s ajustar √≠ndice
            print(f"DEBUG: [GEST√ÉO_PACOTES] For√ßando atualiza√ß√£o de destaques para carta {posicao_carta}")
            self._update_carousel_selection_highlights()
            
            # Obter dados da carta para determinar rate
            rate_carta = self._obter_rate_carta(carta_atual)
            
            # NOVO: Atualizar barras de progresso com valores salvos da carta atual
            self._atualizar_barras_gestao_carta_atual()
            
            # Mostrar controles de gest√£o
            self._mostrar_controles_gestao(rate_carta)
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Gest√£o configurada para carta {os.path.basename(carta_atual)} na posi√ß√£o {posicao_carta}")
            
            # CORRE√á√ÉO: Bot√£o seta s√≥ aparece quando h√° controles de gest√£o vis√≠veis
            # (ser√° mostrado dentro de _mostrar_controles_gestao se necess√°rio)
    
    def _adicionar_destaque_roxo(self, posicao):
        """Adiciona destaque roxo √† volta da carta especificada"""
        print(f"DEBUG: [GEST√ÉO_PACOTES] Adicionando destaque roxo √† carta posi√ß√£o {posicao}")
        
        # Remover destaque anterior se existir
        self._remover_destaque_roxo()
        
        # Verificar se temos card_labels e se a posi√ß√£o √© v√°lida
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: [GEST√ÉO_PACOTES] card_labels n√£o dispon√≠vel para destaque")
            return
        
        if posicao >= len(self.card_labels):
            print(f"DEBUG: [GEST√ÉO_PACOTES] Posi√ß√£o {posicao} inv√°lida (m√°x: {len(self.card_labels)-1})")
            return
        
        # Obter widget da carta
        carta_widget = self.card_labels[posicao]
        
        if carta_widget and carta_widget.winfo_exists():
            # CORRE√á√ÉO CR√çTICA: Aplicar destaque roxo diretamente
            carta_widget.config(
                bg="#800080",  # Fundo roxo
                highlightbackground="#800080",  # Cor roxa da borda
                highlightcolor="#800080",
                highlightthickness=3  # Espessura da borda
            )
            
            # Guardar refer√™ncia para remo√ß√£o posterior
            self._carta_destacada = carta_widget
            # CORRE√á√ÉO: Guardar tamb√©m a posi√ß√£o para verifica√ß√£o de clique
            self._carta_destacada_posicao = posicao
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Destaque roxo aplicado √† carta {posicao}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Widget configurado: bg='{carta_widget.cget('bg')}', highlightthickness={carta_widget.cget('highlightthickness')}")
        else:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Widget da carta {posicao} n√£o dispon√≠vel")
    
    def _remover_destaque_roxo(self):
        """Remove o destaque roxo atual"""
        print("DEBUG: [GEST√ÉO_PACOTES] === REMOVENDO DESTAQUE ROXO ===")
        
        if hasattr(self, '_carta_destacada') and self._carta_destacada:
            try:
                # Remover destaque roxo da carta
                self._carta_destacada.config(
                    bg="black",  # Voltar ao fundo preto
                    highlightbackground="black",  # Remover borda
                    highlightcolor="black",
                    highlightthickness=0  # Remover espessura da borda
                )
                print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Destaque roxo removido da carta espec√≠fica")
                self._carta_destacada = None
            except Exception as e:
                print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Erro ao remover destaque roxo: {e}")
        
        # CORRE√á√ÉO: Limpar tamb√©m a posi√ß√£o destacada
        if hasattr(self, '_carta_destacada_posicao'):
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Limpando posi√ß√£o destacada: {self._carta_destacada_posicao}")
            self._carta_destacada_posicao = None
        
        # Limpar frame_destaque se ainda existir (fallback)
        if hasattr(self, '_frame_destaque') and self._frame_destaque:
            try:
                self._frame_destaque.destroy()
                self._frame_destaque = None
                print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: frame_destaque removido")
            except:
                pass
        
        # CORRE√á√ÉO ADICIONAL: Remover destaque roxo de TODAS as cartas do carrossel
        # para garantir que n√£o fica nenhum destaque residual
        if hasattr(self, 'card_labels') and self.card_labels:
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Limpando destaque roxo de todas as cartas do carrossel")
            for i, lbl in enumerate(self.card_labels):
                if lbl and hasattr(lbl, 'winfo_exists'):
                    try:
                        if lbl.winfo_exists():
                            # Verificar se tem destaque roxo e remover
                            current_bg = lbl.cget('bg')
                            current_thickness = lbl.cget('highlightthickness')
                            
                            if current_bg == "#800080" or current_thickness == 3:
                                lbl.config(
                                    bg="black",
                                    highlightbackground="black",
                                    highlightcolor="black", 
                                    highlightthickness=0
                                )
                                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Destaque roxo removido da carta {i}")
                    except Exception as e:
                        print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: Erro ao limpar carta {i}: {e}")
        
        print("DEBUG: [GEST√ÉO_PACOTES] === DESTAQUE ROXO COMPLETAMENTE REMOVIDO ===")
    
    def _obter_dados_carta(self, carta_path):
        """Obt√©m dados da carta (rate e drops_allowed) da base de dados"""
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print(f"DEBUG: [GEST√ÉO_PACOTES] Database n√£o dispon√≠vel, usando fallback")
                return {
                    'rate': 20, 
                    'rate_options': list(range(21)), 
                    'drops_allowed': True,
                    'message_size': 20,
                    'message_received': 50
                }
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [GEST√ÉO_PACOTES] Obtendo dados para carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair n√∫mero da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        # Obter rate e rate_options
                        if hasattr(activity_card, 'rate'):
                            if isinstance(activity_card.rate, list):
                                rate_max = max(activity_card.rate)
                                rate_options = activity_card.rate
                            else:
                                rate_max = activity_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 20
                            rate_options = list(range(21))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(activity_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se bot√£o Lost deve aparecer
                        penalty_per_packet = getattr(activity_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_received para completion
                        message_size = getattr(activity_card, 'message_size', rate_max)
                        message_received = getattr(activity_card, 'message_received', 0)
                        
                        # CORRE√á√ÉO: Obter par√¢metros de recompensa para Activities
                        reward_per_packet = getattr(activity_card, 'reward_per_packet', 0)
                        min_packets_bonus = getattr(activity_card, 'min_packets_bonus', 0)
                        lost_penalty_per_packet = getattr(activity_card, 'lost_penalty_per_packet', 0)
                        
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Activity rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Activity penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Activity message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Activity reward_per_packet: {reward_per_packet}, min_packets_bonus: {min_packets_bonus}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Activity lost_penalty_per_packet: {lost_penalty_per_packet}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'reward_per_packet': reward_per_packet,
                            'min_packets_bonus': min_packets_bonus,
                            'lost_penalty_per_packet': lost_penalty_per_packet
                        }
            
            elif "challenge" in carta_basename:
                # Extrair n√∫mero do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        # Obter rate e rate_options
                        if hasattr(challenge_card, 'rate'):
                            if isinstance(challenge_card.rate, list):
                                rate_max = max(challenge_card.rate)
                                rate_options = challenge_card.rate
                            else:
                                rate_max = challenge_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 25
                            rate_options = list(range(26))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(challenge_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se bot√£o Lost deve aparecer (Challenges geralmente n√£o t√™m)
                        penalty_per_packet = getattr(challenge_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_bonus para completion
                        message_size = getattr(challenge_card, 'message_size', rate_max)
                        
                        # CORRE√á√ÉO: Obter par√¢metros corretos da base de dados
                        n_turns = getattr(challenge_card, 'n_turns', 0)  # CORRE√á√ÉO: Adicionar n_turns
                        time_limit = getattr(challenge_card, 'time_limit', 0)
                        time_limit_bonus = getattr(challenge_card, 'time_limit_bonus', 0)
                        message_received = getattr(challenge_card, 'message_bonus', 0)  # Field correto
                        reward_per_packet = getattr(challenge_card, 'reward_per_packet', 0)
                        message_received_bonus = getattr(challenge_card, 'message_received_bonus', 0)  # CORRE√á√ÉO: Field correto para JACKPOT
                        
                        # CORRE√á√ÉO: Obter challenge_quit_fee
                        challenge_quit_fee = getattr(challenge_card, 'challenge_quit_fee', 0)
                        
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge n_turns: {n_turns}")  # CORRE√á√ÉO: Debug n_turns
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge time_limit: {time_limit}, time_limit_bonus: {time_limit_bonus}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge reward_per_packet: {reward_per_packet}, message_received_bonus: {message_received_bonus}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge challenge_quit_fee: {challenge_quit_fee}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'n_turns': n_turns,  # CORRE√á√ÉO: Adicionar n_turns ao retorno
                            'time_limit': time_limit,
                            'time_limit_bonus': time_limit_bonus,
                            'reward_per_packet': reward_per_packet,
                            'message_received_bonus': message_received_bonus,
                            'challenge_quit_fee': challenge_quit_fee
                        }
            
            # Fallback baseado no tipo de carta
            if "activity" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Activity_', '').replace('.png', '')
                try:
                    rate_fallback = max(10, int(num) % 30 + 10)
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Fallback Activity rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 50
                    }
                except:
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Erro no fallback Activity, usando 20")
                    return {
                        'rate': 20, 
                        'rate_options': list(range(21)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 20,
                        'message_received': 50
                    }
                    
            elif "challenge" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Challenge_', '').replace('.png', '')
                try:
                    rate_fallback = max(15, int(num) % 40 + 15)
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Fallback Challenge rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 100
                    }
                except:
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Erro no fallback Challenge, usando 25")
                    return {
                        'rate': 25, 
                        'rate_options': list(range(26)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 25,
                        'message_received': 100
                    }
            
            # Fallback final
            print(f"DEBUG: [GEST√ÉO_PACOTES] Fallback final: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }
            
        except Exception as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] Erro ao obter dados da carta: {e}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Fallback de emerg√™ncia: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }

    def _obter_rate_carta(self, carta_path):
        """Obt√©m o rate m√°ximo da carta (Activities/Challenges)"""
        print(f"DEBUG: [GEST√ÉO_PACOTES] === OBTENDO RATE DA CARTA ===")
        print(f"DEBUG: [GEST√ÉO_PACOTES] Carta: {os.path.basename(carta_path)}")
        
        # Usar a nova fun√ß√£o que obt√©m dados completos
        dados = self._obter_dados_carta(carta_path)
        return dados['rate']
    
    def _mostrar_controles_gestao(self, rate_max):
        """Mostra controles + para Rxd e Lost posicionados entre labels e barras"""
        print(f"DEBUG: [GEST√ÉO_PACOTES] Mostrando controles para rate m√°ximo: {rate_max}")
        
        # Limpar controles anteriores
        self._remover_controles_gestao()
        
        # Obter valores atuais
        valores_atuais = self._valores_pacotes[self._carta_atual_gestao]
        
        # Obter dados da carta atual para verificar drops_allowed e penalty_per_packet
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        drops_allowed = dados_carta['drops_allowed']
        penalty_per_packet = dados_carta.get('penalty_per_packet', None)
        rate_options = dados_carta['rate_options']
        
        # CORRE√á√ÉO: Determinar tipo da carta para aplicar l√≥gica espec√≠fica
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Carta: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] Drops allowed: {drops_allowed}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] Penalty per packet: {penalty_per_packet}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] Rate options: {rate_options}")
        
        # CORRE√á√ÉO CR√çTICA: Regras espec√≠ficas para Challenges vs Activities
        if is_challenge:
            # Para Challenges: Lost √© permitido se h√° penalty_per_packet OU drops_allowed=True
            mostrar_botao_lost = drops_allowed or (penalty_per_packet is not None)
            print(f"DEBUG: [GEST√ÉO_PACOTES] Challenge - Mostrar bot√£o Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   - drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
        else:
            # Para Activities: Lost √© permitido se drops_allowed=True OU h√° penalty_per_packet espec√≠fico
            mostrar_botao_lost = drops_allowed or (penalty_per_packet is not None)
            print(f"DEBUG: [GEST√ÉO_PACOTES] Activity - Mostrar bot√£o Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   - drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] DECIS√ÉO FINAL - Mostrar bot√£o Lost: {mostrar_botao_lost}")
        
        # Encontrar as barras de progresso Rxd e Lost
        if not hasattr(self, 'progress_bars'):
            print("DEBUG: [GEST√ÉO_PACOTES] Barras de progresso n√£o encontradas")
            return
        
        # CORRE√á√ÉO CR√çTICA: Remover explicitamente o bot√£o seta quando criamos bot√µes +
        # Isso garante que quando h√° bot√µes +, n√£o h√° bot√£o seta vis√≠vel
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GEST√ÉO_PACOTES] Removendo bot√£o seta antes de criar bot√µes +")
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # CORRE√á√ÉO: Sempre criar bot√µes + independentemente dos valores atuais
        # Os bot√µes + devem aparecer sempre para permitir modifica√ß√µes
        
        # Criar bot√£o + para Rxd (sempre dispon√≠vel)
        if "Rxd" in self.progress_bars:
            rxd_bar = self.progress_bars["Rxd"]
            
            # Posicionar bot√£o + √† esquerda da barra Rxd
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            
            # Posicionar o bot√£o entre o label Rxd e a barra
            # Assumindo que a barra est√° em rely=0.77 e o label um pouco acima
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [GEST√ÉO_PACOTES] Bot√£o + Rxd criado")
        else:
            self._btn_plus_rxd = None
            
        # Criar bot√£o + para Lost baseado na nova regra
        if mostrar_botao_lost and "Lost" in self.progress_bars:
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            
            # Posicionar o bot√£o entre o label Lost e sua barra
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            
            print("DEBUG: [GEST√ÉO_PACOTES] Bot√£o + Lost criado")
        else:
            self._btn_plus_lost = None
            if not mostrar_botao_lost:
                print("DEBUG: [GEST√ÉO_PACOTES] Bot√£o + Lost N√ÉO criado - condi√ß√µes n√£o atendidas (drops_allowed=False e penalty_per_packet=None)")
            else:
                print("DEBUG: [GEST√ÉO_PACOTES] Bot√£o + Lost deveria ter sido criado mas n√£o foi encontrada barra Lost")
        
        # CORRE√á√ÉO: Confirmar que bot√£o seta foi removido quando bot√µes + s√£o criados
        print("DEBUG: [GEST√ÉO_PACOTES] Bot√µes + criados - bot√£o seta removido para evitar conflito")
    
    def _mostrar_controles_gestao_sem_seta(self, rate_max):
        """Vers√£o especial para restaura√ß√£o ap√≥s fullscreen - cria bot√µes + sem mexer no bot√£o seta"""
        print(f"DEBUG: [FULLSCREEN] Criando bot√µes + sem afetar bot√£o seta (rate m√°ximo: {rate_max})")
        
        # IMPORTANTE: N√ÉO chamar _remover_controles_gestao para evitar criar bot√£o seta
        
        # Remover apenas os bot√µes + se existirem (sem afetar seta)
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORRE√á√ÉO: Usar estado preservado para decidir quais bot√µes + recriar
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        print(f"DEBUG: [FULLSCREEN] Estado preservado dos bot√µes +: {botoes_plus_estado}")
        
        # Obter dados da carta atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        rate_options = dados_carta['rate_options']
        
        # Recriar APENAS os bot√µes + que estavam vis√≠veis antes do fullscreen
        if botoes_plus_estado.get('rxd_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando bot√£o + Rxd (estava vis√≠vel)")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [FULLSCREEN] Bot√£o + Rxd recriado")
        else:
            print("DEBUG: [FULLSCREEN] Bot√£o + Rxd N√ÉO recriado - n√£o estava vis√≠vel")
        
        # Recriar bot√£o + Lost apenas se estava vis√≠vel
        if botoes_plus_estado.get('lost_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando bot√£o + Lost (estava vis√≠vel)")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            print("DEBUG: [FULLSCREEN] Bot√£o + Lost recriado")
        else:
            print("DEBUG: [FULLSCREEN] Bot√£o + Lost N√ÉO recriado - n√£o estava vis√≠vel")
        
        # IMPORTANTE: Garantir que o bot√£o seta √© removido se existe
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                self._btn_seta.destroy()
                self._btn_seta = None
                print("DEBUG: [FULLSCREEN] Bot√£o seta removido ap√≥s criar bot√µes +")
            except Exception as e:
                print(f"DEBUG: [FULLSCREEN] Erro ao remover bot√£o seta: {e}")
        
        print("DEBUG: [FULLSCREEN] Bot√µes + recriados baseado no estado preservado")
    
    def _mostrar_controles_gestao_especificos(self, rate_max, mostrar_rxd=False, mostrar_lost=False):
        """Nova fun√ß√£o para restaurar controles espec√≠ficos baseado nas flags salvas"""
        print(f"DEBUG: [ESTADO] Criando controles espec√≠ficos: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
        
        # Remover controles existentes
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
            
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Obter dados da carta atual
        if (hasattr(self, 'cards') and self.cards and 
            self._carta_atual_gestao < len(self.cards)):
            carta_atual = self.cards[self._carta_atual_gestao]
            dados_carta = self._obter_dados_carta(carta_atual)
            rate_options = dados_carta['rate_options']
        else:
            rate_options = [1, 2, 5, 10]  # valores padr√£o
        
        # Criar APENAS os bot√µes solicitados
        if mostrar_rxd:
            print("DEBUG: [ESTADO] Criando bot√£o + Rxd")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
        
        if mostrar_lost:
            print("DEBUG: [ESTADO] Criando bot√£o + Lost")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
        
        print(f"DEBUG: [ESTADO] Controles espec√≠ficos criados: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
        
        # CORRE√á√ÉO CR√çTICA: Se nenhum bot√£o foi criado, verificar se deve finalizar gest√£o
        if not mostrar_rxd and not mostrar_lost:
            print("DEBUG: [ESTADO] ALERTA: Nenhum bot√£o de gest√£o foi criado")
            
            # CORRE√á√ÉO: Usar mesma l√≥gica correta para verificar pr√≥xima carta
            carta_atual_index = getattr(self, '_carta_atual_gestao', 0)
            total_cartas = len(getattr(self, '_cartas_gestao', []))
            proxima_carta_index = carta_atual_index + 1
            
            print(f"DEBUG: [ESTADO] An√°lise de cartas:")
            print(f"DEBUG: [ESTADO]   Carta atual (√≠ndice): {carta_atual_index}")
            print(f"DEBUG: [ESTADO]   Total de cartas: {total_cartas}")
            print(f"DEBUG: [ESTADO]   Pr√≥xima carta (√≠ndice): {proxima_carta_index}")
            
            if proxima_carta_index < total_cartas:
                print("DEBUG: [ESTADO] H√° pr√≥xima carta - criando bot√£o seta para continuar")
                self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
            else:
                print("DEBUG: [ESTADO] SUCCESS: √öltima carta processada - FINALIZANDO GEST√ÉO AUTOMATICAMENTE")
                print("DEBUG: [ESTADO] SUCCESS: Sistema detectou conclus√£o autom√°tica da gest√£o de pacotes")
                # Agendar finaliza√ß√£o para ap√≥s a interface estar pronta
                self.after(100, self._finalizar_gestao_pacotes)
                return
    
    def _verificar_e_mostrar_botao_seta_se_necessario(self):
        """
        Verifica se todos os bot√µes + foram removidos e se deve mostrar o bot√£o seta
        CORRE√á√ÉO: Agora verifica se os widgets existem E est√£o vis√≠veis, n√£o apenas se os atributos existem
        """
        print("DEBUG: [GEST√ÉO_PACOTES] === VERIFICA√á√ÉO AUTOM√ÅTICA DO BOT√ÉO SETA ===")
        
        # CORRE√á√ÉO: Verificar se os bot√µes existem E est√£o vis√≠veis na interface
        def botao_esta_visivel(botao):
            try:
                return (botao is not None and 
                        hasattr(botao, 'winfo_exists') and 
                        botao.winfo_exists() and 
                        hasattr(botao, 'winfo_ismapped') and 
                        botao.winfo_ismapped())
            except (tk.TclError, AttributeError):
                return False
        
        btn_rxd_visivel = (hasattr(self, '_btn_plus_rxd') and 
                          botao_esta_visivel(self._btn_plus_rxd))
        btn_lost_visivel = (hasattr(self, '_btn_plus_lost') and 
                           botao_esta_visivel(self._btn_plus_lost))
        btn_seta_visivel = (hasattr(self, '_btn_seta') and 
                           botao_esta_visivel(self._btn_seta))
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Estado atual dos bot√µes (visibilidade real):")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Bot√£o + Rxd vis√≠vel: {btn_rxd_visivel}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Bot√£o + Lost vis√≠vel: {btn_lost_visivel}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Bot√£o seta vis√≠vel: {btn_seta_visivel}")
        
        # REGRA CORRIGIDA: S√≥ mostrar bot√£o seta se NENHUM bot√£o + est√° vis√≠vel E n√£o h√° bot√£o seta vis√≠vel
        if not btn_rxd_visivel and not btn_lost_visivel and not btn_seta_visivel:
            print("DEBUG: [GEST√ÉO_PACOTES] N√£o h√° bot√µes + vis√≠veis - verificando se h√° mais cartas")
            
            # PROTE√á√ÉO CR√çTICA: Verificar se gest√£o ainda est√° ativa antes de processar
            if not getattr(self, '_final_phase_gestao_ativa', False):
                print("DEBUG: [GEST√ÉO_PACOTES] WARNING: Gest√£o n√£o est√° ativa - ignorando verifica√ß√£o")
                return
            
            # CORRE√á√ÉO: Sempre mostrar bot√£o seta ap√≥s processar carta
            # O usu√°rio deve clicar no bot√£o seta para avan√ßar ou finalizar
            carta_atual_index = getattr(self, '_carta_atual_gestao', 0)
            total_cartas = len(getattr(self, '_cartas_gestao', []))
            proxima_carta_index = carta_atual_index + 1
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] An√°lise de cartas:")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Carta atual (√≠ndice): {carta_atual_index}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Total de cartas: {total_cartas}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Pr√≥xima carta (√≠ndice): {proxima_carta_index}")
            
            # SEMPRE mostrar bot√£o seta - deixar o usu√°rio decidir quando avan√ßar/finalizar
            if proxima_carta_index < total_cartas:
                print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: H√° pr√≥xima carta - criando bot√£o seta para continuar")
            else:
                print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: √öltima carta - criando bot√£o seta para finalizar")
            
            self._mostrar_botao_seta()
        elif btn_seta_visivel:
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Bot√£o seta j√° vis√≠vel - nada a fazer")
        elif btn_rxd_visivel or btn_lost_visivel:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: BLOQUEADO - ainda h√° bot√µes + vis√≠veis na interface")
            # CORRE√á√ÉO CR√çTICA: Se h√° bot√µes + vis√≠veis mas h√° bot√£o seta, remover o bot√£o seta
            if btn_seta_visivel:
                print("DEBUG: [GEST√ÉO_PACOTES] WARNING: Removendo bot√£o seta incorretamente vis√≠vel")
                try:
                    self._btn_seta.destroy()
                    self._btn_seta = None
                except:
                    pass
        else:
            print(f"DEBUG: [GEST√ÉO_PACOTES] NEUTRAL: Estado indeterminado - mantendo como est√°")
        
        print("DEBUG: [GEST√ÉO_PACOTES] === FIM VERIFICA√á√ÉO AUTOM√ÅTICA DO BOT√ÉO SETA ===")
    
    
    
    def _mostrar_overlay_entrada(self, tipo, rate_options):
        """Mostra overlay com bot√µes baseados nas op√ß√µes de rate da carta"""
        print(f"DEBUG: [GEST√ÉO_PACOTES] Mostrando overlay para {tipo} com rate_options {rate_options}")
        
        # PROTE√á√ÉO: Fechar overlay anterior se existir
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            print("DEBUG: [OVERLAY] Fechando overlay anterior antes de criar novo...")
            try:
                self._overlay_entrada.destroy()
            except:
                pass
            self._overlay_entrada = None
        
        # Criar overlay semi-transparente
        self._overlay_entrada = tk.Toplevel(self)
        self._overlay_entrada.title("")
        self._overlay_entrada.configure(bg="black")
        self._overlay_entrada.overrideredirect(True)
        self._overlay_entrada.attributes("-alpha", 0.9)
        self._overlay_entrada.attributes("-topmost", True)  # Garantir que fica por cima
        self._overlay_entrada.transient(self)  # Garantir que √© modal
        
        # Centralizar overlay
        overlay_width = 300
        overlay_height = 200
        x = (self.screen_width - overlay_width) // 2
        y = (self.screen_height - overlay_height) // 2
        self._overlay_entrada.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal do overlay
        main_frame = tk.Frame(self._overlay_entrada, bg="black", highlightbackground="#8B5CF6", highlightthickness=3)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # T√≠tulo
        titulo_tipo = "Rxd" if tipo == "enviados" else "Lost"
        titulo_label = tk.Label(
            main_frame,
            text=f"Inserir {titulo_tipo}:",
            fg="white",
            bg="black",
            font=("Helvetica", 14, "bold")
        )
        titulo_label.pack(pady=10)
        
        # Frame para bot√µes
        botoes_frame = tk.Frame(main_frame, bg="black")
        botoes_frame.pack(pady=20)
        
        # Determinar quais bot√µes mostrar baseado nas op√ß√µes de rate da carta
        # Use os valores espec√≠ficos da base de dados ou o range completo se for uma lista simples
        if isinstance(rate_options, list) and len(rate_options) > 0:
            # Se temos uma lista espec√≠fica de valores, usar essa lista
            botoes_values = sorted(rate_options)
            # CORRE√á√ÉO: Para Lost (perdidos), sempre garantir que 0 est√° inclu√≠do
            if tipo == "perdidos" and 0 not in botoes_values:
                botoes_values = [0] + botoes_values
        else:
            # Fallback: criar range de 0 at√© o valor m√°ximo
            rate_max = max(rate_options) if isinstance(rate_options, list) else rate_options
            botoes_values = list(range(rate_max + 1))
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Valores dos bot√µes: {botoes_values}")
        
        for valor in botoes_values:
            btn = tk.Button(
                botoes_frame,
                text=str(valor),
                bg="#8B5CF6",
                fg="white",
                font=("Helvetica", 12, "bold"),
                width=4,
                height=2,
                command=lambda v=valor: self._aplicar_valor_e_fechar_overlay(tipo, v)
            )
            btn.pack(side="left", padx=5)
        
        # Bot√£o Cancelar
        btn_cancelar = tk.Button(
            main_frame,
            text="Cancelar",
            bg="#666666",
            fg="white",
            font=("Helvetica", 10),
            command=self._fechar_overlay_entrada
        )
        btn_cancelar.pack(pady=10)
    
    def _aplicar_valor_entrada(self, tipo, valor):
        """
        CORRE√á√ÉO: Aplica o valor selecionado sincronizando com card_stats
        E AUTOMATICAMENTE atualiza To send quando Rxd ou Lost mudam
        NOVA FUNCIONALIDADE: Remove o bot√£o + correspondente ap√≥s aplicar valor
        CORRE√á√ÉO PROBLEMA 2: Garantir que valores selecionados s√£o aplicados corretamente
        CORRE√á√ÉO CEN√ÅRIO ZEROS: Registra intera√ß√£o do jogador independente dos valores escolhidos
        """
        print(f"DEBUG: [GEST√ÉO_PACOTES] Aplicando valor {valor} para {tipo}")
        
        # CORRE√á√ÉO CEN√ÅRIO ZEROS: Registar intera√ß√£o do jogador INDEPENDENTE do valor escolhido
        # Isto garante que mesmo clicando 0+0, a carta √© considerada "processada pelo jogador"
        carta_atual_para_interacao = self._get_current_actual_card()
        if carta_atual_para_interacao:
            self._cartas_interagidas_jogador.add(carta_atual_para_interacao)
            print(f"DEBUG: [INTERACAO] Carta {os.path.basename(carta_atual_para_interacao)} registada como interagida pelo jogador")
            print(f"DEBUG: [INTERACAO] Total cartas interagidas: {len(self._cartas_interagidas_jogador)}")
        else:
            print(f"DEBUG: [INTERACAO] WARNING: N√£o foi poss√≠vel registar intera√ß√£o - carta atual n√£o encontrada")
        
        # CORRE√á√ÉO FUNDAMENTAL: Usar carta selecionada diretamente do carrossel
        # Evita problemas de sincroniza√ß√£o ap√≥s restaura√ß√£o de fullscreen
        if not hasattr(self, 'selected_carousel_index') or self.selected_carousel_index is None:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Nenhuma carta selecionada no carrossel!")
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: hasattr(selected_carousel_index): {hasattr(self, 'selected_carousel_index')}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: selected_carousel_index value: {getattr(self, 'selected_carousel_index', 'NOT_SET')}")
            return
        
        posicao_carrossel = self.selected_carousel_index
        
        # CORRE√á√ÉO CR√çTICA: Obter carta_atual diretamente da posi√ß√£o no carrossel, n√£o da vari√°vel cached
        if not hasattr(self, 'cards') or posicao_carrossel >= len(self.cards):
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Posi√ß√£o inv√°lida no carrossel!")
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: posicao_carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: len(cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
            return
        
        carta_atual = self.cards[posicao_carrossel]
        
        # DIAGN√ìSTICO DETALHADO AP√ìS OBTER CARTA
        print(f"DEBUG: [GEST√ÉO_PACOTES] === DIAGN√ìSTICO DETALHADO ===")
        print(f"DEBUG: [GEST√ÉO_PACOTES] posicao_carrossel: {posicao_carrossel}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] carta_atual: {os.path.basename(carta_atual) if carta_atual else 'None'}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] len(self.cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Carta atual obtida do carrossel com sucesso!")
        
        if not carta_atual:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Carta atual √© None!")
            return
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Aplicando valor na posi√ß√£o {posicao_carrossel} do carrossel")
        
        # CORRE√á√ÉO: Obter message_size da base de dados
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # CORRE√á√ÉO: Sincronizar com card_stats usando posi√ß√£o correta do carrossel
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            # Obter valores preservados atuais
            stats_atuais = self.card_stats[posicao_carrossel]
            to_send_anterior = stats_atuais.get('To send', message_size)
            rxd_anterior = stats_atuais.get('Rxd', 0)
            lost_anterior = stats_atuais.get('Lost', 0)
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] Valores anteriores preservados:")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   To send: {to_send_anterior}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Rxd: {rxd_anterior}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Lost: {lost_anterior}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Message size: {message_size}")
            
            # CORRE√á√ÉO PROBLEMA 2: Aplicar o valor selecionado como INCREMENTO
            # O valor selecionado √© ADICIONADO ao valor atual
            if tipo == 'enviados':
                # CORRE√á√ÉO CR√çTICA: Distinguir entre REGISTRAR TENTATIVA e APLICAR VALOR
                # Quando valor=0, registramos a tentativa MAS N√ÉO alteramos o valor efetivo
                if valor > 0:
                    # Valor > 0: Incrementa realmente o Rxd
                    novo_rxd = rxd_anterior + valor
                    self.card_stats[posicao_carrossel]['Rxd'] = novo_rxd
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Rxd incrementado efetivamente: {rxd_anterior} + {valor} = {novo_rxd}")
                    
                    # NOVO: Consumir pacotes dos Data Volume services quando Rxd √© incrementado
                    self._consume_data_volume_packets(valor)
                    
                else:
                    # Valor = 0: N√ÉO altera o valor efetivo, mas registra a tentativa
                    novo_rxd = rxd_anterior  # Mant√©m valor anterior
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Rxd MANTIDO (valor=0): {rxd_anterior} (sem altera√ß√£o)")
                
                novo_lost = lost_anterior  # Lost mant√©m-se igual
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: card_stats[{posicao_carrossel}]['Rxd'] = {novo_rxd}")
                
                # IMPORTANTE: Sempre incrementar contador de processamento (independente do valor)
                # Isto garante que o bot√£o + desaparece ap√≥s ser usado, mesmo com valor 0
                # O contador registra a TENTATIVA do jogador, n√£o o valor efetivo aplicado
                self._increment_processed_this_turn(carta_atual, 'rxd', 1)
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Tentativa de processamento registrada para Rxd (valor selecionado: {valor})")
                
                # NOVA FUNCIONALIDADE: Remover bot√£o + de Rxd ap√≥s aplicar valor
                if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                    try:
                        self._btn_plus_rxd.destroy()
                        self._btn_plus_rxd = None
                        print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Bot√£o + Rxd removido ap√≥s incrementar +{valor}")
                        
                        # CORRE√á√ÉO: Atualizar estado preservado para refletir que bot√£o n√£o est√° mais vis√≠vel
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['rxd_visivel'] = False
                            print("DEBUG: [GEST√ÉO_PACOTES] Estado preservado atualizado: rxd_visivel = False")
                        
                        # CORRE√á√ÉO ADICIONAL: Verificar imediatamente se deve mostrar bot√£o seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: Erro ao remover bot√£o + Rxd: {e}")
                    
            elif tipo == 'perdidos':
                # CORRE√á√ÉO CR√çTICA: Distinguir entre REGISTRAR TENTATIVA e APLICAR VALOR
                # Quando valor=0, registramos a tentativa MAS N√ÉO alteramos o valor efetivo
                novo_rxd = rxd_anterior  # Rxd mant√©m-se igual
                
                if valor > 0:
                    # Valor > 0: Incrementa realmente o Lost
                    novo_lost = lost_anterior + valor
                    self.card_stats[posicao_carrossel]['Lost'] = novo_lost
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Lost incrementado efetivamente: {lost_anterior} + {valor} = {novo_lost}")
                else:
                    # Valor = 0: N√ÉO altera o valor efetivo, mas registra a tentativa
                    novo_lost = lost_anterior  # Mant√©m valor anterior
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Lost MANTIDO (valor=0): {lost_anterior} (sem altera√ß√£o)")
                
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: card_stats[{posicao_carrossel}]['Lost'] = {novo_lost}")
                
                # IMPORTANTE: Sempre incrementar contador de processamento (independente do valor)
                # Isto garante que o bot√£o + desaparece ap√≥s ser usado, mesmo com valor 0
                # O contador registra a TENTATIVA do jogador, n√£o o valor efetivo aplicado
                self._increment_processed_this_turn(carta_atual, 'lost', 1)
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Tentativa de processamento registrada para Lost (valor selecionado: {valor})")
                
                # NOVA FUNCIONALIDADE: Remover bot√£o + de Lost ap√≥s aplicar valor
                if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                    try:
                        self._btn_plus_lost.destroy()
                        self._btn_plus_lost = None
                        print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Bot√£o + Lost removido ap√≥s incrementar +{valor}")
                        
                        # CORRE√á√ÉO: Atualizar estado preservado para refletir que bot√£o n√£o est√° mais vis√≠vel
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['lost_visivel'] = False
                            print("DEBUG: [GEST√ÉO_PACOTES] Estado preservado atualizado: lost_visivel = False")
                        
                        # CORRE√á√ÉO ADICIONAL: Verificar imediatamente se deve mostrar bot√£o seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: Erro ao remover bot√£o + Lost: {e}")
                    
            else:
                novo_rxd = rxd_anterior
                novo_lost = lost_anterior
            
            # CORRE√á√ÉO CR√çTICA: Calcular To send com l√≥gica especial para Activities
            # Para Activities com message_received n√£o None e penalty_per_packet n√£o None:
            # - Lost n√£o decrementa To send (pacotes perdidos s√£o contabilizados separadamente)
            # - Apenas Rxd decrementa To send
            
            # Obter dados da carta para verificar se √© uma Activity especial
            carta_atual = self.cards[posicao_carrossel] if posicao_carrossel < len(self.cards) else None
            dados_carta = self._obter_dados_carta(carta_atual) if carta_atual else None
            
            is_activity_especial = False
            if dados_carta and 'message_received' in dados_carta and 'penalty_per_packet' in dados_carta:
                message_received = dados_carta.get('message_received')
                penalty_per_packet = dados_carta.get('penalty_per_packet')
                if message_received is not None and penalty_per_packet is not None:
                    is_activity_especial = True
                    print(f"DEBUG: [GEST√ÉO_PACOTES] Activity especial detectada: message_received={message_received}, penalty_per_packet={penalty_per_packet}")
            
            if is_activity_especial:
                # Para Activities especiais: apenas Rxd decrementa To send
                novo_to_send = max(message_size - novo_rxd, 0)
                print(f"DEBUG: [GEST√ÉO_PACOTES] L√ìGICA ESPECIAL PARA ACTIVITY:")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   To send = message_size - Rxd (Lost n√£o decrementa)")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   To send = {message_size} - {novo_rxd} = {novo_to_send}")
            else:
                # Para Challenges e Activities normais: tanto Rxd quanto Lost decrementam To send
                novo_to_send = max(message_size - (novo_rxd + novo_lost), 0)
                print(f"DEBUG: [GEST√ÉO_PACOTES] L√ìGICA NORMAL:")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   To send = message_size - (Rxd + Lost)")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   To send = {message_size} - ({novo_rxd} + {novo_lost}) = {novo_to_send}")
            
            # Atualizar To send nos card_stats
            self.card_stats[posicao_carrossel]['To send'] = novo_to_send
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: APLICA√á√ÉO DE VALOR COMPLETA:")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Valor selecionado: {valor}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Aplicado a: {tipo}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   NOVO Rxd total: {novo_rxd}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   NOVO Lost total: {novo_lost}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   NOVO To send: {novo_to_send}")
            if is_activity_especial:
                print(f"DEBUG: [GEST√ÉO_PACOTES]   CORRE√á√ÉO ESPECIAL: Para Activity com message_received/penalty_per_packet, apenas Rxd reduz To send")
            else:
                print(f"DEBUG: [GEST√ÉO_PACOTES]   CORRE√á√ÉO NORMAL: Tanto Lost quanto Rxd reduzem To send")
            
            # CORRE√á√ÉO: Atualizar TODAS as barras visualmente
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Atualizar To send
                if "To send" in self.progress_bars and "To send" in self.progress_labels:
                    self.progress_bars["To send"].config(value=novo_to_send, maximum=message_size)
                    self.progress_labels["To send"].config(text=str(novo_to_send))
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Barra To send atualizada visualmente: {novo_to_send}/{message_size}")
                
                # Atualizar Rxd
                if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                    self.progress_bars["Rxd"].config(value=novo_rxd, maximum=message_size)
                    self.progress_labels["Rxd"].config(text=str(novo_rxd))
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Barra Rxd atualizada visualmente: {novo_rxd}")
                
                # Atualizar Lost
                if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                    self.progress_bars["Lost"].config(value=novo_lost, maximum=message_size)
                    self.progress_labels["Lost"].config(text=str(novo_lost))
                    print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Barra Lost atualizada visualmente: {novo_lost}")
        
        # CORRE√á√ÉO: Sincronizar com card_stats ap√≥s aplicar valores
        try:
            self._sync_card_stats_with_progress_bars()
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: card_stats sincronizado com barras ap√≥s aplicar valor")
        except Exception as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: Erro ao sincronizar card_stats: {e}")
        
        # NOVA CORRE√á√ÉO: Verificar se deve mostrar bot√£o seta ap√≥s remover bot√µes +
        self._verificar_e_mostrar_botao_seta_se_necessario()
        
        # Manter compatibilidade com sistema antigo (se existir)
        if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
        
        # Fechar overlay
        self._fechar_overlay_entrada()
    
    def _fechar_overlay_entrada(self):
        """Fecha o overlay de entrada"""
        try:
            if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
                print("DEBUG: [OVERLAY] Fechando overlay de entrada...")
                self._overlay_entrada.destroy()
                self._overlay_entrada = None
                print("DEBUG: [OVERLAY] SUCCESS: Overlay de entrada fechado com sucesso")
            else:
                print("DEBUG: [OVERLAY] WARNING: Nenhum overlay de entrada encontrado para fechar")
        except Exception as e:
            print(f"DEBUG: [OVERLAY] ERRO ao fechar overlay de entrada: {e}")
            # For√ßa limpeza da refer√™ncia mesmo com erro
            self._overlay_entrada = None
    
    def _aplicar_valor_e_fechar_overlay(self, tipo, valor):
        """Aplica o valor selecionado e fecha o overlay"""
        print(f"DEBUG: [GEST√ÉO_PACOTES] Aplicando valor {valor} para {tipo} e fechando overlay")
        
        try:
            # Aplicar o valor
            self._aplicar_valor_entrada(tipo, valor)
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Valor {valor} aplicado para {tipo}")
        except Exception as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERRO ao aplicar valor: {e}")
        
        try:
            # Fechar o overlay
            self._fechar_overlay_entrada()
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Overlay fechado ap√≥s aplicar valor")
        except Exception as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERRO ao fechar overlay: {e}")
            # For√ßa limpeza da refer√™ncia mesmo com erro
            if hasattr(self, '_overlay_entrada'):
                self._overlay_entrada = None
    
    def _is_challenge_card(self, carta_path):
        """
        Verifica se uma carta √© do tipo Challenge baseada no caminho.
        
        Args:
            carta_path: Caminho para a carta (ex: "/path/Challenge_1.png")
            
        Returns:
            True se for uma carta Challenge, False caso contr√°rio
        """
        if not carta_path:
            return False
            
        filename = os.path.basename(carta_path)
        return filename.startswith('Challenge_') and filename.endswith('.png')
    
    def _incrementar_valor(self, tipo, message_size):
        """
        Incrementa valor respeitando o message_size m√°ximo da carta.
        CORRE√á√ÉO: Usar message_size como limite, n√£o rate_max.
        rate_max √© para pacotes por turno, message_size √© o limite total da mensagem.
        NOVO: Incrementa tamb√©m o contador de processamento por turno.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor_atual = int(entry.get())
            
            # Obter carta atual
            carta_path = self._cartas_gestao[self._carta_atual_gestao]
            
            # Obter rate_max para verificar limite por turno
            rate_max = self._obter_rate_carta(carta_path)
            
            # Verificar contadores de processamento por turno
            tipo_contador = 'rxd' if tipo == 'enviados' else 'lost'
            processed_this_turn = self._get_processed_this_turn(carta_path, tipo_contador)
            
            print(f"DEBUG: [INCREMENTAR] {tipo}: atual={valor_atual}, processed_this_turn={processed_this_turn}")
            print(f"DEBUG: [INCREMENTAR] Limites: message_size={message_size}, rate_max={rate_max}")
            
            # NOVA VERIFICA√á√ÉO: Ambos os limites devem ser respeitados
            pode_incrementar = (valor_atual < message_size) and (processed_this_turn < rate_max)
            
            if pode_incrementar:
                novo_valor = valor_atual + 1
                entry.delete(0, tk.END)
                entry.insert(0, str(novo_valor))
                
                # Atualizar valores armazenados
                self._valores_pacotes[self._carta_atual_gestao][tipo] = novo_valor
                
                # NOVO: Incrementar contador de processamento por turno
                self._increment_processed_this_turn(carta_path, tipo_contador, 1)
                
                # Atualizar barra "To send"
                self._atualizar_barra_to_send()
                
                print(f"DEBUG: [INCREMENTAR] SUCCESS: {tipo} incrementado para {novo_valor}")
                print(f"DEBUG: [INCREMENTAR] Novo processed_this_turn: {self._get_processed_this_turn(carta_path, tipo_contador)}")
            else:
                if valor_atual >= message_size:
                    print(f"DEBUG: [INCREMENTAR] ERROR: Limite de message_size atingido ({message_size})")
                if processed_this_turn >= rate_max:
                    print(f"DEBUG: [INCREMENTAR] ERROR: Limite de rate_max por turno atingido ({rate_max})")
                
        except ValueError:
            print("DEBUG: [INCREMENTAR] Valor inv√°lido no campo")
    
    def _validar_entrada(self, tipo, message_size):
        """
        Valida entrada manual respeitando message_size m√°ximo.
        CORRE√á√ÉO: Usar message_size como limite, n√£o rate_max.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor = int(entry.get())
            if valor < 0:
                valor = 0
                entry.delete(0, tk.END)
                entry.insert(0, "0")
            
            # CORRE√á√ÉO: Verificar limite individual por message_size
            if valor > message_size:
                valor = message_size
                entry.delete(0, tk.END)
                entry.insert(0, str(valor))
            
            # Atualizar valores armazenados
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
            
            # Atualizar barra "To send"
            self._atualizar_barra_to_send()
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] {tipo} validado para {valor} (limite: {message_size})")
            
        except ValueError:
            # Se valor inv√°lido, resetar para 0
            entry.delete(0, tk.END)
            entry.insert(0, "0")
            self._valores_pacotes[self._carta_atual_gestao][tipo] = 0
    
    def _atualizar_barra_to_send(self):
        """Atualiza a barra 'To send' com base nos valores inseridos"""
        valores = self._valores_pacotes[self._carta_atual_gestao]
        
        # CORRE√á√ÉO: "To send" = message_size(DB) - enviados - perdidos
        # Obter message_size da base de dados para a carta atual (coerente com pr√©-Final Phase)
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # Calcular quanto ainda resta para enviar
        total_processado = valores['enviados'] + valores['perdidos']
        to_send_restante = max(message_size - total_processado, 0)
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] C√°lculo 'To send':")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Message size (DB): {message_size}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Enviados (Rxd): {valores['enviados']}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Perdidos (Lost): {valores['perdidos']}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   Total processado: {total_processado}")
        print(f"DEBUG: [GEST√ÉO_PACOTES]   To send restante: {to_send_restante}")
        
        # Atualizar a barra de progresso "To send" usando o widget diretamente
        if hasattr(self, 'progress_bars') and "To send" in self.progress_bars:
            # Usar configura√ß√£o do widget Progressbar do tkinter (m√°ximo coerente com DB)
            self.progress_bars["To send"].config(value=to_send_restante, maximum=message_size)
            print(f"DEBUG: [GEST√ÉO_PACOTES] Progress bar 'To send' atualizada para {to_send_restante}/{message_size}")
            
        # Atualizar label do valor usando o widget diretamente
        if hasattr(self, 'progress_labels') and "To send" in self.progress_labels:
            self.progress_labels["To send"].config(text=str(to_send_restante))
            print(f"DEBUG: [GEST√ÉO_PACOTES] Progress label 'To send' atualizada para {to_send_restante}")
        
        # NOVO: Atualizar tamb√©m as barras Rxd e Lost para refletir os valores atuais
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=valores['enviados'])
                self.progress_labels["Rxd"].config(text=str(valores['enviados']))
                print(f"DEBUG: [GEST√ÉO_PACOTES] Progress bar 'Rxd' atualizada para {valores['enviados']}")
                
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=valores['perdidos'])
                self.progress_labels["Lost"].config(text=str(valores['perdidos']))
                print(f"DEBUG: [GEST√ÉO_PACOTES] Progress bar 'Lost' atualizada para {valores['perdidos']}")
        
        # REMOVIDO: N√£o verificar completion automaticamente - s√≥ no bot√£o seta da √∫ltima carta
        # self._verificar_completion_activity()
    
    def _verificar_completion_activity(self):
        """
        Verifica se uma Activity/Challenge foi completada:
        - To send = 0 (todos os pacotes da mensagem foram enviados)
        - drops_allowed = False
        
        NOTA: Uma Activity/Challenge √© completada quando todos os pacotes da mensagem
        (message_size) foram enviados ao longo de m√∫ltiplos turnos, n√£o apenas
        quando o rate de um turno foi atingido.
        """
        if not hasattr(self, '_valores_pacotes') or self._carta_atual_gestao not in self._valores_pacotes:
            return
        
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        
        # Obter dados da carta da database
        dados_carta = self._obter_dados_carta(carta_atual)
        if not dados_carta:
            print(f"DEBUG: [COMPLETION] N√£o foi poss√≠vel obter dados da carta {os.path.basename(carta_atual)}")
            return
        
        # CORRE√á√ÉO: Para Challenges, verificar completion mesmo com drops_allowed=True
        # As regras de completion s√£o diferentes para Activities vs Challenges
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        drops_allowed = dados_carta.get('drops_allowed', True)
        
        # NOVA L√ìGICA: Challenges sempre verificam completion, Activities s√≥ se drops_allowed=False
        if is_activity and drops_allowed:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=True, n√£o verifica completion")
            return
        elif is_challenge:
            print(f"DEBUG: [COMPLETION] Challenge {os.path.basename(carta_atual)} - sempre verifica completion")
        else:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=False - verifica completion")
        
        # Obter dados da carta para verificar completion
        message_size = dados_carta.get('message_size', 0)
        
        # Verificar se a carta tem dados de progresso acumulados
        if not hasattr(self, 'card_stats'):
            print(f"DEBUG: [COMPLETION] Dados de progresso n√£o encontrados")
            return
            
        # CORRE√á√ÉO: Encontrar o √≠ndice real da carta no carrossel
        carta_idx = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                carta_idx = i
                break
        
        if carta_idx is None or carta_idx >= len(self.card_stats):
            print(f"DEBUG: [COMPLETION] Carta n√£o encontrada no carrossel ou √≠ndice inv√°lido")
            return
            
        stats = self.card_stats[carta_idx]
        to_send_atual = stats['To send']
        rxd_acumulado = stats['Rxd']
        
        print(f"DEBUG: [COMPLETION] Verificando completion para {os.path.basename(carta_atual)}:")
        print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [COMPLETION]   Message size: {message_size}")
        print(f"DEBUG: [COMPLETION]   To send atual: {to_send_atual}")
        print(f"DEBUG: [COMPLETION]   Rxd acumulado: {rxd_acumulado}")
        print(f"DEBUG: [COMPLETION]   Drops allowed: {drops_allowed}")
        
        # CORRE√á√ÉO: Condi√ß√µes de completion mais flex√≠veis
        # Para Challenges: To send = 0 OU Rxd >= message_size
        # Para Activities: To send = 0 E Rxd >= message_size
        completion_achieved = False
        
        if is_challenge:
            # Challenges: mais flex√≠vel - ou todos enviados ou todos recebidos
            completion_achieved = (to_send_atual == 0) or (rxd_acumulado >= message_size)
            completion_reason = "todos enviados" if to_send_atual == 0 else f"todos recebidos ({rxd_acumulado}/{message_size})"
        else:
            # Activities: mais restritivo - todos enviados E todos recebidos
            completion_achieved = (to_send_atual == 0) and (rxd_acumulado >= message_size)
            completion_reason = f"todos enviados e recebidos ({rxd_acumulado}/{message_size})"
        
        if completion_achieved:
            print(f"DEBUG: [COMPLETION] *** {'Challenge' if is_challenge else 'Activity'} COMPLETADA! ***")
            print(f"DEBUG: [COMPLETION] Carta: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [COMPLETION] Motivo: {completion_reason}")
            
            # VALIDA√á√ÉO EXTRA: Confirmar que To send √© realmente 0 antes de mostrar overlay
            if to_send_atual > 0:
                print(f"DEBUG: [COMPLETION] [ERROR] ERRO CR√çTICO: Completion calculado incorretamente!")
                print(f"DEBUG: [COMPLETION] completion_achieved = {completion_achieved}")
                print(f"DEBUG: [COMPLETION] Mas to_send_atual = {to_send_atual} (deveria ser 0)")
                print(f"DEBUG: [COMPLETION] CANCELANDO overlay - valores inconsistentes")
                return
            
            print(f"DEBUG: [COMPLETION] ‚úì Valida√ß√£o confirmada: To send = 0, mostrando overlay")
            
            # Mostrar overlay de congratula√ß√µes
            self._mostrar_overlay_completion(carta_atual, dados_carta)
        else:
            print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_atual)} ainda n√£o completada:")
            print(f"DEBUG: [COMPLETION]   To send: {to_send_atual} (deve ser 0)")
            print(f"DEBUG: [COMPLETION]   Rxd: {rxd_acumulado} (deve ser >= {message_size})")
            print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge (flex√≠vel)' if is_challenge else 'Activity (restritivo)'}")
    
    def _mostrar_overlay_completion(self, carta_path, dados_carta, is_sequential=False, carta_index=None, tempo_limite_obrigatorio=False):
        """
        Mostra overlay de congratula√ß√µes quando Activity/Challenge √© completada
        
        Args:
            carta_path: Caminho da carta completada
            dados_carta: Dados da carta da base de dados
            is_sequential: Se True, este overlay faz parte de uma sequ√™ncia (m√∫ltiplas cartas completadas)
            tempo_limite_obrigatorio: Se True, completion foi por tempo limite obrigat√≥rio (finaliza gest√£o)
            carta_index: √çndice espec√≠fico da carta no carrossel (para c√°lculo correto de reward)
        """
        print(f"DEBUG: [COMPLETION] ===== VALIDA√á√ÉO CR√çTICA ANTES DE MOSTRAR OVERLAY =====")
        print(f"DEBUG: [COMPLETION] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [COMPLETION] Tempo limite obrigat√≥rio: {tempo_limite_obrigatorio}")
        print(f"DEBUG: [COMPLETION] √çndice da carta: {carta_index}")
        
        # CORRE√á√ÉO CR√çTICA: VALIDA√á√ÉO EXTRA ANTES DE MOSTRAR OVERLAY
        # Verificar se a carta realmente pode ser completada antes de mostrar overlay
        if not tempo_limite_obrigatorio:
            # Se n√£o √© completion por tempo limite, verificar condi√ß√µes normais
            carta_basename = os.path.basename(carta_path).lower()
            is_challenge = "challenge" in carta_basename
            is_activity = "activity" in carta_basename
            
            # Obter valores atuais das barras
            if carta_index is not None and hasattr(self, 'card_stats') and carta_index < len(self.card_stats):
                stats = self.card_stats[carta_index]
                to_send_atual = stats.get('To send', 0)
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                # Fallback: tentar obter dos progress_labels
                try:
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                except:
                    to_send_atual = 0
                    rxd_atual = 0
                    lost_atual = 0
            
            message_size = dados_carta.get('message_size', 0)
            
            print(f"DEBUG: [COMPLETION] VALIDA√á√ÉO DOS VALORES ATUAIS:")
            print(f"DEBUG: [COMPLETION]   To send: {to_send_atual}")
            print(f"DEBUG: [COMPLETION]   Rxd: {rxd_atual}")
            print(f"DEBUG: [COMPLETION]   Lost: {lost_atual}")
            print(f"DEBUG: [COMPLETION]   Message size: {message_size}")
            print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge' if is_challenge else 'Activity'}")
            
            # REGRA CR√çTICA: Para Challenges e Activities, To send DEVE ser 0 para completion normal
            if to_send_atual > 0:
                print(f"DEBUG: [COMPLETION] [ERROR] ERRO CR√çTICO: Completion inv√°lido!")
                print(f"DEBUG: [COMPLETION] To send deve ser 0, mas √© {to_send_atual}")
                print(f"DEBUG: [COMPLETION] CANCELANDO overlay de completion - condi√ß√µes n√£o atendidas")
                print(f"DEBUG: [COMPLETION] ===== OVERLAY CANCELADO =====")
                return  # N√ÉO mostrar overlay se condi√ß√µes n√£o est√£o atendidas
            
            print(f"DEBUG: [COMPLETION] ‚úì VALIDA√á√ÉO PASSOU: To send = 0, pode mostrar completion")
        else:
            print(f"DEBUG: [COMPLETION] ‚úì COMPLETION POR TEMPO LIMITE: Valida√ß√£o bypassed")
        
        print(f"DEBUG: [COMPLETION] Mostrando overlay de congratula√ß√µes")
        print(f"DEBUG: [COMPLETION] Sequencial: {is_sequential}")
        
        # Inicializar vari√°vel de decis√£o da gest√£o
        gestao_deve_continuar = None
        
        # CORRE√á√ÉO: Marcar que overlay de completion est√° ativo
        self._completion_overlay_active = True
        print("DEBUG: [COMPLETION] Flag _completion_overlay_active = True")
        
        # NOVA FLAG: Marcar se completion foi por tempo limite obrigat√≥rio
        self._completion_tempo_limite_obrigatorio = tempo_limite_obrigatorio
        if tempo_limite_obrigatorio:
            print("DEBUG: [COMPLETION] COMPLETION POR TEMPO LIMITE OBRIGAT√ìRIO - Gest√£o ser√° finalizada ap√≥s overlay")
        
        # CORRE√á√ÉO: Limpar controles de gest√£o antes de mostrar overlay
        # Isso evita que o bot√£o roxo apare√ßa por baixo do overlay
        if hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa:
            print(f"DEBUG: [COMPLETION] Removendo controles de gest√£o antes do overlay")
            self._remover_controles_gestao_silencioso()
        
        # Determinar tipo da carta (Activity ou Challenge)
        carta_basename = os.path.basename(carta_path).lower()
        if "activity" in carta_basename:
            card_type = "Activity"
        elif "challenge" in carta_basename:
            card_type = "Challenge"
        else:
            card_type = "Activity"  # fallback
        
        print(f"DEBUG: [COMPLETION] Tipo de carta detectado: {card_type}")
        
        # Calcular reward baseado no tipo de carta e regras espec√≠ficas usando √≠ndice correto
        reward_value = self._calcular_reward_completion(carta_path, dados_carta, card_type, carta_index)
        print(f"DEBUG: [COMPLETION] Reward calculado: {reward_value} PICoins")
        
        # NOVO FORMATO: Overlay fullscreen igual ao de ativa√ß√£o
        # Limpar TODOS os widgets para criar overlay fullscreen
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (igual ao overlay de ativa√ß√£o)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela (igual √† ativa√ß√£o)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual √† ativa√ß√£o)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [COMPLETION] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de congratula√ß√µes (centro da tela) - fundo preto com letras coloridas
        # Usar pack(expand=True) para dimensionamento din√¢mico, igual √†s p√°ginas de ativa√ß√£o
        completion_frame = tk.Frame(self, bg="black")
        completion_frame.pack(expand=True)
        
        # NOVO: Se √© sequencial, mostrar informa√ß√£o sobre progresso (APENAS para Challenges)
        if (is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays') and
            card_type == "Challenge"):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            
            progress_lbl = tk.Label(
                completion_frame,
                text=f"Carta {current_index + 1} de {total_overlays} completadas",
                font=("Helvetica", 14),
                fg="#888888",
                bg="black"
            )
            progress_lbl.pack(pady=(5, 0))
            
            # Nome da carta atual
            carta_name = os.path.basename(carta_path).replace('.png', '')
            carta_name_lbl = tk.Label(
                completion_frame,
                text=carta_name,
                font=("Helvetica", 16, "bold"),
                fg="#8000FF",
                bg="black"
            )
            carta_name_lbl.pack(pady=(0, 10))
        
        # T√≠tulo "Congratulations!" em roxo (centralizado)
        title_lbl = tk.Label(
            completion_frame,
            text="   Congratulations!   ",
            font=("Helvetica", 20, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(10, 10), anchor="center")
        
        # Frame para "You've won" + valor + picoin
        won_frame = tk.Frame(completion_frame, bg="black")
        won_frame.pack(pady=(0, 30), anchor="center")
        
        # Texto "You've won"
        won_text_lbl = tk.Label(won_frame, text="You've won", 
                               font=("Helvetica", 14, "bold"), 
                               fg="white", bg="black")
        won_text_lbl.pack(side="left", padx=(0, 10))
        
        # Valor da reward
        valor_lbl = tk.Label(won_frame, text=str(reward_value), 
                            font=("Helvetica", 14, "bold"), 
                            fg="#FFD700", bg="black")
        valor_lbl.pack(side="left", padx=(0, 5))
        
        # √çcone do picoin
        try:
            coin_img_path = os.path.join(os.path.dirname(__file__), "img", "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path).resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                coin_lbl = tk.Label(won_frame, image=coin_img, bg="black")
                coin_lbl.image = coin_img  # type: ignore[attr-defined]
                coin_lbl.pack(side="left")
            else:
                # Fallback para emoji
                coin_lbl = tk.Label(won_frame, text="$", 
                                   font=("Helvetica", 14), 
                                   fg="#FFD700", bg="black")
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar √≠cone picoin: {e}")
            # Fallback para emoji
            coin_lbl = tk.Label(won_frame, text="$", 
                               font=("Helvetica", 14), 
                               fg="#FFD700", bg="black")
            coin_lbl.pack(side="left")
        
        # CORRE√á√ÉO: Bot√£o para fechar o overlay (sempre presente)
        def fechar_e_continuar():
            print(f"DEBUG: [COMPLETION] Fechando overlay e continuando...")
            
            # CR√çTICO: Verificar se j√° foi processado para evitar duplica√ß√£o
            if hasattr(self, '_completion_processed') and self._completion_processed:
                print(f"DEBUG: [COMPLETION] AVISO: Completion j√° processado, ignorando")
                return
                
            # Marcar como processado
            self._completion_processed = True
            
            # CORRE√á√ÉO CR√çTICA: Preservar decis√£o da gest√£o que foi calculada acima
            nonlocal gestao_deve_continuar
            
            # Atualizar saldo do jogador
            self.saldo += reward_value
            print(f"DEBUG: [COMPLETION] Saldo atualizado: +{reward_value}, novo saldo: {self.saldo}")
            
            # NOVO: Sincronizar saldo com servidor
            print(f"DEBUG: [COMPLETION] Chamando sync_score_with_server para recompensa +{reward_value}")
            print(f"DEBUG: [COMPLETION] Estado antes da sincroniza√ß√£o - saldo atual: {self.saldo}")
            print(f"DEBUG: [COMPLETION] Verificando se estamos em modo multiplayer...")
            
            # Verificar se temos cliente dispon√≠vel
            import __main__
            if hasattr(__main__, 'netmaster_client'):
                client = __main__.netmaster_client
                print(f"DEBUG: [COMPLETION] Cliente existe: {client}")
                if client:
                    print(f"DEBUG: [COMPLETION] Cliente conectado: {getattr(client, 'connected', 'N/A')}")
                    print(f"DEBUG: [COMPLETION] Player ID: {getattr(client, 'player_id', 'N/A')}")
                    print(f"DEBUG: [COMPLETION] Session ID: {getattr(client, 'session_id', 'N/A')}")
                else:
                    print(f"DEBUG: [COMPLETION] Cliente √© None")
            else:
                print(f"DEBUG: [COMPLETION] Nenhum cliente encontrado - modo single player?")
            
            self.sync_score_with_server(f"recompensa +{reward_value}")
            
            # NOVO: Limpar tracking de Challenge se for Challenge completado
            if card_type == "Challenge":
                self._cleanup_completed_challenge_tracking(carta_path)
                print(f"DEBUG: [COMPLETION] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # AGORA remover carta do carrossel e devolver para store
            self._devolver_carta_para_store(carta_path, card_type)
            
            # Resetar flag para pr√≥ximo overlay
            self._completion_processed = False
            
            # NOVO: Se √© sequencial, mostrar pr√≥ximo overlay
            if is_sequential and hasattr(self, '_next_completion_overlays') and hasattr(self, '_current_completion_index'):
                next_index = self._current_completion_index + 1
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                self._mostrar_overlays_completion_sequencial(self._next_completion_overlays, next_index)
            else:
                print(f"DEBUG: [COMPLETION] Todos os overlays de completion foram mostrados")
                
                # AGORA verificar se ainda h√° cartas v√°lidas para processar
                cartas_reais_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for i, carta in enumerate(self.cards):
                        carta_basename = os.path.basename(carta).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            # NOVA FUNCIONALIDADE: Verificar flag da carta
                            is_face_up = True  # Default para compatibilidade
                            if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                                is_face_up = self.card_face_up_flags[i]
                            
                            if is_face_up:
                                cartas_reais_no_carrossel += 1
                
                # Verificar se ainda h√° cartas na lista de gest√£o V√ÅLIDAS (j√° foi atualizada acima)
                cartas_gestao_restantes = 0
                cartas_validas_gestao = []
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    # NOVA FUNCIONALIDADE: Primeiro limpar cartas inv√°lidas (viradas para baixo) da gest√£o
                    cartas_para_remover = []
                    for carta in self._cartas_gestao:
                        if carta and hasattr(self, 'cards') and carta in self.cards:
                            carta_index = self.cards.index(carta)
                            if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                if not self.card_face_up_flags[carta_index]:
                                    cartas_para_remover.append(carta)
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} virada para baixo - ser√° removida da gest√£o")
                    
                    # Remover cartas inv√°lidas
                    for carta in cartas_para_remover:
                        carta_index_gestao = self._cartas_gestao.index(carta)
                        self._cartas_gestao.remove(carta)
                        # Ajustar √≠ndice se necess√°rio
                        if carta_index_gestao <= self._carta_atual_gestao and self._carta_atual_gestao > 0:
                            self._carta_atual_gestao -= 1
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} removida da gest√£o")
                    
                    # CORRE√á√ÉO: Verificar apenas se h√° cartas V√ÅLIDAS restantes na lista de gest√£o
                    # N√ÉO verificar se podem processar - isso ser√° feito dentro da gest√£o
                    for i, carta in enumerate(self._cartas_gestao):
                        if carta:
                            carta_basename = os.path.basename(carta).lower()
                            # Carta deve ser Activity ou Challenge E existir no carrossel E estar virada para cima
                            if (not carta_basename.startswith("back_card_") and 
                                ("activity" in carta_basename or "challenge" in carta_basename) and
                                hasattr(self, 'cards') and carta in self.cards):
                                
                                # NOVA FUNCIONALIDADE: Verificar flag da carta
                                carta_index = self.cards.index(carta)
                                is_face_up = True  # Default para compatibilidade
                                if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                    is_face_up = self.card_face_up_flags[carta_index]
                                
                                if is_face_up:
                                    print(f"DEBUG: [COMPLETION] Carta v√°lida encontrada: {os.path.basename(carta)} - gest√£o deve continuar")
                                    cartas_gestao_restantes += 1
                                    cartas_validas_gestao.append(carta)
                                else:
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} est√° virada para baixo - ser√° ignorada")
                    
                    # ADICIONAL: Se h√° cartas na lista mas _carta_atual_gestao est√° fora de range, ajustar
                    if cartas_gestao_restantes > 0 and hasattr(self, '_carta_atual_gestao'):
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            print(f"DEBUG: [COMPLETION] WARNING: _carta_atual_gestao ({self._carta_atual_gestao}) fora de range - ajustando para 0")
                            self._carta_atual_gestao = 0
                
                # VERIFICA√á√ÉO CR√çTICA: Se gest√£o est√° ativa mas n√£o h√° cartas para processar, finalizar imediatamente
                gestao_esta_ativa = (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa)
                
                # CORRE√á√ÉO CR√çTICA: Verificar se h√° cartas SEGUINTES para processar
                # Mesmo com tempo limite obrigat√≥rio, verificar se h√° cartas nas posi√ß√µes seguintes
                tempo_limite_obrigatorio = getattr(self, '_completion_tempo_limite_obrigatorio', False)
                
                # NOVA L√ìGICA CORRETA: Verificar se h√° cartas AP√ìS a posi√ß√£o atual que precisam ser processadas
                cartas_seguintes_existem = False
                if hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao') and self._cartas_gestao:
                    posicao_atual = self._carta_atual_gestao
                    # Verificar todas as posi√ß√µes AP√ìS a atual
                    for i in range(posicao_atual + 1, len(self._cartas_gestao)):
                        carta_seguinte = self._cartas_gestao[i]
                        # Verificar se carta seguinte est√° face up (ativa) no carrossel
                        try:
                            carrossel_idx = self.cards.index(carta_seguinte)
                            if carrossel_idx < len(self.card_face_up_flags) and self.card_face_up_flags[carrossel_idx]:
                                cartas_seguintes_existem = True
                                print(f"DEBUG: [COMPLETION] Carta seguinte encontrada na posi√ß√£o {i}: {os.path.basename(carta_seguinte)}")
                                break
                        except (ValueError, IndexError):
                            continue
                
                # CORRE√á√ÉO CR√çTICA: SEMPRE inicializar cartas_nao_processadas
                cartas_nao_processadas = 0
                cartas_processadas_debug = []
                
                if tempo_limite_obrigatorio and not cartas_seguintes_existem:
                    print("DEBUG: [COMPLETION] TEMPO LIMITE OBRIGAT√ìRIO e N√ÉO h√° cartas seguintes - FINALIZANDO gest√£o")
                    gestao_deve_continuar = False
                elif tempo_limite_obrigatorio and cartas_seguintes_existem:
                    print("DEBUG: [COMPLETION] TEMPO LIMITE OBRIGAT√ìRIO mas H√Å cartas seguintes - CONTINUANDO gest√£o")
                    gestao_deve_continuar = True
                    # AINDA ASSIM calcular cartas n√£o processadas para debugging (com l√≥gica corrigida)
                    for carta in cartas_validas_gestao:
                        try:
                            carta_idx = self.cards.index(carta)
                            carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            # MESMA CORRE√á√ÉO: S√≥ considerar processada se jogador interagiu NESTE CICLO
                            foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                            foi_processada = foi_processada_interacao
                            
                            if not foi_processada:
                                cartas_nao_processadas += 1
                            else:
                                cartas_processadas_debug.append(f"{os.path.basename(carta)}(intera√ß√£o_registrada)")
                        except (ValueError, IndexError):
                            continue
                else:
                    # CORRE√á√ÉO CR√çTICA: A gest√£o deve continuar APENAS se h√° cartas AINDA N√ÉO PROCESSADAS
                    # N√£o √© suficiente verificar se h√° cartas na lista - deve verificar se h√° cartas que ainda precisem de processamento
                    
                    # CORRE√á√ÉO CR√çTICA: Durante gest√£o de pacotes, apenas cartas que AINDA N√ÉO foram processadas
                    # pelo jogador NESTE CICLO DE GEST√ÉO devem continuar. 
                    # IMPORTANTE: Valores de turnos anteriores N√ÉO significam que foram processadas neste ciclo!
                    
                    # Verificar quantas cartas na lista de gest√£o ainda n√£o foram processadas NESTE CICLO
                    for carta in cartas_validas_gestao:
                        # Obter posi√ß√£o no carrossel
                        try:
                            carta_idx = self.cards.index(carta)
                            carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            # CORRE√á√ÉO CR√çTICA: Durante gest√£o de pacotes, s√≥ considerar "processada" se:
                            # 1. Jogador interagiu com a carta NESTE CICLO DE GEST√ÉO (registro de intera√ß√£o)
                            # 2. OU carta foi explicitamente processada pelo sistema NESTE CICLO
                            
                            # IMPORTANTE: Valores > 0 de turnos anteriores N√ÉO contam como "processada neste ciclo"!
                            foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                            
                            # DEBUG: Mostrar an√°lise detalhada de cada carta
                            print(f"DEBUG: [COMPLETION] Analisando carta: {os.path.basename(carta)}")
                            print(f"DEBUG: [COMPLETION]   Stats atuais: Rxd={carta_stats.get('Rxd', 0)}, Lost={carta_stats.get('Lost', 0)}")
                            print(f"DEBUG: [COMPLETION]   Intera√ß√£o registrada: {foi_processada_interacao}")
                            print(f"DEBUG: [COMPLETION]   Cartas interagidas: {[os.path.basename(c) for c in getattr(self, '_cartas_interagidas_jogador', set())]}")
                            
                            # DECIS√ÉO FINAL: Carta √© considerada processada APENAS se jogador interagiu NESTE CICLO
                            foi_processada = foi_processada_interacao
                            
                            if not foi_processada:
                                cartas_nao_processadas += 1
                                print(f"DEBUG: [COMPLETION]   RESULTADO: N√ÉO processada neste ciclo - DEVE continuar gest√£o")
                            else:
                                cartas_processadas_debug.append(f"{os.path.basename(carta)}(intera√ß√£o_registrada)")
                                print(f"DEBUG: [COMPLETION]   RESULTADO: Processada neste ciclo - pode pular")
                        except (ValueError, IndexError):
                            # Carta n√£o encontrada no carrossel
                            print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta)} n√£o encontrada no carrossel")
                            continue
                    
                    print(f"DEBUG: [COMPLETION] === AN√ÅLISE DE PROCESSAMENTO DAS CARTAS ===")
                    print(f"DEBUG: [COMPLETION] Cartas v√°lidas na gest√£o: {len(cartas_validas_gestao)}")
                    print(f"DEBUG: [COMPLETION] Cartas processadas: {len(cartas_processadas_debug)} - {cartas_processadas_debug}")
                    print(f"DEBUG: [COMPLETION] Cartas n√£o processadas: {cartas_nao_processadas}")
                    
                    # L√ìGICA CORRIGIDA: Gest√£o deve continuar APENAS se h√° cartas n√£o processadas
                    gestao_deve_continuar = gestao_esta_ativa and cartas_nao_processadas > 0
                
                print(f"DEBUG: [COMPLETION] ===== DECIS√ÉO DE CONTINUA√á√ÉO DA GEST√ÉO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] cartas_reais_no_carrossel: {cartas_reais_no_carrossel}")
                print(f"DEBUG: [COMPLETION] cartas_gestao_restantes: {cartas_gestao_restantes}")
                print(f"DEBUG: [COMPLETION] cartas_nao_processadas: {cartas_nao_processadas}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                print(f"DEBUG: [COMPLETION] cartas_validas_gestao: {[os.path.basename(c) for c in cartas_validas_gestao]}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                print(f"DEBUG: [COMPLETION] RAZ√ÉO: {'H√° cartas n√£o processadas' if cartas_nao_processadas > 0 else 'Todas as cartas j√° foram processadas'}")
                
                # CORRE√á√ÉO CR√çTICA: PRIMEIRO remover carta da LISTA DE GEST√ÉO, n√£o do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA DA LISTA DE GEST√ÉO ===")
                if (hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao') and
                    self._cartas_gestao and carta_path in self._cartas_gestao):
                    
                    # Encontrar e remover carta da lista de gest√£o
                    try:
                        carta_gestao_idx = self._cartas_gestao.index(carta_path)
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_path)} est√° na posi√ß√£o {carta_gestao_idx} da lista de gest√£o")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao antes da remo√ß√£o: {self._carta_atual_gestao}")
                        
                        # Remover carta da lista
                        self._cartas_gestao.remove(carta_path)
                        
                        # CORRE√á√ÉO CR√çTICA: Ajustar _carta_atual_gestao baseado na posi√ß√£o da carta removida
                        if carta_gestao_idx < self._carta_atual_gestao:
                            # Carta removida estava antes da carta atual, decrementar √≠ndice
                            self._carta_atual_gestao -= 1
                            print(f"DEBUG: [COMPLETION] Carta removida antes da atual - √≠ndice decrementado para: {self._carta_atual_gestao}")
                        elif carta_gestao_idx == self._carta_atual_gestao:
                            # A carta atual foi removida
                            print(f"DEBUG: [COMPLETION] Carta atual foi removida - mantendo √≠ndice {self._carta_atual_gestao}")
                            # NOVA L√ìGICA: Se removemos a carta atual, o √≠ndice fica apontando para a pr√≥xima carta
                            # Se o √≠ndice ficou >= tamanho da lista, significa que removemos a √∫ltima carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                if len(self._cartas_gestao) > 0:
                                    # H√° cartas restantes, voltar ao in√≠cio
                                    self._carta_atual_gestao = 0
                                    print(f"DEBUG: [COMPLETION] √öltima carta removida - voltando ao in√≠cio: {self._carta_atual_gestao}")
                                else:
                                    # N√£o h√° cartas restantes
                                    print(f"DEBUG: [COMPLETION] Nenhuma carta restante na gest√£o")
                        # Se carta_gestao_idx > self._carta_atual_gestao, n√£o precisa ajustar
                        
                        print(f"DEBUG: [COMPLETION] Lista gest√£o ap√≥s remo√ß√£o: {len(self._cartas_gestao)} cartas")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao ap√≥s remo√ß√£o: {self._carta_atual_gestao}")
                        print(f"DEBUG: [COMPLETION] Cartas restantes: {[os.path.basename(c) for c in self._cartas_gestao]}")
                        
                    except ValueError:
                        print(f"DEBUG: [COMPLETION] AVISO: Carta n√£o estava na lista de gest√£o")
                
                # SEGUNDO: AGORA remover carta do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA COMPLETADA DO CARROSSEL ===")
                self._remover_carta_do_carrossel(carta_path)
                
                # TERCEIRO: Determinar se gest√£o deve continuar baseado na lista de gest√£o ATUALIZADA
                # CORRE√á√ÉO CR√çTICA: A carta j√° foi removida da lista _cartas_gestao acima
                print(f"DEBUG: [COMPLETION] === VERIFICA√á√ÉO FINAL DE CONTINUA√á√ÉO ===")
                print(f"DEBUG: [COMPLETION] _cartas_gestao atual: {[os.path.basename(c) for c in getattr(self, '_cartas_gestao', [])]}")
                print(f"DEBUG: [COMPLETION] Tamanho da lista: {len(getattr(self, '_cartas_gestao', []))}")
                
                # CORRE√á√ÉO CR√çTICA: N√ÉO resetar gestao_deve_continuar aqui!
                # A primeira l√≥gica j√° tomou a decis√£o correta baseada em tempo_limite_obrigatorio e cartas seguintes
                # gestao_deve_continuar = False  # REMOVIDO - n√£o sobrescrever primeira decis√£o
                # CORRE√á√ÉO CR√çTICA: Apenas verificar cartas v√°lidas para informa√ß√£o, N√ÉO alterar gestao_deve_continuar
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    # Verificar se ainda h√° cartas v√°lidas na lista de gest√£o (apenas para logs informativos)
                    cartas_validas_na_gestao = 0
                    for carta in self._cartas_gestao:
                        if carta and hasattr(self, 'cards') and carta in self.cards:
                            carta_basename = os.path.basename(carta).lower()
                            # Carta deve ser Activity ou Challenge E existir no carrossel E estar virada para cima
                            if (not carta_basename.startswith("back_card_") and 
                                ("activity" in carta_basename or "challenge" in carta_basename)):
                                
                                # Verificar flag da carta
                                carta_index = self.cards.index(carta)
                                is_face_up = True  # Default para compatibilidade
                                if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                    is_face_up = self.card_face_up_flags[carta_index]
                                
                                if is_face_up:
                                    cartas_validas_na_gestao += 1
                                    print(f"DEBUG: [COMPLETION] Carta v√°lida encontrada: {os.path.basename(carta)}")
                    
                    print(f"DEBUG: [COMPLETION] Cartas v√°lidas restantes na gest√£o: {cartas_validas_na_gestao}")
                    print(f"DEBUG: [COMPLETION] IMPORTANTE: Respeitando decis√£o da primeira l√≥gica: gestao_deve_continuar = {gestao_deve_continuar}")
                    
                    # NOVA VERIFICA√á√ÉO: Mesmo que hajam cartas v√°lidas, verificar se j√° foram processadas
                    if cartas_validas_na_gestao > 0 and gestao_deve_continuar:
                        # Garantir que _carta_atual_gestao est√° dentro dos limites
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            self._carta_atual_gestao = 0
                        
                        # CORRE√á√ÉO ADICIONAL: Verificar se as cartas restantes ainda precisam processamento NESTE CICLO
                        cartas_restantes_nao_processadas = 0
                        for carta in self._cartas_gestao:
                            try:
                                carta_idx = self.cards.index(carta)
                                carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                                
                                # APLICAR A MESMA L√ìGICA CORRIGIDA: APENAS intera√ß√£o do jogador NESTE CICLO
                                foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                                foi_processada = foi_processada_interacao
                                
                                print(f"DEBUG: [COMPLETION] Verifica√ß√£o final carta: {os.path.basename(carta)}")
                                print(f"DEBUG: [COMPLETION]   Intera√ß√£o neste ciclo: {foi_processada_interacao}")
                                
                                if not foi_processada:
                                    cartas_restantes_nao_processadas += 1
                                    print(f"DEBUG: [COMPLETION]   RESULTADO: Precisa processamento - contando como n√£o processada")
                                else:
                                    print(f"DEBUG: [COMPLETION]   RESULTADO: J√° processada neste ciclo - pode pular")
                            except (ValueError, IndexError):
                                print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta)} n√£o encontrada no carrossel para verifica√ß√£o final")
                                continue
                        
                        print(f"DEBUG: [COMPLETION] VERIFICA√á√ÉO FINAL:")
                        print(f"DEBUG: [COMPLETION]   Cartas v√°lidas restantes: {cartas_validas_na_gestao}")
                        print(f"DEBUG: [COMPLETION]   Cartas restantes N√ÉO processadas: {cartas_restantes_nao_processadas}")
                        
                        if cartas_restantes_nao_processadas == 0:
                            print(f"DEBUG: [COMPLETION] CORRE√á√ÉO: Todas as cartas restantes j√° foram processadas - FINALIZANDO gest√£o")
                            gestao_deve_continuar = False
                        else:
                            proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                            print(f"DEBUG: [COMPLETION] SUCCESS: Pr√≥xima carta ser√°: {os.path.basename(proxima_carta)} (posi√ß√£o gest√£o: {self._carta_atual_gestao})")
                    elif cartas_validas_na_gestao == 0:
                        print(f"DEBUG: [COMPLETION] INFO: N√£o h√° cartas V√ÅLIDAS restantes na lista - finalizando independentemente da primeira decis√£o")
                        gestao_deve_continuar = False
                    else:
                        print(f"DEBUG: [COMPLETION] INFO: H√° cartas v√°lidas mas primeira l√≥gica decidiu finalizar gest√£o")
                        # N√ÉO sobrescrever gestao_deve_continuar aqui - primeira l√≥gica j√° decidiu
                else:
                    print(f"DEBUG: [COMPLETION] INFO: Lista de gest√£o vazia - finalizando gest√£o")
                    # S√≥ finalizar se primeira l√≥gica n√£o decidiu continuar por tempo_limite_obrigatorio
                    if not (tempo_limite_obrigatorio and gestao_deve_continuar):
                        gestao_deve_continuar = False
                
                # TERCEIRO: Ajustar √≠ndice se est√° fora de range
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                    if self._carta_atual_gestao >= len(self._cartas_gestao):
                        self._carta_atual_gestao = len(self._cartas_gestao) - 1
                        print(f"DEBUG: [COMPLETION] Ajustado _carta_atual_gestao para {self._carta_atual_gestao}")
                
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                
                # CORRE√á√ÉO: Remover flag de overlay ativo quando widgets s√£o destru√≠dos
                self._completion_overlay_active = False
                print("DEBUG: [COMPLETION] Flag _completion_overlay_active = False (overlay fechado)")
                
                # Limpar flag de tempo limite obrigat√≥rio
                if hasattr(self, '_completion_tempo_limite_obrigatorio'):
                    delattr(self, '_completion_tempo_limite_obrigatorio')
                
                print(f"DEBUG: [COMPLETION] ===== DECIS√ÉO DE CONTINUA√á√ÉO DA GEST√ÉO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                
                # QUARTO: Tomar decis√£o final sobre continua√ß√£o da gest√£o
                if gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] SUCCESS: Continuando gest√£o de pacotes")
                    
                    # CORRE√á√ÉO CR√çTICA: Determinar corretamente a pr√≥xima carta v√°lida na lista de gest√£o
                    if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                        # NOVA L√ìGICA: Quando uma carta √© removida no meio da lista, o √≠ndice atual j√° aponta para a pr√≥xima carta
                        # Se a carta removida estava na posi√ß√£o atual, n√£o incrementamos - a pr√≥xima j√° est√° na mesma posi√ß√£o
                        # Se a carta removida estava antes da atual, j√° decrement√°mos o √≠ndice
                        
                        # Verificar se o √≠ndice atual ainda est√° v√°lido
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            # Se o √≠ndice ficou inv√°lido, significa que removemos a √∫ltima carta
                            # Voltar ao in√≠cio da lista para continuar com a primeira carta restante
                            self._carta_atual_gestao = 0
                            print(f"DEBUG: [COMPLETION] √çndice ajustado para in√≠cio da lista: {self._carta_atual_gestao}")
                        
                        proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                        print(f"DEBUG: [COMPLETION] SUCCESS: Pr√≥xima carta determinada: {os.path.basename(proxima_carta)} (posi√ß√£o gest√£o: {self._carta_atual_gestao})")
                        
                        # CORRE√á√ÉO CR√çTICA: Encontrar posi√ß√£o da pr√≥xima carta no carrossel ATUALIZADO 
                        # Ap√≥s remo√ß√£o, as cartas mudam de posi√ß√£o - procurar pelo basename da carta
                        proxima_posicao = None
                        proxima_carta_basename = os.path.basename(proxima_carta)
                        
                        if hasattr(self, 'cards'):
                            print(f"DEBUG: [COMPLETION] Procurando carta {proxima_carta_basename} no carrossel atualizado:")
                            for i, carta in enumerate(self.cards):
                                carta_basename = os.path.basename(carta)
                                print(f"DEBUG: [COMPLETION]   Posi√ß√£o {i}: {carta_basename}")
                                
                                # CORRE√á√ÉO: Comparar basename e verificar se carta est√° face up
                                if (carta_basename == proxima_carta_basename and 
                                    i < len(self.card_face_up_flags) and 
                                    self.card_face_up_flags[i]):
                                    proxima_posicao = i
                                    print(f"DEBUG: [COMPLETION] SUCCESS: {proxima_carta_basename} encontrada na posi√ß√£o {i} e est√° face up")
                                    break
                        
                        if proxima_posicao is not None:
                            print(f"DEBUG: [COMPLETION] SUCCESS: Atualizando sele√ß√£o para pr√≥xima carta v√°lida:")
                            print(f"DEBUG: [COMPLETION]   Carta: {proxima_carta_basename}")
                            print(f"DEBUG: [COMPLETION]   Posi√ß√£o carrossel: {proxima_posicao}")
                            print(f"DEBUG: [COMPLETION]   Posi√ß√£o gest√£o: {self._carta_atual_gestao}")
                            
                            # ATUALIZAR sele√ß√£o do carrossel para a pr√≥xima carta CORRETA
                            self.selected_carousel_card = self.cards[proxima_posicao]  # Usar carta do carrossel atual
                            self.selected_carousel_index = proxima_posicao
                            
                        else:
                            print(f"DEBUG: [COMPLETION] WARNING: Carta {proxima_carta_basename} n√£o encontrada face up no carrossel")
                            print(f"DEBUG: [COMPLETION] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
                            print(f"DEBUG: [COMPLETION] Estados face up: {self.card_face_up_flags}")
                            print(f"DEBUG: [COMPLETION] IMPORTANTE: Mesmo assim, continuar gest√£o - carta pode estar noutro slot")
                            # N√ÉO definir gestao_deve_continuar = False - deixar a gest√£o continuar
                    
                    if gestao_deve_continuar:
                        print(f"DEBUG: [COMPLETION] Reconstruindo dashboard e continuando gest√£o...")
                        
                        # BACKUP CR√çTICO: Preservar tracking antes da reconstru√ß√£o da interface
                        print(f"DEBUG: [COMPLETION] BACKUP DOS CONTADORES antes da reconstru√ß√£o...")
                        self._backup_turn_counters_before_reconstruction()
                        
                        # RECONSTRUIR DASHBOARD antes de continuar gest√£o
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                        # Depois de reconstruir, continuar gest√£o na carta correta
                        self.after(100, lambda: self._mostrar_gestao_carta_atual())
                        return
                
                if not gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] SUCCESS: Gest√£o de pacotes finalizada - n√£o h√° mais cartas para processar")
                    print(f"DEBUG: [COMPLETION] Voltando ao dashboard normal com End Turn habilitado")
                    
                    # CORRE√á√ÉO CR√çTICA: Finalizar gest√£o mas MANTER Final Phase ativo para End Turn
                    self._final_phase_gestao_ativa = False
                    # N√ÉO limpar _final_phase_active - o jogador ainda est√° em Final Phase!
                    
                    # CORRE√á√ÉO: Ativar End Turn quando gest√£o termina por completion
                    self._show_end_turn_button = True
                    
                    if hasattr(self, '_cartas_gestao'):
                        self._cartas_gestao = []
                    if hasattr(self, '_carta_atual_gestao'):
                        self._carta_atual_gestao = 0
                    
                    # CORRE√á√ÉO CR√çTICA: Voltar ao dashboard MANTENDO Final Phase ativo
                    print(f"DEBUG: [COMPLETION] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    # CORRE√á√ÉO CR√çTICA: Ativar o bot√£o End Turn AP√ìS reconstruir a interface
                    self.after(100, self._ativar_botao_end_turn)
                    
                    # CORRE√á√ÉO NOVA: For√ßar atualiza√ß√£o dos destaques para garantir que carta restante fique destacada
                    self.after(200, lambda: self._update_carousel_selection_highlights())
                    
            # CORRE√á√ÉO CR√çTICA: Preservar a decis√£o da gest√£o para retorno
            print(f"DEBUG: [COMPLETION] Preservando decis√£o final: gestao_deve_continuar = {gestao_deve_continuar}")
        
        # Texto do bot√£o baseado no tipo de carta
        if card_type == "Activity":
            btn_text = "OK"
        elif is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays'):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            if current_index < total_overlays - 1:
                btn_text = "Pr√≥xima ‚Üí"
            else:
                btn_text = "Finalizar"
        else:
            btn_text = "OK"
        
        # Bot√£o OK roxo (inferior central)
        print(f"DEBUG: [COMPLETION] Criando bot√£o OK...")
        ok_btn = tk.Button(
            completion_frame,
            text=btn_text,
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="#8000FF",  # Roxo
            bd=2,
            relief="raised",
            width=12,
            height=1,
            command=fechar_e_continuar
        )
        ok_btn.pack(pady=(20, 20), anchor="center")  # Centralizar o bot√£o
        print(f"DEBUG: [COMPLETION] Bot√£o OK criado e posicionado")
        
        print(f"DEBUG: [COMPLETION] Overlay de congratula√ß√µes criado com bot√£o '{btn_text}'")
        
        # Armazenar dados da recompensa e tipo de carta para quando fechar o overlay
        self._completion_reward = reward_value
        self._completed_card_path = carta_path
        self._completed_card_type = card_type
        
        # For√ßar update da janela principal para garantir que tudo √© renderizado
        self.update_idletasks()
        self.deiconify()  # Garantir que est√° vis√≠vel
        self.lift()       # Trazer para a frente
        self.focus_force()  # For√ßar foco
        
        print(f"DEBUG: [COMPLETION] Overlay criado, tipo: {card_type}, recompensa: {reward_value} PICoins")
        print(f"DEBUG: [COMPLETION] Widgets criados no overlay: {len(completion_frame.winfo_children())} widgets")
        print(f"DEBUG: [COMPLETION] Bot√£o OK widget: {ok_btn}")
        print(f"DEBUG: [COMPLETION] Bot√£o OK vis√≠vel: {ok_btn.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal geometry: {self.geometry()}")
        print(f"DEBUG: [COMPLETION] Janela principal viewable: {self.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal ismapped: {self.winfo_ismapped()}")
    
    def _calcular_reward_completion(self, carta_path, dados_carta, card_type, carta_index=None):
        """
        Calcula o reward de completion baseado nas regras espec√≠ficas do arquivo Reward_Activity e Reward_Challenge
        """
        print(f"DEBUG: [REWARD_CALC] Calculando reward para {card_type}: {os.path.basename(carta_path)}")
        
        # CORRE√á√ÉO: Usar √≠ndice espec√≠fico da carta se fornecido, sen√£o usar selected_card_idx
        card_idx = carta_index if carta_index is not None else getattr(self, 'selected_card_idx', 0)
        
        # Obter valores atuais das barras de progresso usando o √≠ndice correto
        rxd_atual = self._obter_valor_barra_atual_by_index("Rxd", card_idx)
        lost_atual = self._obter_valor_barra_atual_by_index("Lost", card_idx)
        
        print(f"DEBUG: [REWARD_CALC] Valores atuais (carta √≠ndice {card_idx}) - Rxd: {rxd_atual}, Lost: {lost_atual}")
        print(f"DEBUG: [REWARD_CALC] Dados da carta: {dados_carta}")
        
        if card_type == "Activity":
            return self._calcular_reward_activity(carta_path, dados_carta, rxd_atual, lost_atual)
        elif card_type == "Challenge":
            return self._calcular_reward_challenge(carta_path, dados_carta, rxd_atual, lost_atual)
        else:
            # Fallback para valor message_received
            return dados_carta.get('message_received', 0)
    
    def _calcular_reward_activity(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Activity baseado nas regras do arquivo Reward_Activity
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necess√°rios da carta
        reward_per_packet = dados_carta.get('reward_per_packet', 0)
        packet_bonus = dados_carta.get('packet_bonus', 0)
        bonus_condition = dados_carta.get('bonus_condition', 0)
        message_received = dados_carta.get('message_received', 0)
        message_size = dados_carta.get('message_size', 0)
        penalty_per_packet = dados_carta.get('penalty_per_packet', 0)
        penalty_condition = dados_carta.get('penalty_condition', 0)
        
        print(f"DEBUG: [REWARD_CALC] Activity data:")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  packet_bonus: {packet_bonus}")
        print(f"  bonus_condition: {bonus_condition}")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  penalty_per_packet: {penalty_per_packet}")
        print(f"  penalty_condition: {penalty_condition}")
        
        # Identificar qual Activity √© baseado no nome do arquivo
        if "activity_1" in carta_basename:
            # Activity_1 (Home Surveillance): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_1: {n_rxd} √ó {reward_per_packet} = {reward}")
            
        elif "activity_2" in carta_basename or "activity_3" in carta_basename:
            # Activity_2-3 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [n_Rxd x packet_bonus (se n_Rxd >= bonus_condition)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (n_rxd * packet_bonus) if n_rxd >= bonus_condition else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_2-3: {n_rxd}√ó{reward_per_packet} + bonus({n_rxd}√ó{packet_bonus} se {n_rxd}>={bonus_condition}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_4" in carta_basename:
            # Activity_4 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [message_received (se bonus_condition == n_Lost)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if bonus_condition == n_lost else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_4: {n_rxd}√ó{reward_per_packet} + message_received({message_received} se {bonus_condition}=={n_lost}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_5" in carta_basename:
            # Activity_5 (Home Safety): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_5: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_6" in carta_basename or "activity_7" in carta_basename:
            # Activity_6-7 (Home Safety): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost <= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost <= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # N√£o pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_6-7: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}√ó{penalty_per_packet} se {n_lost}<={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_8" in carta_basename:
            # Activity_8 (Short Message): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_8: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_9" in carta_basename:
            # Activity_9 (Short Message): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost >= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost >= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # N√£o pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_9: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}√ó{penalty_per_packet} se {n_lost}>={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_10" in carta_basename:
            # Activity_10 (Gaming): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_10: {n_rxd} √ó {reward_per_packet} = {reward}")
            
        elif "activity_11" in carta_basename:
            # Activity_11 (Gaming): Reward = [n_Rxd x reward_per_packet] + [message_received (se n_Rxd == message_size)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if n_rxd == message_size else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_11: {n_rxd}√ó{reward_per_packet} + message_received({message_received} se {n_rxd}=={message_size}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_12" in carta_basename:
            # Activity_12 (File Transfer): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_12: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        else:
            # Fallback para Activities n√£o reconhecidas
            reward = message_received
            print(f"DEBUG: [REWARD_CALC] Activity n√£o reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que n√£o √© negativo
    
    def _calcular_reward_challenge(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Challenge baseado nas regras do arquivo Reward_Challenge
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necess√°rios da carta
        message_received = dados_carta.get('message_received', 0) or 0
        message_size = dados_carta.get('message_size', 0) or 0
        reward_per_packet = dados_carta.get('reward_per_packet', 0) or 0
        time_limit_bonus = dados_carta.get('time_limit_bonus', 0) or 0
        message_received_bonus = dados_carta.get('message_received_bonus', 0) or 0
        
        # CORRE√á√ÉO: Usar valor passado por par√¢metro em vez de obter da barra atual
        # (que pode estar apontando para carta errada)
        to_send_atual = message_size - n_rxd  # Calcular To send baseado nos valores corretos
        
        print(f"DEBUG: [REWARD_CALC] Challenge data:")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  time_limit_bonus: {time_limit_bonus}")
        print(f"  message_received_bonus: {message_received_bonus}")
        print(f"  to_send_calculado: {to_send_atual}")
        
        # Verificar condi√ß√µes de completion (To send = 0 e Rxd = message_size)
        completion_achieved = (to_send_atual == 0 and n_rxd == message_size)
        print(f"DEBUG: [REWARD_CALC] Completion achieved: {completion_achieved} (to_send={to_send_atual}, rxd={n_rxd}, message_size={message_size})")
        
        # Identificar qual Challenge √© baseado no nome do arquivo
        if any(f"challenge_{i}." in carta_basename for i in range(1, 5)):
            # Challenge_1-4 (Message Mission): Reward = message_received (se completion achieved)
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge_1-4: message_received({message_received} se completion) = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(5, 8)):
            # Challenge_5-7 (Message Sprint): Reward = time_limit_bonus + message_received (se completion achieved E dentro do time_limit)
            time_limit = dados_carta.get('time_limit', 0) or 0
            
            # Verificar se carta foi iniciada e calcular turnos decorridos
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            within_time_limit = turns_elapsed <= time_limit if time_limit > 0 else True
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7 timing:")
            print(f"  time_limit: {time_limit} turnos")
            print(f"  turns_elapsed: {turns_elapsed} turnos")
            print(f"  within_time_limit: {within_time_limit}")
            
            # Time bonus s√≥ √© dado se completion achieved E dentro do limite de tempo
            time_bonus = (time_limit_bonus or 0) if (completion_achieved and within_time_limit) else 0
            # Message received s√≥ √© dado se completion achieved (independente do tempo)
            message_bonus = (message_received or 0) if completion_achieved else 0
            reward = time_bonus + message_bonus
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7: time_limit_bonus({time_limit_bonus} se completion E time_limit) + message_received({message_received} se completion) = {time_bonus} + {message_bonus} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(8, 11)):
            # Challenge_8-10 (Jackpot): Reward = [n_Rxd x reward_per_packet] + [message_received_bonus (se completion achieved)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (message_received_bonus or 0) if completion_achieved else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Challenge_8-10: {n_rxd}√ó{reward_per_packet} + message_received_bonus({message_received_bonus} se completion) = {base_reward} + {bonus_reward} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(11, 15)):
            # Challenge_11-14 (Packet Race): Reward = n_Rxd x reward_per_packet (SEM verifica√ß√£o de completion)
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Challenge_11-14: {n_rxd} √ó {reward_per_packet} = {reward}")
            
        else:
            # Fallback para Challenges n√£o reconhecidas
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge n√£o reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que n√£o √© negativo
    
    def _get_turns_elapsed_for_challenge(self, carta_path):
        """
        Calcula quantos turnos uma Challenge esteve ativa usando a f√≥rmula:
        turnos_ativo = turno_atual - turno_carta_ativou + 1
        
        CORRE√á√ÉO CR√çTICA: Implementa busca por basename como fallback para resolver
        incompatibilidade entre caminhos completos no tracking e basenames no carrossel.
        
        Args:
            carta_path (str): Caminho da carta Challenge
            
        Returns:
            int: N√∫mero de turnos que a carta esteve ativa
        """
        if not carta_path:
            print(f"DEBUG: [TURNS_ELAPSED] Carta path vazio ou None")
            return 0
        
        carta_filename = os.path.basename(carta_path)
        print(f"DEBUG: [TURNS_ELAPSED] Calculando turnos para: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED] Caminho fornecido: {carta_path}")
        print(f"DEBUG: [TURNS_ELAPSED] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [TURNS_ELAPSED] Tracking dispon√≠vel: {self._challenge_start_turns}")
        
        # CORRE√á√ÉO CR√çTICA: Primeiro tentar caminho exato
        if carta_path in self._challenge_start_turns:
            turno_inicio = self._challenge_start_turns[carta_path]
            turnos_ativa = self._current_turn_number - turno_inicio + 1
            print(f"DEBUG: [TURNS_ELAPSED] ‚úì Registo encontrado por caminho exato:")
            print(f"DEBUG: [TURNS_ELAPSED]   Turno de ativa√ß√£o: {turno_inicio}")
            print(f"DEBUG: [TURNS_ELAPSED]   Turno atual: {self._current_turn_number}")
            print(f"DEBUG: [TURNS_ELAPSED]   F√≥rmula: {self._current_turn_number} - {turno_inicio} + 1 = {turnos_ativa}")
            print(f"DEBUG: [TURNS_ELAPSED]   Challenge ativa h√° {turnos_ativa} turnos")
            print(f"DEBUG: [TURNS_ELAPSED]   AMBIENTE: {get_universal_paths()['environment']}")
            return turnos_ativa
        
        # CORRE√á√ÉO CR√çTICA: Se n√£o encontrou por caminho exato, procurar por basename
        print(f"DEBUG: [TURNS_ELAPSED] [WARNING] Caminho exato n√£o encontrado, procurando por basename: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED] AN√ÅLISE DETALHADA do tracking dispon√≠vel:")
        
        for i, (tracked_path, turno_inicio) in enumerate(self._challenge_start_turns.items(), 1):
            tracked_basename = os.path.basename(tracked_path)
            match_basename = tracked_basename == carta_filename
            print(f"DEBUG: [TURNS_ELAPSED]   Entrada {i}:")
            print(f"DEBUG: [TURNS_ELAPSED]     Caminho: {tracked_path}")
            print(f"DEBUG: [TURNS_ELAPSED]     Basename: {tracked_basename}")
            print(f"DEBUG: [TURNS_ELAPSED]     Match com {carta_filename}? {match_basename}")
            print(f"DEBUG: [TURNS_ELAPSED]     Turno in√≠cio: {turno_inicio}")
            
            if match_basename:
                turnos_ativa = self._current_turn_number - turno_inicio + 1
                print(f"DEBUG: [TURNS_ELAPSED] ‚úì MATCH ENCONTRADO por basename!")
                print(f"DEBUG: [TURNS_ELAPSED]   Tracking path: {tracked_path}")
                print(f"DEBUG: [TURNS_ELAPSED]   Basename match: {tracked_basename} == {carta_filename}")
                print(f"DEBUG: [TURNS_ELAPSED]   Turno de ativa√ß√£o: {turno_inicio}")
                print(f"DEBUG: [TURNS_ELAPSED]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [TURNS_ELAPSED]   F√≥rmula: {self._current_turn_number} - {turno_inicio} + 1 = {turnos_ativa}")
                print(f"DEBUG: [TURNS_ELAPSED]   Challenge ativa h√° {turnos_ativa} turnos")
                print(f"DEBUG: [TURNS_ELAPSED]   AMBIENTE: {get_universal_paths()['environment']}")
                return turnos_ativa
        
        # Se nem por basename encontrou, ent√£o realmente n√£o foi registada
        print(f"DEBUG: [TURNS_ELAPSED] [ERROR] ERRO CR√çTICO: Challenge {carta_filename} n√£o tem registo de ativa√ß√£o!")
        print(f"DEBUG: [TURNS_ELAPSED] Nem por caminho exato nem por basename foi encontrada no tracking")
        print(f"DEBUG: [TURNS_ELAPSED] CAUSA POSS√çVEL: Challenge n√£o foi registada quando adicionada ao carrossel")
        print(f"DEBUG: [TURNS_ELAPSED] DIAGN√ìSTICO:")
        print(f"DEBUG: [TURNS_ELAPSED]   - Caminho procurado: {carta_path}")
        print(f"DEBUG: [TURNS_ELAPSED]   - Basename procurado: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED]   - Total tracking entries: {len(self._challenge_start_turns)}")
        print(f"DEBUG: [TURNS_ELAPSED]   - M√©todo de busca: caminho exato + basename fallback")
        
        # CORRE√á√ÉO AUTOM√ÅTICA: Tentar recuperar Challenge sem tracking
        print(f"DEBUG: [TURNS_ELAPSED] [CONFIG] TENTANDO RECUPERA√á√ÉO AUTOM√ÅTICA...")
        if self._tentar_recuperar_challenge_perdida(carta_path):
            # Se conseguiu recuperar, tentar novamente
            print(f"DEBUG: [TURNS_ELAPSED] ‚úì Challenge recuperado! Tentando novamente...")
            if carta_path in self._challenge_start_turns:
                turno_inicio = self._challenge_start_turns[carta_path]
                turnos_ativa = self._current_turn_number - turno_inicio + 1
                print(f"DEBUG: [TURNS_ELAPSED] ‚úì RECUPERA√á√ÉO SUCESSO: Challenge ativa h√° {turnos_ativa} turnos")
                return turnos_ativa
        
        print(f"DEBUG: [TURNS_ELAPSED] [ERROR] RECUPERA√á√ÉO FALHADA: Retornando 0 turnos")
        print(f"DEBUG: [TURNS_ELAPSED] CORRE√á√ÉO SUGERIDA: Verificar _register_challenge_start_turn() ou _substituir_activity_por_challenge()")
        return 0
    
    def _tentar_recuperar_challenge_perdida(self, carta_path):
        """
        Tenta recuperar uma Challenge que perdeu o registo de tracking.
        
        CORRE√á√ÉO CR√çTICA: Challenge rec√©m aceite deve ser registado NO TURNO ATUAL.
        A recupera√ß√£o anterior estava incorretamente estimando turnos passados.
        
        Args:
            carta_path (str): Caminho da Challenge perdida
            
        Returns:
            bool: True se conseguiu recuperar, False caso contr√°rio
        """
        try:
            print(f"DEBUG: [RECOVERY] === INICIANDO RECUPERA√á√ÉO DE CHALLENGE PERDIDA ===")
            print(f"DEBUG: [RECOVERY] Challenge: {os.path.basename(carta_path)}")
            print(f"DEBUG: [RECOVERY] Caminho: {carta_path}")
            
            # PRIMEIRO: Verificar se Challenge est√° nos backups consolidados
            # Se est√°, n√£o √© Challenge perdida - √© problema de sincroniza√ß√£o tempor√°ria
            fontes_backup = []
            
            # Backup imediato (mais recente)
            if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
                backup_imediato = getattr(self._estado_botoes_imediato, 'challenge_tracking_consolidado', {})
                if backup_imediato:
                    fontes_backup.append((backup_imediato, 'imediato'))
            
            # Backups do master (root)
            if hasattr(self.master, '_backup_challenge_tracking'):
                fontes_backup.append((self.master._backup_challenge_tracking, 'master_backup'))
            if hasattr(self.master, '_super_challenge_backup'):
                fontes_backup.append((self.master._super_challenge_backup, 'super_backup'))
            
            # Backup do registry 
            if hasattr(self, '_challenge_backup_registry'):
                fontes_backup.append((self._challenge_backup_registry, 'registry_backup'))
            
            print(f"DEBUG: [RECOVERY] Verificando {len(fontes_backup)} fontes de backup...")
            
            # Procurar Challenge nos backups
            for backup_source, nome_fonte in fontes_backup:
                if carta_path in backup_source:
                    turno_correto = backup_source[carta_path]
                    print(f"DEBUG: [RECOVERY] ‚úì ENCONTRADO em {nome_fonte}: turno {turno_correto}")
                    self._challenge_start_turns[carta_path] = turno_correto
                    print(f"DEBUG: [RECOVERY] ‚úì RECUPERA√á√ÉO DE BACKUP: Challenge registado no turno {turno_correto}")
                    print(f"DEBUG: [RECOVERY] === FIM RECUPERA√á√ÉO (BACKUP) ===")
                    return True
            
            print(f"DEBUG: [RECOVERY] Challenge n√£o encontrado em backups - assumindo Challenge REC√âM ACEITE")
            
            # Se n√£o encontrado em backups, √© Challenge rec√©m aceite no turno atual
            turno_atual = self._current_turn_number
            print(f"DEBUG: [RECOVERY] Turno atual: {turno_atual}")
            print(f"DEBUG: [RECOVERY] CORRE√á√ÉO: Challenge rec√©m aceite deve iniciar NO TURNO ATUAL")
            
            # Registar no turno atual
            self._challenge_start_turns[carta_path] = turno_atual
            print(f"DEBUG: [RECOVERY] ‚úì Challenge registado como REC√âM ACEITE no turno {turno_atual}")
            print(f"DEBUG: [RECOVERY] Challenge ficar√° ativo por toda a sua dura√ß√£o normal")
            print(f"DEBUG: [RECOVERY] === FIM RECUPERA√á√ÉO (NOVA CHALLENGE) ===")
            return True
            
        except Exception as e:
            print(f"DEBUG: [RECOVERY] [ERROR] ERRO durante recupera√ß√£o: {e}")
            print(f"DEBUG: [RECOVERY] === FIM RECUPERA√á√ÉO (ERRO) ===")
            return False
    
    def _debug_challenge_tracking_state(self):
        """
        M√©todo de debug para analisar o estado atual do tracking de Challenges
        e identificar inconsist√™ncias entre carrossel e tracking
        """
        print(f"DEBUG: [TRACKING_DEBUG] ========== ESTADO DO CHALLENGE TRACKING ==========")
        print(f"DEBUG: [TRACKING_DEBUG] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [TRACKING_DEBUG] Challenges no tracking: {len(self._challenge_start_turns)}")
        
        # Analisar tracking atual
        for i, (tracked_path, turno_inicio) in enumerate(self._challenge_start_turns.items(), 1):
            turnos_ativa = self._current_turn_number - turno_inicio + 1
            print(f"DEBUG: [TRACKING_DEBUG] Entrada {i}:")
            print(f"DEBUG: [TRACKING_DEBUG]   Caminho: {tracked_path}")
            print(f"DEBUG: [TRACKING_DEBUG]   Basename: {os.path.basename(tracked_path)}")
            print(f"DEBUG: [TRACKING_DEBUG]   Turno in√≠cio: {turno_inicio}")
            print(f"DEBUG: [TRACKING_DEBUG]   Turnos ativa: {turnos_ativa}")
        
        # Analisar cartas no carrossel
        print(f"DEBUG: [TRACKING_DEBUG] ========== CHALLENGES NO CARROSSEL ==========")
        if hasattr(self, 'cards'):
            for i, carta_path in enumerate(self.cards):
                if carta_path and self._is_challenge_card(carta_path):
                    carta_basename = os.path.basename(carta_path)
                    has_tracking = carta_path in self._challenge_start_turns
                    has_tracking_basename = any(os.path.basename(p) == carta_basename for p in self._challenge_start_turns.keys())
                    
                    print(f"DEBUG: [TRACKING_DEBUG] Posi√ß√£o {i}:")
                    print(f"DEBUG: [TRACKING_DEBUG]   Caminho: {carta_path}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Basename: {carta_basename}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Tem tracking exato: {has_tracking}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Tem tracking basename: {has_tracking_basename}")
                    
                    if not has_tracking and not has_tracking_basename:
                        print(f"DEBUG: [TRACKING_DEBUG]   [WARNING] PROBLEMA: Challenge sem tracking!")
        
        print(f"DEBUG: [TRACKING_DEBUG] ========== FIM AN√ÅLISE TRACKING ==========")
    
    def _register_challenge_start_turn(self, carta_path, turno_especifico=None):
        """
        Regista o turno em que uma carta Challenge foi aceite
        CORRE√á√ÉO CR√çTICA: Aceitar turno espec√≠fico para casos onde o timing √© cr√≠tico
        CORRE√á√ÉO ESPEC√çFICA: Normalizar caminhos para garantir compatibilidade com busca posterior
        CORRE√á√ÉO EMERGENCIAL: Garantir que tracking nunca se perde durante reconstru√ß√µes
        CORRE√á√ÉO FUNDAMENTAL: Detectar se estamos numa substitui√ß√£o e sempre usar turno correto
        
        Args:
            carta_path: Caminho da carta Challenge
            turno_especifico: Turno espec√≠fico para registar (opcional - se None, usa turno atual)
        """
        print(f"DEBUG: [CHALLENGE_REGISTER] === REGISTANDO CHALLENGE START TURN ===")
        print(f"DEBUG: [CHALLENGE_REGISTER] Challenge: {os.path.basename(carta_path)}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Caminho original: {carta_path}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno espec√≠fico solicitado: {turno_especifico}")
        
        # PROTE√á√ÉO CR√çTICA: Inicializar _challenge_start_turns se n√£o existir
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}
            print(f"DEBUG: [CHALLENGE_REGISTER] WARNING: _challenge_start_turns n√£o existia! Inicializado vazio.")
        
        # CORRE√á√ÉO CR√çTICA: Usar turno espec√≠fico se fornecido, sen√£o usar turno atual
        if turno_especifico is not None:
            turno_registo = turno_especifico
            print(f"DEBUG: [CHALLENGE_REGISTER] USANDO TURNO ESPEC√çFICO: {turno_registo}")
        else:
            turno_registo = self._current_turn_number
            print(f"DEBUG: [CHALLENGE_REGISTER] USANDO TURNO ATUAL: {turno_registo}")
        
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno atual do sistema: {self._current_turn_number}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno de registo (aceite neste turno): {turno_registo}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Tracking atual: {self._challenge_start_turns}")
        
        # CORRE√á√ÉO ESPEC√çFICA: Normalizar caminho para usar sempre o basename
        # Isto garante compatibilidade independentemente do caminho completo usado
        challenge_basename = os.path.basename(carta_path)
        
        # CORRE√á√ÉO FUNDAMENTAL: Detectar se esta fun√ß√£o est√° a ser chamada durante aceita√ß√£o/substitui√ß√£o
        # Se turno_especifico foi fornecido, significa que estamos numa opera√ß√£o controlada (aceitar/substituir)
        is_controlled_registration = turno_especifico is not None
        print(f"DEBUG: [CHALLENGE_REGISTER] Opera√ß√£o controlada (aceitar/substituir): {is_controlled_registration}")
        
        # CORRE√á√ÉO CR√çTICA: Verificar se j√° existe registo por basename (busca robusta)
        existing_path = None
        existing_turn = None
        
        # Primeiro verificar caminho exato
        if carta_path in self._challenge_start_turns:
            existing_path = carta_path
            existing_turn = self._challenge_start_turns[carta_path]
        
        # Se n√£o encontrou por caminho exato, procurar por basename
        if not existing_path:
            for tracked_path, turno in self._challenge_start_turns.items():
                if os.path.basename(tracked_path) == challenge_basename:
                    existing_path = tracked_path
                    existing_turn = turno
                    break
        
        # CORRE√á√ÉO FUNDAMENTAL: Se j√° existe registo, distinguir entre opera√ß√µes controladas e recupera√ß√£o autom√°tica
        if existing_path:
            print(f"DEBUG: [CHALLENGE_REGISTER] Challenge {challenge_basename} J√Å tem registo:")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Caminho tracking: {existing_path}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Turno existente: {existing_turn}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Tentativa de re-registo com turno: {turno_registo}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Opera√ß√£o controlada: {is_controlled_registration}")
            
            # CORRE√á√ÉO CR√çTICA: Se √© opera√ß√£o controlada (aceitar/substituir Challenge), SEMPRE atualizar
            if is_controlled_registration:
                print(f"DEBUG: [CHALLENGE_REGISTER] *** OPERA√á√ÉO CONTROLADA DETECTADA ***")
                print(f"DEBUG: [CHALLENGE_REGISTER] Challenge est√° sendo aceite/substitu√≠do AGORA - ATUALIZANDO turno!")
                print(f"DEBUG: [CHALLENGE_REGISTER] SOBRESCREVENDO turno {existing_turn} -> {turno_registo}")
                
                # Atualizar com o turno correto da aceita√ß√£o/substitui√ß√£o
                if existing_path != carta_path:
                    # Migrar chave se necess√°rio
                    del self._challenge_start_turns[existing_path]
                    print(f"DEBUG: [CHALLENGE_REGISTER] Chave migrada: {existing_path} -> {carta_path}")
                
                self._challenge_start_turns[carta_path] = turno_registo
                print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Challenge registado com turno ATUAL {turno_registo}")
                return
            else:
                # Opera√ß√£o n√£o controlada (recupera√ß√£o autom√°tica) - preservar turno existente
                print(f"DEBUG: [CHALLENGE_REGISTER] Opera√ß√£o N√ÉO controlada (recupera√ß√£o autom√°tica)")
                print(f"DEBUG: [CHALLENGE_REGISTER] PRESERVANDO turno original {existing_turn} - N√ÉO sobrescrevendo!")
                
                # CORRE√á√ÉO ESPEC√çFICA: Se os caminhos s√£o diferentes mas o basename igual, 
                # manter o registo com o caminho do carrossel (mais preciso) MAS preservar turno original
                if existing_path != carta_path:
                    print(f"DEBUG: [CHALLENGE_REGISTER] MIGRA√á√ÉO: Atualizando chave de tracking:")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   De: {existing_path}")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   Para: {carta_path}")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   Preservando turno original: {existing_turn}")
                    del self._challenge_start_turns[existing_path]
                    self._challenge_start_turns[carta_path] = existing_turn
                    print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Chave migrada mantendo turno original {existing_turn}")
                else:
                    print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Registo j√° existe e est√° correto - nenhuma a√ß√£o necess√°ria")
                return
        
        # NOTA: O c√≥digo de verifica√ß√£o de substitui√ß√£o foi removido porque agora sempre preservamos
        # o turno original. Substitui√ß√µes devem ser tratadas explicitamente por outras fun√ß√µes.
        
        # Registar novo Challenge com o turno correto de aceita√ß√£o
        self._challenge_start_turns[carta_path] = turno_registo
        print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Challenge {challenge_basename} registado no turno {turno_registo}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Caminho de tracking: {carta_path}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Tracking atualizado: {self._challenge_start_turns}")
        print(f"DEBUG: [CHALLENGE_REGISTER] === FIM REGISTO ===")
        
        # BACKUP CR√çTICO: Salvar tracking no root E master como backup de seguran√ßa
        try:
            # Backup no root (primary)
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root:
                    root._backup_challenge_tracking = self._challenge_start_turns.copy()
                    print(f"DEBUG: [CHALLENGE_REGISTER] BACKUP: Tracking salvo no ROOT (primary)")
            
            # Backup no master (secondary)
            if hasattr(self, 'master') and self.master is not None:
                if not hasattr(self.master, '_challenge_start_turns_backup'):
                    self.master._challenge_start_turns_backup = {}
                self.master._challenge_start_turns_backup[carta_path] = turno_registo
                print(f"DEBUG: [CHALLENGE_REGISTER] BACKUP: Tracking salvo no master (secondary)")
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_REGISTER] WARNING: N√£o foi poss√≠vel salvar backup: {e}")

    
    def _verificar_challenges_tempo_limite(self):
        """
        Verifica se alguma carta Challenge atingiu o limite de n_turns (apenas para logs informativos)
        CORRE√á√ÉO: N√ÉO remove cartas automaticamente - elas devem ser completadas manualmente pelo jogador
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] === VERIFICANDO CHALLENGES COM TEMPO LIMITE (INFO ONLY) ===")
        
        print(f"DEBUG: [CHALLENGE_TIMEOUT] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge registrados: {self._challenge_start_turns}")
        
        challenges_expirados = []
        
        # Verificar todas as cartas no carrossel
        for i, carta_path in enumerate(self.cards):
            if not carta_path or carta_path == os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"):
                continue
                
            # Verificar se √© uma carta Challenge
            carta_basename = os.path.basename(carta_path).lower()
            if not carta_basename.startswith('challenge_'):
                continue
                
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Verificando Challenge: {os.path.basename(carta_path)}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Dados n√£o encontrados para {os.path.basename(carta_path)}")
                continue
                
            n_turns = dados_carta.get('n_turns', 0)
            if n_turns <= 0:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge sem limite de turnos v√°lido: n_turns={n_turns}")
                continue
                
            # Verificar quantos turnos passaram desde que foi ativada
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge {os.path.basename(carta_path)}:")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   n_turns limite: {n_turns}")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   turnos decorridos: {turns_elapsed}")
            
            # Se atingiu o limite, registrar para informa√ß√£o (mas N√ÉO processar automaticamente)
            if turns_elapsed >= n_turns:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] INFO: LIMITE ATINGIDO! Challenge pode ser completado via bot√£o seta")
                challenges_expirados.append(os.path.basename(carta_path))
            else:
                turnos_restantes = n_turns - turns_elapsed
                print(f"DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Ainda tem {turnos_restantes} turno(s) restante(s)")
        
        # Relat√≥rio informativo apenas (sem processamento autom√°tico)
        if challenges_expirados:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] === {len(challenges_expirados)} CHALLENGE(S) PODEM SER COMPLETADOS ===")
            for nome in challenges_expirados:
                print(f"DEBUG: [CHALLENGE_TIMEOUT]   - {nome}: Pronto para completion via bot√£o seta")
        else:
            print("DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Nenhuma carta Challenge atingiu limite de turnos")
        
        # Retornar decis√£o final sobre continuidade da gest√£o
        # Se gestao_deve_continuar n√£o foi definido na l√≥gica principal, usar valor padr√£o
        if gestao_deve_continuar is None:
            print("DEBUG: [COMPLETION] AVISO: gestao_deve_continuar n√£o foi definido - usando valor padr√£o False")
            gestao_deve_continuar = False
        
        print(f"DEBUG: [COMPLETION] === DECIS√ÉO FINAL ===")
        print(f"DEBUG: [COMPLETION] gestao_deve_continuar = {gestao_deve_continuar}")
        return gestao_deve_continuar

    

    

    
    def _mostrar_overlay_completion_tempo_limite(self, carta_path, dados_carta, carta_info, reward):
        """
        Mostra overlay espec√≠fico para completion por tempo limite
        CORRE√á√ÉO CR√çTICA: Prote√ß√µes m√°ximas contra destrui√ß√£o da aplica√ß√£o
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] Mostrando overlay de completion por tempo limite")
        
        # PROTE√á√ÉO CR√çTICA FASE 1: Verifica√ß√µes b√°sicas de estado
        try:
            # Verifica√ß√£o 1: Estado do widget principal
            if not hasattr(self, 'winfo_exists') or not self.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Aplica√ß√£o destru√≠da (winfo_exists) - overlay n√£o pode ser criado")
                return
                
            # Verifica√ß√£o 2: Tentar acessar propriedades b√°sicas
            _ = self.winfo_width()
            _ = self.winfo_height()
            
            # Verifica√ß√£o 3: Verificar se ainda temos acesso aos atributos necess√°rios
            if not hasattr(self, 'screen_width') or not hasattr(self, 'screen_height'):
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Atributos de tela n√£o dispon√≠veis - overlay n√£o pode ser criado")
                return
                
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 1 - aplica√ß√£o destru√≠da: {e}")
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: Erro inesperado fase 1: {e}")
            return
        
        # PROTE√á√ÉO CR√çTICA FASE 2: Tentar criar overlay com fallback completo
        overlay = None
        try:
            # Verifica√ß√£o adicional antes de criar overlay
            if not self.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Aplica√ß√£o destru√≠da antes de criar overlay")
                return
                
            # Criar overlay de fundo
            overlay = tk.Toplevel(self)
            overlay.title("")
            overlay.configure(bg="black")
            overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
            overlay.overrideredirect(True)
            overlay.attributes("-fullscreen", True)
            overlay.lift()
            overlay.focus_set()
            
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 2 - aplica√ß√£o destru√≠da durante cria√ß√£o overlay: {e}")
            if overlay:
                try:
                    overlay.destroy()
                except:
                    pass
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] ERROR: Erro inesperado ao criar overlay: {e}")
            if overlay:
                try:
                    overlay.destroy()
                except:
                    pass
            return
        
        # PROTE√á√ÉO CR√çTICA FASE 3: Criar conte√∫do do overlay com prote√ß√µes adicionais
        try:
            # Verifica√ß√£o cont√≠nua de estado durante cria√ß√£o de widgets
            if not self.winfo_exists() or not overlay.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Widget destru√≠do durante cria√ß√£o de conte√∫do")
                return
            
            # T√≠tulo do overlay
            title_label = tk.Label(
                overlay, 
                text="CHALLENGE - TEMPO LIMITE ATINGIDO!", 
                font=("Helvetica", 28, "bold"),
                bg="black", 
                fg="red"
            )
            title_label.place(relx=0.5, rely=0.15, anchor="center")
            
            # Informa√ß√µes da carta
            carta_nome = os.path.basename(carta_path)
            info_text = f"Carta: {carta_nome}\n"
            info_text += f"Limite de turnos: {carta_info['n_turns']}\n"
            info_text += f"Turnos decorridos: {carta_info['turns_elapsed']}\n\n"
            info_text += f"Valores finais:\n"
            
            carta_index = carta_info['carta_index']
            if carta_index < len(self.card_stats):
                stats = self.card_stats[carta_index]
                info_text += f"Packets Received: {stats['Rxd']}\n"
                info_text += f"Packets Lost: {stats['Lost']}\n"
            
            info_text += f"\nReward obtido: {reward} PICoins"
            
            info_label = tk.Label(
                overlay,
                text=info_text,
                font=("Helvetica", 18),
                bg="black",
                fg="white",
                justify="center"
            )
            info_label.place(relx=0.5, rely=0.5, anchor="center")
            
            # Bot√£o OK com comando seguro
            def safe_close_overlay():
                try:
                    # CORRE√á√ÉO: Limpar tracking de Challenge completado
                    if "challenge" in os.path.basename(carta_path).lower():
                        self._cleanup_completed_challenge_tracking(carta_path)
                        print(f"DEBUG: [COMPLETION_TIMEOUT] Challenge tracking limpo para: {os.path.basename(carta_path)}")
                    
                    if overlay.winfo_exists():
                        overlay.destroy()
                except:
                    pass
            
            ok_button = tk.Button(
                overlay,
                text="OK",
                font=("Helvetica", 16, "bold"),
                bg=self.bar_color if hasattr(self, 'bar_color') else "#AAAAAA",
                fg="black",
                width=10,
                command=safe_close_overlay
            )
            ok_button.place(relx=0.5, rely=0.8, anchor="center")
            
            print("DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Overlay de completion por tempo limite criado com sucesso")
            
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 3 - aplica√ß√£o destru√≠da durante cria√ß√£o de conte√∫do: {e}")
            try:
                overlay.destroy()
            except:
                pass
            print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: N√£o foi poss√≠vel criar overlay - Challenge permanece ativo")
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] ERROR: Erro inesperado ao criar conte√∫do do overlay: {e}")
            try:
                overlay.destroy()
            except:
                pass
            print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: N√£o foi poss√≠vel criar overlay - Challenge permanece ativo")
            return

    def _increment_turn_counter(self):
        """
        Incrementa TODOS os contadores de turnos (chamado no end_turn)
        CORRE√á√ÉO CR√çTICA: Sincronizar todos os sistemas de contagem
        """
        # Detectar ambiente para debug espec√≠fico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        print(f"DEBUG: [TIME_TRACKING] === INCREMENTANDO CONTADORES DE TURNO ===")
        print(f"DEBUG: [TIME_TRACKING] AMBIENTE: {ambiente}")
        print(f"DEBUG: [TIME_TRACKING] Contadores ANTES do incremento:")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_id (Processing): {self._current_turn_id}")
        
        # CORRE√á√ÉO CR√çTICA: Incrementar TODOS os contadores de forma sincronizada
        self._current_turn_number += 1
        self._current_turn += 1
        self._current_turn_id += 1
        
        print(f"DEBUG: [TIME_TRACKING] Contadores AP√ìS incremento (SINCRONIZADOS):")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [TIME_TRACKING] SUCCESS: TODOS OS SISTEMAS AGORA NO TURNO {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING] === FIM INCREMENTO DE CONTADORES ===")
        
        # CR√çTICO: Verificar Challenges que atingiram o tempo limite ap√≥s incremento
        try:
            self._verificar_challenges_tempo_limite()
            print(f"DEBUG: [TIME_TRACKING] SUCCESS: Verifica√ß√£o de tempo limite executada")
        except Exception as e:
            print(f"DEBUG: [TIME_TRACKING] ERROR: Erro na verifica√ß√£o de tempo limite: {e}")
    
    def _cleanup_completed_challenge_tracking(self, carta_path):
        """
        Remove tracking de uma carta Challenge que foi completada
        """
        if carta_path in self._challenge_start_turns:
            del self._challenge_start_turns[carta_path]
            print(f"DEBUG: [TIME_TRACKING] Tracking removido para Challenge completado: {os.path.basename(carta_path)}")
    
    def _cleanup_orphaned_challenge_tracking(self):
        """
        Remove tracking de Challenges √≥rf√£os que n√£o est√£o mais no carrossel.
        Chamado no in√≠cio de cada turno para limpar tracking de Challenges antigos.
        CORRE√á√ÉO CR√çTICA: Tamb√©m limpa todos os backups para evitar restaura√ß√£o.
        """
        print("DEBUG: [ORPHAN_CLEANUP] === LIMPEZA DE TRACKING √ìRF√ÉO ===")
        
        if not hasattr(self, '_challenge_start_turns') or not self._challenge_start_turns:
            print("DEBUG: [ORPHAN_CLEANUP] Nenhum tracking de Challenges para limpar")
            return
        
        # Obter Challenges atualmente no carrossel
        challenges_no_carrossel = set()
        if hasattr(self, 'cards') and self.cards:
            for carta in self.cards:
                if carta and 'challenge' in carta.lower():
                    challenges_no_carrossel.add(carta)
                    print(f"DEBUG: [ORPHAN_CLEANUP] Challenge encontrado no carrossel: {os.path.basename(carta)}")
        
        # Identificar tracking √≥rf√£o
        tracking_orfao = []
        for carta_path in list(self._challenge_start_turns.keys()):
            if carta_path not in challenges_no_carrossel:
                tracking_orfao.append(carta_path)
                print(f"DEBUG: [ORPHAN_CLEANUP] Challenge √≥rf√£o identificado: {os.path.basename(carta_path)}")
        
        # Remover tracking √≥rf√£o
        challenges_removidos = 0
        for carta_path in tracking_orfao:
            if carta_path in self._challenge_start_turns:
                del self._challenge_start_turns[carta_path]
                challenges_removidos += 1
                print(f"DEBUG: [ORPHAN_CLEANUP] ‚úì Tracking √≥rf√£o removido: {os.path.basename(carta_path)}")
        
        # CORRE√á√ÉO CR√çTICA: Limpar tracking √≥rf√£o de TODOS os backups tamb√©m
        backup_locations = []
        
        # 1. Backup no master
        if hasattr(self, 'master') and hasattr(self.master, '_backup_challenge_tracking'):
            master_backup = self.master._backup_challenge_tracking
            backup_locations.append((master_backup, 'master._backup_challenge_tracking'))
        
        # 2. Backup no root - tentar m√∫ltiplas formas de acesso
        root_found = False
        root = None
        if hasattr(self, 'master'):
            # Tentar acessar via self.master.master (normal para Toplevel)
            if hasattr(self.master, 'master'):
                root = self.master.master
                root_found = True
            # Se n√£o funcionar, tentar acessar diretamente via self.master (para root direto)
            elif hasattr(self.master, '_backup_challenge_tracking'):
                root = self.master
                root_found = True
            
            if root_found and hasattr(root, '_backup_challenge_tracking'):
                root_backup = root._backup_challenge_tracking
                backup_locations.append((root_backup, 'root._backup_challenge_tracking'))
        
        # 3. Super backup no master
        if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
            super_backup = self.master._super_challenge_backup
            backup_locations.append((super_backup, 'master._super_challenge_backup'))
        
        # 4. Super backup no root
        if root_found and root and hasattr(root, '_super_challenge_backup'):
            root_super_backup = root._super_challenge_backup
            backup_locations.append((root_super_backup, 'root._super_challenge_backup'))
        
        # Limpar tracking √≥rf√£o de todos os backups
        backups_limpos = 0
        for backup_dict, backup_name in backup_locations:
            backup_removidos = 0
            for carta_path in tracking_orfao:
                if carta_path in backup_dict:
                    del backup_dict[carta_path]
                    backup_removidos += 1
                    print(f"DEBUG: [ORPHAN_CLEANUP] ‚úì Backup √≥rf√£o removido de {backup_name}: {os.path.basename(carta_path)}")
            
            if backup_removidos > 0:
                backups_limpos += 1
                print(f"DEBUG: [ORPHAN_CLEANUP] Backup limpo: {backup_name} ({backup_removidos} entradas removidas)")
        
        print(f"DEBUG: [ORPHAN_CLEANUP] === RESULTADO ===")
        print(f"DEBUG: [ORPHAN_CLEANUP] Challenges no carrossel: {len(challenges_no_carrossel)}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Tracking √≥rf√£o removido: {challenges_removidos}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Backups limpos: {backups_limpos}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Tracking final: {len(self._challenge_start_turns)} entradas")
        
        if challenges_removidos > 0:
            print(f"DEBUG: [ORPHAN_CLEANUP] ‚úì SUCCESS: {challenges_removidos} Challenge(s) √≥rf√£o(s) removido(s) do tracking")
            # Mostrar tracking final limpo
            if self._challenge_start_turns:
                print("DEBUG: [ORPHAN_CLEANUP] Tracking restante:")
                for carta_path, turno in self._challenge_start_turns.items():
                    print(f"DEBUG: [ORPHAN_CLEANUP]   - {os.path.basename(carta_path)}: turno {turno}")
            else:
                print("DEBUG: [ORPHAN_CLEANUP] Tracking completamente limpo")
        else:
            print("DEBUG: [ORPHAN_CLEANUP] Nenhum tracking √≥rf√£o encontrado")
        
        print("DEBUG: [ORPHAN_CLEANUP] === FIM LIMPEZA ===")
    
    def _reset_card_values_on_activation(self, carta_path, posicao_carrossel):
        """
        Reset dos valores das barras de progresso quando uma carta √© ativada no carrossel.
        Sempre come√ßa com: To send = message_size, Rxd = 0, Lost = 0
        """
        try:
            print(f"DEBUG: [RESET_VALUES] Resetando valores para carta: {os.path.basename(carta_path)} na posi√ß√£o {posicao_carrossel}")
            
            # Obter message_size da carta
            message_size = self._get_card_message_size(carta_path)
            if message_size is None:
                print(f"DEBUG: [RESET_VALUES] ERROR: N√£o foi poss√≠vel obter message_size para {os.path.basename(carta_path)}")
                return
            
            # Reset dos valores: To send = message_size, Rxd = 0, Lost = 0
            valores_reset = {
                'To send': message_size,
                'Rxd': 0,
                'Lost': 0
            }
            
            # Atualizar card_stats se existir
            if not hasattr(self, 'card_stats'):
                self.card_stats = {}
            
            self.card_stats[posicao_carrossel] = valores_reset.copy()
            
            print(f"DEBUG: [RESET_VALUES] SUCCESS: Valores resetados para posi√ß√£o {posicao_carrossel}")
            print(f"DEBUG: [RESET_VALUES]   To send: {message_size} (= message_size)")
            print(f"DEBUG: [RESET_VALUES]   Rxd: 0")
            print(f"DEBUG: [RESET_VALUES]   Lost: 0")
            print(f"DEBUG: [RESET_VALUES]   card_stats[{posicao_carrossel}] = {valores_reset}")
            
        except Exception as e:
            print(f"DEBUG: [RESET_VALUES] ERRO ao resetar valores: {e}")
            import traceback
            traceback.print_exc()
    
    def _backup_turn_counters_before_reconstruction(self):
        """
        Faz backup dos contadores de turno antes da reconstru√ß√£o da interface.
        CRITICAL: Garante que os contadores n√£o voltam ao in√≠cio quando h√° substitui√ß√£o.
        """
        print(f"DEBUG: [BACKUP_COUNTERS] === BACKUP CR√çTICO DOS CONTADORES ===")
        print(f"DEBUG: [BACKUP_COUNTERS] Situa√ß√£o: Interface ser√° reconstru√≠da (substitui√ß√£o Challenge/Activity)")
        print(f"DEBUG: [BACKUP_COUNTERS] PROBLEMA: Reconstru√ß√£o pode resetar contadores para turno 1")
        print(f"DEBUG: [BACKUP_COUNTERS] SOLU√á√ÉO: Backup dos valores atuais para restaurar ap√≥s reconstru√ß√£o")
        
        # CORRE√á√ÉO CR√çTICA: Verificar se h√° Challenges rec√©m-registados que podem estar apenas nos backups tempor√°rios
        print(f"DEBUG: [BACKUP_COUNTERS] === VERIFICA√á√ÉO DE CHALLENGES TEMPOR√ÅRIOS ===")
        challenge_tracking_consolidado = getattr(self, '_challenge_start_turns', {}).copy()
        
        # Consolidar Challenges de todos os backups tempor√°rios para n√£o perder nenhum
        backup_sources = []
        
        # 1. Backup imediato do master
        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup_imediato'):
            backup_sources.append(('master_imediato', self.master._challenge_start_turns_backup_imediato))
        
        # 2. Backup do master
        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup'):
            backup_sources.append(('master_backup', self.master._challenge_start_turns_backup))
        
        # 3. Backup do root
        if hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_challenge_tracking'):
                backup_sources.append(('root_backup', root._backup_challenge_tracking))
        
        # 4. Backup da Store (espec√≠fico para Challenges aceites)
        if hasattr(self, 'master') and hasattr(self.master, '_backup_challenge_start_turns'):
            backup_sources.append(('store_backup', self.master._backup_challenge_start_turns))
        
        print(f"DEBUG: [BACKUP_COUNTERS] Fontes de backup encontradas: {len(backup_sources)}")
        
        # Consolidar todos os Challenges de todas as fontes
        for source_name, backup_data in backup_sources:
            if backup_data:
                print(f"DEBUG: [BACKUP_COUNTERS] Processando fonte '{source_name}': {len(backup_data)} itens")
                for challenge_path, turno in backup_data.items():
                    challenge_name = os.path.basename(challenge_path)
                    if challenge_path not in challenge_tracking_consolidado:
                        challenge_tracking_consolidado[challenge_path] = turno
                        print(f"DEBUG: [BACKUP_COUNTERS] ‚úì {challenge_name} consolidado de '{source_name}': turno {turno}")
                    else:
                        print(f"DEBUG: [BACKUP_COUNTERS] {challenge_name} j√° existe no consolidado: turno {challenge_tracking_consolidado[challenge_path]}")
        
        print(f"DEBUG: [BACKUP_COUNTERS] Challenge tracking consolidado: {len(challenge_tracking_consolidado)} itens total")
        for path, turno in challenge_tracking_consolidado.items():
            print(f"DEBUG: [BACKUP_COUNTERS]   - {os.path.basename(path)}: turno {turno}")
        
        # Capturar valores atuais de todos os contadores USANDO tracking consolidado
        current_counters = {
            '_current_turn_number': getattr(self, '_current_turn_number', 1),
            '_current_turn': getattr(self, '_current_turn', 1), 
            '_current_turn_id': getattr(self, '_current_turn_id', 1),
            '_challenge_start_turns': challenge_tracking_consolidado,  # CORRE√á√ÉO: Usar consolidado
            '_event_start_turns': getattr(self, '_event_start_turns', {}).copy(),
            '_service_start_turns': getattr(self, '_service_start_turns', {}).copy(),
            '_event_duration_tracking': getattr(self, '_event_duration_tracking', {}).copy(),
            '_service_duration_tracking': getattr(self, '_service_duration_tracking', {}).copy(),
            '_service_real_activation_turns': getattr(self, '_service_real_activation_turns', {}).copy(),  # NOVO: preservar turnos reais
            '_service_data_volume_tracking': getattr(self, '_service_data_volume_tracking', {}).copy(),  # NOVO: tracking Data Volume
            '_pending_data_volume_expiry_overlays': getattr(self, '_pending_data_volume_expiry_overlays', []).copy()  # NOVO: overlays pendentes
        }
        
        print(f"DEBUG: [BACKUP_COUNTERS] Valores atuais sendo salvos:")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn_number: {current_counters['_current_turn_number']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn: {current_counters['_current_turn']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn_id: {current_counters['_current_turn_id']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   Challenge tracking: {len(current_counters['_challenge_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Event tracking: {len(current_counters['_event_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Service tracking: {len(current_counters['_service_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Service real activation: {len(current_counters['_service_real_activation_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Data Volume tracking: {len(current_counters['_service_data_volume_tracking'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Data Volume pending overlays: {len(current_counters['_pending_data_volume_expiry_overlays'])} itens")
        
        # Salvar no root para sobreviver √† reconstru√ß√£o
        if hasattr(self, 'master') and self.master:
            self.master._backup_turn_counters = current_counters
            print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup salvo no master (janela pai)")
        elif hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root:
                root._backup_turn_counters = current_counters  
                print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup salvo no toplevel root")
        
        # Backup adicional como atributo da classe (fallback)
        self._backup_counters_reconstruction = current_counters
        print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup adicional salvo na inst√¢ncia (fallback)")
        print(f"DEBUG: [BACKUP_COUNTERS] === BACKUP COMPLETO ===")
    
    def _restore_turn_counters_after_reconstruction(self):
        """
        Restaura os contadores de turno ap√≥s a reconstru√ß√£o da interface.
        CORRE√á√ÉO CR√çTICA: Verificar Challenges no carrossel ap√≥s restaura√ß√£o
        """
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURA√á√ÉO DOS CONTADORES ===")
        
        # Tentar restaurar do root primeiro
        backup_counters = None
        
        if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_turn_counters'):
            backup_counters = self.master._backup_turn_counters
            print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no master")
        elif hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_turn_counters'):
                backup_counters = root._backup_turn_counters
                print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no toplevel root")
        elif hasattr(self, '_backup_counters_reconstruction'):
            backup_counters = self._backup_counters_reconstruction
            print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no fallback da inst√¢ncia")
        
        if not backup_counters:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Nenhum backup encontrado - verificando Challenges do carrossel")
            self._ensure_challenge_tracking_integrity()
            return
        
        # Restaurar todos os contadores
        self._current_turn_number = backup_counters.get('_current_turn_number', 1)
        self._current_turn = backup_counters.get('_current_turn', 1)
        self._current_turn_id = backup_counters.get('_current_turn_id', 1)
        self._challenge_start_turns = backup_counters.get('_challenge_start_turns', {}).copy()
        self._event_start_turns = backup_counters.get('_event_start_turns', {}).copy()
        self._service_start_turns = backup_counters.get('_service_start_turns', {}).copy()
        self._event_duration_tracking = backup_counters.get('_event_duration_tracking', {}).copy()
        self._service_duration_tracking = backup_counters.get('_service_duration_tracking', {}).copy()
        self._service_real_activation_turns = backup_counters.get('_service_real_activation_turns', {}).copy()  # NOVO: restaurar turnos reais
        
        # SUPER RESTORATION SYSTEM: Consolidar de m√∫ltiplas fontes de backup
        root = None
        try:
            root = self.master if hasattr(self, 'master') else self.winfo_toplevel()
        except:
            pass
        
        if root:
            # Restaurar Services tracking com consolida√ß√£o m√∫ltipla
            if hasattr(root, '_backup_service_tracking_super'):
                consolidated_services = root._backup_service_tracking_super
                self._service_real_activation_turns.update(consolidated_services)
                print(f"DEBUG: [RESTORE_COUNTERS] Services super backup restaurado: {len(consolidated_services)} entries")
            
            # Consolidar de todas as fontes dispon√≠veis
            if hasattr(root, '_backup_service_tracking'):
                self._service_real_activation_turns.update(root._backup_service_tracking)
            if hasattr(root, '_service_tracking_backup_imediato'):
                self._service_real_activation_turns.update(root._service_tracking_backup_imediato)
            if hasattr(root, '_backup_service_tracking_end_turn'):
                self._service_real_activation_turns.update(root._backup_service_tracking_end_turn)
            
            # Restaurar Events tracking com consolida√ß√£o m√∫ltipla
            if hasattr(root, '_backup_event_tracking_super'):
                consolidated_events = root._backup_event_tracking_super
                self._event_duration_tracking.update(consolidated_events)
                print(f"DEBUG: [RESTORE_COUNTERS] Events super backup restaurado: {len(consolidated_events)} entries")
            
            if hasattr(root, '_backup_event_start_turns_super'):
                consolidated_event_starts = root._backup_event_start_turns_super
                self._event_start_turns.update(consolidated_event_starts)
                print(f"DEBUG: [RESTORE_COUNTERS] Events start turns super backup restaurado: {len(consolidated_event_starts)} entries")
            
            # Consolidar de todas as fontes dispon√≠veis para Events
            if hasattr(root, '_backup_event_tracking'):
                self._event_duration_tracking.update(root._backup_event_tracking)
            if hasattr(root, '_event_tracking_backup_imediato'):
                self._event_duration_tracking.update(root._event_tracking_backup_imediato)
            if hasattr(root, '_backup_event_tracking_end_turn'):
                self._event_duration_tracking.update(root._backup_event_tracking_end_turn)
            
            if hasattr(root, '_backup_event_start_turns'):
                self._event_start_turns.update(root._backup_event_start_turns)
            if hasattr(root, '_backup_event_start_turns_end_turn'):
                self._event_start_turns.update(root._backup_event_start_turns_end_turn)
        
        # NOVO: Restaurar Data Volume tracking de m√∫ltiplas fontes
        if hasattr(root, '_backup_turn_counters'):
            backup_data_volume = backup_counters.get('_service_data_volume_tracking', {})
            if backup_data_volume:
                if not hasattr(self, '_service_data_volume_tracking'):
                    self._service_data_volume_tracking = {}
                self._service_data_volume_tracking.update(backup_data_volume)
                print(f"DEBUG: [RESTORE_COUNTERS] Data Volume tracking backup principal restaurado: {len(backup_data_volume)} itens")
            
            backup_pending_overlays = backup_counters.get('_pending_data_volume_expiry_overlays', [])
            if backup_pending_overlays:
                if not hasattr(self, '_pending_data_volume_expiry_overlays'):
                    self._pending_data_volume_expiry_overlays = []
                self._pending_data_volume_expiry_overlays.extend(backup_pending_overlays)
                print(f"DEBUG: [RESTORE_COUNTERS] Data Volume overlays backup principal restaurado: {len(backup_pending_overlays)} itens")
            
            # Consolidar Data Volume de todas as fontes dispon√≠veis
            if hasattr(root, '_backup_data_volume_tracking'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking)
            if hasattr(root, '_data_volume_tracking_backup_imediato'):
                self._service_data_volume_tracking.update(root._data_volume_tracking_backup_imediato)
            if hasattr(root, '_backup_data_volume_tracking_end_turn'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking_end_turn)
            if hasattr(root, '_backup_data_volume_tracking_super'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking_super)
            
            if hasattr(root, '_backup_data_volume_overlays'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays)
            if hasattr(root, '_backup_data_volume_overlays_end_turn'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays_end_turn)
            if hasattr(root, '_backup_data_volume_overlays_super'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays_super)
        
        # CORRE√á√ÉO CR√çTICA: Verificar se o backup principal tem o _challenge_start_turns atualizado
        print(f"DEBUG: [RESTORE_COUNTERS] Challenge tracking restaurado do backup principal: {len(self._challenge_start_turns)} itens")
        for path, turn in self._challenge_start_turns.items():
            print(f"DEBUG: [RESTORE_COUNTERS]   - {os.path.basename(path)}: turno {turn}")
        
        print(f"DEBUG: [RESTORE_COUNTERS] SUCCESS: Contadores restaurados:")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [RESTORE_COUNTERS]   Challenge tracking: {len(self._challenge_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Event tracking: {len(self._event_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Service tracking: {len(self._service_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Service real activation: {len(self._service_real_activation_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Data Volume tracking: {len(getattr(self, '_service_data_volume_tracking', {}))} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Data Volume pending overlays: {len(getattr(self, '_pending_data_volume_expiry_overlays', []))} itens")
        
        # Debug detalhado dos Services restaurados
        if self._service_real_activation_turns:
            print(f"DEBUG: [RESTORE_COUNTERS] Services com turnos reais preservados:")
            for path, turn in self._service_real_activation_turns.items():
                print(f"DEBUG: [RESTORE_COUNTERS]   - {os.path.basename(path)}: turno real {turn}")
        
        # CORRE√á√ÉO CR√çTICA: N√ÉO chamar _ensure_challenge_tracking_integrity() ap√≥s restore
        # pois ir√° sobrescrever os turnos originais restaurados com o turno atual!
        print(f"DEBUG: [RESTORE_COUNTERS] TRACKING PRESERVADO: Challenges restaurados mant√™m turnos originais")
        
        # CORRE√á√ÉO CR√çTICA CHALLENGE_13: Sistema de restaura√ß√£o m√∫ltiplas camadas
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURA√á√ÉO M√öLTIPLAS CAMADAS ===")
        backup_encontrado = False
        
        try:
            # CAMADA 1: Emergency backup (prioridade m√°xima)
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_challenge_tracking_emergency_backup'):
                emergency_backup = self.master._challenge_tracking_emergency_backup
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 1: Emergency backup encontrado: {emergency_backup}")
                
                for carta_path, turno in emergency_backup.items():
                    self._challenge_start_turns[carta_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 1: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                    backup_encontrado = True
                
                delattr(self.master, '_challenge_tracking_emergency_backup')
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 1: Emergency backup limpo")
            
            # CAMADA 2: Super backup no master  
            if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
                super_backup = self.master._super_challenge_backup
                if super_backup:
                    print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 2: Super backup master encontrado: {super_backup}")
                    
                    for carta_path, turno in super_backup.items():
                        if carta_path not in self._challenge_start_turns:  # N√£o sobrescrever se j√° restaurado
                            self._challenge_start_turns[carta_path] = turno
                            print(f"DEBUG: [RESTORE_COUNTERS] ÔøΩ CAMADA 2: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                            backup_encontrado = True
            
            # CAMADA 3: Super backup no root
            try:
                if hasattr(self.master.master, '_super_challenge_backup'):
                    root_backup = self.master.master._super_challenge_backup
                    if root_backup:
                        print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 3: Super backup root encontrado: {root_backup}")
                        
                        for carta_path, turno in root_backup.items():
                            if carta_path not in self._challenge_start_turns:
                                self._challenge_start_turns[carta_path] = turno
                                print(f"DEBUG: [RESTORE_COUNTERS] [NETWORK] CAMADA 3: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                                backup_encontrado = True
            except:
                print("DEBUG: [RESTORE_COUNTERS] CAMADA 3: Root n√£o acess√≠vel")
            
            # CAMADA 4: Backup registry na inst√¢ncia
            if hasattr(self, '_challenge_backup_registry') and self._challenge_backup_registry:
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 4: Backup registry encontrado: {self._challenge_backup_registry}")
                
                for carta_path, turno in self._challenge_backup_registry.items():
                    if carta_path not in self._challenge_start_turns:
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] [CLIPBOARD] CAMADA 4: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                        backup_encontrado = True
            
            # CAMADA 5: Backup global (√∫ltimo recurso)
            import builtins
            if hasattr(builtins, '_global_challenge_backup') and builtins._global_challenge_backup:
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 5: Backup global encontrado: {builtins._global_challenge_backup}")
                
                for carta_path, turno in builtins._global_challenge_backup.items():
                    if carta_path not in self._challenge_start_turns:
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] [WORLD] CAMADA 5: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                        backup_encontrado = True
                
                # Limpar backup global ap√≥s uso
                builtins._global_challenge_backup = {}
                print("DEBUG: [RESTORE_COUNTERS] CAMADA 5: Backup global limpo")
        
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao processar backups m√∫ltiplas camadas: {e}")
        
        # CORRE√á√ÉO CR√çTICA: Inicializar vari√°vel para backup imediato
        backup_imediato_encontrado = False
        
        try:
            # Verificar backup imediato no master
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_challenge_start_turns_backup_imediato'):
                backup_imediato = self.master._challenge_start_turns_backup_imediato
                print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato encontrado no master: {backup_imediato}")
                
                # Integrar backup imediato no tracking restaurado
                for carta_path, turno in backup_imediato.items():
                    self._challenge_start_turns[carta_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] ‚úì Challenge {os.path.basename(carta_path)} restaurado do backup imediato: turno {turno}")
                    backup_imediato_encontrado = True
                
                # Limpar backup imediato
                delattr(self.master, '_challenge_start_turns_backup_imediato')
                print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato do master limpo")
            
            # CORRE√á√ÉO CR√çTICA CHALLENGE_8: Verificar backup da Store tamb√©m
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_challenge_start_turns'):
                backup_store = self.master._backup_challenge_start_turns
                print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store encontrado no master: {backup_store}")
                
                # CORRE√á√ÉO CR√çTICA: Integrar backup da Store usando caminho completo
                for challenge_path, turno in backup_store.items():
                    self._challenge_start_turns[challenge_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] ‚úì Challenge {os.path.basename(challenge_path)} (caminho: {challenge_path}) restaurado do backup da Store: turno {turno}")
                    backup_imediato_encontrado = True
                
                # Limpar backup da Store
                delattr(self.master, '_backup_challenge_start_turns')
                print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store limpo")
            
            # Verificar tamb√©m no root
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root and hasattr(root, '_challenge_start_turns_backup_imediato'):
                    backup_imediato = root._challenge_start_turns_backup_imediato
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato encontrado no root: {backup_imediato}")
                    
                    # Integrar backup imediato no tracking restaurado  
                    for carta_path, turno in backup_imediato.items():
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] ‚úì Challenge {os.path.basename(carta_path)} restaurado do backup imediato: turno {turno}")
                        backup_imediato_encontrado = True
                    
                    # Limpar backup imediato
                    delattr(root, '_challenge_start_turns_backup_imediato')
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato do root limpo")
                
                # Verificar tamb√©m backup da Store no root
                if root and hasattr(root, '_backup_challenge_start_turns'):
                    backup_store = root._backup_challenge_start_turns
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store encontrado no root: {backup_store}")
                    
                    # CORRE√á√ÉO CR√çTICA: Integrar backup da Store usando caminho completo
                    for challenge_path, turno in backup_store.items():
                        self._challenge_start_turns[challenge_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] ‚úì Challenge {os.path.basename(challenge_path)} (caminho: {challenge_path}) restaurado do backup da Store: turno {turno}")
                        backup_imediato_encontrado = True
                    
                    # Limpar backup da Store do root
                    delattr(root, '_backup_challenge_start_turns')
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store do root limpo")
        
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao processar backup imediato: {e}")
        
        if backup_imediato_encontrado:
            print(f"DEBUG: [RESTORE_COUNTERS] ‚úì BACKUP IMEDIATO INTEGRADO COM SUCESSO!")
            print(f"DEBUG: [RESTORE_COUNTERS] Tracking final com backup imediato: {self._challenge_start_turns}")
        else:
            print(f"DEBUG: [RESTORE_COUNTERS] Nenhum backup imediato encontrado")
        
        # CORRE√á√ÉO CR√çTICA ADICIONAL: Sincronizar _backup_challenge_tracking no root
        # Isto garante que futuras inicializa√ß√µes encontrem o tracking correto
        try:
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root and self._challenge_start_turns:
                    root._backup_challenge_tracking = self._challenge_start_turns.copy()
                    print(f"DEBUG: [RESTORE_COUNTERS] SYNC: _backup_challenge_tracking atualizado no root: {self._challenge_start_turns}")
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao sincronizar _backup_challenge_tracking: {e}")
        
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURA√á√ÉO COMPLETA ===")
        
        # Limpar backup ap√≥s restaurar
        if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_turn_counters'):
            delattr(self.master, '_backup_turn_counters')
        if hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_turn_counters'):
                delattr(root, '_backup_turn_counters')
        if hasattr(self, '_backup_counters_reconstruction'):
            delattr(self, '_backup_counters_reconstruction')
    
    def _ensure_challenge_tracking_integrity(self):
        """
        Assegura que todos os Challenges no carrossel t√™m tracking adequado.
        Esta √© uma medida de seguran√ßa para prevenir perda de tracking.
        """
        print(f"DEBUG: [CHALLENGE_INTEGRITY] === VERIFICANDO INTEGRIDADE DO TRACKING ===")
        
        if not hasattr(self, 'cards') or not self.cards:
            print(f"DEBUG: [CHALLENGE_INTEGRITY] Sem cartas no carrossel - nada a verificar")
            return
        
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}
            print(f"DEBUG: [CHALLENGE_INTEGRITY] _challenge_start_turns inicializado")
        
        challenges_found = 0
        challenges_without_tracking = 0
        
        for i, carta_path in enumerate(self.cards):
            if not carta_path or "back_card_" in carta_path:
                continue
                
            carta_basename = os.path.basename(carta_path).lower()
            if not carta_basename.startswith('challenge_'):
                continue
                
            challenges_found += 1
            print(f"DEBUG: [CHALLENGE_INTEGRITY] Challenge encontrado na posi√ß√£o {i}: {os.path.basename(carta_path)}")
            
            # Verificar se tem tracking (por caminho exato ou basename)
            has_tracking = False
            if carta_path in self._challenge_start_turns:
                has_tracking = True
                print(f"DEBUG: [CHALLENGE_INTEGRITY]   ‚úì Tracking por caminho exato: turno {self._challenge_start_turns[carta_path]}")
            else:
                # Procurar por basename
                for tracked_path, turno in self._challenge_start_turns.items():
                    if os.path.basename(tracked_path) == os.path.basename(carta_path):
                        has_tracking = True
                        print(f"DEBUG: [CHALLENGE_INTEGRITY]   ‚úì Tracking por basename: turno {turno} (migrar chave)")
                        # Migrar chave para o caminho correto
                        del self._challenge_start_turns[tracked_path]
                        self._challenge_start_turns[carta_path] = turno
                        break
            
            if not has_tracking:
                challenges_without_tracking += 1
                print(f"DEBUG: [CHALLENGE_INTEGRITY]   [ERROR] SEM TRACKING para {os.path.basename(carta_path)}")
                
                # CORRE√á√ÉO CR√çTICA: Se _current_turn_number √© 1 (valor padr√£o), N√ÉO registar automaticamente
                # Isto evita sobrescrever tracking correto com valores incorretos durante reconstru√ß√µes
                if self._current_turn_number == 1:
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   PROTE√á√ÉO: Turno atual √© 1 (possivelmente incorreto)")
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   N√ÉO registando automaticamente - aguardar registo manual correto")
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenge permanecer√° sem tracking at√© corre√ß√£o")
                else:
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   Registando com turno atual: {self._current_turn_number}")
                    # Usar a fun√ß√£o com l√≥gica de preserva√ß√£o
                    self._register_challenge_start_turn(carta_path, turno_especifico=self._current_turn_number)
        
        print(f"DEBUG: [CHALLENGE_INTEGRITY] RESULTADO:")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenges encontrados: {challenges_found}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenges sem tracking: {challenges_without_tracking}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Tracking final: {self._challenge_start_turns}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY] === INTEGRIDADE VERIFICADA ===")
    
    # ===============================
    # SISTEMA DE TRACKING DE SERVI√áOS TEMPORARY
    # ===============================
    
    def _register_service_start_turn(self, carta_path):
        """
        Regista o turno em que uma carta Service TEMPORARY foi ativada
        CORRE√á√ÉO: Preservar o turno REAL de ativa√ß√£o, n√£o sobrescrever durante reconstru√ß√µes
        """
        # Verificar se √© um servi√ßo TEMPORARY usando a base de dados
        try:
            service_data = self._get_service_data_from_path(carta_path)
            if service_data and service_data.service_type.value == 'temporary' and service_data.service_turns:
                
                # CORRE√á√ÉO CR√çTICA: Se j√° existe tracking do turno real, PRESERVAR
                if carta_path in self._service_real_activation_turns:
                    turno_real_ativacao = self._service_real_activation_turns[carta_path]
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} J√Å TINHA tracking do turno real: {turno_real_ativacao}")
                    print(f"DEBUG: [SERVICE_TRACKING] PRESERVANDO turno real em vez de usar turno atual ({self._current_turn_number})")
                else:
                    # Primeira vez a ser ativado - registar turno atual como turno real
                    turno_real_ativacao = self._current_turn_number
                    self._service_real_activation_turns[carta_path] = turno_real_ativacao
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} PRIMEIRA ATIVA√á√ÉO no turno {turno_real_ativacao}")
                
                # Usar o turno real (preservado) em vez do turno atual
                self._service_start_turns[carta_path] = turno_real_ativacao
                self._service_duration_tracking[carta_path] = {
                    'duration_turns': service_data.service_turns,
                    'start_turn': turno_real_ativacao  # CORRE√á√ÉO: usar turno real
                }
                
                turnos_decorridos = self._current_turn_number - turno_real_ativacao
                print(f"DEBUG: [SERVICE_TRACKING] Service TEMPORARY {os.path.basename(carta_path)}:")
                print(f"DEBUG: [SERVICE_TRACKING]   Turno real de ativa√ß√£o: {turno_real_ativacao}")
                print(f"DEBUG: [SERVICE_TRACKING]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [SERVICE_TRACKING]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [SERVICE_TRACKING]   Dura√ß√£o total: {service_data.service_turns} turnos")
                
                # Verificar se j√° expirou
                if turnos_decorridos >= service_data.service_turns:
                    print(f"DEBUG: [SERVICE_TRACKING] WARNING: Service {os.path.basename(carta_path)} J√Å EXPIROU!")
                else:
                    print(f"DEBUG: [SERVICE_TRACKING] Service ainda ativo por mais {service_data.service_turns - turnos_decorridos} turnos")
                
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} n√£o √© TEMPORARY - tracking ignorado")
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] ERRO ao registar service: {e}")
    
    def _get_service_data_from_path(self, carta_path):
        """
        Obt√©m dados de um servi√ßo usando a base de dados a partir do caminho
        """
        try:
            # Extrair ID do servi√ßo do caminho (ex: Service_5.png -> service_temporary_5_red)
            filename = os.path.basename(carta_path)
            if not filename.startswith('Service_'):
                return None
                
            # Extrair n√∫mero do servi√ßo
            import re
            match = re.match(r'Service_(\d+)', filename)
            if not match:
                return None
                
            service_number = int(match.group(1))
            
            # Obter todos os servi√ßos e mapear pelo n√∫mero
            all_services = self.card_database.get_all_services()
            if service_number <= len(all_services):
                return all_services[service_number - 1]
                
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] Erro ao obter dados do servi√ßo: {e}")
            
        return None
    
    def _register_data_volume_service(self, carta_path):
        """
        Regista uma carta Service DATA_VOLUME para tracking de pacotes
        """
        try:
            service_data = self._get_service_data_from_path(carta_path)
            if service_data and service_data.service_type.value == 'data_volume' and service_data.service_packets:
                
                # Se j√° existe tracking (por causa de reconstru√ß√£o da interface), preservar
                if carta_path in self._service_data_volume_tracking:
                    print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} J√Å TINHA tracking, preservando...")
                    tracking_data = self._service_data_volume_tracking[carta_path]
                    print(f"DEBUG: [DATA_VOLUME] Pacotes restantes preservados: {tracking_data['packets_remaining']}")
                else:
                    # Primeira vez a ser ativado - inicializar com o n√∫mero total de pacotes
                    self._service_data_volume_tracking[carta_path] = {
                        'packets_remaining': service_data.service_packets,
                        'original_packets': service_data.service_packets
                    }
                    print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} inicializado com {service_data.service_packets} pacotes")
                
            else:
                print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} n√£o √© DATA_VOLUME - tracking ignorado")
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao registar data volume service: {e}")
    
    def _consume_data_volume_packets(self, packets_consumed=1):
        """
        Consome pacotes do pool total de todas as cartas Service DATA_VOLUME ativas
        Distribui a redu√ß√£o pelas cartas ativas usando estrat√©gia FIFO (primeiro a expirar primeiro)
        """
        try:
            print(f"DEBUG: [DATA_VOLUME] === CONSUMINDO {packets_consumed} PACOTES DO POOL TOTAL ===")
            
            # 1. Calcular pool total de pacotes dispon√≠veis
            active_cards = []
            total_packets = 0
            
            for carta_path in list(self._service_data_volume_tracking.keys()):
                if carta_path in self.active_services:  # S√≥ cartas ativas
                    tracking_data = self._service_data_volume_tracking[carta_path]
                    packets_remaining = tracking_data['packets_remaining']
                    
                    if packets_remaining > 0:  # S√≥ cartas com pacotes
                        active_cards.append((carta_path, packets_remaining))
                        total_packets += packets_remaining
                        print(f"DEBUG: [DATA_VOLUME] Service ativo: {os.path.basename(carta_path)} - {packets_remaining} pacotes")
            
            print(f"DEBUG: [DATA_VOLUME] POOL TOTAL: {total_packets} pacotes de {len(active_cards)} cartas")
            
            # 2. Verificar se h√° pacotes suficientes
            if total_packets < packets_consumed:
                print(f"DEBUG: [DATA_VOLUME] [WARNING] POOL INSUFICIENTE: {total_packets} dispon√≠veis, {packets_consumed} requisitados")
                packets_consumed = total_packets  # Consumir s√≥ o que est√° dispon√≠vel
            
            if packets_consumed <= 0:
                print("DEBUG: [DATA_VOLUME] Nenhum pacote para consumir")
                return
                
            # 3. Distribuir redu√ß√£o usando estrat√©gia FIFO (cartas com menos pacotes primeiro)
            # Ordenar cartas por pacotes restantes (ascendente) - as com menos pacotes "expiram" primeiro
            active_cards.sort(key=lambda x: x[1])  # Ordenar por packets_remaining
            
            remaining_to_consume = packets_consumed
            expired_services = []
            
            print(f"DEBUG: [DATA_VOLUME] Distribuindo {packets_consumed} pacotes usando estrat√©gia FIFO:")
            
            for carta_path, current_packets in active_cards:
                if remaining_to_consume <= 0:
                    break
                    
                # Calcular quanto consumir desta carta
                to_consume_from_this = min(remaining_to_consume, current_packets)
                new_packets = current_packets - to_consume_from_this
                
                # Atualizar tracking
                self._service_data_volume_tracking[carta_path]['packets_remaining'] = new_packets
                
                print(f"DEBUG: [DATA_VOLUME] {os.path.basename(carta_path)}: {current_packets} ‚Üí {new_packets} (-{to_consume_from_this})")
                
                # Verificar se expirou
                if new_packets <= 0:
                    print(f"DEBUG: [DATA_VOLUME] EXPIROU: {os.path.basename(carta_path)} ficou sem pacotes!")
                    expired_services.append(carta_path)
                
                remaining_to_consume -= to_consume_from_this
            
            print(f"DEBUG: [DATA_VOLUME] Pool atualizado: {total_packets - packets_consumed + remaining_to_consume} pacotes restantes")
                
            # 4. Processar services expirados
            if expired_services:
                print(f"DEBUG: [DATA_VOLUME] {len(expired_services)} services expiraram por falta de pacotes")
                for expired_service in expired_services:
                    print(f"DEBUG: [DATA_VOLUME] Processando service expirado: {os.path.basename(expired_service)}")
                    
                    # Remover da lista de services ativos
                    if expired_service in self.active_services:
                        self.active_services.remove(expired_service)
                        print(f"DEBUG: [DATA_VOLUME] Service removido dos ativos: {os.path.basename(expired_service)}")
                    
                    # NOVO: Agendar overlay para aparecer IMEDIATAMENTE na interface principal
                    self._schedule_data_volume_expiry_overlay(expired_service)
                
                # NOVO: Verificar se ainda h√° Data Volume services com pacotes dispon√≠veis
                tem_pacotes_disponiveis = self._has_active_data_volume_services_with_packets()
                print(f"DEBUG: [DATA_VOLUME] Ap√≥s expira√ß√£o - ainda h√° pacotes dispon√≠veis: {tem_pacotes_disponiveis}")
                
                # Se n√£o h√° mais pacotes dispon√≠veis E gest√£o est√° ativa, desativar gest√£o
                gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
                if not tem_pacotes_disponiveis and gestao_ativa:
                    print("DEBUG: [DATA_VOLUME] *** SEM PACOTES DISPON√çVEIS - DESATIVANDO GEST√ÉO AUTOMATICAMENTE ***")
                    self._finalizar_gestao_pacotes()
                    
                    # Mostrar overlay imediatamente se estamos na interface principal
                    if hasattr(self, '_pending_data_volume_expiry_overlays') and self._pending_data_volume_expiry_overlays:
                        print("DEBUG: [DATA_VOLUME] *** MOSTRANDO OVERLAY DE DATA VOLUME EXPIRADO IMEDIATAMENTE ***")
                        
                        # NOVO: Transferir overlays pendentes para services_expirados_para_overlay para mostra imediata
                        if not hasattr(self, 'services_expirados_para_overlay'):
                            self.services_expirados_para_overlay = []
                        
                        # Transferir cada overlay pendente para a lista de exibi√ß√£o
                        for expired_service_path in self._pending_data_volume_expiry_overlays[:]:
                            service_expirado = {
                                'file': os.path.basename(expired_service_path),
                                'data': {'service_id': os.path.basename(expired_service_path).replace('.png', '')},
                                'path': expired_service_path,
                                'tipo': 'DATA_VOLUME'
                            }
                            self.services_expirados_para_overlay.append(service_expirado)
                            print(f"DEBUG: [DATA_VOLUME] Overlay transferido para exibi√ß√£o imediata: {os.path.basename(expired_service_path)}")
                        
                        # Limpar lista de pendentes j√° que foram transferidos
                        self._pending_data_volume_expiry_overlays.clear()
                        
                        # Usar after() para garantir que aparece ap√≥s a interface estar est√°vel
                        self.after(500, self._mostrar_overlay_services_expirados_apos_interface)
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao consumir pacotes: {e}")
    
    def _schedule_data_volume_expiry_overlay(self, carta_path):
        """
        Agenda um overlay de Service Data Volume expirado para aparecer no pr√≥ximo turno
        """
        try:
            # Adicionar √† lista de overlays pendentes (similar ao sistema de Services TEMPORARY)
            if not hasattr(self, '_pending_data_volume_expiry_overlays'):
                self._pending_data_volume_expiry_overlays = []
            
            if carta_path not in self._pending_data_volume_expiry_overlays:
                self._pending_data_volume_expiry_overlays.append(carta_path)
                print(f"DEBUG: [DATA_VOLUME] Overlay de expira√ß√£o agendado para: {os.path.basename(carta_path)}")
            else:
                print(f"DEBUG: [DATA_VOLUME] Overlay j√° agendado para: {os.path.basename(carta_path)}")
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao agendar overlay de expira√ß√£o: {e}")
    
    
    def _verificar_services_expirados(self):
        """
        Verifica se algum servi√ßo TEMPORARY expirou baseado no n√∫mero de turnos
        Chamado automaticamente no end_turn()
        """
        print("DEBUG: [SERVICE_EXPIRY] === VERIFICANDO SERVI√áOS EXPIRADOS ===")
        
        services_expirados = []
        
        # Verificar todos os servi√ßos ativos
        for carta_path in self.active_services[:]:  # C√≥pia para evitar modifica√ß√£o durante itera√ß√£o
            if carta_path in self._service_duration_tracking:
                tracking_data = self._service_duration_tracking[carta_path]
                duration_turns = tracking_data['duration_turns']
                start_turn = tracking_data['start_turn']
                
                # Calcular turnos decorridos
                turnos_decorridos = self._current_turn_number - start_turn
                
                print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)}:")
                print(f"DEBUG: [SERVICE_EXPIRY]   In√≠cio: turno {start_turn}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Dura√ß√£o: {duration_turns} turnos")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turno atual: {self._current_turn_number}")
                
                # Verificar se expirou (turnos decorridos >= dura√ß√£o)
                if turnos_decorridos >= duration_turns:
                    print(f"DEBUG: [SERVICE_EXPIRY] TIME: Service {os.path.basename(carta_path)} EXPIROU!")
                    services_expirados.append(carta_path)
        
        if services_expirados:
            print(f"DEBUG: [SERVICE_EXPIRY] {len(services_expirados)} servi√ßos expiraram neste turno")
            # A expira√ß√£o ser√° tratada quando o usu√°rio clicar na carta
        else:
            print("DEBUG: [SERVICE_EXPIRY] Nenhum servi√ßo expirou neste turno")
    
    def _encontrar_todos_services_expirados(self):
        """
        Encontra TODOS os servi√ßos expirados no invent√°rio do jogador
        Retorna uma lista com os caminhos das cartas expiradas ou lista vazia
        """
        print("DEBUG: [SERVICE_BUTTON] === PROCURANDO TODOS OS SERVI√áOS EXPIRADOS ===")
        
        services_expirados = []
        services_inventory = self.inventario.get("services", [])
        
        for carta_path in services_inventory:
            if self._is_service_expired(carta_path):
                print(f"DEBUG: [SERVICE_BUTTON] Service expirado encontrado: {os.path.basename(carta_path)}")
                services_expirados.append(carta_path)
        
        print(f"DEBUG: [SERVICE_BUTTON] Total de servi√ßos expirados encontrados: {len(services_expirados)}")
        return services_expirados
    
    def _encontrar_primeiro_service_expirado(self):
        """
        Encontra o primeiro servi√ßo expirado no invent√°rio do jogador
        Retorna o caminho da carta ou None se n√£o houver servi√ßos expirados
        MANTIDO PARA COMPATIBILIDADE - mas agora usa o m√©todo _encontrar_todos_services_expirados
        """
        print("DEBUG: [SERVICE_BUTTON] === PROCURANDO PRIMEIRO SERVI√áO EXPIRADO (COMPATIBILIDADE) ===")
        
        todos_expirados = self._encontrar_todos_services_expirados()
        
        if todos_expirados:
            primeiro = todos_expirados[0]
            print(f"DEBUG: [SERVICE_BUTTON] Primeiro service expirado: {os.path.basename(primeiro)}")
            return primeiro
        
        print("DEBUG: [SERVICE_BUTTON] Nenhum servi√ßo expirado encontrado no invent√°rio")
        return None
    
    def _encontrar_todos_events_expirados(self):
        """
        Encontra TODOS os events expirados no invent√°rio do jogador
        Retorna uma lista com os caminhos das cartas expiradas ou lista vazia
        """
        print("DEBUG: [EVENT_BUTTON] === PROCURANDO TODOS OS EVENTS EXPIRADOS ===")
        
        events_expirados = []
        events_inventory = self.inventario.get("events", [])
        
        for carta_path in events_inventory:
            if self._is_event_expired(carta_path):
                print(f"DEBUG: [EVENT_BUTTON] Event expirado encontrado: {os.path.basename(carta_path)}")
                events_expirados.append(carta_path)
        
        print(f"DEBUG: [EVENT_BUTTON] Total de events expirados encontrados: {len(events_expirados)}")
        return events_expirados
    
    def _is_service_expired(self, carta_path):
        """
        Verifica se um servi√ßo espec√≠fico expirou
        CORRE√á√ÉO: Usar turno real de ativa√ß√£o em vez de tracking que pode ter sido recriado
        """
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Verificando se Service expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Services com tracking: {list(self._service_duration_tracking.keys())}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Services com turno real: {list(self._service_real_activation_turns.keys())}")
        
        # CORRE√á√ÉO CR√çTICA: Priorizar o turno real de ativa√ß√£o se dispon√≠vel
        if carta_path in self._service_real_activation_turns:
            turno_real_ativacao = self._service_real_activation_turns[carta_path]
            print(f"DEBUG: [SERVICE_EXPIRY_CHECK] USANDO TURNO REAL de ativa√ß√£o: {turno_real_ativacao}")
            
            # Obter dura√ß√£o do Service da base de dados
            try:
                service_data = self._get_service_data_from_path(carta_path)
                if service_data and service_data.service_type.value == 'temporary' and service_data.service_turns:
                    duration_turns = service_data.service_turns
                    
                    turnos_decorridos = self._current_turn_number - turno_real_ativacao
                    expirou = turnos_decorridos >= duration_turns
                    
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)}:")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno real ativa√ß√£o: {turno_real_ativacao}")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Dura√ß√£o: {duration_turns} turnos")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
                    
                    return expirou
                    
                else:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service n√£o √© TEMPORARY - considerado n√£o expirado")
                    return False
                    
            except Exception as e:
                print(f"DEBUG: [SERVICE_EXPIRY_CHECK] ERRO ao obter dados do Service: {e}")
                return False
        
        # FALLBACK: Usar tracking antigo se turno real n√£o dispon√≠vel
        if carta_path not in self._service_duration_tracking:
            print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)} N√ÉO est√° no tracking - considerado n√£o expirado")
            # CORRE√á√ÉO: Verificar se o Service est√° ativo mas sem tracking - recriar tracking se necess√°rio
            if self.is_card_active(carta_path, "services"):
                print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service est√° ATIVO mas sem tracking - tentando recriar...")
                self._register_service_start_turn(carta_path)
                # Ap√≥s recriar, verificar novamente se agora est√° no tracking
                if carta_path in self._service_duration_tracking:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Tracking recriado com sucesso - continuando verifica√ß√£o...")
                else:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Falhou ao recriar tracking - Service considerado n√£o expirado")
                    return False
            else:
                return False
            
        tracking_data = self._service_duration_tracking[carta_path]
        duration_turns = tracking_data['duration_turns']
        start_turn = tracking_data['start_turn']
        
        turnos_decorridos = self._current_turn_number - start_turn
        expirou = turnos_decorridos >= duration_turns
        
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] FALLBACK - Service {os.path.basename(carta_path)}:")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno in√≠cio (tracking): {start_turn}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Dura√ß√£o: {duration_turns} turnos")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)}:")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno in√≠cio: {start_turn}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Dura√ß√£o: {duration_turns} turnos")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        return expirou
    
    def _is_event_expired(self, carta_path):
        """
        Verifica se um event espec√≠fico expirou
        CORRE√á√ÉO: Usar expires_turn quando dispon√≠vel (Events com dura√ß√£o vari√°vel)
        """
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Verificando se Event expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Turno atual: {self._current_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Events com tracking: {list(self._event_duration_tracking.keys())}")
        
        if carta_path not in self._event_duration_tracking:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)} N√ÉO est√° no tracking - considerado n√£o expirado")
            return False
            
        tracking_data = self._event_duration_tracking[carta_path]
        duration_turns = tracking_data.get('duration_turns')
        start_turn = tracking_data.get('start_turn')
        expires_turn = tracking_data.get('expires_turn')
        is_active = tracking_data.get('is_active', False)
        
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)}:")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turno in√≠cio: {start_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Dura√ß√£o: {duration_turns} turnos")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Expires turn: {expires_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Ativo: {is_active}")
        
        # NOVA L√ìGICA: Se expires_turn est√° definido (dado foi lan√ßado), usar isso
        if expires_turn is not None and start_turn is not None:
            expirou = self._current_turn >= expires_turn
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   USANDO expires_turn: {expires_turn}")
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   EXPIROU: {expirou} (turno {self._current_turn} >= {expires_turn})")
            return expirou
        
        # L√ìGICA LEGADA: Para Events com dura√ß√£o fixa
        elif is_active and duration_turns is not None and start_turn is not None:
            # Verificar se duration_turns √© num√©rico antes de calcular
            if duration_turns == "variable":
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Event com dura√ß√£o vari√°vel sem expires_turn - n√£o expirado ainda")
                return False
                
            try:
                duration_turns_int = int(duration_turns)
                turnos_decorridos = self._current_turn - start_turn
                expirou = turnos_decorridos >= duration_turns_int
                
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   USANDO dura√ß√£o fixa: {duration_turns_int}")
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   EXPIROU: {expirou}")
                return expirou
            except (ValueError, TypeError) as e:
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   ERRO: duration_turns inv√°lido: {duration_turns} - {e}")
                return False
        else:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Event inativo ou dados insuficientes - n√£o expirado")
            return False
    
    def _cleanup_expired_service_tracking(self, carta_path):
        """
        Remove tracking de um servi√ßo que expirou
        CORRE√á√ÉO: Limpar tamb√©m o turno real de ativa√ß√£o
        """
        if carta_path in self._service_start_turns:
            del self._service_start_turns[carta_path]
        if carta_path in self._service_duration_tracking:
            del self._service_duration_tracking[carta_path]
        if carta_path in self._service_real_activation_turns:
            del self._service_real_activation_turns[carta_path]
            print(f"DEBUG: [SERVICE_TRACKING] Turno real de ativa√ß√£o removido para Service expirado: {os.path.basename(carta_path)}")
        print(f"DEBUG: [SERVICE_TRACKING] Tracking removido para Service expirado: {os.path.basename(carta_path)}")
    
    def _mostrar_overlays_services_expirados_sequencial(self, services_expirados, index=0):
        """
        Mostra overlays sequenciais para todos os servi√ßos expirados
        
        Args:
            services_expirados (list): Lista de caminhos dos servi√ßos expirados
            index (int): √çndice atual na lista de servi√ßos expirados
        """
        print(f"DEBUG: [SERVICE_SEQUENTIAL] === OVERLAY SEQUENCIAL {index+1}/{len(services_expirados)} ===")
        
        if index >= len(services_expirados):
            print("DEBUG: [SERVICE_SEQUENTIAL] Todos os overlays de servi√ßos expirados foram mostrados")
            # Ap√≥s mostrar todos os overlays, abrir invent√°rio normal de Services
            self.show_inventory_matrix(["services"])
            return
        
        carta_path = services_expirados[index]
        print(f"DEBUG: [SERVICE_SEQUENTIAL] Mostrando overlay para Service {index+1}: {os.path.basename(carta_path)}")
        
        # Mostrar overlay individual para este servi√ßo
        self._mostrar_overlay_service_expirado_sequencial(carta_path, services_expirados, index)
    
    def _mostrar_overlay_service_expirado_sequencial(self, carta_path, services_expirados, index):
        """
        Mostra overlay de servi√ßo expirado individual como parte de uma sequ√™ncia
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Mostrando overlay de expira√ß√£o para {os.path.basename(carta_path)} ({index+1}/{len(services_expirados)})")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativa√ß√£o)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conte√∫do do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # T√≠tulo "Expired Service" em vermelho com contador
        titulo_contador = f"Expired Service ({index+1}/{len(services_expirados)})" if len(services_expirados) > 1 else "Expired Service"
        title_label = tk.Label(
            content_frame, 
            text=f"   {titulo_contador}    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto "Temporary Service has expired"
        service_name = os.path.basename(carta_path).replace('.png', '')
        message_text = "Temporary Service has expired for \n Residential User"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Bot√£o OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_service_expirado_sequencial(overlay, carta_path, services_expirados, index)
        )
        ok_button.pack(pady=20)
    
    def _mostrar_overlay_service_expirado(self, carta_path):
        """
        Mostra overlay de servi√ßo expirado com a carta em fullscreen de fundo
        MANTIDO PARA COMPATIBILIDADE - mas agora chama o sistema sequencial
        """
        print(f"DEBUG: [SERVICE_EXPIRY] M√©todo legado chamado - redirecionando para sistema sequencial")
        
        # Usar o novo sistema sequencial mesmo para um √∫nico servi√ßo
        self._mostrar_overlays_services_expirados_sequencial([carta_path], 0)
    
    def _mostrar_overlay_service_expirado_data_volume(self, carta_path):
        """
        Mostra overlay espec√≠fico para servi√ßo Data Volume expirado por falta de pacotes
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Mostrando overlay espec√≠fico para DATA VOLUME expirado: {os.path.basename(carta_path)}")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conte√∫do do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # T√≠tulo "Data Volume Expired" em vermelho
        title_label = tk.Label(
            content_frame, 
            text="   Data Volume Expired    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto espec√≠fico para Data Volume - "No packets available for transmission"
        message_text = "No packets available for transmission\nfor Residential User"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Bot√£o OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_data_volume_expirado(overlay, carta_path)
        )
        ok_button.pack(pady=10)
        
        print(f"DEBUG: [DATA_VOLUME] Overlay de Data Volume expirado mostrado para: {os.path.basename(carta_path)}")
    
    def _processar_data_volume_expirado(self, overlay, carta_path):
        """
        Processa a expira√ß√£o do servi√ßo Data Volume e fecha o overlay
        """
        print(f"DEBUG: [DATA_VOLUME] Processando expira√ß√£o de Data Volume: {os.path.basename(carta_path)}")
        
        # Processar a expira√ß√£o deste servi√ßo
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar o overlay
        overlay.destroy()
        
        print(f"DEBUG: [DATA_VOLUME] Overlay de Data Volume expirado processado e fechado")
    
    def _processar_service_expirado_sequencial(self, overlay, carta_path, services_expirados, index):
        """
        Processa a expira√ß√£o do servi√ßo sequencialmente e mostra o pr√≥ximo overlay se houver
        """
        print(f"DEBUG: [SERVICE_SEQUENTIAL] Processando expira√ß√£o sequencial de {os.path.basename(carta_path)} ({index+1}/{len(services_expirados)})")
        
        # Processar a expira√ß√£o deste servi√ßo
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar o overlay atual
        overlay.destroy()
        
        # Mostrar o pr√≥ximo overlay se houver mais servi√ßos expirados
        proximo_index = index + 1
        if proximo_index < len(services_expirados):
            print(f"DEBUG: [SERVICE_SEQUENTIAL] Passando para pr√≥ximo servi√ßo: {proximo_index+1}/{len(services_expirados)}")
            # Usar after() para dar tempo ao overlay fechar antes de mostrar o pr√≥ximo
            self.after(100, lambda: self._mostrar_overlays_services_expirados_sequencial(services_expirados, proximo_index))
        else:
            print("DEBUG: [SERVICE_SEQUENTIAL] Todos os servi√ßos expirados foram processados - ficando na interface principal")
            # MUDAN√áA: Em vez de abrir invent√°rio de Services, simplesmente fica na interface principal
            # Overlay foi fechado, interface principal continua vis√≠vel
    
    def _processar_service_expirado_individual(self, carta_path):
        """
        Processa a expira√ß√£o de um servi√ßo individual
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Processando expira√ß√£o individual de {os.path.basename(carta_path)}")
        
        # Remover da lista de servi√ßos ativos
        if carta_path in self.active_services:
            self.active_services.remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service removido da lista ativa")
        
        # CORRE√á√ÉO CR√çTICA: Remover carta do invent√°rio do jogador
        if carta_path in self.inventario.get("services", []):
            self.inventario["services"].remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} removido do invent√°rio do jogador")
        else:
            print(f"DEBUG: [SERVICE_EXPIRY] AVISO: Service {os.path.basename(carta_path)} n√£o encontrado no invent√°rio do jogador")
        
        # CORRE√á√ÉO CR√çTICA: Devolver carta para a Store
        try:
            self._devolver_carta_para_store(carta_path, "services")
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} devolvido para a Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao devolver carta para Store: {e}")
        
        # Limpar tracking do servi√ßo expirado
        self._cleanup_expired_service_tracking(carta_path)
    
    def _processar_service_expirado(self, overlay, carta_path):
        """
        Processa a expira√ß√£o do servi√ßo: remove das cartas ativas, do invent√°rio do jogador e devolve para a Store
        MANTIDO PARA COMPATIBILIDADE
        """
        print(f"DEBUG: [SERVICE_EXPIRY] M√©todo legado de processamento chamado")
        
        # Processar individualmente
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar ao dashboard
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        self._cleanup_expired_service_tracking(carta_path)
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de invent√°rio de Services do jogador (interface completa)
        print(f"DEBUG: [SERVICE_EXPIRY] Abrindo matriz de invent√°rio de Services do jogador")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de invent√°rio de Services (interface completa e formatada)
            self.show_inventory_matrix(["services"], page=0)
            print(f"DEBUG: [SERVICE_EXPIRY] Matriz de invent√°rio de Services aberta com sucesso")
            print(f"DEBUG: [SERVICE_EXPIRY] Processo de expira√ß√£o completo - carta removida do jogador e devolvida √† Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao abrir matriz de invent√°rio de Services: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [SERVICE_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [SERVICE_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [SERVICE_EXPIRY] Servi√ßo {os.path.basename(carta_path)} retornou para o invent√°rio da Store")
    
    def _mostrar_overlays_events_expirados_sequencial(self, events_expirados, index=0):
        """
        Mostra overlays sequenciais para todos os events expirados
        
        Args:
            events_expirados (list): Lista de caminhos dos events expirados
            index (int): √çndice atual na lista de events expirados
        """
        print(f"DEBUG: [EVENT_SEQUENTIAL] === OVERLAY SEQUENCIAL {index+1}/{len(events_expirados)} ===")
        
        if index >= len(events_expirados):
            print("DEBUG: [EVENT_SEQUENTIAL] Todos os overlays de events expirados foram mostrados")
            # Ap√≥s mostrar todos os overlays, abrir invent√°rio normal de Actions/Events
            self.show_inventory_matrix(["actions", "events"])
            return
        
        carta_path = events_expirados[index]
        print(f"DEBUG: [EVENT_SEQUENTIAL] Mostrando overlay para Event {index+1}: {os.path.basename(carta_path)}")
        
        # Mostrar overlay individual para este event
        self._mostrar_overlay_event_expirado_sequencial(carta_path, events_expirados, index)
    
    def _mostrar_overlay_event_expirado_sequencial(self, carta_path, events_expirados, index):
        """
        Mostra overlay de event expirado individual como parte de uma sequ√™ncia
        """
        print(f"DEBUG: [EVENT_EXPIRY] Mostrando overlay de expira√ß√£o para {os.path.basename(carta_path)} ({index+1}/{len(events_expirados)})")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativa√ß√£o)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conte√∫do do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # T√≠tulo "Expired Event" em vermelho com contador
        titulo_contador = f"Expired Event ({index+1}/{len(events_expirados)})" if len(events_expirados) > 1 else "Expired Event"
        title_label = tk.Label(
            content_frame, 
            text=f"   {titulo_contador}    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Obter texto espec√≠fico do tipo de Event
        event_type_text = self._get_event_type_text(carta_path)
        message_text = f"{event_type_text} \nhas expired"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Bot√£o OK verde
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#00AA00",  # Cor verde
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_event_expirado_sequencial(overlay, carta_path, events_expirados, index)
        )
        ok_button.pack(pady=20)
    
    def _processar_event_expirado_sequencial(self, overlay, carta_path, events_expirados, index):
        """
        Processa a expira√ß√£o do event sequencialmente e mostra o pr√≥ximo overlay se houver
        """
        print(f"DEBUG: [EVENT_SEQUENTIAL] Processando expira√ß√£o sequencial de {os.path.basename(carta_path)} ({index+1}/{len(events_expirados)})")
        
        # Processar a expira√ß√£o deste event
        self._processar_event_expirado_individual(carta_path)
        
        # Fechar o overlay atual
        overlay.destroy()
        
        # Mostrar o pr√≥ximo overlay se houver mais events expirados
        proximo_index = index + 1
        if proximo_index < len(events_expirados):
            print(f"DEBUG: [EVENT_SEQUENTIAL] Passando para pr√≥ximo event: {proximo_index+1}/{len(events_expirados)}")
            # Usar after() para dar tempo ao overlay fechar antes de mostrar o pr√≥ximo
            self.after(100, lambda: self._mostrar_overlays_events_expirados_sequencial(events_expirados, proximo_index))
        else:
            print("DEBUG: [EVENT_SEQUENTIAL] Todos os events expirados foram processados")
            # CORRE√á√ÉO: Ap√≥s processar todos, APENAS fechar overlay e permanecer no dashboard
            # N√ÉO abrir invent√°rio automaticamente
            print("DEBUG: [EVENT_SEQUENTIAL] Overlay fechado - permanecendo no dashboard principal")
    
    def _processar_event_expirado_individual(self, carta_path):
        """
        Processa a expira√ß√£o de um event individual
        """
        print(f"DEBUG: [EVENT_EXPIRY] Processando expira√ß√£o individual de {os.path.basename(carta_path)}")
        
        # Remover da lista de eventos ativos (se houver)
        if hasattr(self, 'active_events') and carta_path in self.active_events:
            self.active_events.remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event removido da lista ativa")
        
        # CORRE√á√ÉO CR√çTICA: Remover carta do invent√°rio do jogador
        if carta_path in self.inventario.get("events", []):
            self.inventario["events"].remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do invent√°rio do jogador")
            
            # Marcar que um Event foi removido para a pr√≥xima carta ficar virada para baixo
            self._event_recently_removed = True
            print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
        else:
            print(f"DEBUG: [EVENT_EXPIRY] AVISO: Event {os.path.basename(carta_path)} n√£o encontrado no invent√°rio do jogador")
        
        # CORRE√á√ÉO CR√çTICA: Devolver carta para a Store
        try:
            self._devolver_carta_para_store(carta_path, "events")
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} devolvido para a Store")
        except Exception as e:
            print(f"DEBUG: [EVENT_EXPIRY] Erro ao devolver carta para Store: {e}")
        
        # Limpar tracking do event expirado
        self._cleanup_expired_event_tracking(carta_path)
        
        # NOVA FUNCIONALIDADE: Ativar pr√≥xima carta ap√≥s Event expirar
        # A pr√≥xima carta Action/Event na fila cronol√≥gica fica virada para cima (ativa)
        self._ativar_proxima_carta_apos_event_expirado()
    
    def _ativar_proxima_carta_apos_event_expirado(self):
        """
        Ativa a carta (Action ou Event) que est√° na posi√ß√£o 0 da fila cronol√≥gica ap√≥s um Event expirar
        """
        print("DEBUG: [NEXT_ACTIVATION] === ATIVANDO CARTA NA POSI√á√ÉO 0 AP√ìS EVENT EXPIRADO ===")
        
        # Obter ordem cronol√≥gica atual
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            print("DEBUG: [NEXT_ACTIVATION] Nenhuma carta na fila cronol√≥gica")
            return
        
        # CORRE√á√ÉO: Sempre ativar a carta na posi√ß√£o 0 (topo da fila)
        proxima_carta = chronological_order[0]  # Primeira carta da fila cronol√≥gica
        carta_path = proxima_carta['path']
        carta_tipo = proxima_carta['type']
        
        print(f"DEBUG: [NEXT_ACTIVATION] Ativando carta na posi√ß√£o 0: {os.path.basename(carta_path)} (tipo: {carta_tipo})")
        
        # Verificar se j√° est√° ativa (n√£o deveria estar ap√≥s um Event expirar)
        is_already_active = False
        if carta_tipo == 'actions':
            is_already_active = self.is_card_active(carta_path, 'actions')
        elif carta_tipo == 'events':
            is_already_active = self.is_card_active(carta_path, 'events')
        
        if is_already_active:
            print(f"DEBUG: [NEXT_ACTIVATION] AVISO: Carta {os.path.basename(carta_path)} j√° est√° ativa - n√£o precisa ativar")
            return
        
        # Ativar a carta que est√° no topo da fila
        if carta_tipo == 'actions':
            # Para Actions, adicionar √† lista de actions ativos (se ainda n√£o estiver)
            if carta_path not in self.inventario.get("actions_active", []):
                if "actions_active" not in self.inventario:
                    self.inventario["actions_active"] = []
                self.inventario["actions_active"].append(carta_path)
                print(f"DEBUG: [NEXT_ACTIVATION] Action {os.path.basename(carta_path)} ativado (posi√ß√£o 0)")
        
        elif carta_tipo == 'events':
            # Para Events, adicionar tracking de dura√ß√£o se ainda n√£o estiver
            if carta_path not in self._event_start_turns:
                self._register_event_start_turn(carta_path)
                print(f"DEBUG: [NEXT_ACTIVATION] Event {os.path.basename(carta_path)} ativado (posi√ß√£o 0)")
            else:
                # Se j√° tem tracking mas n√£o est√° ativo, ativar agora
                current_turn = getattr(self, '_current_turn_number', 1)
                self._event_start_turns[carta_path] = current_turn
                
                # Atualizar tracking para ativo
                if carta_path in self._event_duration_tracking:
                    tracking_info = self._event_duration_tracking[carta_path]
                    tracking_info['start_turn'] = current_turn
                    tracking_info['is_active'] = True
                    
                    # Recalcular expira√ß√£o
                    duration_turns = tracking_info.get('duration_turns', 1)
                    tracking_info['expires_turn'] = current_turn + duration_turns
                    
                    print(f"DEBUG: [NEXT_ACTIVATION] Event {os.path.basename(carta_path)} reativado (posi√ß√£o 0)")
                    print(f"DEBUG: [NEXT_ACTIVATION]   Turno in√≠cio: {current_turn}")
                    print(f"DEBUG: [NEXT_ACTIVATION]   Expira no turno: {current_turn + duration_turns}")
        
        print("DEBUG: [NEXT_ACTIVATION] === FIM ATIVA√á√ÉO CARTA POSI√á√ÉO 0 ===")
    
    def _register_event_start_turn(self, carta_path):
        """
        Registra o turno de in√≠cio de um Event quando ativado automaticamente
        """
        current_turn = getattr(self, '_current_turn_number', 1)
        
        # Obter dura√ß√£o do Event da base de dados
        try:
            event_data = self._get_event_data_from_path(carta_path)
            if event_data and event_data.duration_turns:
                duration_turns = event_data.duration_turns
            else:
                duration_turns = 1  # Fallback
        except Exception as e:
            print(f"DEBUG: [REGISTER_EVENT] Erro ao obter dura√ß√£o do Event: {e}")
            duration_turns = 1
        
        # Registrar no tracking
        self._event_start_turns[carta_path] = current_turn
        self._event_duration_tracking[carta_path] = {
            'start_turn': current_turn,
            'duration_turns': duration_turns,
            'expires_turn': current_turn + duration_turns,
            'is_active': True
        }
        
        print(f"DEBUG: [REGISTER_EVENT] Event {os.path.basename(carta_path)} registrado:")
        print(f"DEBUG: [REGISTER_EVENT]   Turno in√≠cio: {current_turn}")
        print(f"DEBUG: [REGISTER_EVENT]   Dura√ß√£o: {duration_turns} turnos")
        print(f"DEBUG: [REGISTER_EVENT]   Expira no turno: {current_turn + duration_turns}")
    
    def _cleanup_expired_event_tracking(self, carta_path):
        """
        Remove tracking de um event que expirou
        """
        if carta_path in self._event_start_turns:
            del self._event_start_turns[carta_path]
        if carta_path in self._event_duration_tracking:
            del self._event_duration_tracking[carta_path]
        print(f"DEBUG: [EVENT_TRACKING] Tracking removido para Event expirado: {os.path.basename(carta_path)}")
    
    def _mostrar_overlay_event_expirado(self, carta_path):
        """
        Mostra overlay de event expirado - agora usa o sistema sequencial
        MANTIDO PARA COMPATIBILIDADE - mas agora chama o sistema sequencial
        """
        print(f"DEBUG: [EVENT_EXPIRY] M√©todo legado chamado - redirecionando para sistema sequencial")
        
        # Usar o novo sistema sequencial mesmo para um √∫nico event
        self._mostrar_overlays_events_expirados_sequencial([carta_path], 0)
    
    def _get_event_type_text(self, carta_path):
        """
        Obt√©m o texto do tipo de Event baseado no caminho da carta usando a base de dados
        
        Args:
            carta_path: Caminho para a carta Event (ex: "/path/Event_55.png")
            
        Returns:
            Texto do tipo do Event (ex: "Transmission Delay", "Link Failure", etc.)
        """
        try:
            # Extrair ID do Event do caminho
            filename = os.path.basename(carta_path)
            match = re.match(r'Event_(\d+)', filename)
            
            if not match:
                print(f"DEBUG: [EVENT_TYPE] Formato de arquivo inv√°lido: {filename}")
                return "Unknown"
            
            event_id = f"event_{match.group(1)}"
            print(f"DEBUG: [EVENT_TYPE] Buscando Event na base de dados: {event_id}")
            
            # Obter Event da base de dados
            if hasattr(self, 'card_database') and self.card_database:
                event_card = self.card_database.get_event(event_id)
                
                if event_card:
                    print(f"DEBUG: [EVENT_TYPE] Event encontrado: {event_card.title}")
                    return event_card.title
                else:
                    print(f"DEBUG: [EVENT_TYPE] Event n√£o encontrado na base de dados: {event_id}")
            else:
                print(f"DEBUG: [EVENT_TYPE] Base de dados n√£o dispon√≠vel")
            
            # Fallback baseado no ID do Event
            event_number = int(match.group(1))
            
            # Mapear n√∫meros para tipos baseado na base de dados
            event_type_mapping = {
                # TRANSMISSION_DELAY Events (1-50)
                range(1, 51): "Transmission Delay",
                # LINK_FAILURE Events (51-100)  
                range(51, 101): "Link Failure",
                # TRAFFIC_BURST Events (101-120)
                range(101, 121): "Traffic Burst",
                # QUEUE_CONGESTION Events (121-130)
                range(121, 131): "Queue Congestion",
                # QUEUE_FULL Events (131-140)
                range(131, 141): "Queue Full",
                # PACKET_DROP Events (141-150)
                range(141, 151): "Packet Drop",
                # EMPTY_QUEUE Events (151-175)
                range(151, 176): "Empty Queue"
            }
            
            # Encontrar tipo baseado no n√∫mero
            for event_range, event_type in event_type_mapping.items():
                if event_number in event_range:
                    print(f"DEBUG: [EVENT_TYPE] Tipo mapeado: {event_type}")
                    return event_type
            
            print(f"DEBUG: [EVENT_TYPE] Tipo n√£o mapeado para n√∫mero: {event_number}")
            return "Unknown Event"
            
        except Exception as e:
            print(f"DEBUG: [EVENT_TYPE] Erro ao obter tipo do Event: {e}")
            return "Unknown Event"
    
    def _processar_event_expirado(self, overlay, carta_path):
        """
        Processa a expira√ß√£o do event: remove do invent√°rio do jogador
        """
        print(f"DEBUG: [EVENT_EXPIRY] Processando expira√ß√£o de {os.path.basename(carta_path)}")
        
        # CORRE√á√ÉO CR√çTICA: Remover carta do invent√°rio do jogador
        if carta_path in self.inventario.get("events", []):
            self.inventario["events"].remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do invent√°rio do jogador")
            
            # Marcar que um Event foi removido para a pr√≥xima carta ficar virada para baixo
            self._event_recently_removed = True
            print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
        else:
            print(f"DEBUG: [EVENT_EXPIRY] AVISO: Event {os.path.basename(carta_path)} n√£o encontrado no invent√°rio do jogador")
        
        # Limpar tracking
        if hasattr(self, '_event_start_turns') and carta_path in self._event_start_turns:
            del self._event_start_turns[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de turno removido para {os.path.basename(carta_path)}")
        
        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
            del self._event_duration_tracking[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de dura√ß√£o removido para {os.path.basename(carta_path)}")
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de invent√°rio de Actions/Events (interface completa)
        print(f"DEBUG: [EVENT_EXPIRY] Voltando para matriz de invent√°rio de Actions/Events")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de invent√°rio de Actions/Events (interface completa e formatada)
            self.show_inventory_matrix(["actions", "events"], page=0)
            print(f"DEBUG: [EVENT_EXPIRY] Matriz de invent√°rio de Actions/Events aberta com sucesso")
            print(f"DEBUG: [EVENT_EXPIRY] Processo de expira√ß√£o completo - carta removida do jogador")
        except Exception as e:
            print(f"DEBUG: [EVENT_EXPIRY] Erro ao abrir matriz de invent√°rio de Actions/Events: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [EVENT_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [EVENT_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do invent√°rio")
    
    
    def _obter_valor_barra_atual(self, tipo_barra):
        """
        Obt√©m o valor atual de uma barra de progresso espec√≠fica
        """
        return self._obter_valor_barra_atual_by_index(tipo_barra, getattr(self, 'selected_card_idx', 0))
    
    def _obter_valor_barra_atual_by_index(self, tipo_barra, card_idx):
        """
        Obt√©m o valor atual de uma barra de progresso espec√≠fica para um √≠ndice de carta espec√≠fico
        """
        try:
            # Verificar se existe dados de estat√≠sticas e √≠ndice v√°lido
            if hasattr(self, 'card_stats') and card_idx < len(self.card_stats):
                valor = self.card_stats[card_idx].get(tipo_barra, 0)
                print(f"DEBUG: [REWARD_CALC] Valor da barra {tipo_barra} (carta {card_idx}): {valor}")
                return valor
            
            print(f"DEBUG: [REWARD_CALC] N√£o foi poss√≠vel obter valor da barra {tipo_barra} para carta {card_idx}, retornando 0")
            return 0
        except Exception as e:
            print(f"DEBUG: [REWARD_CALC] Erro ao obter valor da barra {tipo_barra} para carta {card_idx}: {e}")
            return 0
    
    def _fechar_overlay_completion(self):
        """
        Fecha overlay de completion - M√âTODO LEGADO
        O processamento principal agora √© feito em fechar_e_continuar()
        """
        if hasattr(self, '_overlay_completion') and self._overlay_completion:
            print(f"DEBUG: [COMPLETION] Fechando overlay (m√©todo legado)")
            
            # Apenas fechar overlay - processamento j√° foi feito
            self._overlay_completion.destroy()
            self._overlay_completion = None
            
            # CORRE√á√ÉO: Remover flag de overlay ativo
            self._completion_overlay_active = False
            print(f"DEBUG: [COMPLETION] Flag _completion_overlay_active = False")
            
            print(f"DEBUG: [COMPLETION] Overlay fechado")
    
    def _devolver_carta_para_store(self, carta_path, card_type):
        """
        Devolve carta completada para a Store conforme o tipo:
        - Challenge: volta para o baralho da Store
        - Activity: volta para o invent√°rio Activity da Store
        - Services: volta para o invent√°rio Services da Store
        """
        try:
            print(f"DEBUG: [DEVOLVER_STORE] Devolvendo {card_type}: {os.path.basename(carta_path)}")
            
            # CORRE√á√ÉO CR√çTICA: Primeiro remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # CORRE√á√ÉO: Normalizar tipo para mai√∫sculo para compara√ß√£o
            card_type_normalized = card_type.capitalize() if isinstance(card_type, str) else str(card_type).capitalize()
            
            if card_type_normalized == "Challenge":
                # Challenge volta para o baralho da Store
                self._devolver_challenge_para_baralho(carta_path)
            elif card_type_normalized == "Activity":
                # Activity volta para o invent√°rio Activity da Store
                self._devolver_activity_para_inventario(carta_path)
            elif card_type_normalized == "Services":
                # Services volta para o invent√°rio Services da Store
                self._devolver_service_para_inventario_store(carta_path)
            else:
                print(f"DEBUG: [DEVOLVER_STORE] AVISO: Tipo de carta desconhecido: {card_type} (normalizado: {card_type_normalized})")
                # CORRE√á√ÉO ADICIONAL: Tentar detectar tipo pelo nome do arquivo
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Activity pelo nome do arquivo - devolvendo como Activity")
                    self._devolver_activity_para_inventario(carta_path)
                elif "challenge" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Challenge pelo nome do arquivo - devolvendo como Challenge")
                    self._devolver_challenge_para_baralho(carta_path)
                elif "service" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Service pelo nome do arquivo - devolvendo como Service")
                    self._devolver_service_para_inventario_store(carta_path)
                else:
                    print(f"DEBUG: [DEVOLVER_STORE] ERRO: N√£o foi poss√≠vel determinar tipo da carta")
                
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_STORE] ERRO ao devolver carta √† Store: {e}")
            import traceback
            traceback.print_exc()
    
    def _devolver_challenge_para_baralho(self, carta_path):
        """
        Devolve Challenge completado para o baralho da Store
        """
        try:
            # CORRE√á√ÉO: Limpar tracking do Challenge antes de devolver
            self._cleanup_completed_challenge_tracking(carta_path)
            print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # Determinar cor da carta (geralmente neutral para Challenges)
            cor_carta = self._get_color_from_path(carta_path) or "neutral"
            
            # Tentar devolver via Store_v2 se houver refer√™ncia
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "challenges", cor_carta)
                    print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "challenges" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["challenges"] = []
                
                # Adicionar no in√≠cio do baralho (topo)
                baralhos[cor_carta]["challenges"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho global challenges/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO: N√£o foi poss√≠vel importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO ao devolver Challenge: {e}")
    
    def _devolver_activity_para_inventario(self, carta_path):
        """
        Devolve Activity completada para o invent√°rio Activity da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver refer√™ncia
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "activities", cor_carta)
                    print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao invent√°rio da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "activities" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["activities"] = []
                
                # Adicionar no in√≠cio do baralho (topo)
                baralhos[cor_carta]["activities"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao baralho global activities/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO: N√£o foi poss√≠vel importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO ao devolver Activity: {e}")
    
    def _devolver_service_para_inventario_store(self, carta_path):
        """
        Devolve Service expirado para o invent√°rio Services da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver refer√™ncia
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "services", cor_carta)
                    print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao invent√°rio da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais da Store
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "services" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["services"] = []
                
                # Adicionar no in√≠cio do baralho (topo) para ficar dispon√≠vel imediatamente
                baralhos[cor_carta]["services"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao baralho global services/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_SERVICE] ERRO: N√£o foi poss√≠vel importar baralhos da Store: {e}")
                # Fallback adicional: tentar diretamente atrav√©s de Store_v2
                try:
                    from Store import StoreWindow
                    # Criar inst√¢ncia tempor√°ria da Store para adicionar carta
                    # Nota: Isto √© um fallback extremo, normalmente a store_window deve estar dispon√≠vel
                    print(f"DEBUG: [DEVOLVER_SERVICE] Tentando fallback via StoreWindow direto")
                except Exception as e2:
                    print(f"DEBUG: [DEVOLVER_SERVICE] ERRO no fallback StoreWindow: {e2}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_SERVICE] ERRO ao devolver Service: {e}")
    
    def _remover_carta_do_carrossel(self, carta_path):
        """
        Remove carta completada do carrossel e volta ao estado vazio
        """
        try:
            # CORRE√á√ÉO: Limpar tracking do Challenge se for Challenge
            if "challenge" in os.path.basename(carta_path).lower():
                self._cleanup_completed_challenge_tracking(carta_path)
                print(f"DEBUG: [REMOVER_CARROSSEL] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # Encontrar posi√ß√£o da carta no carrossel
            carta_removida_idx = None
            for i, card_path in enumerate(self.cards):
                if card_path == carta_path:
                    carta_removida_idx = i
                    break
            
            if carta_removida_idx is not None:
                print(f"DEBUG: [COMPLETION] Removendo carta da posi√ß√£o {carta_removida_idx} do carrossel")
                
                # Voltar para carta de costas padr√£o
                default_card = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                self.cards[carta_removida_idx] = default_card
                
                # NOVA FUNCIONALIDADE: Atualizar flag da carta para False (virada para baixo)
                if hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags[carta_removida_idx] = False
                    print(f"DEBUG: [COMPLETION] Flag da posi√ß√£o {carta_removida_idx} atualizada para False (virada para baixo)")
                    print(f"DEBUG: [COMPLETION] Estados das cartas: {self.card_face_up_flags}")
                
                # Resetar estat√≠sticas da carta
                self.card_stats[carta_removida_idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # NOTA: N√ÉO removemos da lista de gest√£o aqui - isso √© feito antes na fun√ß√£o de completion
                # Apenas removemos visualmente do carrossel
                
                # Atualizar carrossel visual
                self.atualizar_carrossel()
                
                # Se a carta removida era a carta atual, atualizar barras de progresso
                if carta_removida_idx == self.selected_card_idx:
                    self.update_progress_bars_for_card(carta_removida_idx)
                
                print(f"DEBUG: [COMPLETION] Carta removida com sucesso da posi√ß√£o {carta_removida_idx}")
            else:
                print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta_path)} n√£o encontrada no carrossel")
        
        except Exception as e:
            print(f"DEBUG: [COMPLETION] ERRO ao remover carta do carrossel: {e}")
            import traceback
            traceback.print_exc()
    
    def _atualizar_display_saldo(self):
        """
        Atualiza o display do saldo na interface (se existir)
        """
        # Procurar por widgets de saldo na interface principal
        for widget in self.winfo_children():
            if isinstance(widget, tk.Label):
                # Tentar encontrar label do saldo pelo texto num√©rico
                try:
                    texto = widget.cget("text")
                    if texto.isdigit():
                        widget.config(text=str(self.saldo))
                        print(f"DEBUG: [COMPLETION] Display do saldo atualizado para {self.saldo}")
                        break
                except:
                    continue
    
    def _carta_pode_processar_pacotes(self, carta_path):
        """
        Verifica se uma carta ainda tem capacidade de processamento restante.
        Uma carta N√ÉO pode processar mais se:
        1. Para Activities: Rxd >= message_size E To send <= 0
        2. Para Activities: J√° processou rate_max pacotes neste turno
        3. Para Challenges: Similar mas com regras espec√≠ficas
        
        Returns:
            bool: True se a carta pode processar mais pacotes, False caso contr√°rio
        """
        try:
            carta_basename = os.path.basename(carta_path).lower()
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem dados - N√ÉO pode processar")
                return False
            
            rate_max = dados_carta.get('rate', 1)
            message_size = dados_carta.get('message_size', 20)
            
            # Encontrar posi√ß√£o da carta no carrossel para obter valores atuais
            posicao_carrossel = None
            if hasattr(self, 'cards') and carta_path in self.cards:
                posicao_carrossel = self.cards.index(carta_path)
            
            if posicao_carrossel is None:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: n√£o encontrada no carrossel - N√ÉO pode processar")
                return False
            
            # Obter valores atuais das barras
            if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                stats = self.card_stats[posicao_carrossel]
                to_send_atual = stats.get('To send', 0)
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem stats - N√ÉO pode processar")
                return False
            
            # Verificar quantos pacotes foram processados NESTE turno
            rxd_processado_turno = self._get_processed_this_turn(carta_path, 'rxd')
            lost_processado_turno = self._get_processed_this_turn(carta_path, 'lost')
            total_processado_turno = rxd_processado_turno + lost_processado_turno
            
            print(f"DEBUG: [PODE_PROCESSAR] === VERIFICA√á√ÉO CARTA {os.path.basename(carta_path)} ===")
            print(f"DEBUG: [PODE_PROCESSAR] Valores atuais: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            print(f"DEBUG: [PODE_PROCESSAR] Rate m√°ximo por turno: {rate_max}")
            print(f"DEBUG: [PODE_PROCESSAR] Message size (limite total): {message_size}")
            print(f"DEBUG: [PODE_PROCESSAR] Processado neste turno: Rxd={rxd_processado_turno}, Lost={lost_processado_turno}, Total={total_processado_turno}")
            
            # REGRA 1: Verificar limite por turno (rate_max)
            if total_processado_turno >= rate_max:
                print(f"DEBUG: [PODE_PROCESSAR] ERROR: Limite por turno atingido ({total_processado_turno}/{rate_max})")
                return False
            
            # REGRA 2: Para Activities - verificar completion
            if "activity" in carta_basename:
                # Activity completa quando: To send = 0 E Rxd >= message_size
                if to_send_atual <= 0 and rxd_atual >= message_size:
                    print(f"DEBUG: [PODE_PROCESSAR] ERROR: Activity completada (To send={to_send_atual}, Rxd={rxd_atual}/{message_size})")
                    return False
                
                # Verificar se ainda pode incrementar Rxd ou Lost
                pode_incrementar_rxd = (rxd_atual < message_size and rxd_processado_turno < rate_max)
                
                # Para Lost: verificar se drops s√£o permitidos
                drops_allowed = dados_carta.get('drops_allowed', False)
                penalty_per_packet = dados_carta.get('penalty_per_packet')
                lost_permitido = drops_allowed or penalty_per_packet is not None
                pode_incrementar_lost = (lost_permitido and lost_atual < message_size and lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Activity pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            # REGRA 3: Para Challenges - similar mas com regras espec√≠ficas
            elif "challenge" in carta_basename:
                # Challenge pode processar enquanto n√£o atingir rate_max neste turno
                pode_incrementar_rxd = (rxd_processado_turno < rate_max)
                pode_incrementar_lost = (lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Challenge pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            print(f"DEBUG: [PODE_PROCESSAR] ERROR: Tipo de carta n√£o reconhecido: {carta_basename}")
            return False
            
        except Exception as e:
            print(f"DEBUG: [PODE_PROCESSAR] ERROR: ERRO ao verificar carta {os.path.basename(carta_path)}: {e}")
            return False
    
    def _atualizar_barras_gestao_carta_atual(self):
        """
        CORRE√á√ÉO CR√çTICA: Atualiza barras usando sempre a carta REAL do carrossel
        e n√£o a carta preservada que pode estar incorreta
        """
        print(f"DEBUG: [GEST√ÉO_PACOTES] === ATUALIZA√á√ÉO BARRAS CARTA SELECIONADA ===")
        
        # CORRE√á√ÉO FUNDAMENTAL: SEMPRE usar a carta que est√° REALMENTE no carrossel
        # em vez de confiar na carta preservada que pode estar desatualizada
        carta_atual = None
        posicao_carrossel = None
        
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            posicao_carrossel = self.selected_carousel_index
            carta_atual = self.cards[posicao_carrossel]
            
            print(f"DEBUG: [GEST√ÉO_PACOTES]   SUCCESS: USANDO CARTA REAL DO CARROSSEL:")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Posi√ß√£o no carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Carta REAL: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar se h√° diferen√ßa entre carta real e preservada
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: [GEST√ÉO_PACOTES]   WARNING: DIFEREN√áA DETECTADA:")
                    print(f"DEBUG: [GEST√ÉO_PACOTES]   Carta preservada: {carta_preservada}")
                    print(f"DEBUG: [GEST√ÉO_PACOTES]   Carta real: {carta_real}")
                    print(f"DEBUG: [GEST√ÉO_PACOTES]   SUCCESS: USANDO A CARTA REAL!")
            
        else:
            # Fallback: usar sistema antigo se n√£o h√° carrossel v√°lido
            if hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao'):
                carta_atual = self._cartas_gestao[self._carta_atual_gestao]
                carta_basename = os.path.basename(carta_atual)
                
                print(f"DEBUG: [GEST√ÉO_PACOTES] === FALLBACK - CARTA ATUAL (SISTEMA ANTIGO) ===")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   Carta: {carta_basename}")
                print(f"DEBUG: [GEST√ÉO_PACOTES]   √çndice gest√£o: {self._carta_atual_gestao}")
                
                # Encontrar a posi√ß√£o real no carrossel (self.cards)
                posicao_carrossel = None
                if hasattr(self, 'cards'):
                    for i, card_path in enumerate(self.cards):
                        if card_path == carta_atual:
                            posicao_carrossel = i
                            break
                
                if posicao_carrossel is None:
                    print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: Carta n√£o encontrada no carrossel!")
                    return
                
                print(f"DEBUG: [GEST√ÉO_PACOTES]   Posi√ß√£o real no carrossel: {posicao_carrossel}")
            else:
                print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO: N√£o h√° informa√ß√£o de cartas!")
                return
        
        # CORRE√á√ÉO: Verificar se h√° valores preservados para esta carta primeiro
        preserved_stats = None
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[posicao_carrossel]
            print(f"DEBUG: [GEST√ÉO_PACOTES] Stats preservadas encontradas: {preserved_stats}")
        
        # CORRE√á√ÉO: Se h√° stats preservadas, usar essas; sen√£o buscar da base de dados
        if preserved_stats:
            # Usar valores preservados do turno atual
            to_send_atual = preserved_stats.get('To send', 0)
            rxd_atual = preserved_stats.get('Rxd', 0) 
            lost_atual = preserved_stats.get('Lost', 0)
            
            # Obter message_size da base de dados para m√°ximo das barras
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: USANDO VALORES PRESERVADOS:")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   To send: {to_send_atual}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Rxd: {rxd_atual}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Lost: {lost_atual}")
            print(f"DEBUG: [GEST√ÉO_PACOTES]   Message size (m√°ximo): {message_size}")
            
        else:
            # Fallback: usar base de dados se n√£o h√° valores preservados
            print(f"DEBUG: [GEST√ÉO_PACOTES] WARNING: Sem valores preservados - usando base de dados")
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            # Verificar se h√° valores nos _valores_pacotes (antigo sistema)
            if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
                valores = self._valores_pacotes[self._carta_atual_gestao]
                total_processado = valores['enviados'] + valores['perdidos']
                to_send_atual = max(message_size - total_processado, 0)
                rxd_atual = valores['enviados']
                lost_atual = valores['perdidos']
            else:
                # Reset completo se n√£o h√° dados
                to_send_atual = message_size
                rxd_atual = 0
                lost_atual = 0
        
        # Atualizar todas as barras com os valores corretos
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            # Atualizar To send
            if "To send" in self.progress_bars and "To send" in self.progress_labels:
                self.progress_bars["To send"].config(value=to_send_atual, maximum=message_size)
                self.progress_labels["To send"].config(text=str(to_send_atual))
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: To send atualizada: {to_send_atual}/{message_size}")
            
            # Atualizar Rxd
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=rxd_atual, maximum=message_size)
                self.progress_labels["Rxd"].config(text=str(rxd_atual))
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Rxd atualizada: {rxd_atual}")
            
            # Atualizar Lost
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=lost_atual, maximum=message_size)
                self.progress_labels["Lost"].config(text=str(lost_atual))
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Lost atualizada: {lost_atual}")
                
            # IMPORTANTE: Sincronizar os valores preservados com o que est√° nas barras
            if preserved_stats is None and hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                self.card_stats[posicao_carrossel] = {
                    'To send': to_send_atual,
                    'Rxd': rxd_atual,
                    'Lost': lost_atual
                }
                print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Stats sincronizadas na posi√ß√£o {posicao_carrossel}")
        else:
            print("DEBUG: [GEST√ÉO_PACOTES] ERROR: Barras de progresso n√£o encontradas para atualiza√ß√£o")
    
    def _mostrar_botao_seta(self):
        """Mostra bot√£o seta (‚Üí) na mesma altura do End Turn com cor roxa"""
        print("DEBUG: [GEST√ÉO_PACOTES] === INICIANDO CRIA√á√ÉO DO BOT√ÉO SETA ===")
        
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                print("DEBUG: [GEST√ÉO_PACOTES] Removendo bot√£o seta existente...")
                self._btn_seta.destroy()
            except (tk.TclError, AttributeError):
                print("DEBUG: [GEST√ÉO_PACOTES] Erro ao remover bot√£o seta existente")
                pass
        
        try:
            self._btn_seta = tk.Button(
                self,
                text="‚Üí",
                font=("Helvetica", 16, "bold"),
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                command=self._proxima_carta_gestao,
                width=3,
                height=1
            )
            
            # Posicionar na mesma altura (rely) que o End Turn (aproximadamente)
            # End Turn est√° em rely=0.945, ent√£o usamos uma posi√ß√£o ligeiramente diferente
            self._btn_seta.place(relx=0.05, rely=0.945, anchor="w")
            
            # For√ßar o bot√£o a aparecer por cima de todos os outros elementos
            self._btn_seta.lift()
            
            # Atualizar a interface para garantir que o bot√£o aparece
            self.update_idletasks()
            
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Bot√£o seta criado com sucesso!")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Posi√ß√£o: relx=0.05, rely=0.945")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Widget existe: {hasattr(self, '_btn_seta') and self._btn_seta}")
            
        except Exception as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: ERRO ao criar bot√£o seta: {e}")
            self._btn_seta = None
    
    def _proxima_carta_gestao(self):
        """
        NOVA FUNCIONALIDADE: 
        1. Verificar PRIMEIRO se √© Challenge na Final Phase (independente da posi√ß√£o)
        2. Se for Challenge na Final Phase, mostrar overlay completion
        3. Caso contr√°rio, continuar gest√£o normal
        """
        print(f"DEBUG: [SETA_COMPLETION] ===== BOT√ÉO SETA CLICADO =====")
        print(f"DEBUG: [SETA_COMPLETION] Carta atual (√≠ndice): {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION] Total de cartas gest√£o: {len(self._cartas_gestao)}")
        
        # CORRE√á√ÉO CR√çTICA: Bloquear temporariamente cliques no carrossel por 500ms
        # para evitar fullscreen acidental ap√≥s clique no bot√£o seta
        self._bloqueio_temporario_carrossel = True
        self.after(500, lambda: setattr(self, '_bloqueio_temporario_carrossel', False))
        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Bloqueio tempor√°rio do carrossel ativado por 500ms")
        
        # CORRE√á√ÉO CR√çTICA: Validar √≠ndices antes de acessar as listas
        print(f"DEBUG: [SETA_COMPLETION] Valida√ß√£o inicial:")
        print(f"DEBUG: [SETA_COMPLETION]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [SETA_COMPLETION]   _cartas_gestao: {[os.path.basename(c) for c in self._cartas_gestao]}")
        
        # CORRE√á√ÉO FUNDAMENTAL: Verificar se o √≠ndice √© v√°lido antes de acessar
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: √çndice gest√£o ({self._carta_atual_gestao}) >= tamanho lista ({len(self._cartas_gestao)})")
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: CORRE√á√ÉO: Usando carta selecionada do carrossel como refer√™ncia")
            selected_carta = getattr(self, 'selected_carousel_card', None)
            if selected_carta:
                carta_atual = selected_carta
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Carta corrigida para: {os.path.basename(carta_atual)}")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO CR√çTICO: Sem carta selecionada no carrossel")
                return
        else:
            # CORRE√á√ÉO CR√çTICA: Garantir que estamos a processar a carta CORRETA
            # A carta atual da gest√£o deve corresponder √† carta selecionada no carrossel
            carta_atual = self._cartas_gestao[self._carta_atual_gestao]
            selected_carta = getattr(self, 'selected_carousel_card', None)
        
        print(f"DEBUG: [SETA_COMPLETION] Carta gest√£o atual: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [SETA_COMPLETION] Carta selecionada carrossel: {os.path.basename(selected_carta) if selected_carta else 'None'}")
        
        # CORRE√á√ÉO FUNDAMENTAL: Se h√° discrep√¢ncia E a gest√£o tem cartas v√°lidas, usar a carta selecionada do carrossel
        # que √© a que est√° destacada em roxo e vis√≠vel ao utilizador
        if (selected_carta and 
            len(self._cartas_gestao) > 0 and 
            self._carta_atual_gestao < len(self._cartas_gestao) and 
            selected_carta != carta_atual):
            print(f"DEBUG: [SETA_COMPLETION] WARNING: DISCREP√ÇNCIA DETECTADA!")
            print(f"DEBUG: [SETA_COMPLETION] Gest√£o: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [SETA_COMPLETION] Carrossel: {os.path.basename(selected_carta)}")
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: CORRIGINDO - Usando carta do carrossel como refer√™ncia")
            carta_atual = selected_carta
            
            # Atualizar a posi√ß√£o da gest√£o para corresponder √† carta correta
            try:
                nova_posicao_gestao = self._cartas_gestao.index(carta_atual)
                self._carta_atual_gestao = nova_posicao_gestao
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Posi√ß√£o gest√£o corrigida para: {nova_posicao_gestao}")
            except ValueError:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: AVISO: Carta selecionada n√£o est√° na lista de gest√£o")
                print(f"DEBUG: [SETA_COMPLETION] Lista gest√£o: {[os.path.basename(c) for c in self._cartas_gestao]}")
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Continuando com carta selecionada do carrossel")
        elif selected_carta and len(self._cartas_gestao) == 0:
            print(f"DEBUG: [SETA_COMPLETION] WARNING: Lista gest√£o vazia - usando carta selecionada do carrossel")
            carta_atual = selected_carta
        
        carta_basename = os.path.basename(carta_atual).lower()
        
        print(f"DEBUG: [SETA_COMPLETION] Carta final a processar: {carta_basename}")
        
        # CORRE√á√ÉO: Verificar PRIMEIRO se √© Challenge que atingiu tempo limite
        is_challenge_card = "challenge" in carta_basename
        
        if is_challenge_card:
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Challenge detectado - verificando tempo limite")
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_atual)
            
            if dados_carta and 'n_turns' in dados_carta:
                n_turns = dados_carta['n_turns']
                
                # NOVA VERIFICA√á√ÉO: Usar a mesma l√≥gica do end_turn() para verificar tempo limite
                if n_turns > 0:
                    print(f"DEBUG: [SETA_COMPLETION] Verifica√ß√£o de tempo limite:")
                    print(f"DEBUG: [SETA_COMPLETION]   Challenge: {os.path.basename(carta_atual)}")
                    print(f"DEBUG: [SETA_COMPLETION]   n_turns limite: {n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   Turno atual: {self._current_turn_number}")
                    
                    # CORRE√á√ÉO CR√çTICA: Usar exatamente a mesma l√≥gica que o end_turn() para verificar tempo limite
                    # Isso garante consist√™ncia entre a gest√£o e o final do turno
                    
                    # Calcular turnos decorridos usando a fun√ß√£o oficial
                    turns_elapsed = self._get_turns_elapsed_for_challenge(carta_atual)
                    
                    print(f"DEBUG: [SETA_COMPLETION] AN√ÅLISE DETALHADA DO TEMPO LIMITE:")
                    print(f"DEBUG: [SETA_COMPLETION]   Challenge: {os.path.basename(carta_atual)}")
                    print(f"DEBUG: [SETA_COMPLETION]   n_turns limite: {n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   Turnos decorridos: {turns_elapsed}")
                    print(f"DEBUG: [SETA_COMPLETION]   Compara√ß√£o: {turns_elapsed} >= {n_turns}?")
                    
                    # L√ìGICA UNIFICADA: Usar exatamente a mesma condi√ß√£o do end_turn()
                    tempo_limite_atingido = (turns_elapsed >= n_turns) and (n_turns > 0)
                    
                    print(f"DEBUG: [SETA_COMPLETION]   RESULTADO: tempo_limite_atingido = {tempo_limite_atingido}")
                    print(f"DEBUG: [SETA_COMPLETION]   VALIDA√á√ÉO: turns_elapsed({turns_elapsed}) >= n_turns({n_turns}) = {turns_elapsed >= n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   VALIDA√á√ÉO: n_turns({n_turns}) > 0 = {n_turns > 0}")
                    print(f"DEBUG: [SETA_COMPLETION]   RESULTADO FINAL: {tempo_limite_atingido}")
                    
                    if tempo_limite_atingido:
                        print(f"DEBUG: [SETA_COMPLETION] *** TEMPO LIMITE ATINGIDO! ***")
                        print(f"DEBUG: [SETA_COMPLETION] *** Challenge esteve ativo por {turns_elapsed} turnos (limite: {n_turns}) ***")
                        print(f"DEBUG: [SETA_COMPLETION] *** COMPLETION OBRIGAT√ìRIO NECESS√ÅRIO ***")
                    else:
                        print(f"DEBUG: [SETA_COMPLETION] Challenge ainda ativo: {turns_elapsed}/{n_turns} turnos")
                    
                    # CORRE√á√ÉO CR√çTICA: Challenges que atingiram tempo limite DEVEM ser completados
                    # quando o jogador clicar no bot√£o seta, independente do estado dos pacotes
                    if tempo_limite_atingido:
                        print(f"DEBUG: [SETA_COMPLETION] *** TEMPO LIMITE ATINGIDO! ***")
                        print(f"DEBUG: [SETA_COMPLETION] Challenge deve ser completado obrigatoriamente com valores atuais")
                        
                        # Obter valores atuais das barras para o completion
                        carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                        
                        if carta_index_carrossel is None:
                            for i, carta_carrossel in enumerate(self.cards):
                                if carta_carrossel == carta_atual:
                                    carta_index_carrossel = i
                                    break
                        
                        if carta_index_carrossel is not None:
                            stats = self.card_stats[carta_index_carrossel] if carta_index_carrossel < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            print(f"DEBUG: [SETA_COMPLETION] COMPLETION OBRIGAT√ìRIO - Valores finais:")
                            print(f"DEBUG: [SETA_COMPLETION]   To send: {stats['To send']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Rxd: {stats['Rxd']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Lost: {stats['Lost']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Motivo: Tempo limite atingido ({turns_elapsed}/{n_turns} turnos)")
                            
                            # Preservar valores antes de mostrar completion
                            self._preservar_valores_atuais_barras()
                            
                            # Mostrar overlay de completion por tempo limite
                            self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel, tempo_limite_obrigatorio=True)
                            return
                        else:
                            print(f"DEBUG: [SETA_COMPLETION] ERROR: N√£o foi poss√≠vel encontrar carta no carrossel")
                            return
                
                # Se n√£o atingiu tempo limite, verificar completion normal por pacotes
                message_size = dados_carta.get('message_size', 0)
                
                # Obter valores atuais das barras (posi√ß√£o atual do carrossel)
                current_to_send = 0
                current_rxd = 0
                
                try:
                    if hasattr(self, 'progress_labels'):
                        # CORRE√á√ÉO: Usar formato correto para obter texto dos labels
                        if "To send" in self.progress_labels:
                            if hasattr(self.progress_labels["To send"], 'cget'):
                                # √â um objeto Label
                                current_to_send = int(self.progress_labels["To send"].cget("text") or "0")
                            else:
                                # √â um dicion√°rio com chave 'text'
                                current_to_send = int(self.progress_labels["To send"].get("text", "0"))
                        
                        if "Rxd" in self.progress_labels:
                            if hasattr(self.progress_labels["Rxd"], 'cget'):
                                # √â um objeto Label
                                current_rxd = int(self.progress_labels["Rxd"].cget("text") or "0")
                            else:
                                # √â um dicion√°rio com chave 'text'
                                current_rxd = int(self.progress_labels["Rxd"].get("text", "0"))
                except Exception as e:
                    print(f"DEBUG: [SETA_COMPLETION] ERROR: Erro ao obter valores das barras: {e}")
                    current_to_send = 0
                    current_rxd = 0
                
                # CONDI√á√ïES DE COMPLETION PARA CHALLENGES:
                # REGRA: Challenge pode ser completado quando To send = 0 OU quando expira por tempo limite
                # (o tempo limite j√° foi verificado acima)
                
                # Para completion por pacotes: apenas To send = 0 √© necess√°rio
                pacotes_todos_enviados = (current_to_send == 0)
                
                # Challenge pode ser completado quando todos os pacotes foram enviados (To send = 0)
                challenge_pode_ser_completado = pacotes_todos_enviados
                
                print(f"DEBUG: [SETA_COMPLETION] Challenge dados completos:")
                print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                print(f"DEBUG: [SETA_COMPLETION]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [SETA_COMPLETION]   Condi√ß√£o (todos enviados): {pacotes_todos_enviados}")
                print(f"DEBUG: [SETA_COMPLETION]   challenge_pode_ser_completado: {challenge_pode_ser_completado}")
                
                # DEBUG ESPEC√çFICO: Se Challenge deveria estar expirado, fazer an√°lise detalhada
                if tempo_limite_atingido:
                    print(f"DEBUG: [SETA_COMPLETION] [WARNING] CHALLENGE EXPIRADO DETECTADO!")
                    print(f"DEBUG: [SETA_COMPLETION] Fazendo an√°lise completa do tracking...")
                    self._debug_challenge_tracking_state()
                
                if challenge_pode_ser_completado:
                    completion_tipo = "To send = 0"
                    print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Challenge pode ser completado - {completion_tipo}")
                    
                    # VALIDA√á√ÉO DUPLA: Confirmar que to_send √© realmente 0
                    if current_to_send != 0:
                        print(f"DEBUG: [SETA_COMPLETION] [ERROR] ERRO CR√çTICO: Validation failed!")
                        print(f"DEBUG: [SETA_COMPLETION] challenge_pode_ser_completado = {challenge_pode_ser_completado}")  
                        print(f"DEBUG: [SETA_COMPLETION] Mas current_to_send = {current_to_send} (deveria ser 0)")
                        print(f"DEBUG: [SETA_COMPLETION] CANCELANDO completion - condi√ß√µes inconsistentes")
                        # Continuar gest√£o normal em case de inconsist√™ncia
                        challenge_pode_ser_completado = False
                    
                    if challenge_pode_ser_completado:
                        # Preservar valores antes de mostrar completion
                        self._preservar_valores_atuais_barras()
                        
                        # CORRE√á√ÉO: Usar o √≠ndice correto da carta no carrossel, n√£o o √≠ndice na gest√£o
                        # O √≠ndice no carrossel √© selected_carousel_index, n√£o _carta_atual_gestao
                        carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                        
                        # CORRE√á√ÉO ADICIONAL: Se n√£o h√° selected_carousel_index, procurar a carta no carrossel
                        if carta_index_carrossel is None:
                            for i, carta_carrossel in enumerate(self.cards):
                                if carta_carrossel == carta_atual:
                                    carta_index_carrossel = i
                                    print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posi√ß√£o: {i}")
                                    break
                        
                        if carta_index_carrossel is None:
                            print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: N√£o foi poss√≠vel encontrar carta no carrossel")
                            return
                        
                        print(f"DEBUG: [SETA_COMPLETION] Usando √≠ndice do carrossel: {carta_index_carrossel} (gest√£o: {self._carta_atual_gestao})")
                        
                        # Mostrar overlay de completion diretamente
                        self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                        
                        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Overlay de completion mostrado para Challenge")
                        return
                
                # Se chegou at√© aqui, Challenge n√£o pode ser completado
                else:
                    print(f"DEBUG: [SETA_COMPLETION] Challenge n√£o pode ser completado ainda - continuar gest√£o normal")
                    print(f"DEBUG: [SETA_COMPLETION]   Raz√£o: To send deve ser 0, atual: {current_to_send}")
                    print(f"DEBUG: [SETA_COMPLETION]   Nota: Challenge s√≥ pode ser completado com To send = 0 ou tempo limite atingido")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: Dados da carta n√£o encontrados")
        else:
            print(f"DEBUG: [SETA_COMPLETION] ERROR: N√£o √© Challenge - verificando se √© Activity...")
            
            # CORRE√á√ÉO CR√çTICA: Adicionar verifica√ß√£o de completion para Activities
            is_activity_card = "activity" in carta_basename
            
            if is_activity_card:
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Activity detectado - verificando completion")
                
                # Obter dados da carta
                dados_carta = self._obter_dados_carta(carta_atual)
                
                if dados_carta:
                    message_size = dados_carta.get('message_size', 0)
                    drops_allowed = dados_carta.get('drops_allowed', True)
                    
                    # Obter valores atuais das barras (posi√ß√£o atual do carrossel)
                    current_to_send = 0
                    current_rxd = 0
                    
                    try:
                        if hasattr(self, 'progress_labels'):
                            # CORRE√á√ÉO: Usar formato correto para obter texto dos labels
                            if "To send" in self.progress_labels:
                                if hasattr(self.progress_labels["To send"], 'cget'):
                                    # √â um objeto Label
                                    current_to_send = int(self.progress_labels["To send"].cget("text") or "0")
                                else:
                                    # √â um dicion√°rio com chave 'text'
                                    current_to_send = int(self.progress_labels["To send"].get("text", "0"))
                            
                            if "Rxd" in self.progress_labels:
                                if hasattr(self.progress_labels["Rxd"], 'cget'):
                                    # √â um objeto Label
                                    current_rxd = int(self.progress_labels["Rxd"].cget("text") or "0")
                                else:
                                    # √â um dicion√°rio com chave 'text'
                                    current_rxd = int(self.progress_labels["Rxd"].get("text", "0"))
                    except Exception as e:
                        print(f"DEBUG: [SETA_COMPLETION] ERROR: Erro ao obter valores das barras: {e}")
                        current_to_send = 0
                        current_rxd = 0
                    
                    print(f"DEBUG: [SETA_COMPLETION] Activity dados completos:")
                    print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                    print(f"DEBUG: [SETA_COMPLETION]   drops_allowed: {drops_allowed}")
                    
                    # CONDI√á√ïES DE COMPLETION PARA ACTIVITIES:
                    # REGRA SIMPLIFICADA: Activity s√≥ pode ser completada quando To send = 0
                    # N√£o importa o valor de Rxd ou drops_allowed
                    
                    pacotes_todos_enviados = (current_to_send == 0)
                    
                    # Activity √© completada APENAS quando todos os pacotes foram enviados (To send = 0)
                    activity_completada = pacotes_todos_enviados
                    
                    print(f"DEBUG: [SETA_COMPLETION]   Condi√ß√£o (todos enviados): {pacotes_todos_enviados}")
                    print(f"DEBUG: [SETA_COMPLETION]   activity_completada: {activity_completada}")
                    
                    if activity_completada:
                        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Activity pode ser completada - mostrar overlay")
                        
                        # VALIDA√á√ÉO DUPLA: Confirmar que to_send √© realmente 0
                        if current_to_send != 0:
                            print(f"DEBUG: [SETA_COMPLETION] [ERROR] ERRO CR√çTICO: Activity validation failed!")
                            print(f"DEBUG: [SETA_COMPLETION] activity_completada = {activity_completada}")
                            print(f"DEBUG: [SETA_COMPLETION] Mas current_to_send = {current_to_send} (deveria ser 0)")
                            print(f"DEBUG: [SETA_COMPLETION] CANCELANDO completion - condi√ß√µes inconsistentes")
                            # Continuar gest√£o normal em case de inconsist√™ncia
                            activity_completada = False
                        
                        if activity_completada:
                            # Preservar valores antes de mostrar completion
                            self._preservar_valores_atuais_barras()
                            
                            # CORRE√á√ÉO: Usar o √≠ndice correto da carta no carrossel, n√£o o √≠ndice na gest√£o
                            carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                            
                            # CORRE√á√ÉO ADICIONAL: Se n√£o h√° selected_carousel_index, procurar a carta no carrossel
                            if carta_index_carrossel is None:
                                for i, carta_carrossel in enumerate(self.cards):
                                    if carta_carrossel == carta_atual:
                                        carta_index_carrossel = i
                                        print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posi√ß√£o: {i}")
                                        break
                            
                            if carta_index_carrossel is None:
                                print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: N√£o foi poss√≠vel encontrar carta no carrossel")
                                return
                            
                            print(f"DEBUG: [SETA_COMPLETION] Usando √≠ndice do carrossel: {carta_index_carrossel} (gest√£o: {self._carta_atual_gestao})")
                            
                            # Mostrar overlay de completion diretamente
                            self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                            
                            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Overlay de completion mostrado para Activity")
                            return
                    
                    # Se chegou at√© aqui, Activity n√£o pode ser completada
                    else:
                        print(f"DEBUG: [SETA_COMPLETION] ERROR: Activity n√£o pode ser completada ainda - continuar gest√£o normal")
                        print(f"DEBUG: [SETA_COMPLETION]   Raz√£o: To send deve ser 0, atual: {current_to_send}")
                else:
                    print(f"DEBUG: [SETA_COMPLETION] ERROR: Dados da Activity n√£o encontrados")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: N√£o √© nem Challenge nem Activity - continuar gest√£o normal")
        
        print(f"DEBUG: [SETA_COMPLETION] ERROR: Condi√ß√µes para completion n√£o atendidas - continuar gest√£o normal")
        
        # FLUXO ORIGINAL: PRESERVAR VALORES DA CARTA ATUAL ANTES DE AVAN√áAR
        
        # Encontrar posi√ß√£o real no carrossel
        posicao_carrossel_atual = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                posicao_carrossel_atual = i
                break
        
        if posicao_carrossel_atual is not None:
            # Capturar valores atuais das barras vis√≠veis
            try:
                if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # IMPORTANTE: Preservar na posi√ß√£o correta do carrossel
                    if hasattr(self, 'card_stats') and posicao_carrossel_atual < len(self.card_stats):
                        self.card_stats[posicao_carrossel_atual] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual, 
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [GEST√ÉO_PACOTES] SUCCESS: VALORES PRESERVADOS antes de avan√ßar:")
                        print(f"DEBUG: [GEST√ÉO_PACOTES]   Posi√ß√£o carrossel: {posicao_carrossel_atual}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES]   To send: {to_send_atual}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES]   Rxd: {rxd_atual}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES]   Lost: {lost_atual}")
                        print(f"DEBUG: [GEST√ÉO_PACOTES]   card_stats[{posicao_carrossel_atual}] = {self.card_stats[posicao_carrossel_atual]}")
                    
            except Exception as e:
                print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Erro ao preservar valores: {e}")
        
        # CORRE√á√ÉO 2: Salvar tamb√©m no sistema antigo (compatibilidade)
        if hasattr(self, '_entry_rxd') and hasattr(self, '_entry_lost'):
            try:
                enviados = int(self._entry_rxd.get()) if hasattr(self._entry_rxd, 'get') else rxd_atual
                perdidos = int(self._entry_lost.get()) if hasattr(self._entry_lost, 'get') else lost_atual
                
                if not hasattr(self, '_valores_pacotes'):
                    self._valores_pacotes = {}
                    
                self._valores_pacotes[self._carta_atual_gestao] = {
                    'enviados': enviados,
                    'perdidos': perdidos
                }
                print(f"DEBUG: [GEST√ÉO_PACOTES] Valores salvos no sistema antigo - Enviados: {enviados}, Perdidos: {perdidos}")
            except (ValueError, AttributeError):
                print("DEBUG: [GEST√ÉO_PACOTES] Sistema antigo n√£o dispon√≠vel")
        
        # Remover controles atuais
        self._remover_controles_gestao()
        
        # CORRE√á√ÉO 3: Avan√ßar para pr√≥xima carta
        self._carta_atual_gestao += 1
        print(f"DEBUG: [GEST√ÉO_PACOTES] Nova carta atual (√≠ndice): {self._carta_atual_gestao}")
        
        # VERIFICA√á√ÉO CR√çTICA: Antes de continuar, verificar se ainda h√° cartas v√°lidas
        cartas_validas_restantes = 0
        if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
            for i, carta in enumerate(self._cartas_gestao):
                if (i >= self._carta_atual_gestao and carta and hasattr(self, 'cards') and 
                    carta in self.cards):
                    carta_basename = os.path.basename(carta).lower()
                    if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                        cartas_validas_restantes += 1
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] Cartas v√°lidas restantes para processar: {cartas_validas_restantes}")
        print(f"DEBUG: [GEST√ÉO_PACOTES] √çndice atual: {self._carta_atual_gestao}, Total cartas: {len(getattr(self, '_cartas_gestao', []))}")
        
        # Se n√£o h√° mais cartas v√°lidas, finalizar gest√£o automaticamente
        if cartas_validas_restantes == 0 or self._carta_atual_gestao >= len(getattr(self, '_cartas_gestao', [])):
            print("DEBUG: [GEST√ÉO_PACOTES] ERROR: N√£o h√° mais cartas v√°lidas para processar")
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: FINALIZANDO GEST√ÉO DE PACOTES AUTOMATICAMENTE")
            
            # CORRE√á√ÉO CR√çTICA: Finalizar gest√£o mas MANTER Final Phase ativo para End Turn
            # A gest√£o termina mas o jogador ainda est√° em Final Phase
            self._final_phase_gestao_ativa = False
            # N√ÉO limpar _final_phase_active - o jogador ainda est√° em Final Phase!
            # self._final_phase_active = False  # ERROR: REMOVIDO - Final Phase deve continuar ativo
            
            # CORRE√á√ÉO: Ativar End Turn quando gest√£o termina automaticamente
            self._show_end_turn_button = True
            
            if hasattr(self, '_cartas_gestao'):
                self._cartas_gestao = []
            if hasattr(self, '_carta_atual_gestao'):
                self._carta_atual_gestao = 0
            
            # Remover controles silenciosamente
            self._remover_controles_gestao_silencioso()
            
            # CORRE√á√ÉO CR√çTICA: Reconstruir dashboard MANTENDO Final Phase ativo
            print("DEBUG: [GEST√ÉO_PACOTES] Voltando ao dashboard com Final Phase ativo e End Turn enabled...")
            print(f"DEBUG: [GEST√ÉO_PACOTES] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # CORRE√á√ÉO CR√çTICA: Ativar o bot√£o End Turn AP√ìS reconstruir a interface
            self.after(100, self._ativar_botao_end_turn)
            
            # CORRE√á√ÉO NOVA: For√ßar atualiza√ß√£o dos destaques para garantir que carta restante fique destacada
            self.after(200, lambda: self._update_carousel_selection_highlights())
            return
        
        # CORRE√á√ÉO 4: Mostrar gest√£o da pr√≥xima carta ou finalizar
        self._mostrar_gestao_carta_atual()
        
        print(f"DEBUG: [GEST√ÉO_PACOTES] ===== AVAN√áO CONCLU√çDO =====")
    
    def _remover_controles_gestao_silencioso(self):
        """Remove controles de gest√£o SEM criar automaticamente o bot√£o seta"""
        print("DEBUG: [GEST√ÉO_PACOTES] Removendo controles de gest√£o silenciosamente...")
        
        # Remover frame de controles (vers√£o antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover bot√µes + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # Remover bot√£o seta se existir
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GEST√ÉO_PACOTES] Controles removidos silenciosamente")

    def _remover_controles_gestao(self):
        """Remove controles de gest√£o atuais"""
        print("DEBUG: [GEST√ÉO_PACOTES] Removendo controles de gest√£o...")
        
        # Verificar se h√° bot√µes + para remover
        tinha_botoes_plus = False
        if ((hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd) or 
            (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost)):
            tinha_botoes_plus = True
        
        # Remover frame de controles (vers√£o antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover bot√µes + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORRE√á√ÉO: Mostrar bot√£o seta AP√ìS remover os bot√µes +
        if tinha_botoes_plus:
            print("DEBUG: [GEST√ÉO_PACOTES] Bot√µes + foram removidos - agora mostrar bot√£o seta")
            self._mostrar_botao_seta()
        
        # N√ÉO remover bot√£o seta aqui, pois ele deve aparecer quando os bot√µes + desaparecem
        # O bot√£o seta ser√° removido apenas quando a gest√£o de pacotes terminar completamente
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GEST√ÉO_PACOTES] Controles removidos")
    
    def _finalizar_gestao_pacotes(self):
        """Finaliza gest√£o de pacotes e ativa bot√£o End Turn"""
        print("DEBUG: [GEST√ÉO_PACOTES] === FINALIZANDO GEST√ÉO DE PACOTES ===")
        
        # PROTE√á√ÉO CR√çTICA: Evitar m√∫ltiplas chamadas quando gest√£o j√° foi finalizada
        if not getattr(self, '_final_phase_gestao_ativa', False):
            print("DEBUG: [GEST√ÉO_PACOTES] WARNING: Gest√£o j√° foi finalizada - ignorando chamada duplicada")
            return
        
        # CORRE√á√ÉO CR√çTICA: Desativar gest√£o de pacotes PRIMEIRO
        self._final_phase_gestao_ativa = False
        print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: _final_phase_gestao_ativa = False")
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles (incluindo bot√£o seta)
        self._remover_controles_gestao()
        
        # CORRE√á√ÉO: Remover bot√£o seta quando gest√£o termina completamente
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GEST√ÉO_PACOTES] Removendo bot√£o seta - gest√£o de pacotes finalizada")
            try:
                self._btn_seta.destroy()
                self._btn_seta = None
            except tk.TclError:
                self._btn_seta = None
        
        # CORRE√á√ÉO CR√çTICA: Verificar completion ANTES de limpar vari√°veis de gest√£o
        self._aplicar_valores_finais()
        
        # CORRE√á√ÉO: Limpar todas as vari√°veis de gest√£o
        if hasattr(self, '_cartas_gestao'):
            self._cartas_gestao = []
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: _cartas_gestao limpa")
        
        if hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: _carta_atual_gestao resetado")
        
        if hasattr(self, '_carta_destacada'):
            self._carta_destacada = None
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: _carta_destacada limpa")
        
        if hasattr(self, '_carta_destacada_posicao'):
            self._carta_destacada_posicao = None
            print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: _carta_destacada_posicao limpa")
        
        # CORRE√á√ÉO CR√çTICA: Limpar sele√ß√£o do carrossel para evitar destaques residuais
        self.selected_carousel_card = None
        self.selected_carousel_index = None
        print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: Sele√ß√£o do carrossel limpa")
        
        # CORRE√á√ÉO CR√çTICA: For√ßar limpeza completa de todos os destaques
        print("DEBUG: [GEST√ÉO_PACOTES] SUCCESS: For√ßando limpeza completa de destaques")
        if hasattr(self, 'card_labels') and self.card_labels:
            for lbl in self.card_labels:
                try:
                    lbl.config(highlightthickness=0)
                except tk.TclError:
                    pass
        
        # Atualiza√ß√£o em m√∫ltiplas etapas para garantir limpeza
        self.after(25, lambda: self._update_carousel_selection_highlights())
        self.after(50, lambda: self._update_carousel_selection_highlights())
        
        # CORRE√á√ÉO: Ativar bot√£o End Turn APENAS se n√£o h√° overlays de completion pendentes
        self.after(75, self._ativar_botao_end_turn_se_apropriado)
        
        print("DEBUG: [GEST√ÉO_PACOTES] === GEST√ÉO FINALIZADA COM SUCESSO ===")
    
    def _aplicar_valores_finais(self):
        """
        CORRE√á√ÉO: Verifica completion de TODAS as cartas ativas no carrossel
        N√£o depende de _cartas_gestao que pode estar vazia
        """
        print("DEBUG: [GEST√ÉO_PACOTES] === VERIFICA√á√ÉO FINAL DE COMPLETION DE TODAS AS CARTAS ===")
        
        cartas_completadas = []
        
        # CORRE√á√ÉO CR√çTICA: Verificar todas as cartas ativas no carrossel, n√£o apenas _cartas_gestao
        for carta_idx, carta_path in enumerate(self.cards):
            if carta_idx >= len(self.card_stats) or not carta_path:
                continue
            
            # Verificar se √© uma carta ativa (n√£o √© back_card)
            carta_name = os.path.basename(carta_path)
            if "back_card" in carta_name.lower():
                continue
            
            # Verificar se tem barras de progresso v√°lidas
            stats = self.card_stats[carta_idx]
            
            print(f"DEBUG: [COMPLETION_FINAL] Verificando carta {carta_idx}: {carta_name}")
            print(f"DEBUG: [COMPLETION_FINAL] Estado final da carta {carta_idx}:")
            print(f"DEBUG: [COMPLETION_FINAL]   To send: {stats['To send']}")
            print(f"DEBUG: [COMPLETION_FINAL]   Rxd total: {stats['Rxd']}")
            print(f"DEBUG: [COMPLETION_FINAL]   Lost total: {stats['Lost']}")
            
            # NOVA FUNCIONALIDADE: Verificar completion para cada carta
            dados_carta = self._obter_dados_carta(carta_path)
            if dados_carta:
                message_size = dados_carta.get('message_size', 0)
                drops_allowed = dados_carta.get('drops_allowed', True)
                
                # Determinar tipo da carta
                carta_basename = carta_name.lower()
                is_challenge = "challenge" in carta_basename
                is_activity = "activity" in carta_basename
                
                print(f"DEBUG: [COMPLETION_FINAL] Carta: {carta_name}")
                print(f"DEBUG: [COMPLETION_FINAL]   Tipo: {'Challenge' if is_challenge else 'Activity' if is_activity else 'Outro'}")
                print(f"DEBUG: [COMPLETION_FINAL]   Message size: {message_size}")
                print(f"DEBUG: [COMPLETION_FINAL]   Drops allowed: {drops_allowed}")
                
                # Aplicar regras de completion
                completion_achieved = False
                completion_reason = ""
                
                # Para Activities: s√≥ verificar se drops_allowed=False
                # Para Challenges: sempre verificar
                should_check_completion = is_challenge or (is_activity and not drops_allowed)
                
                if should_check_completion:
                    to_send = stats['To send']
                    rxd = stats['Rxd']
                    
                    print(f"DEBUG: [COMPLETION_FINAL] Verificando completion para {carta_name}:")
                    print(f"DEBUG: [COMPLETION_FINAL]   To send: {to_send}, Rxd: {rxd}, Message size: {message_size}")
                    
                    if is_challenge:
                        # Challenges: mais flex√≠vel - considera completado se To send = 0 OU Rxd >= message_size
                        completion_achieved = (to_send == 0) or (rxd >= message_size)
                        if to_send == 0:
                            completion_reason = "todos os pacotes foram enviados"
                        elif rxd >= message_size:
                            completion_reason = f"todos os pacotes foram recebidos ({rxd}/{message_size})"
                    else:
                        # Activities: mais restritivo - precisa To send = 0 E Rxd >= message_size
                        completion_achieved = (to_send == 0) and (rxd >= message_size)
                        if completion_achieved:
                            completion_reason = f"todos os pacotes foram enviados e recebidos ({rxd}/{message_size})"
                    
                    # Verificar se carta foi completada
                    if completion_achieved:
                        print(f"DEBUG: [COMPLETION_FINAL] *** {'Challenge' if is_challenge else 'Activity'} {carta_name} COMPLETADA! ***")
                        print(f"DEBUG: [COMPLETION_FINAL] Motivo: {completion_reason}")
                        cartas_completadas.append({
                            'path': carta_path,
                            'name': carta_name,
                            'type': 'Challenge' if is_challenge else 'Activity',
                            'reason': completion_reason,
                            'dados': dados_carta,
                            'index': carta_idx  # CORRE√á√ÉO: Adicionar √≠ndice da carta
                        })
                    else:
                        print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} n√£o completada:")
                        print(f"DEBUG: [COMPLETION_FINAL]   To send: {to_send}, Rxd: {rxd}, Message size: {message_size}")
                else:
                    print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} n√£o verifica completion (Activity com drops_allowed=True)")
        
        # NOVA FUNCIONALIDADE: Mostrar overlays para TODAS as cartas completadas
        if cartas_completadas:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: {len(cartas_completadas)} CARTAS COMPLETADAS ===")
            for carta_info in cartas_completadas:
                print(f"DEBUG: [COMPLETION_FINAL] - {carta_info['type']}: {carta_info['name']} ({carta_info['reason']})")
            
            # Mostrar overlays sequencialmente (com delay entre elas)
            self._mostrar_overlays_completion_sequencial(cartas_completadas)
        else:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: NENHUMA CARTA COMPLETADA ===")
    
    def _mostrar_overlays_completion_sequencial(self, cartas_completadas, index=0):
        """
        Mostra overlays de completion para m√∫ltiplas cartas de forma sequencial
        """
        if index >= len(cartas_completadas):
            print("DEBUG: [COMPLETION_FINAL] SUCCESS: Todos os overlays de completion foram mostrados")
            return
        
        carta_info = cartas_completadas[index]
        print(f"DEBUG: [COMPLETION_FINAL] Mostrando overlay {index+1}/{len(cartas_completadas)} para {carta_info['name']}")
        
        # Armazenar informa√ß√µes para o pr√≥ximo overlay
        self._next_completion_overlays = cartas_completadas
        self._current_completion_index = index
        
        # Mostrar overlay atual (ser√° fechado automaticamente ou pelo usu√°rio)
        self._mostrar_overlay_completion(carta_info['path'], carta_info['dados'], is_sequential=True, carta_index=carta_info.get('index'))
    
    def _mostrar_overlay_quit_challenge(self, carta_path):
        """
        Mostra overlay de confirma√ß√£o para quit challenge
        """
        print(f"DEBUG: [QUIT_CHALLENGE] Criando overlay de confirma√ß√£o para: {os.path.basename(carta_path)}")
        
        # Obter dados da carta para challenge_quit_fee
        dados_carta = self._obter_dados_carta(carta_path)
        challenge_quit_fee = dados_carta.get('challenge_quit_fee', 0)
        
        print(f"DEBUG: [QUIT_CHALLENGE] Challenge quit fee: {challenge_quit_fee}")
        
        # Criar overlay
        if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
            self._overlay_quit_challenge.destroy()
        
        self._overlay_quit_challenge = tk.Toplevel(self)
        self._overlay_quit_challenge.title("")
        self._overlay_quit_challenge.configure(bg="black")
        self._overlay_quit_challenge.overrideredirect(True)
        self._overlay_quit_challenge.attributes("-topmost", True)
        
        # Centralizar na tela com altura reduzida
        overlay_width, overlay_height = 400, 220  # Reduzido de 300 para 220
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_quit_challenge.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com padding reduzido
        main_frame = tk.Frame(self._overlay_quit_challenge, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=5)  # Reduzido pady de 10 para 5
        
        # T√≠tulo "Are you sure you want to quit?" em roxo (centralizado) com padding reduzido
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to quit?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(15, 15))  # Reduzido de (20, 20) para (15, 15)
        
        # Frame para "You'll lost" + valor + moeda com padding reduzido
        lost_frame = tk.Frame(main_frame, bg="black")
        lost_frame.pack(pady=(5, 15))  # Reduzido de (10, 20) para (5, 15)
        
        # Texto "You'll lost " em branco
        lost_text_lbl = tk.Label(
            lost_frame,
            text="You'll lost ",
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        lost_text_lbl.pack(side="left")
        
        # Valor da taxa em branco
        fee_value_lbl = tk.Label(
            lost_frame,
            text=str(challenge_quit_fee),
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        fee_value_lbl.pack(side="left", padx=(0, 5))
        
        # S√≠mbolo da piccoin
        try:
            coin_img_path = os.path.join(IMG_DIR, "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path)
                coin_pil = coin_pil.resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                
                coin_lbl = tk.Label(
                    lost_frame,
                    image=coin_img,
                    bg="black"
                )
                coin_lbl.image = coin_img  # manter refer√™ncia
                coin_lbl.pack(side="left")
            else:
                # Fallback se imagem n√£o existir
                coin_lbl = tk.Label(
                    lost_frame,
                    text="$",
                    font=("Helvetica", 14),
                    fg="gold",
                    bg="black"
                )
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: [QUIT_CHALLENGE] Erro ao carregar imagem da moeda: {e}")
            # Fallback emoji
            coin_lbl = tk.Label(
                lost_frame,
                text="$",
                font=("Helvetica", 14),
                fg="gold",
                bg="black"
            )
            coin_lbl.pack(side="left")
        
        # Frame para bot√µes com padding reduzido
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(15, 5))  # Reduzido de (20, 10) para (15, 5)
        
        # Fun√ß√£o para fechar overlay sem quit
        def fechar_sem_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador cancelou quit challenge")
            if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
                self._overlay_quit_challenge.destroy()
                self._overlay_quit_challenge = None
        
        # Fun√ß√£o para confirmar quit
        def confirmar_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador confirmou quit challenge")
            
            # Verificar se jogador tem saldo suficiente
            if self.saldo < challenge_quit_fee:
                print(f"DEBUG: [QUIT_CHALLENGE] ERROR: Saldo insuficiente: {self.saldo} < {challenge_quit_fee}")
                # Talvez mostrar mensagem de erro aqui
                fechar_sem_quit()
                return
            
            # Decrementar saldo
            self.saldo -= challenge_quit_fee
            print(f"DEBUG: [QUIT_CHALLENGE] Saldo decrementado: -{challenge_quit_fee}, novo saldo: {self.saldo}")
            self._atualizar_display_saldo()
            
            # NOVO: Sincronizar saldo com servidor
            self.sync_score_with_server(f"taxa desist√™ncia -{challenge_quit_fee}")
            
            # CORRE√á√ÉO: Remover carta do invent√°rio do jogador ANTES de devolver ao baralho
            if 'challenges' in self.inventario and carta_path in self.inventario['challenges']:
                self.inventario['challenges'].remove(carta_path)
                print(f"DEBUG: [QUIT_CHALLENGE] SUCCESS: Carta {os.path.basename(carta_path)} removida do invent√°rio challenges do jogador")
            else:
                print(f"DEBUG: [QUIT_CHALLENGE] WARNING: Carta {os.path.basename(carta_path)} n√£o encontrada no invent√°rio challenges do jogador")
            
            # Remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # Devolver carta para baralho da Store (challenges)
            self._devolver_challenge_para_baralho(carta_path)
            
            # Fechar overlay
            fechar_sem_quit()
            
            # Voltar para interface principal
            print(f"DEBUG: [QUIT_CHALLENGE] Voltando para interface principal ap√≥s quit")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Bot√£o "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_quit
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Bot√£o "Yes" verde (lado direito)
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",
            fg="white",
            width=8,
            height=1,
            command=confirmar_quit
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [QUIT_CHALLENGE] Overlay de quit challenge criado")
    
    def _mostrar_overlay_confirmacao_troca(self, carta_path, tipos, page=0):
        """
        Mostra overlay de confirma√ß√£o para troca de carta com warning sobre perda de progresso
        """
        print(f"DEBUG: [SWITCH_CONFIRM] Criando overlay de confirma√ß√£o de troca para: {os.path.basename(carta_path)}")
        
        # Criar overlay
        if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
            self._overlay_switch_confirm.destroy()
        
        self._overlay_switch_confirm = tk.Toplevel(self)
        self._overlay_switch_confirm.title("")
        self._overlay_switch_confirm.configure(bg="black")
        self._overlay_switch_confirm.overrideredirect(True)
        self._overlay_switch_confirm.attributes("-topmost", True)
        
        # Centralizar na tela 
        overlay_width, overlay_height = 400, 200
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_switch_confirm.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com borda
        main_frame = tk.Frame(self._overlay_switch_confirm, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # T√≠tulo "Are you sure you want to switch?" em roxo (centralizado)
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to switch?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",  # Roxo
            bg="black"
        )
        title_lbl.pack(pady=(20, 10))
        
        # Subt√≠tulo "All progress will be lost" em branco
        subtitle_lbl = tk.Label(
            main_frame,
            text="All progress will be lost",
            font=("Helvetica", 12),
            fg="white",
            bg="black"
        )
        subtitle_lbl.pack(pady=(0, 20))
        
        # Frame para bot√µes
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(10, 0))
        
        # Fun√ß√£o para fechar overlay sem confirmar troca
        def fechar_sem_trocar():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador cancelou a troca")
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
        
        # Fun√ß√£o para confirmar troca (executar troca e voltar ao dashboard)
        def confirmar_troca():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador confirmou a troca")
            
            # Fechar overlay
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
            
            # CORRE√á√ÉO CR√çTICA: Executar a troca diretamente
            print(f"DEBUG: [SWITCH_CONFIRM] Executando troca da carta: {os.path.basename(carta_path)}")
            
            # Chama diretamente aceitar_carta_carrossel que faz a troca completa
            self.aceitar_carta_carrossel(carta_path, tipos, page)
        
        # Bot√£o "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",  # Vermelho
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_trocar
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Bot√£o "Yes" verde (lado direito)  
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",  # Verde
            fg="white",
            width=8,
            height=1,
            command=confirmar_troca
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [SWITCH_CONFIRM] Overlay de confirma√ß√£o de troca criado")
    
    def _ativar_botao_end_turn_se_apropriado(self):
        """
        Ativa o bot√£o End Turn apenas se n√£o h√° overlays de completion pendentes.
        """
        print("DEBUG: [END_TURN] === VERIFICANDO SE √â APROPRIADO ATIVAR END TURN ===")
        
        # Verificar se h√° overlays de completion ativos
        overlay_completion_ativo = False
        
        # Verificar se h√° atributos que indicam overlay ativo
        if hasattr(self, '_completion_overlay_active') and self._completion_overlay_active:
            overlay_completion_ativo = True
            print("DEBUG: [END_TURN] Overlay de completion detectado via flag _completion_overlay_active")
        
        # Verificar se h√° widgets de overlay na interface
        for widget in self.winfo_children():
            widget_name = str(widget).lower()
            if 'overlay' in widget_name or 'completion' in widget_name:
                overlay_completion_ativo = True
                print(f"DEBUG: [END_TURN] Overlay de completion detectado via widget: {widget}")
                break
        
        if overlay_completion_ativo:
            print("DEBUG: [END_TURN] WARNING: Overlay de completion ativo - adiando ativa√ß√£o do End Turn")
            # Tentar novamente em 500ms
            self.after(500, self._ativar_botao_end_turn_se_apropriado)
            return
        
        print("DEBUG: [END_TURN] SUCCESS: Nenhum overlay de completion ativo - procedendo com ativa√ß√£o")
        self._ativar_botao_end_turn()

    def _ativar_botao_end_turn(self):
        """Ativa o bot√£o End Turn e muda sua apar√™ncia"""
        print("DEBUG: [END_TURN] === TENTANDO ATIVAR BOT√ÉO END TURN ===")
        try:
            # CORRE√á√ÉO: Procurar por bot√£o End Turn em toda a interface se necess√°rio
            end_turn_button = None
            
            # 1. Verificar se temos refer√™ncia v√°lida
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                if hasattr(self.end_turn_btn, 'winfo_exists') and self.end_turn_btn.winfo_exists():
                    end_turn_button = self.end_turn_btn
                    print("DEBUG: [END_TURN] SUCCESS: Bot√£o encontrado via refer√™ncia self.end_turn_btn")
                else:
                    print("DEBUG: [END_TURN] ERROR: Refer√™ncia self.end_turn_btn inv√°lida")
                    self.end_turn_btn = None
            
            # 2. Se n√£o encontrou, procurar em toda a interface
            if not end_turn_button:
                print("DEBUG: [END_TURN] Procurando bot√£o End Turn em toda a interface...")
                end_turn_button = self._procurar_botao_end_turn_na_interface()
                if end_turn_button:
                    self.end_turn_btn = end_turn_button
                    print("DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn encontrado na interface")
            
            # 3. Se encontrou o bot√£o, ativar
            if end_turn_button:
                end_turn_button.config(
                    state="normal",
                    bg="#808080",
                    fg="black"
                )
                print("DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn ATIVADO com sucesso")
            else:
                print("DEBUG: [END_TURN] ERROR: Bot√£o End Turn n√£o encontrado")
                # CORRE√á√ÉO: Tentar recriar o bot√£o se n√£o existir
                self._tentar_recriar_end_turn_button()
                
        except tk.TclError as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro TclError ao ativar End Turn: {e}")
            # Limpar refer√™ncia inv√°lida e tentar recriar
            self.end_turn_btn = None
            self._tentar_recriar_end_turn_button()
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro inesperado ao ativar End Turn: {e}")
    
    def _procurar_botao_end_turn_na_interface(self):
        """Procura o bot√£o End Turn em toda a interface atual"""
        try:
            # Procurar em todos os widgets filhos
            for widget in self.winfo_children():
                if hasattr(widget, 'winfo_children'):
                    for sub_widget in widget.winfo_children():
                        # Verificar se √© um bot√£o com texto "End Turn"
                        if (hasattr(sub_widget, 'cget') and 
                            hasattr(sub_widget, 'config') and
                            hasattr(sub_widget, 'state')):
                            try:
                                text = sub_widget.cget('text')
                                if text and 'End Turn' in str(text):
                                    print(f"DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn encontrado: {text}")
                                    return sub_widget
                            except:
                                continue
            
            print("DEBUG: [END_TURN] ERROR: Bot√£o End Turn n√£o encontrado na interface")
            return None
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao procurar bot√£o: {e}")
            return None
    
    def _tentar_recriar_end_turn_button(self):
        """Tenta recriar o bot√£o End Turn se n√£o existir"""
        try:
            print("DEBUG: [END_TURN] Tentando recriar bot√£o End Turn...")
            # Verificar se h√° um container v√°lido para o bot√£o
            if hasattr(self, 'winfo_children') and self.winfo_children():
                # CORRE√á√ÉO: Usar m√©todo seguro para criar End Turn
                print("DEBUG: [END_TURN] SUCCESS: Container v√°lido encontrado - tentando recriar...")
                self.after(100, lambda: self._criar_botao_end_turn_seguro())
            else:
                print("DEBUG: [END_TURN] ERROR: N√£o h√° container v√°lido para recriar End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao tentar recriar End Turn: {e}")
    
    def _criar_botao_end_turn_seguro(self):
        """Cria bot√£o End Turn de forma segura"""
        try:
            if not hasattr(self, 'end_turn_btn') or not self.end_turn_btn:
                # Verificar se j√° existe na interface atual
                existing_button = self._procurar_botao_end_turn_na_interface()
                if existing_button:
                    self.end_turn_btn = existing_button
                    print("DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn existente encontrado e vinculado")
                    
                    # Ativar imediatamente
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn ativado")
                    return
                
                # Se n√£o existe, tentar criar novo
                print("DEBUG: [END_TURN] Tentando criar novo bot√£o End Turn...")
                self._criar_botao_end_turn()
                
                # Se criado com sucesso, ativar imediatamente
                if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] SUCCESS: Bot√£o End Turn recriado e ativado")
                else:
                    print("DEBUG: [END_TURN] ERROR: Falha ao criar novo bot√£o End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao criar End Turn seguro: {e}")
    
    def _manter_end_turn_disabled(self):
        """Mant√©m o bot√£o End Turn disabled enquanto h√° cartas para processar"""
        try:
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn and self.end_turn_btn.winfo_exists():
                self.end_turn_btn.config(
                    state="disabled",
                    bg="#666666",  # Cor mais escura para indicar disabled
                    fg="#999999"   # Texto mais claro para indicar disabled
                )
                print(f"DEBUG: [GEST√ÉO_PACOTES] Bot√£o End Turn mantido DISABLED - carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)} em processamento")
            else:
                print("DEBUG: [GEST√ÉO_PACOTES] ERROR: Bot√£o End Turn n√£o encontrado para manter disabled")
        except tk.TclError as e:
            print(f"DEBUG: [GEST√ÉO_PACOTES] ERROR: Erro ao manter End Turn disabled: {e}")
            # Limpar refer√™ncia inv√°lida
            self.end_turn_btn = None
    
    def _limpar_gestao_pacotes(self):
        """Limpa todas as vari√°veis e widgets do sistema de gest√£o de pacotes"""
        print("DEBUG: [GEST√ÉO_PACOTES] Limpando sistema de gest√£o de pacotes")
        
        # Desbloquear intera√ß√µes do carrossel
        self._desbloquear_interacoes_carrossel()
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles
        self._remover_controles_gestao()
        
        # Limpar vari√°veis
        if hasattr(self, '_cartas_gestao'):
            delattr(self, '_cartas_gestao')
        
        if hasattr(self, '_carta_atual_gestao'):
            delattr(self, '_carta_atual_gestao')
        
        if hasattr(self, '_valores_pacotes'):
            delattr(self, '_valores_pacotes')
        
        print("DEBUG: [GEST√ÉO_PACOTES] Sistema de gest√£o de pacotes limpo")

    def end_turn(self):
        # CORRE√á√ÉO CR√çTICA: Preservar estat√≠sticas das cartas antes de terminar turno
        print("DEBUG: End Turn clicado - preservando estat√≠sticas das cartas")
        
        # SUPER BACKUP SYSTEM: Garantir backup completo de todos os trackings cr√≠ticos
        root = self.master
        
        # 1. Backup das estat√≠sticas das cartas
        if hasattr(self, 'card_stats') and hasattr(self, 'cards'):
            root._backup_card_stats = []
            root._backup_cards = []
            
            for i, stats in enumerate(self.card_stats):
                # Criar c√≥pia profunda das estat√≠sticas
                backup_stats = {
                    'To send': stats['To send'],
                    'Rxd': stats['Rxd'], 
                    'Lost': stats['Lost']
                }
                root._backup_card_stats.append(backup_stats)
                print(f"DEBUG: [END_TURN] Carta {i} estat√≠sticas salvas: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # Salvar tamb√©m os caminhos das cartas
            for i, card_path in enumerate(self.cards):
                root._backup_cards.append(card_path)
                print(f"DEBUG: [END_TURN] Carta {i} path salvo: {os.path.basename(card_path) if card_path else 'None'}")
        
        # CORRE√á√ÉO CR√çTICA: Preservar mapeamento de Activities com valores preservados
        if hasattr(self, '_activity_preserved_stats'):
            root = self.master
            root._activity_preserved_stats = self._activity_preserved_stats.copy()
            print(f"DEBUG: [END_TURN] Mapeamento de Activities preservadas salvo: {len(self._activity_preserved_stats)} entries")
            for activity_path, stats in self._activity_preserved_stats.items():
                print(f"DEBUG: [END_TURN] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
        
        # CORRE√á√ÉO CR√çTICA: Incrementar primeiro, depois salvar os contadores corretos
        print(f"DEBUG: [END_TURN] ======= INCREMENTANDO CONTADORES DE TURNO =======")
        print(f"DEBUG: [END_TURN] Contadores ANTES do incremento:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # CORRE√á√ÉO CR√çTICA: N√ÉO incrementar contadores aqui - isso s√≥ deve acontecer no pr√≥ximo dice roll
        # Os contadores permanecem no turno atual at√© o jogador lan√ßar o dado para o pr√≥ximo turno
        print(f"DEBUG: [END_TURN] Contadores PERMANECEM NO TURNO ATUAL (n√£o incrementados):")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [END_TURN] IMPORTANTE: Incremento s√≥ acontece no pr√≥ximo dice roll!")
        
        # CR√çTICO: SALVAR OS CONTADORES J√Å INCREMENTADOS para preserva√ß√£o
        root = self.master
        # CORRE√á√ÉO CR√çTICA: Salvar valores INCREMENTADOS em vez dos atuais
        next_turn_number = self._current_turn_number + 1
        next_turn = self._current_turn + 1
        next_turn_id = self._current_turn_id + 1
        
        root._backup_turn_counters = {
            '_current_turn_number': next_turn_number,
            '_current_turn': next_turn,
            '_current_turn_id': next_turn_id,
            '_challenge_start_turns': self._challenge_start_turns.copy(),  # CORRE√á√ÉO CR√çTICA: Adicionar tracking
            '_service_real_activation_turns': getattr(self, '_service_real_activation_turns', {}).copy(),  # CORRE√á√ÉO CR√çTICA: Preservar turnos reais de Services
            '_event_duration_tracking': getattr(self, '_event_duration_tracking', {}).copy(),  # CORRE√á√ÉO CR√çTICA: Salvar tracking de Events
            '_event_start_turns': getattr(self, '_event_start_turns', {}).copy(),  # CORRE√á√ÉO CR√çTICA: Salvar start turns de Events
            '_service_data_volume_tracking': getattr(self, '_service_data_volume_tracking', {}).copy(),  # CORRE√á√ÉO CR√çTICA: Preservar tracking Data Volume
            '_pending_data_volume_expiry_overlays': getattr(self, '_pending_data_volume_expiry_overlays', []).copy()  # CORRE√á√ÉO CR√çTICA: Preservar overlays pendentes
        }
        
        print(f"DEBUG: [END_TURN] Valores INCREMENTADOS a serem salvos:")
        print(f"DEBUG: [END_TURN]   Atual -> Pr√≥ximo turno:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number} -> {next_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn} -> {next_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id} -> {next_turn_id}")
        
        # SUPER BACKUP SYSTEM: Backup completo de todos os trackings cr√≠ticos
        root._backup_challenge_tracking = self._challenge_start_turns.copy()
        
        # 2. Backup robusto de Services tracking (consolida√ß√£o m√∫ltipla)
        if hasattr(self, '_service_real_activation_turns'):
            root._backup_service_tracking_end_turn = self._service_real_activation_turns.copy()
        else:
            root._backup_service_tracking_end_turn = {}
        
        # Consolidar de m√∫ltiplas fontes para m√°xima preserva√ß√£o
        consolidated_services = getattr(root, '_backup_service_tracking', {}).copy()
        consolidated_services.update(getattr(root, '_service_tracking_backup_imediato', {}))
        consolidated_services.update(root._backup_service_tracking_end_turn)
        root._backup_service_tracking_super = consolidated_services
        
        # 3. Backup robusto de Events tracking (consolida√ß√£o m√∫ltipla)
        if hasattr(self, '_event_duration_tracking'):
            root._backup_event_tracking_end_turn = self._event_duration_tracking.copy()
        else:
            root._backup_event_tracking_end_turn = {}
            
        if hasattr(self, '_event_start_turns'):
            root._backup_event_start_turns_end_turn = self._event_start_turns.copy()
        else:
            root._backup_event_start_turns_end_turn = {}
        
        # Consolidar de m√∫ltiplas fontes para m√°xima preserva√ß√£o
        consolidated_events = getattr(root, '_backup_event_tracking', {}).copy()
        consolidated_events.update(getattr(root, '_event_tracking_backup_imediato', {}))
        consolidated_events.update(root._backup_event_tracking_end_turn)
        root._backup_event_tracking_super = consolidated_events
        
        consolidated_event_starts = getattr(root, '_backup_event_start_turns', {}).copy()
        consolidated_event_starts.update(root._backup_event_start_turns_end_turn)
        root._backup_event_start_turns_super = consolidated_event_starts
        
        # 4. Backup robusto de Data Volume tracking (consolida√ß√£o m√∫ltipla)
        if hasattr(self, '_service_data_volume_tracking'):
            root._backup_data_volume_tracking_end_turn = self._service_data_volume_tracking.copy()
        else:
            root._backup_data_volume_tracking_end_turn = {}
            
        if hasattr(self, '_pending_data_volume_expiry_overlays'):
            root._backup_data_volume_overlays_end_turn = self._pending_data_volume_expiry_overlays.copy()
        else:
            root._backup_data_volume_overlays_end_turn = []
        
        # Consolidar de m√∫ltiplas fontes para m√°xima preserva√ß√£o
        consolidated_data_volume = getattr(root, '_backup_data_volume_tracking', {}).copy()
        consolidated_data_volume.update(getattr(root, '_data_volume_tracking_backup_imediato', {}))
        consolidated_data_volume.update(root._backup_data_volume_tracking_end_turn)
        root._backup_data_volume_tracking_super = consolidated_data_volume
        
        consolidated_data_volume_overlays = getattr(root, '_backup_data_volume_overlays', []).copy()
        consolidated_data_volume_overlays.extend(root._backup_data_volume_overlays_end_turn)
        root._backup_data_volume_overlays_super = consolidated_data_volume_overlays
        
        print(f"DEBUG: [END_TURN] ======= CONTADORES PRESERVADOS =======")
        print(f"DEBUG: [END_TURN] Root object: {root}")
        print(f"DEBUG: [END_TURN] Backup salvo (INCREMENTADOS): {root._backup_turn_counters}")
        print(f"DEBUG: [END_TURN] Challenge tracking salvo: {root._backup_challenge_tracking}")
        print(f"DEBUG: [END_TURN] Services super backup: {len(root._backup_service_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Events super backup: {len(root._backup_event_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Data Volume super backup: {len(root._backup_data_volume_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Data Volume overlays backup: {len(root._backup_data_volume_overlays_super)} entries")
        print(f"DEBUG: [END_TURN] SUCCESS: PR√ìXIMO DICE ROLL RESTAURAR√Å OS VALORES INCREMENTADOS!")
        print(f"DEBUG: [END_TURN] ======= FIM PRESERVA√á√ÉO CONTADORES =======")
        
        # CORRE√á√ÉO CR√çTICA: Verifica√ß√£o de Challenges tempo limite removida do end_turn
        # Agora acontece no pr√≥ximo dice roll quando os contadores s√£o realmente incrementados
        print("DEBUG: [END_TURN] Verifica√ß√£o de Challenges tempo limite adiada para pr√≥ximo dice roll")
        
        # NOVO: Verificar servi√ßos TEMPORARY que expiraram
        self._verificar_services_expirados()
        
        # NOVO: Verificar events que expiraram
        self._verificar_events_expirados()
        
        # NOVA CORRE√á√ÉO: Resetar flag Final Phase clicked para o pr√≥ximo turno
        self._final_phase_clicked_this_turn = False
        self._final_phase_turn_id = None
        print("DEBUG: [END_TURN] Flags Final Phase resetadas para pr√≥ximo turno - gest√£o n√£o ser√° restaurada automaticamente")
        
        # CORRE√á√ÉO CR√çTICA: Limpar completamente estado Challenge no final do turno
        # Isto garante que cartas Challenge n√£o persistem para o pr√≥ximo turno
        print("DEBUG: End Turn clicado - limpando estado Challenge antes de terminar turno")
        
        # Limpar vari√°veis Challenge do PlayerDashboard
        if hasattr(self, '_store_challenge_carta_path'):
            self._store_challenge_carta_path = None
            print("DEBUG: _store_challenge_carta_path limpo no End Turn")
        
        if hasattr(self, '_store_challenge_carta_tipo'):
            self._store_challenge_carta_tipo = None
            print("DEBUG: _store_challenge_carta_tipo limpo no End Turn")
        
        # Limpar tamb√©m flags de Challenge
        self._challenge_accepted = False
        print("DEBUG: _challenge_accepted resetado para False no End Turn")
        
        # CORRE√á√ÉO: Reabilitar bot√£o Store no final do turno
        # Isto permite que o jogador use casas Challenge novamente no pr√≥ximo turno
        self.enable_store_button()
        print("DEBUG: Bot√£o Store reabilitado no End Turn - permite novas intera√ß√µes Challenge")
        
        # Limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar todas as vari√°veis relacionadas com Challenge na Store
                    challenge_attrs = ['fullscreen_carta_path', 'fullscreen_carta_tipo', 
                                     '_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                     '_original_carta_path', '_original_carta_tipo']
                    for attr in challenge_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: Store {attr} limpo no End Turn")
            except Exception as e:
                print(f"DEBUG: Erro ao limpar Store no End Turn: {e}")
        
        print("DEBUG: Estado Challenge completamente limpo no End Turn")
        
        # LIMPEZA ADICIONAL: Limpar estados salvos para evitar restaura√ß√µes incorretas no pr√≥ximo turno
        if hasattr(self, '_saved_dashboard_state'):
            self._saved_dashboard_state = None
            print("DEBUG: [END_TURN] Estado salvo do dashboard limpo")
        if hasattr(self, '_estado_botoes_imediato'):
            self._estado_botoes_imediato = None
            print("DEBUG: [END_TURN] Estado imediato dos bot√µes limpo")
        
        # PLACEHOLDER comentado para n√£o bloquear a transi√ß√£o para pr√≥ximo turno
        # Placeholder: l√≥gica para terminar o turno e passar ao pr√≥ximo jogador
        # Aqui pode-se implementar a l√≥gica de altern√¢ncia de jogador
        # import tkinter.messagebox
        # tkinter.messagebox.showinfo("End Turn", "Turno terminado! Pr√≥ximo jogador...")
        # Exemplo: pode-se limpar a interface ou chamar uma fun√ß√£o para o pr√≥ximo jogador
        # CORRE√á√ÉO CR√çTICA: Definir flag para indicar que vamos para o pr√≥ximo turno
        # Detectar ambiente para debug espec√≠fico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        self._coming_from_end_turn = True
        print(f"DEBUG: [END_TURN] AMBIENTE: {ambiente}")
        print(f"DEBUG: [END_TURN] Flag _coming_from_end_turn definida - pr√≥ximo dice roll ir√° incrementar contadores")
        print(f"DEBUG: [END_TURN] Estado atual dos contadores:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # CORRE√á√ÉO FINAL: Limpeza √≥rf√£ no final do turno para garantir limpeza completa
        print("DEBUG: [END_TURN] === LIMPEZA √ìRF√É FINAL ===")
        self._cleanup_orphaned_challenge_tracking()
        print("DEBUG: [END_TURN] === FIM LIMPEZA √ìRF√É FINAL ===")
        
        # NOVO: Enviar mensagem de fim de turno para o servidor (multiplayer)
        self._send_end_turn_to_server()
        
        print("DEBUG: [END_TURN] SUCCESS: M√©todo end_turn() terminado com sucesso - retornando controlo para _criar_botao_end_turn()")

    def _send_end_turn_to_server(self):
        """Envia mensagem de fim de turno para o servidor (multiplayer)"""
        try:
            # Verificar se estamos numa sess√£o multiplayer
            if not hasattr(netmaster_client, 'session_data') or not netmaster_client.session_data:
                print("DEBUG: [END_TURN] N√£o h√° session_data - n√£o √© multiplayer, ignorando envio")
                return
            
            if not netmaster_client.connected:
                print("DEBUG: [END_TURN] Cliente n√£o conectado - n√£o √© poss√≠vel enviar end_turn")
                return
            
            print("DEBUG: [END_TURN] === ENVIANDO MENSAGEM DE FIM DE TURNO PARA SERVIDOR ===")
            
            # Obter dados da sess√£o
            session_data = netmaster_client.session_data
            current_player_id = netmaster_client.player_id
            session_id = session_data.get('id') or getattr(netmaster_client, 'session_id', None)
            
            print(f"DEBUG: [END_TURN] Player ID: {current_player_id}")
            print(f"DEBUG: [END_TURN] Session ID: {session_id}")
            
            if not current_player_id or not session_id:
                print("DEBUG: [END_TURN] Dados de sess√£o incompletos - n√£o enviando end_turn")
                return
            
            # Criar mensagem de fim de turno
            end_turn_message = {
                'type': 'end_turn',
                'session_id': session_id,
                'player_id': current_player_id
            }
            
            print(f"DEBUG: [END_TURN] Mensagem a enviar: {end_turn_message}")
            
            # Usar asyncio para enviar a mensagem de forma ass√≠ncrona
            async def send_message_async():
                try:
                    success = await netmaster_client.send_message(end_turn_message)
                    if success:
                        print("DEBUG: [END_TURN] ‚úì Mensagem end_turn enviada com sucesso!")
                    else:
                        print("DEBUG: [END_TURN] ‚úó Falha ao enviar mensagem end_turn")
                except Exception as e:
                    print(f"DEBUG: [END_TURN] ‚úó Erro ao enviar end_turn: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Executar na thread principal
            try:
                import threading
                import asyncio
                
                # Verificar se estamos numa thread que tem loop asyncio
                try:
                    loop = asyncio.get_running_loop()
                    # Se h√° loop ativo, criar task
                    task = loop.create_task(send_message_async())
                    print("DEBUG: [END_TURN] Task de envio criada no loop existente")
                except RuntimeError:
                    # Se n√£o h√° loop ativo, executar usando run_until_complete em nova thread
                    def run_async():
                        try:
                            asyncio.run(send_message_async())
                        except Exception as e:
                            print(f"DEBUG: [END_TURN] ‚úó Erro na thread ass√≠ncrona: {e}")
                    
                    thread = threading.Thread(target=run_async, daemon=True)
                    thread.start()
                    print("DEBUG: [END_TURN] Thread de envio iniciada")
            except Exception as e:
                print(f"DEBUG: [END_TURN] ‚úó Erro na configura√ß√£o ass√≠ncrona: {e}")
            
            print("DEBUG: [END_TURN] === MENSAGEM DE FIM DE TURNO AGENDADA ===")
        
        except Exception as e:
            print(f"DEBUG: [END_TURN] ‚úó Erro ao processar envio de end_turn: {e}")
            import traceback
            traceback.print_exc()

    def _aplicar_router_upgrade(self, router_id):
        """
        Aplica o efeito ROUTER UPGRADE baseado no router_id.
        Verifica se existe Small Router ativo correspondente e abre invent√°rio para upgrade.
        """
        print(f"DEBUG: [ROUTER_UPGRADE] Aplicando Router Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID √© None - n√£o aplicando upgrade")
            return
        
        # Mapeamento: Small Router -> Medium Router
        equipment_mapping = {
            1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
            2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
            3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID {router_id} n√£o suportado")
            return
        
        small_router, medium_router = equipment_mapping[router_id]
        
        # Verificar se existe o Small Router correspondente ATIVO (virado para cima)
        target_small_router = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == small_router:
                target_small_router = equipment_path
                break
        
        if target_small_router:
            print(f"DEBUG: [ROUTER_UPGRADE] Small Router {small_router} ativo encontrado - procedendo com invent√°rio")
            print(f"DEBUG: [ROUTER_UPGRADE] Router ativo: {os.path.basename(target_small_router)}")
            
            # Verificar se o jogador j√° tem o Medium Router correspondente no invent√°rio
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
            
            if medium_router_exists:
                print(f"DEBUG: [ROUTER_UPGRADE] ERROR: {medium_router} j√° existe no invent√°rio - upgrade n√£o aplicado")
                return
            
            # Definir contexto de ROUTER UPGRADE e router_id
            self._in_router_upgrade_context = True
            self._router_upgrade_target_id = router_id
            
            # Abrir invent√°rio de equipamentos para sele√ß√£o
            self._show_equipment_inventory_for_router_upgrade()
            print("DEBUG: [ROUTER_UPGRADE] SUCCESS: Invent√°rio de equipamentos aberto para upgrade")
        else:
            print(f"DEBUG: [ROUTER_UPGRADE] Nenhum Small Router {small_router} ativo encontrado - n√£o √© poss√≠vel fazer upgrade")
            print(f"DEBUG: [ROUTER_UPGRADE] ROUTER UPGRADE s√≥ funciona se houver {small_router} ativo (virado para cima)")
            print(f"DEBUG: [ROUTER_UPGRADE] Equipamentos ativos encontrados:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_UPGRADE]   - {os.path.basename(equipment_path)}")

    def _show_equipment_inventory_for_router_upgrade(self):
        """Cria p√°gina especializada para ROUTER UPGRADE com equipamentos Small Router filtrados"""
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] Criando p√°gina especializada ROUTER UPGRADE")
        
        # Definir contexto espec√≠fico
        self._in_router_upgrade_context = True
        
        # Obter router_id da Action card ativa
        router_id = getattr(self, '_router_upgrade_target_id', None)
        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Router ID da Action: {router_id}")
        
        if router_id is None:
            print("DEBUG: [ROUTER_UPGRADE_INVENTORY] ERRO: Router ID n√£o definido")
            return
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se necess√°rio
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [ROUTER_UPGRADE_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] TopBar n√£o encontrada, criando fallback")
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] ERRO ao criar TopBar: {e}")
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
        
        # Nome do jogador
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo
        title = tk.Label(self, text="ROUTER UPGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Filtrar equipamentos Small Router com specific_id igual ao router_id
        equipamentos_filtrados = []
        all_equipments = self.inventario.get("equipments", [])
        
        for equipment_path in all_equipments:
            try:
                # Extrair n√∫mero do equipamento do nome do arquivo (Equipment_X.png)
                filename = os.path.basename(equipment_path)
                if filename.startswith("Equipment_") and filename.endswith(".png"):
                    equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
                    
                    # Small Router s√£o Equipment_1, Equipment_2, Equipment_3
                    if 1 <= equipment_num <= 3 and equipment_num == router_id:
                        equipamentos_filtrados.append(equipment_path)
                        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment filtrado: {filename} (router_id={router_id})")
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao processar equipamento {equipment_path}: {e}")
                continue
        
        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Total equipamentos filtrados: {len(equipamentos_filtrados)}")
        
        # Layout baseado no n√∫mero de equipamentos
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120
        total_equipments = len(equipamentos_filtrados)
        
        if total_equipments == 1:
            # Carta √∫nica - layout centralizado
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Carta √∫nica detectada - usando layout centralizado")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
        else:
            # M√∫ltiplas cartas - grid 2xn
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] M√∫ltiplas cartas detectadas - usando grid 2xn")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)
        
        # Colocar equipamentos em layout apropriado
        for idx, equipment_path in enumerate(equipamentos_filtrados):
            try:
                if total_equipments == 1:
                    # Carta √∫nica - centralizar na posi√ß√£o (0,0)
                    row, col = 0, 0
                else:
                    # M√∫ltiplas cartas - grid 2xn
                    row = idx // 2
                    col = idx % 2
                
                # Verificar se equipamento est√° ativo
                is_active = self.is_card_active(equipment_path, "equipments")
                
                if is_active:
                    # Equipamento ativo: mostrar virado para cima
                    img = ImageTk.PhotoImage(Image.open(equipment_path).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment ATIVO: {os.path.basename(equipment_path)}")
                else:
                    # Equipamento inativo: mostrar virado para baixo
                    back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment INATIVO: {os.path.basename(equipment_path)}")
                
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Click handler para fullscreen
                def make_click_handler(path):
                    return lambda e: self._show_equipment_fullscreen_router_upgrade(path)
                
                carta_lbl.bind("<Button-1>", make_click_handler(equipment_path))
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao carregar equipment: {e}")
                continue
        
        # Barra inferior
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Barra inferior carregada")
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao carregar barra inferior: {e}")
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)
        
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] SUCCESS: P√°gina ROUTER UPGRADE criada")

    def _show_equipment_fullscreen_router_upgrade(self, equipment_path):
        """Mostra equipamento em fullscreen para ROUTER UPGRADE com bot√µes de confirma√ß√£o"""
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(equipment_path)}")
        
        # Verificar se equipamento est√° ativo
        is_active = self.is_card_active(equipment_path, "equipments")
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Equipment {os.path.basename(equipment_path)} ativo: {is_active}")
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] active_equipments: {[os.path.basename(p) for p in self.active_equipments]}")
        
        if not is_active:
            print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Equipamento inativo - n√£o permitindo upgrade")
            return
        
        # Usar o mesmo padr√£o do fullscreen normal: limpar widgets e usar janela principal
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == getattr(self, 'topbar_label', None):
                continue
            widget.destroy()
        
        # Carregar e exibir imagem do equipamento
        try:
            pil_img = Image.open(equipment_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
            # Fallback: mostrar placeholder
            placeholder = tk.Label(self, text="Equipment Image", font=("Helvetica", 24), fg="white", bg="black")
            placeholder.place(relx=0.5, rely=0.5, anchor="center")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para p√°gina ROUTER UPGRADE
        def close_fullscreen():
            print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Fechando fullscreen - voltando para p√°gina ROUTER UPGRADE")
            self._show_equipment_inventory_for_router_upgrade()
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o de confirma√ß√£o (roxo, canto superior direito)
        def confirm_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Confirmando upgrade: {os.path.basename(equipment_path)}")
            self._executar_router_upgrade(equipment_path)
        
        confirm_btn = tk.Button(
            self,
            text="‚úì",
            font=("Helvetica", 24, "bold"),
            bg="#800080",  # Roxo
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_upgrade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] ===== FULLSCREEN CRIADO COM SUCESSO =====")
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Usando padr√£o normal de fullscreen (sem Toplevel)")
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] ===== FIM DEBUG FULLSCREEN =====")

    def _executar_router_upgrade(self, small_router_path):
        """Mostra overlay de confirma√ß√£o para ROUTER UPGRADE"""
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Mostrando overlay de confirma√ß√£o: {os.path.basename(small_router_path)}")
        
        try:
            # Extrair router_id do nome do arquivo
            filename = os.path.basename(small_router_path)
            router_id = int(filename.replace("Equipment_", "").replace(".png", ""))
            
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Router ID: {router_id}")
            
            # Mostrar overlay de confirma√ß√£o (como na ativa√ß√£o normal)
            self._mostrar_overlay_confirmacao_router_upgrade(small_router_path, router_id)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERRO: {e}")

    def _mostrar_overlay_confirmacao_router_upgrade(self, small_router_path, router_id):
        """Mostra overlay de confirma√ß√£o para ROUTER UPGRADE (igual ao de ativa√ß√£o normal)"""
        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Criando overlay: Router ID {router_id}")
        
        # Obter specific_id da carta Equipment atrav√©s da base de dados
        specific_id = router_id  # Fallback para o router_id caso n√£o encontre na base de dados
        if self.card_database:
            try:
                # Extrair filename da carta
                filename = os.path.basename(small_router_path)
                
                # Determinar cor baseada no diret√≥rio
                color = None
                if "/red/" in small_router_path.lower():
                    color = "red"
                elif "/green/" in small_router_path.lower():
                    color = "green"
                elif "/blue/" in small_router_path.lower():
                    color = "blue"
                elif "/yellow/" in small_router_path.lower():
                    color = "yellow"
                
                if color:
                    # Construir equipment_id baseado no filename e cor
                    equipment_id = f"small_router_{router_id}_{color}"
                    equipment_card = self.card_database.get_equipment(equipment_id)
                    
                    if equipment_card:
                        specific_id = equipment_card.specific_id
                        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Specific ID encontrado: {specific_id}")
                    else:
                        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Equipment n√£o encontrado: {equipment_id}")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Cor n√£o detectada no path: {small_router_path}")
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Erro ao obter specific_id: {e}")
        
        # Limpar TODOS os widgets (igual √† ativa√ß√£o normal)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (igual √† ativa√ß√£o normal)
        try:
            carta_img = Image.open(small_router_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Erro ao carregar imagem: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (igual √† ativa√ß√£o normal)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo (igual √† ativa√ß√£o normal)
        tk.Label(confirm_frame, text="Router Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirma√ß√£o com specific_id
        tk.Label(confirm_frame, text=f"Router {specific_id} is going to be upgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para o bot√£o (s√≥ bot√£o Ok)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo - sem bot√£o No)
        def confirmar_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Ok clicado - executando upgrade")
            self._processar_router_upgrade_completo(small_router_path, router_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",  # Roxo (purple)
            fg="white",
            width=8,
            height=2,
            command=confirmar_upgrade,
            cursor="hand2"
        )
        ok_btn.pack(padx=20)
        
        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] SUCCESS: Overlay criado - aguardando confirma√ß√£o")

    def _execute_detection_for_router_upgrade(self, object_name, loading_window):
        """
        Executa detec√ß√£o YOLO espec√≠fica para ROUTER UPGRADE que volta para PlayerDashboard principal.
        
        Args:
            object_name: Nome do objeto para dete√ß√£o
            loading_window: Loading screen j√° criado
            
        Returns:
            True se o script executou com sucesso, False caso contr√°rio
        """
        try:
            # Usar os utilit√°rios universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Simulando execu√ß√£o do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
                # Simular delay e voltar para PlayerDashboard principal
                if loading_window:
                    def close_loading_and_return_to_dashboard():
                        loading_window.destroy()
                        # CORRE√á√ÉO: Voltar para PlayerDashboard principal, n√£o invent√°rio
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    self.after(3000, close_loading_and_return_to_dashboard)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Script n√£o encontrado")
                    return False
            
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Executando: {script_path} {object_name}")
            
            # Tornar o script execut√°vel
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, object_name])
            
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Script iniciado (PID: {process.pid})")
            
            # Monitorar script com loading screen existente
            if loading_window:
                def check_yolo_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO deve estar inicializado - fechar loading screen
                        print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Fechando loading screen - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o
                        def check_script_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_script_completion)
                            else:
                                print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] YOLO terminou - voltando para PlayerDashboard principal")
                                self.deiconify()
                                # CORRE√á√ÉO: Voltar para PlayerDashboard principal, n√£o invent√°rio
                                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                        self.after(1000, check_script_completion)
                    else:
                        # Script terminou antes de inicializar
                        loading_window.destroy()
                        # CORRE√á√ÉO: Voltar para PlayerDashboard principal, n√£o invent√°rio
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_yolo_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False

    def _execute_two_phase_detection_for_router_upgrade(self, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name):
        """
        Executa detec√ß√£o YOLO em duas fases para ROUTER UPGRADE:
        1. Primeira fase: Detectar objeto antigo (Small Router)
        2. Segunda fase: Detectar objeto novo (Medium Router)  
        3. Finaliza√ß√£o: Voltar ao PlayerDashboard principal
        
        Args:
            old_object_name: Nome do objeto antigo para primeira detec√ß√£o
            new_object_name: Nome do objeto novo para segunda detec√ß√£o
            loading_window: Loading screen j√° criado
            old_equipment_name: Nome do equipamento antigo (ex: "Equipment_1.png")
            new_equipment_name: Nome do equipamento novo (ex: "Equipment_4.png")
            
        Returns:
            True se o processo foi iniciado com sucesso, False caso contr√°rio
        """
        try:
            print(f"DEBUG: [TWO_PHASE_DETECTION] === INICIANDO DETEC√á√ÉO EM DUAS FASES ===")
            print(f"DEBUG: [TWO_PHASE_DETECTION] Fase 1: {old_equipment_name} -> {old_object_name}")
            print(f"DEBUG: [TWO_PHASE_DETECTION] Fase 2: {new_equipment_name} -> {new_object_name}")
            
            # Usar os utilit√°rios universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando detec√ß√£o em duas fases (ambiente: {universal_paths['environment']})")
                # Simular sequ√™ncia completa e voltar para PlayerDashboard principal
                if loading_window:
                    def simulate_two_phase_detection():
                        # Simular primeira fase (3 segundos)
                        print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando Fase 1: {old_object_name}")
                        
                        def start_phase_2():
                            loading_window.destroy()
                            # Criar loading screen para segunda fase
                            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
                            if phase_2_loading:
                                print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando Fase 2: {new_object_name}")
                                
                                def finish_detection():
                                    phase_2_loading.destroy()
                                    print(f"DEBUG: [TWO_PHASE_DETECTION] Simula√ß√£o completa - voltando ao PlayerDashboard")
                                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                                
                                self.after(3000, finish_detection)
                        
                        self.after(3000, start_phase_2)
                    
                    self.after(100, simulate_two_phase_detection)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [TWO_PHASE_DETECTION] Script n√£o encontrado")
                    return False
            
            print(f"DEBUG: [TWO_PHASE_DETECTION] Script encontrado: {script_path}")
            
            # Tornar o script execut√°vel
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Iniciar primeira fase da detec√ß√£o
            self._start_phase_1_detection(script_path, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [TWO_PHASE_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False
    
    def _start_phase_1_detection(self, script_path, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name):
        """Inicia a primeira fase da detec√ß√£o (objeto antigo)"""
        try:
            print(f"DEBUG: [PHASE_1] === INICIANDO FASE 1: {old_equipment_name} ===")
            print(f"DEBUG: [PHASE_1] Executando: {script_path} {old_object_name}")
            
            # Executar script para primeira detec√ß√£o
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [PHASE_1] Script Fase 1 iniciado (PID: {process.pid})")
            
            # Monitorar primeira fase
            if loading_window:
                def check_phase_1_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [PHASE_1] Fechando loading screen Fase 1 - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [PHASE_1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()
                                # Iniciar segunda fase
                                self._start_phase_2_detection(script_path, new_object_name, new_equipment_name)
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [PHASE_1] Fase 1 terminou inesperadamente")
                        loading_window.destroy()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
                
        except Exception as e:
            print(f"DEBUG: [PHASE_1] Erro na Fase 1: {e}")
            if loading_window:
                loading_window.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _start_phase_2_detection(self, script_path, new_object_name, new_equipment_name):
        """Inicia a segunda fase da detec√ß√£o (objeto novo)"""
        try:
            print(f"DEBUG: [PHASE_2] === INICIANDO FASE 2: {new_equipment_name} ===")
            
            # Criar novo loading screen para segunda fase
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [PHASE_2] ERRO: N√£o foi poss√≠vel criar loading screen Fase 2")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
                
            print(f"DEBUG: [PHASE_2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [PHASE_2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detec√ß√£o
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [PHASE_2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar segunda fase
            def check_phase_2_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO Fase 2 inicializado - fechar loading screen
                    print(f"DEBUG: [PHASE_2] Fechando loading screen Fase 2 - YOLO inicializando")
                    phase_2_loading.destroy()
                    self.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclus√£o da Fase 2
                    def check_phase_2_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            self.after(1000, check_phase_2_completion)
                        else:
                            print(f"DEBUG: [PHASE_2] === DETEC√á√ÉO COMPLETA - VOLTANDO AO PLAYERDASHBOARD ===")
                            self.deiconify()
                            # Voltar ao PlayerDashboard principal
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    self.after(1000, check_phase_2_completion)
                else:
                    # Script terminou antes de inicializar
                    print(f"DEBUG: [PHASE_2] Fase 2 terminou inesperadamente")
                    phase_2_loading.destroy()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # Aguardar 4.5 segundos para YOLO inicializar
            self.after(4500, check_phase_2_initialization)
                
        except Exception as e:
            print(f"DEBUG: [PHASE_2] Erro na Fase 2: {e}")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def _processar_router_upgrade_completo(self, small_router_path, router_id):
        """Processa o upgrade completo: troca de equipamento + YOLO detection (igual √† ativa√ß√£o normal)"""
        print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Processando upgrade completo: Router {router_id}")
        
        try:
            # Obter object_name da carta (igual √† ativa√ß√£o normal)
            object_name = get_equipment_object_name(small_router_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Criando loading screen para object: {object_name}")
                
                # CRIAR LOADING SCREEN IMEDIATAMENTE (igual √† ativa√ß√£o normal)
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Loading screen criado - processando upgrade em background")
                    
                    # Fun√ß√£o para processar upgrade depois do loading screen estar ativo
                    def processar_upgrade_com_yolo():
                        try:
                            # Mapeamento Small Router -> Medium Router
                            equipment_mapping = {
                                1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
                                2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
                                3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
                            }
                            
                            small_router_file, medium_router_file = equipment_mapping[router_id]
                            
                            # Construir caminhos completos
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] Path original Small Router: {small_router_path}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] dirname(small_router_path): {os.path.dirname(small_router_path)}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] dirname(dirname(small_router_path)): {os.path.dirname(os.path.dirname(small_router_path))}")
                            
                            # CORRE√á√ÉO: Usar o mesmo diret√≥rio do Small Router para construir path do Medium Router
                            # Se Small Router est√° em: /path/color/Equipment_1.png
                            # Medium Router deve estar em: /path/color/Equipment_4.png
                            small_router_dir = os.path.dirname(small_router_path)
                            medium_router_path = os.path.join(small_router_dir, medium_router_file)
                            
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Upgrade: {small_router_file} -> {medium_router_file}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router directory: {small_router_dir}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Caminho Medium Router CORRIGIDO: {medium_router_path}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Verificando se arquivo existe: {os.path.exists(medium_router_path)}")
                            
                            # CORRE√á√ÉO: Remover Small Router do invent√°rio
                            if small_router_path in self.inventario.get("equipments", []):
                                self.inventario["equipments"].remove(small_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router removido do invent√°rio")
                            
                            # Verificar se Medium Router existe no invent√°rio
                            if medium_router_path not in self.inventario.get("equipments", []):
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ADICIONANDO Medium Router ao invent√°rio")
                                self.inventario["equipments"].append(medium_router_path)
                            
                            # Remover Small Router dos ativos
                            if small_router_path in self.active_equipments:
                                self.active_equipments.remove(small_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router removido dos ativos")
                            
                            # Adicionar Medium Router aos ativos
                            if medium_router_path not in self.active_equipments:
                                self.active_equipments.append(medium_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Medium Router adicionado aos ativos")
                            
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Upgrade executado - iniciando detec√ß√£o em duas fases")
                            
                            # Obter object_name do Medium Router para segunda detec√ß√£o
                            medium_router_object_name = get_equipment_object_name(medium_router_path, self.card_database)
                            
                            # Executar detec√ß√£o em duas fases: Small Router primeiro, depois Medium Router
                            detection_success = self._execute_two_phase_detection_for_router_upgrade(
                                object_name, medium_router_object_name, loading_window, small_router_file, medium_router_file
                            )
                            
                            if detection_success:
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Detec√ß√£o em duas fases iniciada com sucesso")
                                # O processo ir√° gerir automaticamente as duas detec√ß√µes e voltar ao PlayerDashboard
                            else:
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] AVISO: Detec√ß√£o falhou - fechando loading screen")
                                if loading_window:
                                    loading_window.destroy()
                                # Voltar ao PlayerDashboard em caso de erro
                                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                                
                        except Exception as e:
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO no upgrade: {e}")
                            if loading_window:
                                loading_window.destroy()
                            # Voltar ao PlayerDashboard em caso de erro
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    # Executar upgrade ap√≥s 100ms (loading screen j√° est√° vis√≠vel)
                    self.after(100, processar_upgrade_com_yolo)
                    
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO: Loading screen n√£o foi criado - voltando para dashboard")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            else:
                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] AVISO: Object name n√£o encontrado - voltando para dashboard")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            print("DEBUG: [ROUTER_UPGRADE_PROCESS] SUCCESS: Router upgrade iniciado")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO durante upgrade: {e}")
            # Voltar ao PlayerDashboard em caso de erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)



    def _show_equipment_inventory_for_router_downgrade(self):
        """Cria p√°gina especializada para ROUTER DOWNGRADE com equipamentos Medium Router filtrados"""
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Criando p√°gina especializada ROUTER DOWNGRADE")
        
        # Definir contexto espec√≠fico
        self._in_router_downgrade_context = True
        
        # Obter router_id da Action card ativa
        router_id = getattr(self, '_router_downgrade_target_id', None)
        print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Router ID da Action: {router_id}")
        
        if router_id is None:
            print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] ERRO: Router ID n√£o definido")
            return
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se necess√°rio
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] TopBar n√£o encontrada, criando fallback")
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] ERRO ao criar TopBar: {e}")
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
        
        # Nome do jogador
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo
        title = tk.Label(self, text="ROUTER DOWNGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Filtrar equipamentos Medium Router com specific_id igual ao router_id
        equipamentos_filtrados = []
        all_equipments = self.inventario.get("equipments", [])
        
        for equipment_path in all_equipments:
            try:
                # Extrair n√∫mero do equipamento do nome do arquivo (Equipment_X.png)
                filename = os.path.basename(equipment_path)
                if filename.startswith("Equipment_") and filename.endswith(".png"):
                    equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
                    
                    # Medium Router s√£o Equipment_4, Equipment_5, Equipment_6
                    # Equipment_4 = Medium Router 1, Equipment_5 = Medium Router 2, Equipment_6 = Medium Router 3
                    if 4 <= equipment_num <= 6:
                        medium_router_id = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, Equipment_6 -> 3
                        if medium_router_id == router_id:
                            equipamentos_filtrados.append(equipment_path)
                            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment filtrado: {filename} (router_id={router_id})")
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao processar equipamento {equipment_path}: {e}")
                continue
        
        print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Total equipamentos filtrados: {len(equipamentos_filtrados)}")
        
        # Layout baseado no n√∫mero de equipamentos
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120
        total_equipments = len(equipamentos_filtrados)
        
        if total_equipments == 1:
            # Carta √∫nica - layout centralizado
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Carta √∫nica detectada - usando layout centralizado")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
        else:
            # M√∫ltiplas cartas - grid 2xn
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] M√∫ltiplas cartas detectadas - usando grid 2xn")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)
        
        # Colocar equipamentos em layout apropriado
        for idx, equipment_path in enumerate(equipamentos_filtrados):
            try:
                if total_equipments == 1:
                    # Carta √∫nica - centralizar na posi√ß√£o (0,0)
                    row, col = 0, 0
                else:
                    # M√∫ltiplas cartas - grid 2xn
                    row = idx // 2
                    col = idx % 2
                
                # Verificar se equipamento est√° ativo
                is_active = self.is_card_active(equipment_path, "equipments")
                
                if is_active:
                    # Equipamento ativo: mostrar virado para cima
                    img = ImageTk.PhotoImage(Image.open(equipment_path).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment ATIVO: {os.path.basename(equipment_path)}")
                else:
                    # Equipamento inativo: mostrar virado para baixo
                    back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment INATIVO: {os.path.basename(equipment_path)}")
                
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Click handler para fullscreen
                def make_click_handler(path):
                    return lambda e: self._show_equipment_fullscreen_router_downgrade(path)
                
                carta_lbl.bind("<Button-1>", make_click_handler(equipment_path))
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao carregar equipment: {e}")
                continue
        
        # Barra inferior
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Barra inferior carregada")
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao carregar barra inferior: {e}")
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)
        
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] SUCCESS: P√°gina ROUTER DOWNGRADE criada")

    def _show_equipment_fullscreen_router_downgrade(self, equipment_path):
        """Mostra equipamento em fullscreen para ROUTER DOWNGRADE com bot√µes de confirma√ß√£o"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(equipment_path)}")
        
        # Verificar se equipamento est√° ativo
        is_active = self.is_card_active(equipment_path, "equipments")
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Equipment {os.path.basename(equipment_path)} ativo: {is_active}")
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] active_equipments: {[os.path.basename(p) for p in self.active_equipments]}")
        
        if not is_active:
            print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Equipamento inativo - n√£o permitindo downgrade")
            return
        
        # Usar o mesmo padr√£o do fullscreen normal: limpar widgets e usar janela principal
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == getattr(self, 'topbar_label', None):
                continue
            widget.destroy()
        
        # Carregar e exibir imagem do equipamento
        try:
            pil_img = Image.open(equipment_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
            # Fallback: mostrar placeholder
            placeholder = tk.Label(self, text="Equipment Image", font=("Helvetica", 24), fg="white", bg="black")
            placeholder.place(relx=0.5, rely=0.5, anchor="center")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para p√°gina ROUTER DOWNGRADE
        def close_fullscreen():
            print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Fechando fullscreen - voltando para p√°gina ROUTER DOWNGRADE")
            self._show_equipment_inventory_for_router_downgrade()
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o de confirma√ß√£o (roxo, canto superior direito)
        def confirm_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Confirmando downgrade: {os.path.basename(equipment_path)}")
            self._mostrar_overlay_confirmacao_router_downgrade(equipment_path)
        
        confirm_btn = tk.Button(
            self,
            text="‚úì",
            font=("Helvetica", 24, "bold"),
            bg="#800080",  # Roxo
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_downgrade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] ===== FULLSCREEN CRIADO COM SUCESSO =====")
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Usando padr√£o normal de fullscreen (sem Toplevel)")
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] ===== FIM DEBUG FULLSCREEN =====")

    def _mostrar_overlay_confirmacao_router_downgrade(self, equipment_path):
        """Mostra overlay de confirma√ß√£o para ROUTER DOWNGRADE (usando mesmo m√©todo que ROUTER UPGRADE)"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Mostrando confirma√ß√£o: {os.path.basename(equipment_path)}")
        
        # Limpar TODOS os widgets da janela principal (igual ao ROUTER UPGRADE)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(equipment_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao carregar imagem: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (igual ao ROUTER UPGRADE)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo (igual ao ROUTER UPGRADE)
        tk.Label(confirm_frame, text="Router Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta Equipment
        specific_id = "N/A"
        router_id = None
        try:
            if self.card_database:
                # Extrair informa√ß√µes do caminho
                filename = os.path.basename(equipment_path)
                color = self._get_color_from_path(equipment_path)
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Filename: {filename}, Color: {color}")
                
                # Mapear filename para equipment_id
                match = re.match(r'Equipment_(\d+)\.png', filename)
                if match:
                    equipment_num = int(match.group(1))
                    
                    # Equipment_4.png, Equipment_5.png, Equipment_6.png -> medium_router_1_color, etc
                    if 4 <= equipment_num <= 6:
                        specific_id_num = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, etc
                        router_id = specific_id_num
                        equipment_id = f"medium_router_{specific_id_num}_{color}"
                        
                        # Obter carta da base de dados
                        equipment_result = self.card_database.get_equipment_with_file(equipment_id)
                        
                        if equipment_result:
                            equipment_data, _ = equipment_result
                            # CORRE√á√ÉO: EquipmentCard √© um objeto, n√£o um dict - usar atributo diretamente
                            specific_id = str(getattr(equipment_data, 'specific_id', specific_id_num))
                            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment encontrado - specific_id: {specific_id}")
                        else:
                            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment n√£o encontrado na base de dados")
                            specific_id = str(specific_id_num)  # Fallback para n√∫mero calculado
                    else:
                        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment number fora do range Medium Router: {equipment_num}")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Filename n√£o corresponde ao padr√£o Equipment_X.png")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Card database n√£o dispon√≠vel")
                
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao obter specific_id: {e}")
            # Usar fallback baseado em router_id se dispon√≠vel
            if hasattr(self, '_router_downgrade_target_id') and self._router_downgrade_target_id:
                specific_id = str(self._router_downgrade_target_id)
        
        # Mensagem de confirma√ß√£o com specific_id (igual ao ROUTER UPGRADE)
        tk.Label(confirm_frame, text=f"Router {specific_id} is going to be downgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o bot√£o (s√≥ bot√£o Ok, igual ao ROUTER UPGRADE)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo - sem bot√£o Cancel, igual ao ROUTER UPGRADE)
        def confirmar_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Ok clicado - executando downgrade")
            self._executar_router_downgrade(equipment_path)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",  # Roxo (purple) - igual ao ROUTER UPGRADE
            fg="white",
            width=8,
            height=2,
            command=confirmar_downgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Overlay de confirma√ß√£o criado")

    def _executar_router_downgrade(self, medium_router_path):
        """Executa o processo de ROUTER DOWNGRADE com detec√ß√£o em duas fases"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Executando downgrade: {os.path.basename(medium_router_path)}")
        
        try:
            # Extrair router_id do nome do arquivo
            filename = os.path.basename(medium_router_path)
            equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
            router_id = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, Equipment_6 -> 3
            
            # Mapeamento Medium Router -> Small Router
            equipment_mapping = {
                1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
                2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
                3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
            }
            
            medium_router_file, small_router_file = equipment_mapping[router_id]
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Downgrade: {medium_router_file} -> {small_router_file}")
            
            # NOVA L√ìGICA: Executar detec√ß√£o em duas fases antes de processar downgrade
            # Fase 1: Detectar Medium Router (objeto atual)
            # Fase 2: Detectar Small Router (objeto de destino)
            
            # Obter object names para detec√ß√£o ANTES de criar loading screen
            old_object_name = get_equipment_object_name(medium_router_path, self.card_database)
            
            # Criar loading screen inicial com object name real
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else "router_medio_vermelho")
            
            if loading_window:
                print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Loading screen criado - iniciando detec√ß√£o duas fases")
                
                # Construir caminho para Small Router (usar mesmo diret√≥rio do Medium Router)
                small_router_path = os.path.join(os.path.dirname(medium_router_path), small_router_file)
                new_object_name = get_equipment_object_name(small_router_path, self.card_database)
                
                old_equipment_name = f"Medium Router {router_id}"
                new_equipment_name = f"Small Router {router_id}"
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Old object: {old_object_name}")
                print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] New object: {new_object_name}")
                
                if old_object_name and new_object_name:
                    # Executar detec√ß√£o em duas fases
                    success = self._execute_two_phase_detection_for_router_downgrade(
                        old_object_name, new_object_name, loading_window, 
                        old_equipment_name, new_equipment_name, medium_router_path, router_id
                    )
                    
                    if success:
                        print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] SUCCESS: Detec√ß√£o duas fases iniciada")
                        # Processamento ser√° continuado ap√≥s detec√ß√£o bem-sucedida
                        return
                    else:
                        print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: Falha ao iniciar detec√ß√£o duas fases")
                        if loading_window:
                            loading_window.destroy()
                else:
                    print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: N√£o foi poss√≠vel obter object names")
                    if loading_window:
                        loading_window.destroy()
            else:
                print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: N√£o foi poss√≠vel criar loading screen")
            
            # Fallback: se detec√ß√£o falhar, processar diretamente (desenvolvimento)
            print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Fallback: processando downgrade diretamente")
            self._processar_router_downgrade_completo(medium_router_path, router_id)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO durante downgrade: {e}")
            # Limpar flags em caso de erro
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None

    def _execute_two_phase_detection_for_router_downgrade(self, old_object_name, new_object_name, loading_window, 
                                                        old_equipment_name, new_equipment_name, medium_router_path, router_id):
        """
        Executa detec√ß√£o YOLO em duas fases para ROUTER DOWNGRADE:
        Fase 1: Detectar Medium Router (objeto atual)
        Fase 2: Detectar Small Router (objeto de destino)
        """
        try:
            # Usar os utilit√°rios universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print("DEBUG: [ROUTER_DOWNGRADE_2PHASE] Ambiente n√£o √© Raspberry Pi - usando fallback")
                if loading_window:
                    loading_window.destroy()
                # Processar downgrade diretamente no desenvolvimento
                self.after(1000, lambda: self._processar_router_downgrade_completo(medium_router_path, router_id))
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Script n√£o encontrado: {script_path}")
                if loading_window:
                    loading_window.destroy()
                return False
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Iniciando Fase 1: {old_object_name}")
            
            # Iniciar Fase 1: Detec√ß√£o do Medium Router
            success = self._start_phase_1_detection_downgrade(
                script_path, old_object_name, new_object_name, loading_window, 
                old_equipment_name, new_equipment_name, medium_router_path, router_id
            )
            
            return success
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False

    def _start_phase_1_detection_downgrade(self, script_path, old_object_name, new_object_name, loading_window, 
                                         old_equipment_name, new_equipment_name, medium_router_path, router_id):
        """Inicia Fase 1: Detec√ß√£o do Medium Router atual"""
        try:
            print(f"DEBUG: [DOWNGRADE_PHASE1] Executando: {script_path} {old_object_name}")
            
            # Tornar o script execut√°vel
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [DOWNGRADE_PHASE1] Script iniciado (PID: {process.pid})")
            
            # Monitorar inicializa√ß√£o da Fase 1 (igual ao ROUTER UPGRADE)
            def check_phase_1_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [DOWNGRADE_PHASE1] Fechando loading screen Fase 1 - YOLO inicializando")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [DOWNGRADE_PHASE1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Iniciar segunda fase
                                self._start_phase_2_detection_downgrade(
                                    script_path, new_object_name, new_equipment_name, 
                                    medium_router_path, router_id
                                )
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [DOWNGRADE_PHASE1] Fase 1 terminou inesperadamente")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        # Fallback: processar diretamente
                        self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                except Exception as e:
                    print(f"DEBUG: [DOWNGRADE_PHASE1] Erro no monitor: {e}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: processar diretamente
                    self._processar_router_downgrade_completo(medium_router_path, router_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_1_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [DOWNGRADE_PHASE1] Erro: {e}")
            if loading_window and loading_window.winfo_exists():
                loading_window.destroy()
            return False

    def _start_phase_2_detection_downgrade(self, script_path, new_object_name, new_equipment_name, 
                                         medium_router_path, router_id):
        """Inicia Fase 2: Detec√ß√£o do Small Router de destino (igual ao ROUTER UPGRADE)"""
        try:
            print(f"DEBUG: [DOWNGRADE_PHASE2] === INICIANDO FASE 2: {new_equipment_name} ===")
            
            # Criar novo loading screen para segunda fase
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [DOWNGRADE_PHASE2] ERRO: N√£o foi poss√≠vel criar loading screen Fase 2")
                self._processar_router_downgrade_completo(medium_router_path, router_id)
                return
                
            print(f"DEBUG: [DOWNGRADE_PHASE2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [DOWNGRADE_PHASE2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detec√ß√£o
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [DOWNGRADE_PHASE2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar inicializa√ß√£o da Fase 2 (igual ao ROUTER UPGRADE)
            def check_phase_2_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 2 inicializado - fechar loading screen atual
                        print(f"DEBUG: [DOWNGRADE_PHASE2] Fechando loading screen Fase 2 - YOLO inicializando")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o da Fase 2
                        def check_phase_2_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_2_completion)
                            else:
                                print(f"DEBUG: [DOWNGRADE_PHASE2] Fase 2 completa - processando downgrade")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Processar downgrade completo
                                self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                        self.after(1000, check_phase_2_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [DOWNGRADE_PHASE2] Fase 2 terminou inesperadamente")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        # Fallback: processar diretamente
                        self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                except Exception as e:
                    print(f"DEBUG: [DOWNGRADE_PHASE2] Erro no monitor: {e}")
                    if phase_2_loading and phase_2_loading.winfo_exists():
                        phase_2_loading.destroy()
                    # Fallback: processar diretamente
                    self._processar_router_downgrade_completo(medium_router_path, router_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_2_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [DOWNGRADE_PHASE2] Erro: {e}")
            return False

    def _processar_router_downgrade_completo(self, medium_router_path, router_id):
        """
        Processa efetivamente o ROUTER DOWNGRADE ap√≥s detec√ß√£o bem-sucedida.
        Remove Medium Router e adiciona Small Router correspondente.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Processando downgrade completo")
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Medium Router: {os.path.basename(medium_router_path)}")
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Router ID: {router_id}")
        
        try:
            # Mapeamento: Medium Router -> Small Router
            equipment_mapping = {
                1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
                2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
                3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
            }
            
            medium_router_file, small_router_file = equipment_mapping[router_id]
            
            # PASSO 1: Remover Medium Router dos equipments ativos
            medium_router_path_ativo = None
            for equipment_path in self.active_equipments:
                if os.path.basename(equipment_path) == medium_router_file:
                    medium_router_path_ativo = equipment_path
                    break
            
            if medium_router_path_ativo:
                self.active_equipments.remove(medium_router_path_ativo)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} removido dos equipments ativos")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] AVISO: {medium_router_file} n√£o encontrado nos equipments ativos")
            
            # PASSO 2: Remover Medium Router do invent√°rio
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_inventory = None
            for equipment_path in equipments_inventory:
                if os.path.basename(equipment_path) == medium_router_file:
                    medium_router_inventory = equipment_path
                    break
            
            if medium_router_inventory:
                self.inventario["equipments"].remove(medium_router_inventory)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} removido do invent√°rio")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] AVISO: {medium_router_file} n√£o encontrado no invent√°rio")
            
            # PASSO 3: Adicionar Small Router ao invent√°rio (usar mesmo diret√≥rio)
            small_router_path = os.path.join(os.path.dirname(medium_router_path), small_router_file)
            
            # Verificar se j√° existe no invent√°rio
            small_router_exists = any(
                os.path.basename(equipment_path) == small_router_file 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not small_router_exists:
                self.inventario["equipments"].append(small_router_path)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} adicionado ao invent√°rio")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} j√° existe no invent√°rio")
            
            # PASSO 4: CORRE√á√ÉO CR√çTICA - Ativar Small Router (igual ao ROUTER UPGRADE)
            # Adicionar Small Router aos equipments ativos para que fique virado para cima
            if small_router_path not in self.active_equipments:
                self.active_equipments.append(small_router_path)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] CORRE√á√ÉO: {small_router_file} adicionado aos ativos (carta fica virada para cima)")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} j√° est√° nos ativos")
            
            # PASSO 5: Limpar flags de contexto
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] SUCCESS: Router Downgrade aplicado com sucesso!")
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} -> {small_router_file} (ATIVO)")
            
            # PASSO 6: Voltar para o PlayerDashboard ap√≥s processamento completo
            self.after(1000, lambda: self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            ))
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] ERRO durante processamento: {e}")
            # Limpar flags em caso de erro
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None
            
            # Voltar para dashboard mesmo em caso de erro
            self.after(1000, lambda: self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            ))

    def _aplicar_router_downgrade(self, router_id):
        """
        Inicia o processo ROUTER DOWNGRADE baseado no router_id.
        Verifica se o medium router est√° ativo antes de mostrar overlay de confirma√ß√£o.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Iniciando Router Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID √© None - n√£o aplicando downgrade")
            return
        
        # Validar router_id suportado
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID {router_id} n√£o suportado")
            return
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORRE√á√ÉO CR√çTICA: Verificar se o medium router est√° ATIVO antes de mostrar overlay
        medium_router_ativo = any(
            os.path.basename(equipment_path) == medium_router 
            for equipment_path in self.active_equipments
        )
        
        print(f"DEBUG: [ROUTER_DOWNGRADE] Verificando se {medium_router} est√° ativo...")
        print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
        print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} ativo: {medium_router_ativo}")
        
        if not medium_router_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ERROR: {medium_router} n√£o est√° ativo - ROUTER DOWNGRADE n√£o pode ser aplicado")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Action_32 foi consumida mas o efeito n√£o se aplica")
            return
        
        # Medium router est√° ativo - ir DIRETAMENTE para invent√°rio de Equipments
        print(f"DEBUG: [ROUTER_DOWNGRADE] SUCCESS: {medium_router} est√° ativo - indo para invent√°rio Equipments")
        
        # Armazenar contexto para o fullscreen da carta Equipment
        self._in_router_downgrade_context = True
        self._router_downgrade_target_id = router_id
        
        # Ir diretamente para invent√°rio de Equipments (SEM overlay)
        self._show_equipment_inventory_for_router_downgrade()
        
    def _processar_router_downgrade(self, router_id):
        """
        Processa efetivamente o ROUTER DOWNGRADE baseado no router_id.
        Troca Medium Router ativo por Small Router correspondente.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Processando Router Downgrade para Router ID: {router_id}")
        
        # Mapeamento: Medium Router -> Small Router
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORRE√á√ÉO: Encontrar e remover medium router dos equipments ativos
        medium_router_path_ativo = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == medium_router:
                medium_router_path_ativo = equipment_path
                break
        
        if medium_router_path_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Encontrado {medium_router} nos equipments ativos")
            
            # Remover Medium Router dos equipments ativos
            self.active_equipments.remove(medium_router_path_ativo)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido dos equipments ativos")
            
            # Remover Medium Router do invent√°rio tamb√©m
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_inventory = None
            for equipment_path in equipments_inventory:
                if os.path.basename(equipment_path) == medium_router:
                    medium_router_inventory = equipment_path
                    break
            
            if medium_router_inventory:
                self.inventario["equipments"].remove(medium_router_inventory)
                print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido do invent√°rio")
            
            # Construir caminho para Small Router (usar mesma estrutura de diret√≥rio)
            base_dir = os.path.dirname(medium_router_path_ativo)
            small_router_path = os.path.join(base_dir, small_router)
            
            # Adicionar Small Router ao invent√°rio (fica inativo por padr√£o)
            self.inventario["equipments"].append(small_router_path)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {small_router} adicionado ao invent√°rio (inativo)")
            print(f"DEBUG: [ROUTER_DOWNGRADE] SUCCESS: Router Downgrade aplicado com sucesso!")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ERROR: {medium_router} n√£o encontrado nos equipments ativos")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_DOWNGRADE]   - {os.path.basename(equipment_path)}")

    def _aplicar_link_upgrade(self, router_id):
        """
        Aplica o efeito LINK UPGRADE baseado no router_id.
        Abre p√°gina SELECT LINK para sele√ß√£o do Long Link a ser upgradado.
        Sistema flex√≠vel baseado no specific_id da base de dados.
        """
        print(f"DEBUG: [LINK_UPGRADE] Aplicando Link Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_UPGRADE] Router ID √© None - n√£o aplicando upgrade")
            return
        
        # Sistema flex√≠vel: verificar se h√° Long Links com specific_id = router_id
        long_links_available = self._get_long_links_by_specific_id(router_id)
        
        if not long_links_available:
            print(f"DEBUG: [LINK_UPGRADE] Nenhum Long Link com specific_id {router_id} encontrado no invent√°rio")
            return
        
        # CORRE√á√ÉO: Verificar se pelo menos um Long Link est√° ATIVO
        active_long_links = [link for link in long_links_available if link in self.active_equipments]
        
        if not active_long_links:
            print(f"DEBUG: [LINK_UPGRADE] ERRO: Long Link com specific_id {router_id} existe mas N√ÉO est√° ativo")
            print(f"DEBUG: [LINK_UPGRADE] Long Links encontrados: {[os.path.basename(link) for link in long_links_available]}")
            print(f"DEBUG: [LINK_UPGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
            print(f"DEBUG: [LINK_UPGRADE] Para usar LINK UPGRADE, o Long Link deve estar ativo (carta virada para cima)")
            return
        
        print(f"DEBUG: [LINK_UPGRADE] Long Links ativos encontrados: {len(active_long_links)}")
        
        # Verificar se j√° existe Short Link com mesmo specific_id
        short_link_exists = self._check_short_link_exists_by_specific_id(router_id)
        
        if short_link_exists:
            print(f"DEBUG: [LINK_UPGRADE] ERRO: J√° existe Short Link com specific_id {router_id} no invent√°rio")
            return
        
        print(f"DEBUG: [LINK_UPGRADE] Long Links encontrados: {len(long_links_available)}")
        
        # Definir contexto de LINK UPGRADE e router_id
        self._in_link_upgrade_context = True
        self._link_upgrade_target_id = router_id
        
        # Abrir p√°gina SELECT LINK (similar ao REMOVE ROUTER)
        self._show_select_link_page(router_id)
        print("DEBUG: [LINK_UPGRADE] SUCCESS: P√°gina SELECT LINK aberta")
    
    def _get_long_links_by_specific_id(self, specific_id):
        """
        Obt√©m todos os Long Links no invent√°rio com specific_id correspondente.
        """
        print(f"DEBUG: [LINK_UPGRADE_SELECT] Procurando Long Links com specific_id {specific_id}")
        
        long_links_found = []
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_long_link_with_specific_id(equipment_path, specific_id):
                long_links_found.append(equipment_path)
        
        print(f"DEBUG: [LINK_UPGRADE_SELECT] Encontrados {len(long_links_found)} Long Links")
        return long_links_found
    
    def _show_select_link_page(self, router_id):
        """
        Cria p√°gina SELECT LINK para escolher qual Long Link fazer upgrade.
        Layout similar √† p√°gina REMOVE ROUTER.
        """
        print(f"DEBUG: [SELECT_LINK_PAGE] Criando p√°gina SELECT LINK para Router ID {router_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar do jogador - usar TopBar espec√≠fico da cor do jogador (igual √† interface principal)
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                topbar_label.image = topbar_img
                topbar_label.pack(side="top", fill="x")
                print(f"DEBUG: [SELECT_LINK_PAGE] TopBar do jogador {self.player_color} aplicado com sucesso")
            else:
                print(f"DEBUG: [SELECT_LINK_PAGE] TopBar do jogador n√£o encontrado, usando fallback")
                # Criar TopBar fallback com cor do jogador
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao criar TopBar do jogador: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
        
        # Nome do jogador (igual ao invent√°rio original - fundo da cor do jogador e texto preto)
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo
        title = tk.Label(self, text="SELECT LINK", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Long Links com specific_id correspondente
        long_links = self._get_long_links_by_specific_id(router_id)
        
        if not long_links:
            # Mensagem se n√£o h√° Long Links dispon√≠veis
            no_links_msg = tk.Label(self, text="No Long Links available for upgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Bot√£o de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para m√∫ltiplas Equipment Long Link
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padr√£o igual ao REMOVE ROUTER
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necess√°rio
        for idx, link_path in enumerate(long_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_select_link_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior do jogador - usar BelowBar espec√≠fico da cor do jogador
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [SELECT_LINK_PAGE] Barra inferior do jogador {self.player_color} carregada")
            else:
                print(f"DEBUG: [SELECT_LINK_PAGE] BelowBar do jogador n√£o encontrado, usando fallback")
                # Criar barra inferior fallback com cor do jogador
                belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao carregar BelowBar do jogador: {e}")
            # Criar barra inferior fallback
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [SELECT_LINK_PAGE] SUCCESS: P√°gina SELECT LINK criada")
    
    def _show_select_link_fullscreen(self, link_path):
        """
        Mostra Long Link em fullscreen com bot√£o roxo para confirma√ß√£o.
        """
        print(f"DEBUG: [SELECT_LINK_FULLSCREEN] Mostrando fullscreen: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Long Link
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para SELECT LINK
        def close_fullscreen():
            router_id = getattr(self, '_link_upgrade_target_id', 1)
            self._show_select_link_page(router_id)
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o de confirma√ß√£o (roxo, canto superior direito)
        def confirm_link_selection():
            self._show_link_upgrade_confirmation(link_path)
        
        confirm_btn = tk.Button(
            self,
            text="‚úì",
            font=("Helvetica", 24, "bold"),
            bg="#800080",
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_link_selection,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [SELECT_LINK_FULLSCREEN] Fullscreen criado com bot√µes")
    
    def _show_link_upgrade_confirmation(self, link_path):
        """
        Mostra overlay de confirma√ß√£o Link Upgrade Confirmation.
        """
        print(f"DEBUG: [LINK_UPGRADE_CONFIRMATION] Mostrando confirma√ß√£o para: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirma√ß√£o
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(link_path)
        
        # Mensagem de confirma√ß√£o
        tk.Label(confirm_frame, text=f"Long Link {specific_id} is going to be upgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o bot√£o
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo)
        def confirmar_upgrade():
            print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Upgrade confirmado - destruindo interface e iniciando Fase 1")
            # CORRE√á√ÉO: Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Interface destru√≠da - prosseguindo para detec√ß√£o YOLO")
            self._executar_link_upgrade_phase_1(link_path, specific_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_upgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Overlay de confirma√ß√£o criado")
    
    def _executar_link_upgrade_phase_1(self, long_link_path, specific_id):
        """
        Executa a Fase 1: detec√ß√£o do Long Link atual com loading + YOLO.
        """
        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Iniciando Fase 1 para: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object name para detec√ß√£o
            old_object_name = get_equipment_object_name(long_link_path, self.card_database)
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else f"link_longo_{specific_id}")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_PHASE1] Loading screen criado - iniciando detec√ß√£o")
                
                # Usar utilit√°rios universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script n√£o encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: ir direto para p√°gina LINK UPGRADE
                    self._show_link_upgrade_page(long_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Executando: {script_path} {old_object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                process = subprocess.Popen([script_path, old_object_name])
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script iniciado (PID: {process.pid})")
                
                # Monitor de inicializa√ß√£o e conclus√£o
                def check_phase_1_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda est√° rodando - YOLO deve ter inicializado
                            print(f"DEBUG: [LINK_UPGRADE_PHASE1] YOLO inicializado - destruindo loading screen")
                            
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclus√£o
                            def check_phase_1_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detec√ß√£o completa
                                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Detec√ß√£o Fase 1 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Ir para p√°gina LINK UPGRADE
                                        self._show_link_upgrade_page(long_link_path, specific_id)
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_1_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._show_link_upgrade_page(long_link_path, specific_id)
                            
                            self.after(1000, check_phase_1_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._show_link_upgrade_page(long_link_path, specific_id)
                    except Exception as e:
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro na inicializa√ß√£o: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._show_link_upgrade_page(long_link_path, specific_id)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
            else:
                print("DEBUG: [LINK_UPGRADE_PHASE1] Erro ao criar loading screen - fallback direto")
                self._show_link_upgrade_page(long_link_path, specific_id)
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro: {e}")
            self._show_link_upgrade_page(long_link_path, specific_id)
    
    def _show_link_upgrade_page(self, long_link_path, specific_id):
        """
        Cria p√°gina LINK UPGRADE para escolher Short Link.
        Layout similar √† p√°gina REMOVE ROUTER.
        """
        print(f"DEBUG: [LINK_UPGRADE_PAGE] Criando p√°gina LINK UPGRADE para specific_id {specific_id}")
        
        # Salvar refer√™ncias importantes
        self._current_long_link_path = long_link_path
        self._current_specific_id = specific_id
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar igual √† Store - usar awning da Store
        try:
            awning_img_path = os.path.join(IMG_DIR, "Store_awning_v3.png")
            if os.path.exists(awning_img_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_img_path).resize((screen_width, 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                
                # Label pequeno √† esquerda do logo (igual √† Store)
                left_label = tk.Label(self, text="‚Ä¢‚Ä¢‚Ä¢‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                left_label.place(relx=0.46, y=10, anchor="center")
                
                # Logo NetMaster posicionado independentemente (igual √† Store)
                try:
                    logo_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "logo_netmaster_store.png")).resize((20, 20)))
                    logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                    logo_lbl.image = logo_img
                    logo_lbl.place(relx=0.5, y=10, anchor="center")
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar logo: {e}")
                
                # Label largo √† direita do logo para cobrir √°rea amarela (igual √† Store)
                right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                right_logo_label.place(relx=0.53, y=10, anchor="w")
                
                # Label adicional para garantir cobertura completa (igual √† Store)
                extra_cover_label = tk.Label(self, text="     ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
                extra_cover_label.place(relx=0.55, y=10, anchor="w")
                
                print(f"DEBUG: [LINK_UPGRADE_PAGE] TopBar da Store aplicado com sucesso")
                
            else:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Store awning n√£o encontrado, usando fallback")
                # Criar TopBar fallback
                topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                topbar_frame.pack(pady=(0, 10), fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao criar TopBar da Store: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            topbar_frame.pack(pady=(0, 10), fill="x")
            topbar_frame.pack_propagate(False)
        
        # Texto "Store" posicionado independentemente (igual √† Store)
        store_name_lbl = tk.Label(self, text="Store", 
                                 font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        store_name_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno √† direita do nome Store (igual √† Store original)
        right_store_label = tk.Label(self, text="‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_store_label.place(relx=0.6, y=30, anchor="center")
        
        # T√≠tulo
        title = tk.Label(self, text="LINK UPGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Short Links correspondentes (mesmo specific_id)
        short_links = self._get_short_links_for_upgrade(specific_id)
        
        if not short_links:
            # Mensagem de erro
            no_links_msg = tk.Label(self, text="No Short Links available", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Bot√£o de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_link_upgrade)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para m√∫ltiplas cartas Short Link (igual ao SELECT LINK)
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padr√£o igual ao REMOVE ROUTER
        
        # CORRE√á√ÉO: Layout 2xn sempre (2 colunas, n linhas conforme necess√°rio)
        # Colocar Short Links em grid 2xn
        for idx, link_path in enumerate(short_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Short Link {os.path.basename(link_path)} colocado na linha {row}, coluna {col}")
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_link_upgrade_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior igual √† Store - usar BelowBar_store.png
        try:
            belowbar_img_path = os.path.join(IMG_DIR, "BelowBar_store.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Barra inferior BelowBar_store.png carregada (igual √† Store)")
            else:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] BelowBar_store.png n√£o encontrado, usando fallback")
                # Criar barra inferior fallback
                belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar BelowBar_store.png: {e}")
            # Criar barra inferior fallback
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [LINK_UPGRADE_PAGE] SUCCESS: P√°gina LINK UPGRADE criada")
    
    def _get_short_links_for_upgrade(self, specific_id):
        """
        Obt√©m cartas Short Link da COR DO JOGADOR com specific_id correspondente na Store.
        Similar ao SELECT LINK mas procura apenas na cor do jogador.
        """
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Obtendo Short Links da cor '{self.player_color}' para specific_id {specific_id}")
        
        # Obter informa√ß√µes do Short Link baseado no specific_id
        short_link_info = self._get_corresponding_short_link_info(specific_id)
        
        if not short_link_info:
            print(f"DEBUG: [LINK_UPGRADE_LINKS] Nenhum Short Link correspondente encontrado")
            return []
        
        short_links_found = []
        filename = short_link_info['filename']
        
        # Usar utilit√°rios universais para detectar caminhos
        universal_paths = get_universal_paths()
        base_dir = universal_paths['base_dir']
        
        # Mapear cor do jogador para nome do diret√≥rio (primeira letra mai√∫scula)
        player_color_dir = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Procurando {filename} na cor {player_color_dir}...")
        
        # Poss√≠veis bases para busca
        possivel_bases = [base_dir]
        
        # Para cada base poss√≠vel, buscar Short Links
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                continue
                
            # Testar estruturas de diret√≥rios (similar ao _obter_equipments_da_store)
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (min√∫scula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (mai√∫scula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [LINK_UPGRADE_LINKS] Usando estrutura: {equipments_base}")
                    break
            
            if not equipments_base:
                continue
                
            # Buscar Short Links APENAS na cor do jogador
            cor_dir = os.path.join(equipments_base, player_color_dir)
            if not os.path.exists(cor_dir):
                print(f"DEBUG: [LINK_UPGRADE_LINKS] Diret√≥rio da cor {player_color_dir} n√£o existe: {cor_dir}")
                continue
                
            # CORRE√á√ÉO: Procurar TODAS as cartas com o filename da cor do jogador
            # Se h√° 3 Equipment_7.png verdes na Store, todas aparecer√£o
            print(f"DEBUG: [LINK_UPGRADE_LINKS] Procurando em: {cor_dir}")
            
            # Listar todos os arquivos no diret√≥rio da cor do jogador
            if os.path.isdir(cor_dir):
                arquivos_na_cor = os.listdir(cor_dir)
                print(f"DEBUG: [LINK_UPGRADE_LINKS] Arquivos encontrados na cor {player_color_dir}: {arquivos_na_cor}")
                
                # Procurar TODAS as inst√¢ncias do filename
                for arquivo in arquivos_na_cor:
                    if arquivo == filename:
                        short_link_path = os.path.join(cor_dir, arquivo)
                        short_links_found.append(short_link_path)
                        print(f"DEBUG: [LINK_UPGRADE_LINKS] Short Link encontrado: {short_link_path}")
        
        # NOTA: Se h√° m√∫ltiplas c√≥pias da mesma carta na Store (ex: 3x Equipment_7.png verdes)
        # elas aparecer√£o na lista. Para simular isto, podemos duplicar o path se necess√°rio
        
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Total de Short Links encontrados: {len(short_links_found)}")
        return short_links_found
    
    def _show_link_upgrade_fullscreen(self, short_link_path):
        """
        Mostra Short Link em fullscreen com bot√£o roxo para confirma√ß√£o de trade.
        """
        print(f"DEBUG: [LINK_UPGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(short_link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Short Link
        try:
            pil_img = Image.open(short_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para LINK UPGRADE
        def close_fullscreen():
            long_link_path = getattr(self, '_current_long_link_path', None)
            specific_id = getattr(self, '_current_specific_id', 1)
            if long_link_path and specific_id:
                self._show_link_upgrade_page(long_link_path, specific_id)
            else:
                self._voltar_dashboard_apos_link_upgrade()
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o de confirma√ß√£o (roxo, canto superior direito)
        def confirm_trade():
            self._show_link_trade_confirmation(short_link_path)
        
        confirm_btn = tk.Button(
            self,
            text="‚úì",
            font=("Helvetica", 24, "bold"),
            bg="#800080",
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_trade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [LINK_UPGRADE_FULLSCREEN] Fullscreen criado com bot√µes")
    
    def _voltar_dashboard_apos_select_link(self):
        """Volta para o PlayerDashboard ap√≥s SELECT LINK"""
        print("DEBUG: [SELECT_LINK] Voltando para PlayerDashboard")
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _show_link_trade_confirmation(self, short_link_path):
        """
        Overlay de confirma√ß√£o final para o trade Link Upgrade.
        Usa o mesmo estilo do Link Upgrade Confirmation.
        """
        print(f"DEBUG: [LINK_TRADE_CONFIRMATION] Criando overlay de trade para: {os.path.basename(short_link_path)}")
        
        # Salvar refer√™ncia do Short Link escolhido
        self._chosen_short_link_path = short_link_path
        
        # Limpar widgets (mesmo padr√£o do Link Upgrade Confirmation)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta Short Link como fundo
        try:
            pil_img = Image.open(short_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_TRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirma√ß√£o (mesmo padr√£o)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo (mesmo padr√£o)
        tk.Label(confirm_frame, text="Link Trade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
         # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(short_link_path)
        
        # Mensagem de confirma√ß√£o (mesmo padr√£o)
        tk.Label(confirm_frame, text=f"Short Link {specific_id} is going to be added \nto your inventory", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o bot√£o (mesmo padr√£o)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo - mesmo padr√£o do Link Upgrade Confirmation)
        def confirmar_trade():
            print("DEBUG: [LINK_TRADE_CONFIRMATION] Trade confirmado - destruindo fullscreen e iniciando Fase 2")
            # CORRE√á√ÉO: Destruir completamente a interface fullscreen antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_TRADE_CONFIRMATION] Interface fullscreen destru√≠da - prosseguindo para detec√ß√£o YOLO")
            self._executar_link_upgrade_phase_2()
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_trade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_TRADE_CONFIRMATION] Overlay de trade criado")
    
    def _executar_link_upgrade_phase_2(self):
        """
        Executa a Fase 2: detec√ß√£o do Short Link novo + conclus√£o do upgrade.
        """
        short_link_path = getattr(self, '_chosen_short_link_path', '')
        long_link_path = getattr(self, '_current_long_link_path', '')
        specific_id = getattr(self, '_current_specific_id', 1)
        
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Iniciando Fase 2")
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Short Link: {os.path.basename(short_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object name do Short Link
            new_object_name = get_equipment_object_name(short_link_path, self.card_database)
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, new_object_name if new_object_name else f"short_link_{specific_id}")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_PHASE2] Loading screen criado - iniciando detec√ß√£o")
                
                # Usar utilit√°rios universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script n√£o encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: completar upgrade sem YOLO
                    self._complete_link_upgrade()
                    return
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Executando: {script_path} {new_object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                process = subprocess.Popen([script_path, new_object_name])
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script iniciado (PID: {process.pid})")
                
                # Monitor de inicializa√ß√£o e conclus√£o
                def check_phase_2_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda est√° rodando - YOLO deve ter inicializado
                            print(f"DEBUG: [LINK_UPGRADE_PHASE2] YOLO inicializado - destruindo loading screen")
                            
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclus√£o
                            def check_phase_2_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detec√ß√£o completa
                                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Detec√ß√£o Fase 2 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Completar upgrade
                                        self._complete_link_upgrade()
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_2_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._complete_link_upgrade()
                            
                            self.after(1000, check_phase_2_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._complete_link_upgrade()
                    except Exception as e:
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro na inicializa√ß√£o: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._complete_link_upgrade()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_2_initialization)
            else:
                print("DEBUG: [LINK_UPGRADE_PHASE2] Erro ao criar loading screen - fallback direto")
                self._complete_link_upgrade()
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro: {e}")
            self._complete_link_upgrade()
    
    def _complete_link_upgrade(self):
        """
        Completa o processo de Link Upgrade: remove Long Link, adiciona Short Link.
        """
        long_link_path = getattr(self, '_current_long_link_path', '')
        short_link_path = getattr(self, '_chosen_short_link_path', '')
        
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Completando upgrade")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Removendo: {os.path.basename(long_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Adicionando: {os.path.basename(short_link_path)}")
        
        try:
            # Usar existing helper functions para completar trade
            success = self._perform_link_upgrade_database_transaction(long_link_path, short_link_path)
            
            if success:
                # Mostrar mensagem de sucesso e voltar ao dashboard
                self._show_upgrade_success_message()
            else:
                # Mostrar mensagem de erro
                self._show_upgrade_error_message()
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Erro ao completar upgrade: {e}")
            self._show_upgrade_error_message()
    
    def _perform_link_upgrade_database_transaction(self, long_link_path, short_link_path):
        """
        Executa a transa√ß√£o de base de dados para Link Upgrade: remove Long Link e adiciona Short Link.
        
        Args:
            long_link_path: Caminho para o Long Link a ser removido
            short_link_path: Caminho para o Short Link a ser adicionado
            
        Returns:
            bool: True se transa√ß√£o foi bem-sucedida, False caso contr√°rio
        """
        try:
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Iniciando transa√ß√£o")
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link: {os.path.basename(long_link_path)}")
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link: {os.path.basename(short_link_path)}")
            
            # PASSO 1: Remover Long Link do invent√°rio
            if long_link_path in self.inventario.get("equipments", []):
                self.inventario["equipments"].remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link removido do invent√°rio")
            else:
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] AVISO: Long Link n√£o encontrado no invent√°rio")
            
            # PASSO 2: Remover Long Link dos ativos (se estiver ativo)
            if long_link_path in self.active_equipments:
                self.active_equipments.remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link removido dos ativos")
            
            # PASSO 3: Adicionar Short Link ao invent√°rio
            # Verificar se j√° existe no invent√°rio
            short_link_filename = os.path.basename(short_link_path)
            short_link_exists = any(
                os.path.basename(equipment_path) == short_link_filename 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not short_link_exists:
                self.inventario["equipments"].append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link adicionado ao invent√°rio")
            else:
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link j√° existe no invent√°rio")
            
            # PASSO 4: Ativar Short Link (carta fica virada para cima)
            if short_link_path not in self.active_equipments:
                self.active_equipments.append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link adicionado aos ativos (carta virada para cima)")
            
            # PASSO 5: Devolver Long Link para a Store (se existir)
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(long_link_path, "equipments")
                    print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link devolvido √† Store")
                except Exception as store_e:
                    print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] ERRO ao devolver √† Store: {store_e}")
            
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Transa√ß√£o completa com sucesso")
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] ERRO na transa√ß√£o: {e}")
            return False
    
    def _show_upgrade_success_message(self):
        """
        Mostra mensagem de sucesso do Link Upgrade.
        """
        print("DEBUG: [LINK_UPGRADE_SUCCESS] Mostrando mensagem de sucesso")
        
        # Criar overlay
        overlay = tk.Toplevel(self)
        overlay.configure(bg="black")
        overlay.attributes("-alpha", 0.9)
        overlay.attributes("-fullscreen", True)
        overlay.attributes("-topmost", True)
        overlay.grab_set()
        overlay.focus_set()
        
        # Frame central
        frame = tk.Frame(overlay, bg="#1B5E20", relief="raised", bd=3, padx=30, pady=25)
        frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # T√≠tulo
        title = tk.Label(frame, text="Link Upgrade Completed!", 
                        font=("Helvetica", 24, "bold"), fg="white", bg="#1B5E20")
        title.pack(pady=(0, 20))
        
        # Mensagem
        msg = tk.Label(frame, text="Your Long Link has been\nsuccessfully upgraded to Short Link!", 
                      font=("Helvetica", 16), fg="white", bg="#1B5E20", justify="center")
        msg.pack(pady=(0, 25))
        
        # Bot√£o OK
        def return_dashboard():
            print("DEBUG: [LINK_UPGRADE_SUCCESS] Voltando para PlayerDashboard")
            overlay.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        ok_btn = tk.Button(frame, text="Continue", font=("Helvetica", 16, "bold"), 
                          bg="#4CAF50", fg="white", width=15, height=2,
                          command=return_dashboard)
        ok_btn.pack()
        
        # Auto-close ap√≥s 3 segundos
        self.after(3000, return_dashboard)
    
    def _show_upgrade_error_message(self):
        """
        Mostra mensagem de erro do Link Upgrade.
        """
        print("DEBUG: [LINK_UPGRADE_ERROR] Mostrando mensagem de erro")
        
        # Criar overlay
        overlay = tk.Toplevel(self)
        overlay.configure(bg="black")
        overlay.attributes("-alpha", 0.9)
        overlay.attributes("-fullscreen", True)
        overlay.attributes("-topmost", True)
        overlay.grab_set()
        overlay.focus_set()
        
        # Frame central
        frame = tk.Frame(overlay, bg="#B71C1C", relief="raised", bd=3, padx=30, pady=25)
        frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # T√≠tulo
        title = tk.Label(frame, text="Link Upgrade Failed", 
                        font=("Helvetica", 24, "bold"), fg="white", bg="#B71C1C")
        title.pack(pady=(0, 20))
        
        # Mensagem
        msg = tk.Label(frame, text="There was an error processing\nyour Link Upgrade. Please try again.", 
                      font=("Helvetica", 16), fg="white", bg="#B71C1C", justify="center")
        msg.pack(pady=(0, 25))
        
        # Bot√£o OK
        def return_dashboard():
            print("DEBUG: [LINK_UPGRADE_ERROR] Voltando para PlayerDashboard")
            overlay.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        ok_btn = tk.Button(frame, text="Back to Dashboard", font=("Helvetica", 16, "bold"), 
                          bg="#F44336", fg="white", width=18, height=2,
                          command=return_dashboard)
        ok_btn.pack()
    
    def _voltar_dashboard_apos_link_upgrade(self):
        """Volta para o PlayerDashboard ap√≥s LINK UPGRADE"""
        print("DEBUG: [LINK_UPGRADE] Voltando para PlayerDashboard")
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _find_long_link_by_specific_id(self, specific_id):
        """
        Encontra Long Link no invent√°rio com specific_id correspondente.
        Usa a base de dados integrada para determinar dinamicamente o equipment_id.
        """
        print(f"DEBUG: [LINK_UPGRADE_SEARCH] Procurando Long Link com specific_id {specific_id}")
        
        if not self.card_database:
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Base de dados n√£o dispon√≠vel - usando fallback")
            return self._find_long_link_fallback(specific_id)
        
        try:
            # Obter cor do jogador para construir equipment_id
            player_color = self.player_color.lower()
            equipment_id = f"long_link_{specific_id}_{player_color}"
            
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Procurando equipment_id: {equipment_id}")
            
            # Verificar se existe na base de dados
            equipment_card = self.card_database.get_equipment(equipment_id)
            if not equipment_card:
                print(f"DEBUG: [LINK_UPGRADE_SEARCH] Equipment {equipment_id} n√£o encontrado na base de dados")
                return None
            
            # Procurar no invent√°rio do jogador
            equipments_inventory = self.inventario.get("equipments", [])
            
            for equipment_path in equipments_inventory:
                # Verificar se o caminho corresponde ao Long Link procurado
                if self._is_long_link_with_specific_id(equipment_path, specific_id):
                    print(f"DEBUG: [LINK_UPGRADE_SEARCH] ENCONTRADO: {os.path.basename(equipment_path)}")
                    return equipment_path
            
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Long Link com specific_id {specific_id} n√£o encontrado no invent√°rio")
            return None
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Erro: {e}")
            return None
    
    def _check_short_link_exists_by_specific_id(self, specific_id):
        """
        Verifica se j√° existe Short Link no invent√°rio com specific_id correspondente.
        """
        print(f"DEBUG: [LINK_UPGRADE_CHECK] Verificando Short Link com specific_id {specific_id}")
        
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_short_link_with_specific_id(equipment_path, specific_id):
                print(f"DEBUG: [LINK_UPGRADE_CHECK] CONFLITO: {os.path.basename(equipment_path)} j√° existe")
                return True
        
        print(f"DEBUG: [LINK_UPGRADE_CHECK] Short Link com specific_id {specific_id} n√£o existe - upgrade poss√≠vel")
        return False
    
    def _is_long_link_with_specific_id(self, equipment_path, specific_id):
        """
        Verifica se um caminho de equipment corresponde a Long Link com specific_id.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        # Long Link: Equipment_10.png (id=1), Equipment_11.png (id=2), Equipment_12.png (id=3)
        long_link_mapping = {
            "Equipment_10.png": 1,
            "Equipment_11.png": 2, 
            "Equipment_12.png": 3
        }
        
        return long_link_mapping.get(filename) == specific_id
    
    def _is_short_link_with_specific_id(self, equipment_path, specific_id):
        """
        Verifica se um caminho de equipment corresponde a Short Link com specific_id.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        # Short Link: Equipment_7.png (id=1), Equipment_8.png (id=2), Equipment_9.png (id=3)
        short_link_mapping = {
            "Equipment_7.png": 1,
            "Equipment_8.png": 2,
            "Equipment_9.png": 3
        }
        
        return short_link_mapping.get(filename) == specific_id
    
    def _find_long_link_fallback(self, specific_id):
        """
        Fallback para encontrar Long Link quando base de dados n√£o est√° dispon√≠vel.
        """
        # Mapeamento fallback baseado nos filenames
        long_link_files = {
            1: "Equipment_10.png",
            2: "Equipment_11.png", 
            3: "Equipment_12.png"
        }
        
        if specific_id not in long_link_files:
            return None
        
        target_filename = long_link_files[specific_id]
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if os.path.basename(equipment_path) == target_filename:
                return equipment_path
        
        return None
    
    def _get_equipment_specific_id_from_path(self, equipment_path):
        """
        Obt√©m o specific_id de um equipment baseado no seu caminho.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        equipment_mapping = {
            # Small Router
            "Equipment_1.png": 1, "Equipment_2.png": 2, "Equipment_3.png": 3,
            # Medium Router  
            "Equipment_4.png": 1, "Equipment_5.png": 2, "Equipment_6.png": 3,
            # Short Link
            "Equipment_7.png": 1, "Equipment_8.png": 2, "Equipment_9.png": 3,
            # Long Link
            "Equipment_10.png": 1, "Equipment_11.png": 2, "Equipment_12.png": 3
        }
        
        return equipment_mapping.get(filename)
    
    def _get_equipment_info_from_path(self, equipment_path):
        """
        Obt√©m informa√ß√µes detalhadas de um equipment baseado no seu caminho.
        """
        filename = os.path.basename(equipment_path)
        specific_id = self._get_equipment_specific_id_from_path(equipment_path)
        
        if not specific_id:
            return None
        
        # Determinar tipo baseado no filename
        if filename in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]:
            equipment_type = "small_router"
        elif filename in ["Equipment_4.png", "Equipment_5.png", "Equipment_6.png"]:
            equipment_type = "medium_router"
        elif filename in ["Equipment_7.png", "Equipment_8.png", "Equipment_9.png"]:
            equipment_type = "short_link"
        elif filename in ["Equipment_10.png", "Equipment_11.png", "Equipment_12.png"]:
            equipment_type = "long_link"
        else:
            return None
        
        return {
            "filename": filename,
            "equipment_type": equipment_type,
            "specific_id": specific_id,
            "path": equipment_path
        }
    
    def _get_corresponding_short_link_info(self, specific_id):
        """
        Obt√©m informa√ß√µes do Short Link correspondente baseado no specific_id.
        """
        # Mapeamento specific_id -> filename do Short Link
        short_link_mapping = {
            1: "Equipment_7.png",
            2: "Equipment_8.png", 
            3: "Equipment_9.png"
        }
        
        filename = short_link_mapping.get(specific_id)
        if not filename:
            return None
        
        return {
            "filename": filename,
            "equipment_type": "short_link", 
            "specific_id": specific_id
        }

    def _show_equipment_inventory_for_link_upgrade(self):
        """Abre invent√°rio de equipamentos especificamente para LINK UPGRADE"""
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Criando invent√°rio espec√≠fico para LINK UPGRADE")
        
        # Definir contexto espec√≠fico
        self._in_link_upgrade_context = True
        
        # Chamar invent√°rio de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_UPGRADE_INVENTORY] SUCCESS: Invent√°rio espec√≠fico para LINK UPGRADE criado")

    def _executar_link_upgrade(self, long_link_path, link_id):
        """Executa o processo de LINK UPGRADE com detec√ß√£o YOLO em duas fases (igual ao ROUTER UPGRADE)"""
        print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Executando upgrade: {os.path.basename(long_link_path)}")
        
        try:
            # Sistema flex√≠vel baseado no specific_id da base de dados
            long_link_specific_id = self._get_equipment_specific_id_from_path(long_link_path)
            
            if long_link_specific_id != link_id:
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: specific_id {long_link_specific_id} n√£o corresponde ao link_id {link_id}")
                return
            
            # Obter informa√ß√µes do Long Link da base de dados
            long_link_info = self._get_equipment_info_from_path(long_link_path)
            
            # Calcular Short Link correspondente (mesmo specific_id, diferente tipo)
            short_link_info = self._get_corresponding_short_link_info(link_id)
            
            if not long_link_info or not short_link_info:
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: N√£o foi poss√≠vel obter informa√ß√µes dos equipments")
                return
            
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Upgrade: {long_link_info['filename']} -> {short_link_info['filename']}")
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Long Link specific_id: {long_link_specific_id}")
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Short Link specific_id: {link_id}")
            
            # NOVA L√ìGICA: Executar detec√ß√£o em duas fases antes de processar upgrade
            # Fase 1: Detectar Long Link (objeto atual)
            # Fase 2: Detectar Short Link (objeto de destino)
            
            # Obter object names para detec√ß√£o ANTES de criar loading screen
            old_object_name = get_equipment_object_name(long_link_path, self.card_database)
            
            # Criar loading screen inicial com object name real
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else "ligacao_longa_vermelha")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_EXECUTE] Loading screen criado - iniciando detec√ß√£o duas fases")
                
                # Construir caminho para Short Link (usar mesmo diret√≥rio do Long Link)
                short_link_filename = short_link_info['filename']
                short_link_path = os.path.join(os.path.dirname(long_link_path), short_link_filename)
                new_object_name = get_equipment_object_name(short_link_path, self.card_database)
                
                old_equipment_name = f"Long Link {link_id}"
                new_equipment_name = f"Short Link {link_id}"
                
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Old object: {old_object_name}")
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] New object: {new_object_name}")
                
                if old_object_name and new_object_name:
                    # Executar detec√ß√£o em duas fases
                    success = self._execute_two_phase_detection_for_link_upgrade(
                        old_object_name, new_object_name, loading_window, 
                        old_equipment_name, new_equipment_name, long_link_path, link_id
                    )
                    
                    if success:
                        print("DEBUG: [LINK_UPGRADE_EXECUTE] SUCCESS: Detec√ß√£o duas fases iniciada")
                        # Processamento ser√° continuado ap√≥s detec√ß√£o bem-sucedida
                        return
                    else:
                        print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: Falha ao iniciar detec√ß√£o duas fases")
                        if loading_window:
                            loading_window.destroy()
                else:
                    print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: N√£o foi poss√≠vel obter object names")
                    if loading_window:
                        loading_window.destroy()
            else:
                print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: N√£o foi poss√≠vel criar loading screen")
            
            # Fallback: se detec√ß√£o falhar, processar diretamente (desenvolvimento)
            print("DEBUG: [LINK_UPGRADE_EXECUTE] Fallback: processando upgrade diretamente")
            self._processar_link_upgrade_completo(long_link_path, link_id)
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO durante upgrade: {e}")
            # Limpar flags em caso de erro
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None

    def _execute_two_phase_detection_for_link_upgrade(self, old_object_name, new_object_name, loading_window, 
                                                     old_equipment_name, new_equipment_name, long_link_path, link_id):
        """
        Executa detec√ß√£o YOLO em duas fases para LINK UPGRADE:
        Fase 1: Detectar Long Link (objeto atual)
        Fase 2: Detectar Short Link (objeto de destino)
        """
        try:
            # Usar os utilit√°rios universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print("DEBUG: [LINK_UPGRADE_2PHASE] Ambiente n√£o √© Raspberry Pi - usando fallback")
                if loading_window:
                    loading_window.destroy()
                # Processar upgrade diretamente no desenvolvimento
                self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                print(f"DEBUG: [LINK_UPGRADE_2PHASE] Script n√£o encontrado: {script_path}")
                if loading_window:
                    loading_window.destroy()
                # Fallback: processar diretamente
                self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
                return False
            
            print(f"DEBUG: [LINK_UPGRADE_2PHASE] Script encontrado: {script_path}")
            
            # Iniciar Fase 1: Detectar Long Link
            success = self._start_phase_1_detection_link_upgrade(
                script_path, old_object_name, new_object_name, loading_window,
                old_equipment_name, new_equipment_name, long_link_path, link_id
            )
            
            return success
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_2PHASE] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            # Fallback: processar diretamente
            self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
            return False

    def _start_phase_1_detection_link_upgrade(self, script_path, old_object_name, new_object_name, loading_window, 
                                             old_equipment_name, new_equipment_name, long_link_path, link_id):
        """Inicia a Fase 1 da detec√ß√£o: Long Link"""
        try:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Iniciando Fase 1: {old_object_name}")
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Executando: {script_path} {old_object_name}")
            
            # Executar script para primeira detec√ß√£o
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script Fase 1 iniciado (PID: {process.pid})")
            
            # Monitorar inicializa√ß√£o da Fase 1 (igual ao ROUTER UPGRADE)
            def check_phase_1_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fechando loading screen Fase 1 - YOLO inicializando")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Iniciar Fase 2
                                self._start_phase_2_detection_link_upgrade(
                                    script_path, new_object_name, new_equipment_name, long_link_path, link_id
                                )
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fase 1 terminou inesperadamente")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        # Fallback: processar diretamente
                        self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro no monitor: {e}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: processar diretamente
                    self._processar_link_upgrade_completo(long_link_path, link_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_1_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro: {e}")
            return False

    def _start_phase_2_detection_link_upgrade(self, script_path, new_object_name, new_equipment_name, 
                                             long_link_path, link_id):
        """Inicia a Fase 2 da detec√ß√£o: Short Link"""
        try:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Iniciando Fase 2: {new_object_name}")
            
            # Criar loading screen para Fase 2
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] ERRO: N√£o foi poss√≠vel criar loading screen Fase 2")
                self._processar_link_upgrade_completo(long_link_path, link_id)
                return
                
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detec√ß√£o
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar inicializa√ß√£o da Fase 2 (igual ao ROUTER UPGRADE)
            def check_phase_2_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 2 inicializado - fechar loading screen atual
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fechando loading screen Fase 2 - YOLO inicializando")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o da Fase 2
                        def check_phase_2_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_2_completion)
                            else:
                                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fase 2 completa - processando upgrade")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Processar upgrade completo
                                self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                        self.after(1000, check_phase_2_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fase 2 terminou inesperadamente")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        # Fallback: processar diretamente
                        self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro no monitor: {e}")
                    if phase_2_loading and phase_2_loading.winfo_exists():
                        phase_2_loading.destroy()
                    # Fallback: processar diretamente
                    self._processar_link_upgrade_completo(long_link_path, link_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_2_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro: {e}")
            return False

    def _processar_link_upgrade_completo(self, long_link_path, link_id):
        """
        Processa efetivamente o LINK UPGRADE ap√≥s detec√ß√£o bem-sucedida.
        Remove Long Link e adiciona Short Link correspondente (ativo).
        """
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Processando upgrade completo")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Long Link: {os.path.basename(long_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Link ID: {link_id}")
        
        try:
            # Sistema flex√≠vel baseado no specific_id
            long_link_info = self._get_equipment_info_from_path(long_link_path)
            short_link_info = self._get_corresponding_short_link_info(link_id)
            
            if not long_link_info or not short_link_info:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO: N√£o foi poss√≠vel obter informa√ß√µes dos equipments")
                return
            
            long_link_file = long_link_info['filename']
            short_link_file = short_link_info['filename']
            
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Sistema flex√≠vel: {long_link_file} -> {short_link_file}")
            
            # PASSO 1: Remover Long Link do invent√°rio
            if long_link_path in self.inventario.get("equipments", []):
                self.inventario["equipments"].remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {long_link_file} removido do invent√°rio")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] AVISO: {long_link_file} n√£o encontrado no invent√°rio")
            
            # PASSO 2: Adicionar Short Link ao invent√°rio (usar mesmo diret√≥rio)
            short_link_path = os.path.join(os.path.dirname(long_link_path), short_link_file)
            
            # Verificar se j√° existe no invent√°rio
            short_link_exists = any(
                os.path.basename(equipment_path) == short_link_file 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not short_link_exists:
                self.inventario["equipments"].append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} adicionado ao invent√°rio")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} j√° existe no invent√°rio")
            
            # PASSO 3: CORRE√á√ÉO CR√çTICA - Ativar Short Link (diferente da l√≥gica anterior)
            # Adicionar Short Link aos equipments ativos para que fique virado para cima
            if short_link_path not in self.active_equipments:
                self.active_equipments.append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] CORRE√á√ÉO: {short_link_file} adicionado aos ativos (carta fica virada para cima)")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} j√° est√° nos ativos")
            
            # PASSO 4: Enviar Long Link para a Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(long_link_path, "equipments", "neutral")
                    print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Long Link enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Erro ao enviar Long Link para Store: {e}")
            
            # PASSO 5: Limpar flags de contexto
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None
            
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] SUCCESS: Link Upgrade aplicado com sucesso!")
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {long_link_file} -> {short_link_file} (ATIVO)")
            
            # PASSO 6: Voltar IMEDIATAMENTE para o PlayerDashboard ap√≥s processamento completo
            # (Sem delay para evitar qualquer display intermedi√°rio indesejado)
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Voltando diretamente ao PlayerDashboard")
            self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            )
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO durante processamento: {e}")
            # Limpar flags em caso de erro
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None
            
            # Voltar para dashboard mesmo em caso de erro
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO - Voltando diretamente ao PlayerDashboard")
            self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            )

    def _aplicar_link_downgrade(self, router_id):
        """
        Aplica o efeito LINK DOWNGRADE baseado no router_id.
        Similar ao LINK UPGRADE mas inverso: Short Link (invent√°rio) ‚Üí Long Link (Store)
        """
        print(f"DEBUG: [LINK_DOWNGRADE] Iniciando Link Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_DOWNGRADE] Router ID √© None - cancelando")
            return
        
        # Mapear router_id para specific_id (mesmo mapeamento do LINK UPGRADE)
        specific_id = router_id  # router_id 1 -> specific_id 1, etc.
        
        print(f"DEBUG: [LINK_DOWNGRADE] Router ID {router_id} -> Specific ID {specific_id}")
        
        # Verificar se h√° Short Links com specific_id correspondente no invent√°rio do jogador
        short_links_available = self._get_short_links_by_specific_id_from_inventory(specific_id)
        
        if not short_links_available:
            print(f"DEBUG: [LINK_DOWNGRADE] Nenhum Short Link com specific_id {specific_id} encontrado no invent√°rio")
            print(f"DEBUG: [LINK_DOWNGRADE] LINK DOWNGRADE requer Short Links no invent√°rio do jogador")
            return
        
        # CORRE√á√ÉO: Verificar se pelo menos um Short Link est√° ATIVO
        active_short_links = [link for link in short_links_available if link in self.active_equipments]
        
        if not active_short_links:
            print(f"DEBUG: [LINK_DOWNGRADE] ERRO: Short Link com specific_id {specific_id} existe mas N√ÉO est√° ativo")
            print(f"DEBUG: [LINK_DOWNGRADE] Short Links encontrados: {[os.path.basename(link) for link in short_links_available]}")
            print(f"DEBUG: [LINK_DOWNGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
            print(f"DEBUG: [LINK_DOWNGRADE] Para usar LINK DOWNGRADE, o Short Link deve estar ativo (carta virada para cima)")
            return
        
        print(f"DEBUG: [LINK_DOWNGRADE] Short Links ativos encontrados: {len(active_short_links)}")
        print(f"DEBUG: [LINK_DOWNGRADE] {len(short_links_available)} Short Link(s) encontrado(s)")
        
        # Definir contexto de LINK DOWNGRADE
        self._in_link_downgrade_context = True
        self._link_downgrade_target_id = router_id
        
        # Ir para p√°gina SELECT LINK (mas com Short Links em vez de Long Links)
        self._show_select_short_link_page(router_id)
    
    def _get_short_links_by_specific_id_from_inventory(self, specific_id):
        """
        Obt√©m todos os Short Links no invent√°rio com specific_id correspondente.
        Similar ao _get_long_links_by_specific_id mas para Short Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_SELECT] Procurando Short Links com specific_id {specific_id}")
        
        short_links_found = []
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_short_link_with_specific_id(equipment_path, specific_id):
                short_links_found.append(equipment_path)
        
        print(f"DEBUG: [LINK_DOWNGRADE_SELECT] Encontrados {len(short_links_found)} Short Links")
        return short_links_found
    
    def _show_select_short_link_page(self, router_id):
        """
        Cria p√°gina SELECT LINK para Short Links (inverso da p√°gina Long Links).
        Layout id√™ntico mas com Short Links em vez de Long Links.
        """
        print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Criando p√°gina SELECT LINK para Short Links - Router ID {router_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar do jogador
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                topbar_label.image = topbar_img
                topbar_label.pack(side="top", fill="x")
                topbar_label._is_topbar = True
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] TopBar do jogador {self.player_color} carregado")
            else:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] TopBar n√£o encontrado, usando fallback")
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar TopBar: {e}")
        
        # Nome do jogador (igual ao invent√°rio original - fundo da cor do jogador e texto preto)
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo da p√°gina
        title = tk.Label(self, text="SELECT LINK", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Short Links com specific_id correspondente
        short_links = self._get_short_links_by_specific_id_from_inventory(router_id)
        
        if not short_links:
            # Mensagem se n√£o h√° Short Links dispon√≠veis
            no_links_msg = tk.Label(self, text="No Short Links available for downgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Bot√£o de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para m√∫ltiplos Short Links
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padr√£o
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necess√°rio
        for idx, link_path in enumerate(short_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta (vai para confirma√ß√£o de downgrade)
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_select_short_link_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior do jogador
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] BelowBar do jogador {self.player_color} carregado")
            else:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] BelowBar n√£o encontrado, usando fallback")
                belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar BelowBar: {e}")
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [SELECT_SHORT_LINK_PAGE] SUCCESS: P√°gina SELECT LINK (Short Links) criada")
    
    def _show_select_short_link_fullscreen(self, link_path):
        """
        Mostra Short Link em fullscreen com bot√£o roxo para confirma√ß√£o de downgrade.
        """
        print(f"DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] Mostrando fullscreen: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Short Link
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para SELECT LINK
        def close_fullscreen():
            router_id = getattr(self, '_link_downgrade_target_id', 1)
            self._show_select_short_link_page(router_id)
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o ROXO (canto superior direito) - confirma downgrade
        def confirm_downgrade():
            self._show_link_downgrade_confirmation(link_path)
        
        purple_btn = tk.Button(
            self, 
            text="‚úì", 
            font=("Helvetica", 24, "bold"), 
            bg="#800080", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=confirm_downgrade, 
            cursor="hand2", 
            activebackground="#9900AA"
        )
        purple_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] SUCCESS: Fullscreen criado com bot√µes")
    
    def _show_link_downgrade_confirmation(self, link_path):
        """
        Mostra overlay de confirma√ß√£o Link Downgrade Confirmation.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Mostrando confirma√ß√£o para: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirma√ß√£o
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(link_path)
        
        # Mensagem de confirma√ß√£o
        tk.Label(confirm_frame, text=f"Short Link {specific_id} is going to be downgraded", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o bot√£o
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo)
        def confirmar_downgrade():
            print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Downgrade confirmado - destruindo interface e iniciando Fase 1")
            # Salvar Short Link path para uso posterior
            self._link_downgrade_short_link_path = link_path
            # Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Interface destru√≠da - prosseguindo para detec√ß√£o YOLO")
            self._executar_link_downgrade_phase_1(link_path, specific_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_downgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Overlay de confirma√ß√£o criado")
    
    def _executar_link_downgrade_phase_1(self, short_link_path, specific_id):
        """
        Phase 1 de LINK DOWNGRADE: Detectar Short Link atual.
        Ap√≥s detec√ß√£o, vai para p√°gina LINK DOWNGRADE com Long Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Iniciando Phase 1 para Short Link: {os.path.basename(short_link_path)}")
        
        try:
            # Obter object_name do Short Link para detec√ß√£o YOLO
            if self.card_database:
                object_name = get_equipment_object_name(short_link_path, self.card_database)
                
                if not object_name:
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Nenhum object_name encontrado - fallback direto")
                    self._show_link_downgrade_page(short_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Object name para detec√ß√£o: {object_name}")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Base de dados n√£o dispon√≠vel - fallback direto")
                self._show_link_downgrade_page(short_link_path, specific_id)
                return
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print("DEBUG: [LINK_DOWNGRADE_PHASE1] Loading screen criado - iniciando detec√ß√£o")
                
                # Usar utilit√°rios universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Script n√£o encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    self._show_link_downgrade_page(short_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Executando: {script_path} {object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                subprocess.run(['chmod', '+x', script_path], check=True)
                process = subprocess.Popen([script_path, object_name])
                
                # Monitor de inicializa√ß√£o (aguardar YOLO carregar)
                def check_phase_1_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda rodando - YOLO inicializado com sucesso
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] YOLO inicializado - destruindo loading")
                            
                            # Destruir loading screen
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclus√£o
                            def check_phase_1_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detec√ß√£o completa
                                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Detec√ß√£o Phase 1 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Ir para p√°gina LINK DOWNGRADE
                                        self._show_link_downgrade_page(short_link_path, specific_id)
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_1_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._show_link_downgrade_page(short_link_path, specific_id)
                            
                            self.after(1000, check_phase_1_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._show_link_downgrade_page(short_link_path, specific_id)
                    except Exception as e:
                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro na inicializa√ß√£o: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._show_link_downgrade_page(short_link_path, specific_id)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
            else:
                print("DEBUG: [LINK_DOWNGRADE_PHASE1] Erro ao criar loading screen - fallback direto")
                self._show_link_downgrade_page(short_link_path, specific_id)
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro: {e}")
            self._show_link_downgrade_page(short_link_path, specific_id)
    
    def _show_link_downgrade_page(self, short_link_path, specific_id):
        """
        Cria p√°gina LINK DOWNGRADE para escolher Long Link.
        Inverso da p√°gina LINK UPGRADE: t√≠tulo "LINK DOWNGRADE" e Long Links da Store.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Criando p√°gina LINK DOWNGRADE para specific_id {specific_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar igual √† Store - usar awning da Store
        try:
            awning_img_path = os.path.join(IMG_DIR, "Store_awning_v3.png")
            if os.path.exists(awning_img_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_img_path).resize((screen_width, 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                awning_label._is_topbar = True
                
                # Label pequeno √† esquerda do logo (igual √† Store)
                left_label = tk.Label(self, text="‚Ä¢‚Ä¢‚Ä¢‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                left_label.place(relx=0.46, y=10, anchor="center")
                
                # Logo NetMaster posicionado independentemente (igual √† Store)
                try:
                    logo_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "logo_netmaster_store.png")).resize((20, 20)))
                    logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                    logo_lbl.image = logo_img
                    logo_lbl.place(relx=0.5, y=10, anchor="center")
                except Exception as e:
                    print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar logo: {e}")
                
                # Label largo √† direita do logo para cobrir √°rea amarela (igual √† Store)
                right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                right_logo_label.place(relx=0.53, y=10, anchor="w")
                
                # Label adicional para garantir cobertura completa (igual √† Store)
                extra_cover_label = tk.Label(self, text="     ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
                extra_cover_label.place(relx=0.55, y=10, anchor="w")
                
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] TopBar da Store aplicado com sucesso")
                
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Store awning n√£o encontrado, usando fallback")
                # Criar TopBar fallback
                topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                topbar_frame.pack(pady=(0, 10), fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao criar TopBar da Store: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            topbar_frame.pack(pady=(0, 10), fill="x")
            topbar_frame.pack_propagate(False)
        
        # Texto "Store" posicionado independentemente (igual √† Store)
        store_name_lbl = tk.Label(self, text="Store", 
                                 font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        store_name_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno √† direita do nome Store (igual √† Store original)
        right_store_label = tk.Label(self, text="‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_store_label.place(relx=0.6, y=30, anchor="center")
        
        # T√≠tulo da p√°gina - LINK DOWNGRADE (em vez de LINK UPGRADE)
        title = tk.Label(self, text="LINK DOWNGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Long Links para downgrade (da Store da cor do jogador)
        long_links = self._get_long_links_for_downgrade(specific_id)
        
        if not long_links:
            # Mensagem se n√£o h√° Long Links dispon√≠veis
            no_links_msg = tk.Label(self, text="No Long Links available for downgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Bot√£o de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para m√∫ltiplos Long Links
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padr√£o
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necess√°rio
        for idx, link_path in enumerate(long_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_link_downgrade_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior da Store (igual √† p√°gina LINK UPGRADE)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, "BelowBar_store.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] BelowBar_store carregado")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] BelowBar_store n√£o encontrado, usando fallback")
                belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar BelowBar_store: {e}")
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [LINK_DOWNGRADE_PAGE] SUCCESS: P√°gina LINK DOWNGRADE criada")
    
    def _get_long_links_for_downgrade(self, specific_id):
        """
        Obt√©m cartas Long Link da COR DO JOGADOR com specific_id correspondente na Store.
        Inverso do _get_short_links_for_upgrade: procura Long Links em vez de Short Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Obtendo Long Links da cor '{self.player_color}' para specific_id {specific_id}")
        
        # Obter informa√ß√µes do Long Link baseado no specific_id
        long_link_info = self._get_corresponding_long_link_info(specific_id)
        
        if not long_link_info:
            print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Nenhum Long Link correspondente encontrado")
            return []
        
        long_links_found = []
        filename = long_link_info['filename']
        
        # Usar utilit√°rios universais para detectar caminhos
        universal_paths = get_universal_paths()
        base_dir = universal_paths['base_dir']
        
        # Mapear cor do jogador para nome do diret√≥rio (primeira letra mai√∫scula)
        player_color_dir = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Procurando {filename} na cor {player_color_dir}...")
        
        # Poss√≠veis bases para busca
        possivel_bases = [base_dir]
        
        # Para cada base poss√≠vel, buscar Long Links
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                continue
                
            # Testar estruturas de diret√≥rios (similar ao _obter_equipments_da_store)
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (min√∫scula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (mai√∫scula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Usando estrutura: {equipments_base}")
                    break
            
            if not equipments_base:
                continue
                
            # Buscar Long Links APENAS na cor do jogador
            cor_dir = os.path.join(equipments_base, player_color_dir)
            if not os.path.exists(cor_dir):
                print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Diret√≥rio da cor {player_color_dir} n√£o existe: {cor_dir}")
                continue
                
            # Procurar TODAS as cartas com o filename da cor do jogador
            print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Procurando em: {cor_dir}")
            
            # Listar todos os arquivos no diret√≥rio da cor do jogador
            if os.path.isdir(cor_dir):
                arquivos_na_cor = os.listdir(cor_dir)
                print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Arquivos encontrados na cor {player_color_dir}: {arquivos_na_cor}")
                
                # Procurar TODAS as inst√¢ncias do filename
                for arquivo in arquivos_na_cor:
                    if arquivo == filename:
                        long_link_path = os.path.join(cor_dir, arquivo)
                        long_links_found.append(long_link_path)
                        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Long Link encontrado: {long_link_path}")
        
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Total de Long Links encontrados: {len(long_links_found)}")
        return long_links_found
    
    def _get_corresponding_long_link_info(self, specific_id):
        """
        Obt√©m informa√ß√µes do Long Link correspondente ao specific_id.
        Inverso do _get_corresponding_short_link_info.
        """
        # Mapeamento: specific_id -> Long Link filename
        mapping = {
            1: "Equipment_10.png",  # Long Link 1
            2: "Equipment_11.png",  # Long Link 2
            3: "Equipment_12.png",  # Long Link 3
        }
        
        filename = mapping.get(specific_id)
        if filename:
            return {'filename': filename, 'specific_id': specific_id}
        return None
    
    def _show_link_downgrade_fullscreen(self, long_link_path):
        """
        Mostra Long Link em fullscreen com bot√£o roxo para confirma√ß√£o de trade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(long_link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Long Link
        try:
            pil_img = Image.open(long_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Bot√£o X (cinzento, canto superior esquerdo) - volta para LINK DOWNGRADE
        def close_fullscreen():
            router_id = getattr(self, '_link_downgrade_target_id', 1)
            specific_id = router_id
            short_link_path = getattr(self, '_link_downgrade_source_path', None)
            self._show_link_downgrade_page(short_link_path, specific_id)
        
        x_btn = tk.Button(
            self, 
            text="‚úñ", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o ROXO (canto superior direito) - confirma trade
        def confirm_trade():
            self._show_link_downgrade_trade_confirmation(long_link_path)
        
        purple_btn = tk.Button(
            self, 
            text="‚úì", 
            font=("Helvetica", 24, "bold"), 
            bg="#800080", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=confirm_trade, 
            cursor="hand2", 
            activebackground="#9900AA"
        )
        purple_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [LINK_DOWNGRADE_FULLSCREEN] SUCCESS: Fullscreen criado com bot√µes")
    
    def _show_link_downgrade_trade_confirmation(self, long_link_path):
        """
        Overlay de confirma√ß√£o final para o trade Link Downgrade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_TRADE] Criando overlay de trade para: {os.path.basename(long_link_path)}")
        
        # Salvar refer√™ncia do Long Link escolhido
        self._link_downgrade_long_link_path = long_link_path
        
        # Limpar widgets 
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta Long Link como fundo
        try:
            pil_img = Image.open(long_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_TRADE] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirma√ß√£o
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Trade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
         # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(long_link_path)
        
        # Mensagem de confirma√ß√£o
        tk.Label(confirm_frame, text=f"Long Link {specific_id} is going to be added \nto your inventory", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o bot√£o
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o Ok (roxo)
        def confirmar_trade():
            print("DEBUG: [LINK_DOWNGRADE_TRADE] Trade confirmado - destruindo interface e iniciando Fase 2")
            # Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_DOWNGRADE_TRADE] Interface destru√≠da - prosseguindo para detec√ß√£o YOLO")
            self._executar_link_downgrade_phase_2(long_link_path)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_trade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_DOWNGRADE_TRADE] Overlay de trade criado")
    
    def _executar_link_downgrade_phase_2(self, long_link_path):
        """
        Phase 2 de LINK DOWNGRADE: Detectar Long Link da Store.
        Ap√≥s detec√ß√£o, completa o downgrade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Iniciando Phase 2 para Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object_name do Long Link para detec√ß√£o YOLO
            if self.card_database:
                object_name = get_equipment_object_name(long_link_path, self.card_database)
                
                if not object_name:
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Nenhum object_name encontrado - fallback direto")
                    self._complete_link_downgrade()
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Object name para detec√ß√£o: {object_name}")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Base de dados n√£o dispon√≠vel - fallback direto")
                self._complete_link_downgrade()
                return
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print("DEBUG: [LINK_DOWNGRADE_PHASE2] Loading screen criado - iniciando detec√ß√£o")
                
                # Usar utilit√°rios universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Script n√£o encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: completar downgrade sem YOLO
                    self._complete_link_downgrade()
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Executando: {script_path} {object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                subprocess.run(['chmod', '+x', script_path], check=True)
                process = subprocess.Popen([script_path, object_name])
                
                # Monitor de inicializa√ß√£o (aguardar YOLO carregar)
                def check_phase_2_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda rodando - YOLO inicializado com sucesso
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] YOLO inicializado - destruindo loading")
                            
                            # Destruir loading screen
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclus√£o
                            def check_phase_2_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detec√ß√£o completa
                                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Detec√ß√£o Phase 2 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Completar o downgrade
                                        self._complete_link_downgrade()
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_2_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._complete_link_downgrade()
                            
                            self.after(1000, check_phase_2_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._complete_link_downgrade()
                    except Exception as e:
                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro na inicializa√ß√£o: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._complete_link_downgrade()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_2_initialization)
            else:
                print("DEBUG: [LINK_DOWNGRADE_PHASE2] Erro ao criar loading screen - fallback direto")
                self._complete_link_downgrade()
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro: {e}")
            self._complete_link_downgrade()
    
    def _complete_link_downgrade(self):
        """
        Completa o LINK DOWNGRADE fazendo a troca na base de dados.
        Short Link (invent√°rio) -> Long Link (Store)
        """
        print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Completando Link Downgrade")
        
        try:
            # Obter paths salvos
            short_link_path = getattr(self, '_link_downgrade_short_link_path', None)
            long_link_path = getattr(self, '_link_downgrade_long_link_path', None)
            
            if not short_link_path or not long_link_path:
                print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Erro: paths n√£o encontrados")
                self._show_downgrade_error_message()
                return
            
            # Realizar transa√ß√£o na base de dados
            success = self._perform_link_downgrade_database_transaction(short_link_path, long_link_path)
            
            if success:
                # CORRE√á√ÉO: Ir diretamente para o dashboard ap√≥s sucesso
                print("DEBUG: [LINK_DOWNGRADE_COMPLETE] SUCCESS: Transa√ß√£o completa, voltando ao dashboard")
                self._voltar_dashboard_apos_link_downgrade()
            else:
                self._show_downgrade_error_message()
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Erro: {e}")
            self._show_downgrade_error_message()
    
    def _perform_link_downgrade_database_transaction(self, short_link_path, long_link_path):
        """
        Realiza a transa√ß√£o de LINK DOWNGRADE na base de dados.
        Remove Short Link do invent√°rio, adiciona Long Link ao invent√°rio.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Executando transa√ß√£o")
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link: {os.path.basename(short_link_path)}")
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Desativar Short Link antes de remov√™-lo (se estiver ativo)
            try:
                if self.is_card_active(short_link_path, "equipments"):
                    self.deactivate_card(short_link_path, "equipments")
                    print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link desativado: {os.path.basename(short_link_path)}")
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Aviso ao desativar Short Link: {e}")
            
            # Remover Short Link do invent√°rio do jogador
            if short_link_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(short_link_path)
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link removido do invent√°rio")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Erro: Short Link n√£o encontrado no invent√°rio")
                return False
            
            # Adicionar Long Link ao invent√°rio do jogador
            self.inventario["equipments"].append(long_link_path)
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link adicionado ao invent√°rio")
            
            # CORRE√á√ÉO: Ativar automaticamente o Long Link ap√≥s o downgrade
            try:
                self.activate_card("equipments", long_link_path)
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link ativado automaticamente: {os.path.basename(long_link_path)}")
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Aviso: N√£o foi poss√≠vel ativar Long Link automaticamente: {e}")
                # N√£o falhar a transa√ß√£o por causa disso, o jogador pode ativar manualmente
            
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] SUCCESS: Transa√ß√£o completa")
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Erro na transa√ß√£o: {e}")
            return False
    
    def _show_downgrade_success_message(self):
        """Mostra mensagem de sucesso do LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_SUCCESS] Mostrando mensagem de sucesso")
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        
        # Mensagem de sucesso
        success_label = tk.Label(self, text="LINK DOWNGRADE SUCCESSFUL!", 
                               font=("Helvetica", 24, "bold"), 
                               fg="#00FF00", bg="black")
        success_label.place(relx=0.5, rely=0.4, anchor="center")
        
        # Mensagem adicional
        info_label = tk.Label(self, text="Short Link has been converted to Long Link", 
                            font=("Helvetica", 16), 
                            fg="white", bg="black")
        info_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Bot√£o para voltar ao dashboard
        back_btn = tk.Button(self, text="Continue", font=("Helvetica", 16), 
                           bg="#00AA00", fg="white", width=15, height=2,
                           command=self._voltar_dashboard_apos_link_downgrade)
        back_btn.place(relx=0.5, rely=0.65, anchor="center")
        
        print("DEBUG: [LINK_DOWNGRADE_SUCCESS] SUCCESS: Mensagem de sucesso criada")
    
    def _show_downgrade_error_message(self):
        """Mostra mensagem de erro do LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_ERROR] Mostrando mensagem de erro")
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        
        # Mensagem de erro
        error_label = tk.Label(self, text="LINK DOWNGRADE FAILED!", 
                             font=("Helvetica", 24, "bold"), 
                             fg="#FF0000", bg="black")
        error_label.place(relx=0.5, rely=0.4, anchor="center")
        
        # Mensagem adicional
        info_label = tk.Label(self, text="An error occurred during the downgrade process", 
                            font=("Helvetica", 16), 
                            fg="white", bg="black")
        info_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Bot√£o para voltar ao dashboard
        back_btn = tk.Button(self, text="Continue", font=("Helvetica", 16), 
                           bg="#AA0000", fg="white", width=15, height=2,
                           command=self._voltar_dashboard_apos_link_downgrade)
        back_btn.place(relx=0.5, rely=0.65, anchor="center")
        
        print("DEBUG: [LINK_DOWNGRADE_ERROR] SUCCESS: Mensagem de erro criada")
    
    def _voltar_dashboard_apos_link_downgrade(self):
        """Volta ao dashboard principal ap√≥s LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_RETURN] Retornando ao dashboard")
        
        # Limpar flags de contexto
        self._in_link_downgrade_context = False
        self._link_downgrade_target_id = None
        self._link_downgrade_short_link_path = None
        self._link_downgrade_long_link_path = None
        
        # Voltar √† interface principal
        self.playerdashboard_interface(
            self.player_name, 
            self.saldo, 
            self.other_players, 
            show_store_button=True
        )

    def _show_equipment_inventory_for_link_downgrade(self):
        """Abre invent√°rio de equipamentos especificamente para LINK DOWNGRADE"""
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Criando invent√°rio espec√≠fico para LINK DOWNGRADE")
        
        # Definir contexto espec√≠fico
        self._in_link_downgrade_context = True
        
        # Chamar invent√°rio de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] SUCCESS: Invent√°rio espec√≠fico para LINK DOWNGRADE criado")

    def _aplicar_add_router(self):
        """Abre p√°gina para escolher router gratuito (Equipment_1, Equipment_2, ou Equipment_3) da Store"""
        print("DEBUG: [ADD_ROUTER] Iniciando p√°gina de sele√ß√£o de router")
        try:
            self._criar_router_selection_page()
            print("DEBUG: [ADD_ROUTER] SUCCESS: P√°gina de sele√ß√£o criada com sucesso")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] ERROR: Erro ao criar p√°gina de sele√ß√£o: {e}")
            import traceback
            print(f"DEBUG: [ADD_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def _aplicar_remove_router(self):
        """Abre p√°gina de invent√°rio espec√≠fica para REMOVE ROUTER mostrando apenas Small Routers ativos"""
        print("DEBUG: [REMOVE_ROUTER] Iniciando processo REMOVE ROUTER")
        try:
            # Verificar se h√° equipamentos no invent√°rio
            equipments_inventory = self.inventario.get("equipments", [])
            if not equipments_inventory:
                print("DEBUG: [REMOVE_ROUTER] Invent√°rio de equipamentos vazio")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            # Verificar se h√° Small Routers (Equipment_1, Equipment_2, Equipment_3) ATIVOS
            small_routers_active = []
            for equipment_path in equipments_inventory:
                equipment_filename = os.path.basename(equipment_path)
                # Verificar se √© Small Router (Equipment_1, Equipment_2 ou Equipment_3)
                if any(router_name in equipment_filename for router_name in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]):
                    # Verificar se est√° ativo (virado para cima)
                    if self.is_card_active(equipment_path, "equipments"):
                        small_routers_active.append(equipment_path)
            
            if not small_routers_active:
                print("DEBUG: [REMOVE_ROUTER] Nenhum Small Router ativo encontrado - n√£o √© poss√≠vel remover routers")
                print("DEBUG: [REMOVE_ROUTER] REMOVE ROUTER s√≥ funciona se houver Equipment_1, Equipment_2 ou Equipment_3 ativos (virados para cima)")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            print(f"DEBUG: [REMOVE_ROUTER] {len(small_routers_active)} Small Router(s) ativo(s) encontrado(s)")
            for router in small_routers_active:
                print(f"DEBUG: [REMOVE_ROUTER] Small Router ativo: {os.path.basename(router)}")
            
            # Definir contexto REMOVE ROUTER
            self._in_remove_router_context = True
            self._remove_router_phase = "select_router"  # Fase 1: Selecionar router para remover
            self._small_routers_active = small_routers_active
            
            # Mostrar invent√°rio espec√≠fico apenas com Small Routers ativos (SEM bot√£o Back)
            self._show_remove_router_inventory()
            print("DEBUG: [REMOVE_ROUTER] SUCCESS: Invent√°rio espec√≠fico para REMOVE ROUTER criado")
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER] ERROR: Erro ao abrir invent√°rio: {e}")
            import traceback
            print(f"DEBUG: [REMOVE_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _show_remove_router_inventory(self):
        """Cria invent√°rio espec√≠fico para REMOVE ROUTER com layout EXATAMENTE igual ao invent√°rio normal"""
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] Criando invent√°rio espec√≠fico para REMOVE ROUTER")
        
        # Determinar que cartas mostrar baseado na fase
        if getattr(self, '_remove_router_phase', 'select_router') == 'select_router':
            # Fase 1: Mostrar apenas Small Routers ativos
            cards_to_show = getattr(self, '_small_routers_active', [])
            title_text = "REMOVE ROUTER"
        else:
            # Fase 2: Mostrar apenas Links com mesmo specific_id
            cards_to_show = getattr(self, '_links_to_remove', [])
            title_text = "REMOVE LINKS"
        
        print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Fase: {getattr(self, '_remove_router_phase', 'select_router')}")
        print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Cartas a mostrar: {len(cards_to_show)}")
        
        # Limpar widgets (menos barra superior) - IGUAL AO INVENT√ÅRIO NORMAL
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()

        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se n√£o existir - IGUAL AO INVENT√ÅRIO NORMAL
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Arquivo TopBar n√£o encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar fallback criada ap√≥s erro!")
        
        # --- Nome do jogador --- IGUAL AO INVENT√ÅRIO NORMAL
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Marcar contexto para p√°gina especial
        self._in_router_selection_page = True
        
        # T√≠tulo EXATAMENTE igual ao invent√°rio normal (sobre a barra superior)
        title_label = tk.Label(self, text=title_text, font=("Helvetica", 22, "bold"),
                              fg="white", bg="black")  # CORRE√á√ÉO: fg=white, bg=black igual ao invent√°rio normal
        title_label.place(relx=0.5, y=65, anchor="n")
        
        # Se n√£o h√° cartas, mostrar mensagem
        if not cards_to_show:
            if getattr(self, '_remove_router_phase', 'select_router') == 'select_router':
                message = "No active Small Routers found"
            else:
                message = "All associated links removed!"
            
            no_cards_label = tk.Label(self, text=message, font=("Helvetica", 16), 
                                     bg="black", fg="white")
            no_cards_label.place(relx=0.5, rely=0.5, anchor="center")
        else:
            # CORRE√á√ÉO CR√çTICA: Usar EXATAMENTE o mesmo layout do invent√°rio normal
            # Layout em grade pequena 2x2 com cartas 85x120 - IGUAL AO INVENT√ÅRIO NORMAL
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            
            # CORRE√á√ÉO: Usar tamanhos pequenos iguais ao invent√°rio normal
            card_w, card_h = 85, 120  # Tamanhos PEQUENOS igual ao invent√°rio normal
            n_col = 2  # 2 colunas igual ao invent√°rio normal
            
            for idx, carta_path in enumerate(cards_to_show):
                row = idx // n_col
                col = idx % n_col
                
                try:
                    # CORRE√á√ÉO: Carregar imagem com tamanho pequeno igual ao invent√°rio normal
                    carta_img = Image.open(carta_path)
                    carta_img = carta_img.resize((card_w, card_h), Image.LANCZOS)
                    carta_photo = ImageTk.PhotoImage(carta_img)
                    
                    # Criar label da carta clic√°vel EXATAMENTE igual ao invent√°rio normal
                    carta_lbl = tk.Label(matriz_frame, image=carta_photo, bg="black", cursor="hand2")
                    carta_lbl.image = carta_photo
                    carta_lbl.grid(row=row, column=col, padx=8, pady=8)  # CORRE√á√ÉO: usar grid igual ao invent√°rio normal
                    
                    # Bind para abrir fullscreen
                    carta_lbl.bind("<Button-1>", lambda e, path=carta_path: self._show_remove_router_card_fullscreen(path))
                    
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Carta colocada na linha {row}, coluna {col}: {os.path.basename(carta_path)}")
                    
                except Exception as e:
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Erro ao carregar carta {carta_path}: {e}")
        
        # --- BARRA INFERIOR COM IMAGEM EXATAMENTE igual ao invent√°rio normal ---
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada na p√°gina REMOVE ROUTER")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png na p√°gina REMOVE ROUTER: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        # Saldo no canto inferior direito - IGUAL AO INVENT√ÅRIO NORMAL
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))
        
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] SUCCESS: Invent√°rio espec√≠fico criado com layout ID√äNTICO ao normal")
    
    def _show_remove_router_card_fullscreen(self, carta_path):
        """Mostra carta em fullscreen com bot√µes X cinza e ‚úì roxo (completamente fullscreen)"""
        print(f"DEBUG: [REMOVE_ROUTER_FULLSCREEN] Mostrando carta: {os.path.basename(carta_path)}")
        
        # CORRE√á√ÉO: Limpar TODOS os widgets para fullscreen completo (incluindo TopBar)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.configure(bg="black")
        
        try:
            # Carregar e centralizar imagem da carta (completamente fullscreen)
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular ratio para ocupar m√°ximo da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com imagem da carta centralizada
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_FULLSCREEN] Erro ao carregar carta: {e}")
        
        # Bot√£o X no canto superior ESQUERDO
        x_btn = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), 
                         bg="#AAAAAA", fg="white", width=2, height=1, 
                         borderwidth=0, highlightthickness=0, 
                         command=self._voltar_remove_router_inventory, 
                         cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o ‚úì ROXO (canto superior direito) - Confirmar remo√ß√£o
        # Verificar se √© router ou link para usar fun√ß√£o correta
        current_phase = getattr(self, '_remove_router_phase', 'select_router')
        if current_phase == 'remove_links':
            # Fase 2: Confirmar remo√ß√£o de link
            check_btn = tk.Button(self, text="‚úì", font=("Helvetica", 24, "bold"),
                                bg="#8A2BE2", fg="white", width=2, height=1,
                                borderwidth=0, highlightthickness=0,
                                command=lambda: self._confirmar_remocao_link(carta_path),
                                cursor="hand2", activebackground="#7B68EE")
        else:
            # Fase 1: Confirmar remo√ß√£o de router
            check_btn = tk.Button(self, text="‚úì", font=("Helvetica", 24, "bold"),
                                bg="#8A2BE2", fg="white", width=2, height=1,
                                borderwidth=0, highlightthickness=0,
                                command=lambda: self._confirmar_remocao_router(carta_path),
                                cursor="hand2", activebackground="#7B68EE")
        check_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [REMOVE_ROUTER_FULLSCREEN] Fullscreen completo criado com bot√µes X cinza (esquerda) e ‚úì ROXO (direita)")
    
    def _remover_link_automaticamente(self, carta_path):
        """Remove um link automaticamente durante a fase 2 do REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_LINK_AUTO] Removendo link: {os.path.basename(carta_path)}")
        
        try:
            # Remover link do invent√°rio e lista de ativos
            if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido do invent√°rio")
                
            if carta_path in self.active_equipments:
                self.active_equipments.remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido da lista de ativos")
            
            # Devolver carta √† Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                    print(f"DEBUG: [REMOVE_LINK_AUTO] Link enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [REMOVE_LINK_AUTO] Erro ao enviar link para Store: {e}")
            
            # Remover da lista de links a remover
            if hasattr(self, '_links_to_remove') and carta_path in self._links_to_remove:
                self._links_to_remove.remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido da lista de remo√ß√£o")
            
            # Verificar se ainda h√° links para remover
            if hasattr(self, '_links_to_remove') and len(self._links_to_remove) > 0:
                print(f"DEBUG: [REMOVE_LINK_AUTO] Ainda h√° {len(self._links_to_remove)} links para remover")
                # Voltar ao invent√°rio para mostrar links restantes
                self._show_remove_router_inventory()
            else:
                print("DEBUG: [REMOVE_LINK_AUTO] Todos os links removidos, finalizando processo")
                # Todos os links foram removidos, finalizar processo
                self._finalizar_remove_router()
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_LINK_AUTO] Erro durante remo√ß√£o autom√°tica: {e}")
            self._voltar_dashboard_apos_remove_router()
    
    def _voltar_remove_router_inventory(self):
        """Volta para o invent√°rio espec√≠fico do REMOVE ROUTER"""
        print("DEBUG: [REMOVE_ROUTER] Voltando para invent√°rio REMOVE ROUTER")
        self._show_remove_router_inventory()
    
    def _confirmar_remocao_router(self, carta_path):
        """Mostra overlay de confirma√ß√£o para remo√ß√£o do router"""
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Iniciando confirma√ß√£o para: {os.path.basename(carta_path)}")
        
        # Obter specific_id do router
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            carta_label = tk.Label(self, image=carta_photo, bg="black")
            carta_label.image = carta_photo
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao carregar imagem: {e}")
        
        # Frame para overlay de confirma√ß√£o
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        title_label = tk.Label(confirm_frame, text="Router Removal Confirmation",
                              font=("Helvetica", 16, "bold"), fg="yellow", bg="black")
        title_label.pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Do you want to remove the router {router_id}?"
        message_label = tk.Label(confirm_frame, text=message_text,
                               font=("Helvetica", 16), fg="white", bg="black")
        message_label.pack(pady=(0, 10))
        
        # Mensagem adicional
        info_label = tk.Label(confirm_frame, text="Don't forget to remove\nthe associated queue and link",
                            font=("Helvetica", 14), fg="white", bg="black")
        info_label.pack(pady=(0, 20))
        
        # Frame para bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Bot√£o No - Voltar ao invent√°rio
        no_btn = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"),
                          bg="#F44336", fg="white", width=8,
                          command=self._voltar_remove_router_inventory)
        no_btn.pack(side="left", padx=20, pady=10)
        
        # Bot√£o Yes - Processar remo√ß√£o
        yes_btn = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"),
                           bg="#4CAF50", fg="white", width=8,
                           command=lambda: self._processar_remocao_router(carta_path, router_id))
        yes_btn.pack(side="left", padx=20, pady=10)
        
        print("DEBUG: [REMOVE_ROUTER_CONFIRM] Overlay de confirma√ß√£o criado")
    
    def _processar_remocao_router(self, carta_path, router_id):
        """Processa a remo√ß√£o do router e mostra links associados"""
        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Processando remo√ß√£o router ID {router_id}")
        
        try:
            # NOVA FUNCIONALIDADE: Criar loading screen e executar script de detec√ß√£o
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Carta Equipment detectada - criando loading screen")
            
            # Obter object_name da carta
            object_name = get_equipment_object_name(carta_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Criando loading screen para object: {object_name}")
                
                # Criar loading screen imediatamente
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Loading screen criado com sucesso")
                    
                    # Executar script de detec√ß√£o com monitor correto
                    detection_success = self._execute_detection_with_router_continuation(object_name, loading_window, carta_path, router_id)
                    
                    if detection_success:
                        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Script de detec√ß√£o iniciado com sucesso")
                        return  # Sair aqui - a continua√ß√£o ser√° tratada pelo monitor
                    else:
                        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] AVISO: Script de detec√ß√£o falhou")
                        # Fechar loading screen em caso de erro
                        if loading_window:
                            loading_window.destroy()
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_PROCESS] ERRO: N√£o foi poss√≠vel criar loading screen")
            else:
                print(f"DEBUG: [REMOVE_ROUTER_PROCESS] AVISO: Object name n√£o encontrado para carta Equipment")
            
            # Fallback: processar remo√ß√£o diretamente se detec√ß√£o YOLO falhar
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Fallback: processando remo√ß√£o sem detec√ß√£o YOLO")
            self._continue_router_removal_after_detection(carta_path, router_id)
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Erro durante processamento: {e}")
            self._voltar_dashboard_apos_remove_router()
    
    def _confirmar_remocao_link(self, carta_path):
        """Mostra overlay de confirma√ß√£o para remo√ß√£o de link"""
        try:
            print(f"DEBUG: [CONFIRM_LINK] Confirmando remo√ß√£o de link: {os.path.basename(carta_path)}")
            
            # Obter specific_id do link (se existir)
            link_id = self._get_equipment_specific_id(carta_path)
            
            # Limpar interface
            for widget in self.winfo_children():
                widget.destroy()
            self.configure(bg="black")
            
            # Carregar imagem da carta como fundo
            try:
                carta_img = Image.open(carta_path)
                screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                
                ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                carta_photo = ImageTk.PhotoImage(carta_resized)
                
                carta_label = tk.Label(self, image=carta_photo, bg="black")
                carta_label.image = carta_photo
                carta_label.place(relx=0.5, rely=0.5, anchor="center")
                
            except Exception as e:
                print(f"DEBUG: [CONFIRM_LINK] Erro ao carregar imagem: {e}")
            
            # Frame para overlay de confirma√ß√£o
            confirm_frame = tk.Frame(self, bg="black")
            confirm_frame.pack(expand=True)
            
            # T√≠tulo
            title_label = tk.Label(confirm_frame, text="Link Removal Confirmation",
                                  font=("Helvetica", 16, "bold"), fg="yellow", bg="black")
            title_label.pack(pady=(40, 20))
            
            # Mensagem principal
            message_text = f"Link {link_id} is going to be removed" if link_id else "This link is going to be removed"
            message_label = tk.Label(confirm_frame, text=message_text,
                                   font=("Helvetica", 16), fg="white", bg="black")
            message_label.pack(pady=(0, 20))
            
            # Frame para bot√£o
            btns_frame = tk.Frame(confirm_frame, bg="black")
            btns_frame.pack(pady=30)
            
            # Bot√£o Ok - Processar remo√ß√£o do link
            ok_btn = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"),
                              bg="#4CAF50", fg="white", width=10,
                              command=lambda: self._processar_remocao_link(carta_path))
            ok_btn.pack(pady=10)
            
            print("DEBUG: [CONFIRM_LINK] Overlay de confirma√ß√£o de link criado")
            
        except Exception as e:
            print(f"DEBUG: [CONFIRM_LINK] Erro ao criar overlay: {e}")
            self._show_remove_router_inventory()
    
    def _execute_detection_with_router_continuation(self, object_name, loading_window, carta_path, router_id):
        """Executa detec√ß√£o YOLO e continua processamento de router ap√≥s terminar"""
        def continuation_callback():
            # Processar remo√ß√£o de router ap√≥s detec√ß√£o YOLO
            self._continue_router_removal_after_detection(carta_path, router_id)
        
        return execute_detection_with_continuation(object_name, self, loading_window, continuation_callback)
    
    def _continue_router_removal_after_detection(self, carta_path, router_id):
        """Continua o processamento de remo√ß√£o de router ap√≥s a detec√ß√£o YOLO"""
        try:
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Continuando remo√ß√£o router ap√≥s detec√ß√£o YOLO")
            
            # Remover router do invent√°rio e lista de ativos
            if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(carta_path)
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router removido do invent√°rio")
                
            if carta_path in self.active_equipments:
                self.active_equipments.remove(carta_path)
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router removido da lista de ativos")
            
            # Devolver carta √† Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                    print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Erro ao enviar router para Store: {e}")
            
            # Encontrar links ativos com mesmo specific_id
            links_associados = self._find_active_links_with_same_id(router_id)
            
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Links encontrados com ID {router_id}: {len(links_associados)}")
            for link in links_associados:
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Link associado: {os.path.basename(link)}")
            
            if links_associados:
                # Mudar para fase 2: remover links
                self._remove_router_phase = "remove_links"
                self._links_to_remove = links_associados
                self._router_id_being_removed = router_id
                
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Mudando para fase 2: remover {len(links_associados)} links")
                self._show_remove_router_inventory()
            else:
                # Sem links associados, finalizar processo
                print("DEBUG: [REMOVE_ROUTER_CONTINUE] Nenhum link associado, finalizando processo")
                self._finalizar_remove_router()
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Erro: {e}")
            self._finalizar_remove_router()
    
    def _execute_detection_with_link_continuation(self, object_name, loading_window, carta_path):
        """Executa detec√ß√£o YOLO e continua processamento de link ap√≥s terminar"""
        def continuation_callback():
            # Processar remo√ß√£o de link ap√≥s detec√ß√£o YOLO
            self._continue_link_removal_after_detection(carta_path)
        
        return execute_detection_with_continuation(object_name, self, loading_window, continuation_callback)
    
    def _continue_link_removal_after_detection(self, carta_path):
        """Continua o processamento de remo√ß√£o de link ap√≥s a detec√ß√£o YOLO"""
        try:
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Continuando remo√ß√£o link ap√≥s detec√ß√£o YOLO")
            
            # Remover link usando a fun√ß√£o autom√°tica existente
            # CORRE√á√ÉO: A fun√ß√£o _remover_link_automaticamente j√° decide se volta ao invent√°rio ou finaliza
            # baseado na quantidade de links restantes, ent√£o n√£o devemos chamar _finalizar_remove_router aqui
            self._remover_link_automaticamente(carta_path)
            
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Link processado - decis√£o de navega√ß√£o feita por _remover_link_automaticamente")
            
        except Exception as e:
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Erro ao processar remo√ß√£o: {e}")
            self._finalizar_remove_router()
    
    def _processar_remocao_link(self, carta_path):
        """Processa a remo√ß√£o do link ap√≥s confirma√ß√£o"""
        try:
            print(f"DEBUG: [PROCESS_LINK] Processando remo√ß√£o de link: {os.path.basename(carta_path)}")
            
            # NOVA FUNCIONALIDADE: Criar loading screen e executar script de detec√ß√£o
            print(f"DEBUG: [PROCESS_LINK] Carta Equipment detectada - criando loading screen")
            
            # Obter object_name da carta
            object_name = get_equipment_object_name(carta_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [PROCESS_LINK] Criando loading screen para object: {object_name}")
                
                # Criar loading screen imediatamente
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [PROCESS_LINK] Loading screen criado com sucesso")
                    
                    # Executar script de detec√ß√£o com monitor correto
                    detection_success = self._execute_detection_with_link_continuation(object_name, loading_window, carta_path)
                    
                    if detection_success:
                        print(f"DEBUG: [PROCESS_LINK] Script de detec√ß√£o iniciado com sucesso")
                        return  # Sair aqui - a continua√ß√£o ser√° tratada pelo monitor
                    else:
                        print(f"DEBUG: [PROCESS_LINK] AVISO: Script de detec√ß√£o falhou")
                        # Fechar loading screen em caso de erro
                        if loading_window:
                            loading_window.destroy()
                else:
                    print(f"DEBUG: [PROCESS_LINK] ERRO: N√£o foi poss√≠vel criar loading screen")
            else:
                print(f"DEBUG: [PROCESS_LINK] AVISO: Object name n√£o encontrado para carta Equipment")
            
            # Fallback: remover link diretamente se detec√ß√£o falhar
            self._remover_link_automaticamente(carta_path)
            self._finalizar_remove_router()
            
        except Exception as e:
            print(f"DEBUG: [PROCESS_LINK] Erro ao processar remo√ß√£o: {e}")
            self._finalizar_remove_router()

    def _finalizar_remove_router(self):
        """Finaliza o processo REMOVE ROUTER e volta ao dashboard"""
        print("DEBUG: [REMOVE_ROUTER] Finalizando processo REMOVE ROUTER")
        
        # CORRE√á√ÉO CR√çTICA: Fazer backup dos trackings antes da reconstru√ß√£o
        # Isso garante que Challenges, Events e Services ativos n√£o sejam perdidos
        print("DEBUG: [REMOVE_ROUTER] Fazendo backup dos trackings antes de reconstruir interface")
        self._backup_turn_counters_before_reconstruction()
        
        # Limpar contexto REMOVE ROUTER
        self._in_remove_router_context = False
        self._remove_router_phase = None
        self._small_routers_active = []
        self._links_to_remove = []
        self._router_id_being_removed = None
        self._in_router_selection_page = False  # Limpar flag de p√°gina especial
        
        # Voltar ao dashboard principal
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _voltar_dashboard_apos_remove_router(self):
        """Volta ao dashboard ap√≥s completar ou cancelar REMOVE ROUTER"""
        print("DEBUG: [REMOVE_ROUTER] Voltando ao dashboard")
        self._finalizar_remove_router()
    
    def _criar_router_selection_page(self):
        """Cria p√°gina completa para sele√ß√£o de router da Store (padr√£o igual Store_v2.py)"""
        print("DEBUG: [ADD_ROUTER] ======= INICIANDO CRIA√á√ÉO DA P√ÅGINA =======")
        print("DEBUG: [ADD_ROUTER] Criando p√°gina de sele√ß√£o de router")
        
        # PROTE√á√ÉO: Marcar que estamos numa p√°gina especial (impede callbacks autom√°ticos)
        self._in_router_selection_page = True
        print("DEBUG: [ADD_ROUTER] Flag _in_router_selection_page = True")
        
        # VERIFICA√á√ÉO DE SEGURAN√áA: Garantir que esta fun√ß√£o s√≥ √© chamada em contexto v√°lido
        if not hasattr(self, 'cards') or not self.cards:
            print("DEBUG: [ADD_ROUTER] ERRO - Cards n√£o dispon√≠veis, abortando")
            return
        
        # FOR√áA ATUALIZA√á√ÉO DA INTERFACE (cr√≠tico para Raspberry Pi)
        self.update_idletasks()
        self.update()
        
        # Limpar interface atual (IGUAL STORE_V2.PY)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        print("DEBUG: [ADD_ROUTER] Interface limpa e fundo preto definido")
        
        # FOR√áA SEGUNDA ATUALIZA√á√ÉO AP√ìS LIMPEZA
        self.update_idletasks()
        self.update()
        
        # Barra superior com Store_awning_v3.png (como pedido)
        try:
            # Usar Store_awning_v3.png como especificado
            awning_path = os.path.join(os.path.dirname(__file__), "img", "Store_awning_v3.png")
            if os.path.exists(awning_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_path).resize((self.winfo_screenwidth(), 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                print("DEBUG: [ADD_ROUTER] Header com Store_awning_v3.png criado")
            else:
                raise FileNotFoundError("Store_awning_v3.png n√£o encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar Store_awning_v3.png: {e} - usando fallback")
            # Fallback simples
            header_frame = tk.Frame(self, bg="#4CAF50", height=50)
            header_frame.pack(fill="x", pady=(0, 10))
            header_label = tk.Label(header_frame, text="NetMaster", font=("Helvetica", 18, "bold"), 
                                  fg="white", bg="#4CAF50")
            header_label.pack(expand=True)

        # Label pequeno √† esquerda do logo (como na Store)
        left_label = tk.Label(self, text="‚Ä¢‚Ä¢‚Ä¢‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        left_label.place(relx=0.46, y=10, anchor="center")
        
        # Logo NetMaster posicionado independentemente (igual Store_v2.py)
        try:
            # Tentar carregar o logo do diret√≥rio img
            # Usar os utilit√°rios universais para encontrar o logo
            logo_img_path = find_existing_path("img/logo_netmaster_store.png")
            if not logo_img_path:
                # Fallback local
                logo_img_path = os.path.join(os.path.dirname(__file__), "img", "logo_netmaster_store.png")
            
            if os.path.exists(logo_img_path):
                logo_img = ImageTk.PhotoImage(Image.open(logo_img_path).resize((20, 20)))
                logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                logo_lbl.image = logo_img
                logo_lbl.place(relx=0.5, y=10, anchor="center")
                print("DEBUG: [ADD_ROUTER] Logo NetMaster adicionado com sucesso")
            else:
                print("DEBUG: [ADD_ROUTER] Logo n√£o encontrado em nenhum diret√≥rio")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar logo: {e}")
        
        # Label largo √† direita do logo para cobrir √°rea amarela (ajustado)
        right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_logo_label.place(relx=0.52, y=10, anchor="w")
        
        # Label adicional para garantir cobertura completa (reduzido)
        extra_cover_label = tk.Label(self, text="  ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
        extra_cover_label.place(relx=0.54, y=10, anchor="w")
        
        # Texto "Store" posicionado independentemente (como na Store)
        title_lbl = tk.Label(self, text="Store", 
                            font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        title_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno √† direita do t√≠tulo (igual Store original)
        right_title_label = tk.Label(self, text="‚Ä¢", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_title_label.place(relx=0.6, y=30, anchor="center")

        # Tamanho das cartas - igual ao da Store (75x110)
        card_w, card_h = 75, 110

        # Obter equipamentos dispon√≠veis sincronizados com o invent√°rio
        routers_disponiveis = self._obter_equipments_sincronizados()
        
        print(f"DEBUG: [ADD_ROUTER] Routers dispon√≠veis sincronizados: {len(routers_disponiveis)}")
        
        # Pagina√ß√£o (igual Store_v2.py, mesmo que s√≥ tenhamos 3 routers)
        cards_per_page = 4  # Igual √† Store_v2.py
        total_pages = max(1, (len(routers_disponiveis) + cards_per_page - 1) // cards_per_page)
        page = 0  # Sempre p√°gina 0 para routers
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        routers_page = routers_disponiveis[start_idx:end_idx]
        
        # Frame para os routers (centralizado, movido mais para cima)
        self.matriz_frame = tk.Frame(self, bg="black")
        self.matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        n_col = 2  # 2 colunas para layout 2xn como solicitado
        card_w, card_h = 75, 110  # Tamanho das cartas de router
        
        # Vari√°veis para sele√ß√£o
        self.router_selection = None
        self.router_buttons = []
        
        # Callback para sele√ß√£o de router
        def make_router_selection_callback(router_path, router_idx):
            def callback(event=None):
                print(f"DEBUG: [ADD_ROUTER] Router selecionado: {os.path.basename(router_path)}")
                self._selecionar_router_page(router_path, router_idx)
            return callback
        
        # Criar grid de routers em layout 2xn
        for i, router_path in enumerate(routers_page):
            row = i // n_col
            col = i % n_col
            
            # Frame para router + label
            router_frame = tk.Frame(self.matriz_frame, bg="black")
            router_frame.grid(row=row, column=col, padx=15, pady=8)
            
            # Carregar imagem do router
            try:
                # Verificar se √© placeholder ou arquivo real
                if router_path.startswith("PLACEHOLDER_"):
                    # Criar imagem placeholder
                    placeholder_img = Image.new('RGB', (card_w, card_h), color='#4A4A4A')
                    router_img = ImageTk.PhotoImage(placeholder_img)
                    print(f"DEBUG: [ADD_ROUTER] Placeholder criado para {router_path}")
                else:
                    # Carregar imagem real
                    img = ImageTk.PhotoImage(Image.open(router_path).resize((card_w, card_h)))
                    router_img = img
                    print(f"DEBUG: [ADD_ROUTER] Imagem carregada: {os.path.basename(router_path)}")
            except Exception as e:
                print(f"DEBUG: [ADD_ROUTER] Erro ao carregar {router_path}: {e}")
                # Fallback: criar imagem simples
                placeholder_img = Image.new('RGB', (card_w, card_h), color='#666666')
                router_img = ImageTk.PhotoImage(placeholder_img)
            
            # Criar bot√£o do router igual √† Store_v2.py
            router_btn = tk.Button(router_frame, image=router_img, bg="black", cursor="hand2",
                                  borderwidth=3, relief="raised")
            router_btn.image = router_img  # Manter refer√™ncia
            router_btn.pack()
            router_btn.bind("<Button-1>", make_router_selection_callback(router_path, i))
            
            # Label com nome do router por baixo
            filename = os.path.basename(router_path)
            router_id = filename.replace("Equipment_", "").replace(".png", "")
            
            router_name_lbl = tk.Label(router_frame, text=f"Router {router_id}", 
                                     font=("Helvetica", 12, "bold"), fg="white", bg="black")
            router_name_lbl.pack(pady=(5, 0))
            
            # Status label (dispon√≠vel)
            status_lbl = tk.Label(router_frame, text="Available", 
                                font=("Helvetica", 10), fg="#00FF00", bg="black")
            status_lbl.pack()
            
            self.router_buttons.append(router_btn)
        
        # Bot√µes de a√ß√£o na parte inferior com BelowBar_store.png (como pedido)
        # Barra inferior com BelowBar_store.png
        try:
            belowbar_path = os.path.join(os.path.dirname(__file__), "img", "BelowBar_store.png")
            if os.path.exists(belowbar_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_path).resize((self.winfo_screenwidth(), 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print("DEBUG: [ADD_ROUTER] Footer com BelowBar_store.png criado")
            else:
                raise FileNotFoundError("BelowBar_store.png n√£o encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar BelowBar_store.png: {e} - usando fallback")
            footer_frame = tk.Frame(self, bg="#4CAF50", height=50)
            footer_frame.pack(side="bottom", fill="x")
        
        # Bot√µes de a√ß√£o sobrepostos ao footer (igual Store_v2.py)
        buttons_frame = tk.Frame(self, bg="black")
        buttons_frame.place(relx=0.5, rely=0.95, anchor="center")
        
        # Apenas o bot√£o Confirm (sem Cancel button como solicitado)
        self.confirm_button = tk.Button(buttons_frame, text="Confirm", 
                                       font=("Helvetica", 14, "bold"), fg="white", 
                                       bg="#555555", relief="flat", width=10, height=1,
                                       state="disabled", command=self._confirmar_router_selection_page)
        self.confirm_button.pack()
        
        print("DEBUG: [ADD_ROUTER] SUCCESS: P√°gina de sele√ß√£o de router criada (padr√£o Store_v2.py)")
        
        # FOR√áA ATUALIZA√á√ÉO FINAL DA INTERFACE
        self.update_idletasks()
        self.update()
        
        # VERIFICA√á√ÉO FINAL: Confirmar que a p√°gina foi criada E est√° vis√≠vel
        def verificar_pagina_final():
            if hasattr(self, '_in_router_selection_page') and self._in_router_selection_page:
                widgets_count = len(self.winfo_children())
                print(f"DEBUG: [ADD_ROUTER] SUCCESS: P√°gina ativa com {widgets_count} widgets ap√≥s verifica√ß√£o final")
                
                # FOR√áAR REFRESH VISUAL ADICIONAL
                self.lift()  # Traz a janela para frente
                self.focus_force()  # For√ßa foco
                self.update_idletasks()
                print("DEBUG: [ADD_ROUTER] SUCCESS: Interface for√ßada para frente e atualizada")
            else:
                print("DEBUG: [ADD_ROUTER] WARNING: Flag de p√°gina perdida ap√≥s verifica√ß√£o final")
        
        # Verifica√ß√£o imediata + verifica√ß√£o com delay
        verificar_pagina_final()
        self.after(100, verificar_pagina_final)
        
        print("DEBUG: [ADD_ROUTER] ======= P√ÅGINA CRIADA COM SUCESSO =======")
    
    def _obter_equipments_da_store(self):
        """Obt√©m lista de equipamentos dispon√≠veis na Store"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos dispon√≠veis...")
        
        # Lista dos 3 routers sempre dispon√≠veis para ADD ROUTER
        routers_add_router = ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]
        equipments_encontrados = []
        
        # DETEC√á√ÉO INTELIGENTE DE CAMINHOS
        # Usar os utilit√°rios universais para detectar caminhos
        universal_paths = get_universal_paths()
        print(f"DEBUG: [ADD_ROUTER] Ambiente detectado: {universal_paths['environment']}")
        
        possivel_bases = [universal_paths['base_dir']]
        
        # Se for Raspberry Pi, tentar tamb√©m caminhos alternativos
        if universal_paths['environment'] == 'raspberry_pi':
            # Adicionar caminhos alternativos poss√≠veis
            additional_bases = get_possible_raspberry_pi_paths("")  # Base paths
            possivel_bases.extend([path for path in additional_bases if path not in possivel_bases])
        
        print(f"DEBUG: [ADD_ROUTER] Bases a testar: {possivel_bases[:3]}")  # Mostrar apenas as primeiras 3
        
        # Para cada base poss√≠vel, testar se tem estrutura Equipments
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                print(f"DEBUG: [ADD_ROUTER] ERROR: Base n√£o existe: {base_path}")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] SUCCESS: Testando base: {base_path}")
            
            # Verificar se tem diret√≥rio Equipments (teste m√∫ltiplas varia√ß√µes)
            # CORRE√á√ÉO: Testar tanto "Equipments" quanto "equipments" para Raspberry Pi
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (min√∫scula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (mai√∫scula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [ADD_ROUTER] SUCCESS: Encontrou Equipments: {equipments_base}")
                    break
                else:
                    print(f"DEBUG: [ADD_ROUTER] ERROR: Sem Equipments: {variation}")
            
            if not equipments_base:
                print(f"DEBUG: [ADD_ROUTER] ERROR: Nenhuma varia√ß√£o de Equipments encontrada")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] SUCCESS: Encontrou Equipments: {equipments_base}")
            
            # Testar cada cor para encontrar os routers
            for cor in ["Red", "Blue", "Green", "Yellow"]:
                cor_dir = os.path.join(equipments_base, cor)
                if not os.path.exists(cor_dir):
                    print(f"DEBUG: [ADD_ROUTER] ERROR: Cor {cor} n√£o existe: {cor_dir}")
                    continue
                    
                print(f"DEBUG: [ADD_ROUTER] SUCCESS: Testando cor {cor}: {cor_dir}")
                
                # Verificar se tem todos os 3 routers nesta cor
                routers_nesta_cor = []
                for router_filename in routers_add_router:
                    router_path = os.path.join(cor_dir, router_filename)
                    if os.path.exists(router_path):
                        routers_nesta_cor.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router encontrado: {router_path}")
                    else:
                        print(f"DEBUG: [ADD_ROUTER] ERROR: Router missing: {router_path}")
                
                # Se encontramos todos os 3, usar esta cor
                if len(routers_nesta_cor) == 3:
                    equipments_encontrados = routers_nesta_cor
                    print(f"DEBUG: [ADD_ROUTER] CELEBRATION: SUCESSO! Todos os 3 routers encontrados em {cor_dir}")
                    break
            
            # Se encontramos, parar de procurar outras bases
            if equipments_encontrados:
                break
        
        # FALLBACK: Se ainda n√£o encontramos, criar placeholders visuais
        if not equipments_encontrados:
            print("DEBUG: [ADD_ROUTER] WARNING: NENHUM ROUTER ENCONTRADO - Usando placeholders")
            
            # Usar imagens de placeholder ou criar caminhos virtuais
            placeholder_base = "/tmp" if universal_paths['environment'] == 'raspberry_pi' else os.getcwd()
            for i, router_filename in enumerate(routers_add_router, 1):
                placeholder_path = f"PLACEHOLDER_ROUTER_{i}"
                equipments_encontrados.append(placeholder_path)
                print(f"DEBUG: [ADD_ROUTER] NOTE: Placeholder criado: {placeholder_path}")
        
        print(f"DEBUG: [ADD_ROUTER] FINISH: RESULTADO FINAL:")
        print(f"DEBUG: [ADD_ROUTER]   Routers para ADD ROUTER: {len(equipments_encontrados)}")
        for i, router in enumerate(equipments_encontrados, 1):
            print(f"DEBUG: [ADD_ROUTER]   {i}. {router}")
        
        return equipments_encontrados
    
    def _obter_equipments_sincronizados(self):
        """Obt√©m lista de equipamentos dispon√≠veis sincronizados com o invent√°rio (igual √† Store)"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos sincronizados com invent√°rio...")
        
        # Primeiro obter todos os equipments dispon√≠veis
        all_equipments = self._obter_equipments_da_store()
        
        # Filtrar apenas Equipment_1, Equipment_2, Equipment_3
        routers_base = []
        for equipment_path in all_equipments:
            filename = os.path.basename(equipment_path)
            if filename in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]:
                routers_base.append(equipment_path)
        
        print(f"DEBUG: [ADD_ROUTER] Routers base encontrados: {len(routers_base)}")
        
        # Aplicar sincroniza√ß√£o com invent√°rio (igual Store_v2.py)
        routers_sincronizados = routers_base.copy()  # Come√ßar com todos
        
        if hasattr(self, 'inventario') and self.inventario:
            print(f"DEBUG: [ADD_ROUTER] Aplicando sincroniza√ß√£o com invent√°rio...")
            
            # Verificar equipments no invent√°rio
            equipments_inventario = self.inventario.get("equipments", [])
            if equipments_inventario:
                print(f"DEBUG: [ADD_ROUTER] Equipments no invent√°rio: {len(equipments_inventario)}")
                
                # Remover equipments que j√° est√£o no invent√°rio
                routers_filtrados = []
                for router_path in routers_sincronizados:
                    router_filename = os.path.basename(router_path)
                    
                    # Verificar se este equipment est√° no invent√°rio
                    equipment_no_inventario = False
                    for inv_path in equipments_inventario:
                        if os.path.basename(inv_path) == router_filename:
                            equipment_no_inventario = True
                            print(f"DEBUG: [ADD_ROUTER] Removendo {router_filename} (j√° no invent√°rio)")
                            break
                    
                    # Se n√£o est√° no invent√°rio, manter dispon√≠vel
                    if not equipment_no_inventario:
                        routers_filtrados.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] Mantendo {router_filename} (dispon√≠vel)")
                
                routers_sincronizados = routers_filtrados
            else:
                print(f"DEBUG: [ADD_ROUTER] Nenhum equipment no invent√°rio")
        else:
            print(f"DEBUG: [ADD_ROUTER] Sem invent√°rio para sincronizar")
        
        print(f"DEBUG: [ADD_ROUTER] Resultado sincroniza√ß√£o:")
        print(f"DEBUG: [ADD_ROUTER]   Routers dispon√≠veis: {len(routers_sincronizados)}")
        for router in routers_sincronizados:
            print(f"DEBUG: [ADD_ROUTER]   - {os.path.basename(router)}")
        
        return routers_sincronizados
    
    def _selecionar_router_page(self, router_path, button_index):
        """Seleciona router na p√°gina e atualiza visual dos bot√µes"""
        print(f"DEBUG: [ADD_ROUTER] Router selecionado: {router_path}")
        
        self.router_selection = router_path
        
        # Resetar todos os bot√µes para cor normal
        for btn in self.router_buttons:
            btn.configure(bg="#4A4A4A", relief="raised", borderwidth=3)
        
        # Destacar bot√£o selecionado em roxo
        if button_index < len(self.router_buttons):
            self.router_buttons[button_index].configure(bg="#8A2BE2", relief="sunken", borderwidth=4)
        
        # Ativar bot√£o Confirm e deixar roxo
        self.confirm_button.configure(state="normal", bg="#8A2BE2", cursor="hand2")
    
    def _cancelar_router_selection(self):
        """Cancela sele√ß√£o e volta ao PlayerDashboard"""
        print("DEBUG: [ADD_ROUTER] Cancelando sele√ß√£o de router")
        
        # RESETAR FLAG DE PROTE√á√ÉO
        self._in_router_selection_page = False
        
        # Limpar sele√ß√£o
        self.router_selection = None
        
        # Restaurar interface do PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _confirmar_router_selection_page(self):
        """Confirma sele√ß√£o na p√°gina e adiciona router gratuito ao invent√°rio do jogador"""
        if not self.router_selection:
            return
            
        print(f"DEBUG: [ADD_ROUTER] Confirmando sele√ß√£o: {self.router_selection}")
        
        # RESETAR FLAG DE PROTE√á√ÉO
        self._in_router_selection_page = False
        
        # Preparar caminho do router para adicionar ao invent√°rio
        router_para_inventario = self.router_selection
        
        # Se √© placeholder, criar um caminho de equipamento v√°lido baseado no ID
        if router_para_inventario.startswith("PLACEHOLDER_"):
            # Extrair ID do placeholder (ex: PLACEHOLDER_ROUTER_1 -> Equipment_1.png)
            placeholder_id = router_para_inventario.split("_")[-1]  # Pega √∫ltimo n√∫mero
            router_filename = f"Equipment_{placeholder_id}.png"
            
            # Criar caminho final baseado na cor do jogador
            base_equipments = detect_player_inventory_base_dir()
            color_mapping = {
                "red": "Red",
                "blue": "Blue", 
                "green": "Green",
                "yellow": "Yellow"
            }
            player_color_title = color_mapping.get(self.player_color.lower(), "Red")
            
            router_para_inventario = os.path.join(
                base_equipments, 
                "Equipments", 
                "Residential-level", 
                player_color_title, 
                router_filename
            )
            
            print(f"DEBUG: [ADD_ROUTER] Placeholder convertido para: {router_para_inventario}")
        
        # NOVA FUNCIONALIDADE: Obter object_name para detec√ß√£o YOLO
        object_name = get_equipment_object_name(router_para_inventario, self.card_database)
        
        if object_name:
            print(f"DEBUG: [ADD_ROUTER] Object name encontrado: {object_name} - mostrando loading screen")
            
            # CRIAR LOADING SCREEN IMEDIATAMENTE
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print(f"DEBUG: [ADD_ROUTER] Loading screen criado - processando em background")
                
                # Fun√ß√£o para processar adi√ß√£o e detec√ß√£o em background
                def processar_router_com_yolo():
                    try:
                        # Adicionar router ao invent√°rio do jogador
                        if "equipments" not in self.inventario:
                            self.inventario["equipments"] = []
                            
                        self.inventario["equipments"].append(router_para_inventario)
                        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router adicionado gratuitamente ao invent√°rio!")
                        print(f"DEBUG: [ADD_ROUTER] Invent√°rio equipments agora tem: {len(self.inventario['equipments'])} itens")
                        
                        # Executar script YOLO com continua√ß√£o personalizada
                        detection_success = self._execute_detection_with_router_continuation(object_name, loading_window, router_para_inventario)
                        
                        if not detection_success:
                            print(f"DEBUG: [ADD_ROUTER] AVISO: Script YOLO falhou - fechando loading screen")
                            if loading_window:
                                loading_window.destroy()
                            # Voltar ao PlayerDashboard em caso de erro
                            self._voltar_playerdashboard_apos_router_selection()
                            
                    except Exception as e:
                        print(f"DEBUG: [ADD_ROUTER] ERRO no processamento: {e}")
                        if loading_window:
                            loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                
                # Executar processamento ap√≥s 100ms (loading screen j√° est√° vis√≠vel)
                self.after(100, processar_router_com_yolo)
                
            else:
                print(f"DEBUG: [ADD_ROUTER] ERRO: Loading screen n√£o foi criado - continuando normalmente")
                # Fallback: processamento normal se loading screen falhar
                self._processar_router_normal()
        else:
            print(f"DEBUG: [ADD_ROUTER] AVISO: Object name n√£o encontrado - processamento normal")
            # Processamento normal se n√£o conseguir obter object_name
            self._processar_router_normal()
    
    def _processar_router_normal(self):
        """Processa adi√ß√£o de router sem detec√ß√£o YOLO (fallback)"""
        router_para_inventario = self.router_selection
        
        # Se √© placeholder, criar um caminho de equipamento v√°lido baseado no ID
        if router_para_inventario.startswith("PLACEHOLDER_"):
            placeholder_id = router_para_inventario.split("_")[-1]
            router_filename = f"Equipment_{placeholder_id}.png"
            
            base_equipments = detect_player_inventory_base_dir()
            color_mapping = {
                "red": "Red",
                "blue": "Blue", 
                "green": "Green",
                "yellow": "Yellow"
            }
            player_color_title = color_mapping.get(self.player_color.lower(), "Red")
            
            router_para_inventario = os.path.join(
                base_equipments, 
                "Equipments", 
                "Residential-level", 
                player_color_title, 
                router_filename
            )
        
        # Adicionar router ao invent√°rio do jogador
        if "equipments" not in self.inventario:
            self.inventario["equipments"] = []
            
        self.inventario["equipments"].append(router_para_inventario)
        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router adicionado gratuitamente ao invent√°rio!")
        print(f"DEBUG: [ADD_ROUTER] Invent√°rio equipments agora tem: {len(self.inventario['equipments'])} itens")
        
        # Voltar ao PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _execute_detection_with_router_continuation(self, object_name, loading_window, router_path):
        """
        Executa detec√ß√£o YOLO com continua√ß√£o espec√≠fica para router selection.
        
        Args:
            object_name: Nome do objeto para detec√ß√£o
            loading_window: Loading screen ativo
            router_path: Caminho do router adicionado ao invent√°rio
            
        Returns:
            True se iniciou com sucesso, False caso contr√°rio
        """
        try:
            # Usar os utilit√°rios universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [ADD_ROUTER_DETECTION] Simulando execu√ß√£o do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
                # Simular delay e fechar loading screen
                if loading_window:
                    def close_loading_and_return():
                        loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                    self.after(3000, close_loading_and_return)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [ADD_ROUTER_DETECTION] Script n√£o encontrado")
                    return False
            
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Executando: {script_path} {object_name}")
            
            # Tornar o script execut√°vel
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, object_name])
            
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Script iniciado (PID: {process.pid})")
            
            # Monitorar script com loading screen
            if loading_window:
                def check_yolo_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO deve estar inicializado - fechar loading screen
                        print(f"DEBUG: [ADD_ROUTER_DETECTION] Fechando loading screen - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclus√£o
                        def check_script_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_script_completion)
                            else:
                                print(f"DEBUG: [ADD_ROUTER_DETECTION] YOLO terminou - voltando ao PlayerDashboard")
                                self.deiconify()
                                self._voltar_playerdashboard_apos_router_selection()
                        
                        self.after(1000, check_script_completion)
                    else:
                        # Script terminou antes de inicializar
                        loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_yolo_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False
    
    def _voltar_playerdashboard_apos_router_selection(self):
        """Volta ao PlayerDashboard ap√≥s sele√ß√£o/cancelamento de router"""
        print("DEBUG: [ADD_ROUTER] Voltando ao PlayerDashboard")
        
        # RESETAR FLAG DE PROTE√á√ÉO (garantia adicional)
        self._in_router_selection_page = False
        
        # Limpar a p√°gina atual
        for widget in self.winfo_children():
            widget.destroy()
        
        # Restaurar o PlayerDashboard completo
        # Preservar estado atual
        current_saldo = getattr(self, 'saldo', 1000)
        current_color = getattr(self, 'player_color', 'red')
        current_others = getattr(self, 'other_players', ['green', 'blue', 'yellow'])
        current_name = getattr(self, 'player_name', 'Player')
        current_card_idx = getattr(self, 'selected_card_idx', 0)
        
        # Recriar interface do PlayerDashboard
        self.playerdashboard_interface(
            current_name, 
            current_saldo, 
            current_others,
            show_store_button=True
        )


    def show_inventory_matrix(self, tipos, page=0, back_callback=None):
        # PROTE√á√ÉO CONTRA LOOP: Marcar que estamos a abrir invent√°rio
        self._inventory_opening = True
        
        # CORRE√á√ÉO CR√çTICA: Salvar estado da interface ANTES de destruir widgets
        print("DEBUG: [show_inventory_matrix] *** SALVANDO ESTADO ANTES DE LIMPAR WIDGETS ***")
        self._save_dashboard_state()
        
        print(f"DEBUG: [show_inventory_matrix] *** FUN√á√ÉO CHAMADA ***")
        print(f"DEBUG: [show_inventory_matrix] Tipos solicitados: {tipos}")
        print(f"DEBUG: [show_inventory_matrix] Page solicitada: {page}")
        print(f"DEBUG: [show_inventory_matrix] Estado COMPLETO do invent√°rio:")
        total_cartas = 0
        for tipo, cartas_list in self.inventario.items():
            print(f"DEBUG: [show_inventory_matrix]   {tipo}: {len(cartas_list)} cartas")
            total_cartas += len(cartas_list)
            if cartas_list:
                for i, carta in enumerate(cartas_list[:5]):  # Mostrar primeiras 5 para debug
                    print(f"DEBUG: [show_inventory_matrix]     {i+1}. {os.path.basename(carta)}")
        print(f"DEBUG: [show_inventory_matrix] Total de cartas no invent√°rio: {total_cartas}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se n√£o existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [show_inventory_matrix] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [show_inventory_matrix] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [show_inventory_matrix] Arquivo TopBar n√£o encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [show_inventory_matrix] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [show_inventory_matrix] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [show_inventory_matrix] TopBar fallback criada ap√≥s erro!")
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        # T√≠tulo
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        elif set(tipos) == set(["actions", "events"]):
            title_str = "Actions / Events"
        elif set(tipos) == set(["activities", "challenges"]):
            title_str = "Activities / Challenges"
        else:
            # Para outros casos, mostrar os tipos separados por /
            title_str = " / ".join([t.capitalize() for t in tipos])
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        # Verificar se √© Actions/Events ou Activities/Challenges para organiza√ß√£o especial em colunas
        if set(tipos) == set(["actions", "events"]):
            # CORRE√á√ÉO CR√çTICA: Garantir que Events t√™m tracking antes de mostrar invent√°rio
            print(f"DEBUG: [show_inventory_matrix] Verificando tracking de Events antes de mostrar invent√°rio")
            self.ensure_events_have_tracking()
            
            # NOVA IMPLEMENTA√á√ÉO: Fila √∫nica centrada combinando Actions e Events
            # CORRE√á√ÉO: Mostrar TODAS as cartas do invent√°rio em fila FIFO √∫nica
            cartas_actions_raw = self.inventario.get("actions", [])
            cartas_events_raw = self.inventario.get("events", [])
            
            # NOVA ABORDAGEM: N√£o filtrar - mostrar todas as cartas, mas marcar quais s√£o v√°lidas
            cartas_actions_filtered = self._filter_action_event_cards(cartas_actions_raw, "actions")
            cartas_events_filtered = self._filter_action_event_cards(cartas_events_raw, "events")
            
            # Combinar Actions e Events numa √∫nica fila FIFO cronol√≥gica
            # USAR A ORDEM CRONOL√ìGICA REAL de adi√ß√£o ao invent√°rio
            chronological_order = self._get_chronological_actions_events_order()
            
            # Filtrar as cartas v√°lidas
            cartas_actions_filtered = self._filter_action_event_cards(cartas_actions_raw, "actions")
            cartas_events_filtered = self._filter_action_event_cards(cartas_events_raw, "events")
            
            # Construir a fila combinada na ordem cronol√≥gica
            combined_cards = []
            for card_info in chronological_order:
                carta_path = card_info['path']
                carta_tipo = card_info['type']
                
                # Verificar se a carta ainda existe nos invent√°rios
                if carta_tipo == 'actions' and carta_path in cartas_actions_raw:
                    is_valid = carta_path in cartas_actions_filtered
                    original_idx = cartas_actions_raw.index(carta_path)
                    combined_cards.append({
                        'path': carta_path,
                        'type': 'actions',
                        'original_idx': original_idx,
                        'is_valid': is_valid,
                        'chronological_pos': card_info['timestamp']
                    })
                elif carta_tipo == 'events' and carta_path in cartas_events_raw:
                    is_valid = carta_path in cartas_events_filtered
                    original_idx = cartas_events_raw.index(carta_path)
                    combined_cards.append({
                        'path': carta_path,
                        'type': 'events',
                        'original_idx': original_idx,
                        'is_valid': is_valid,
                        'chronological_pos': card_info['timestamp']
                    })
            
            print(f"DEBUG: [show_inventory_matrix] Fila √∫nica Actions+Events: {len(combined_cards)} cartas")
            print(f"DEBUG: [show_inventory_matrix] Actions: {len(cartas_actions_raw)}, Events: {len(cartas_events_raw)}")
            
            # Pagina√ß√£o para fila √∫nica usando disposi√ß√£o vertical nx1
            cards_per_page = 2  # Apenas 2 cartas por p√°gina para evitar sobreposi√ß√£o
            total_pages = max(1, (len(combined_cards) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cards_page = combined_cards[start_idx:end_idx]
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            n_col = 1  # Uma √∫nica coluna centrada
            
            # Processar cartas da p√°gina numa fila √∫nica vertical
            for idx, card_info in enumerate(cards_page):
                row = idx  # Cada carta numa linha diferente
                col = 0    # Sempre coluna 0 (√∫nica coluna)
                
                carta_path = card_info['path']
                carta_tipo = card_info['type']
                original_idx = card_info['original_idx']
                is_valid = card_info['is_valid']
                
                # Calcular posi√ß√£o absoluta na fila combinada
                absolute_position = start_idx + idx
                
                try:
                    # NOVA L√ìGICA COM SISTEMA DE SEQUENCIAMENTO:
                    # 1. Usar get_active_cards_for_type para determinar se carta est√° ativa
                    # 2. Cartas ativas ficam viradas para cima
                    # 3. Cartas inativas ficam viradas para baixo mas s√£o clic√°veis para visualiza√ß√£o
                    
                    # Obter cartas ativas usando sistema de sequenciamento
                    cartas_ativas_actions = self.get_active_cards_for_type("actions")
                    cartas_ativas_events = self.get_active_cards_for_type("events")
                    
                    # Verificar se a carta atual est√° ativa
                    is_carta_ativa = False
                    if carta_tipo == "actions":
                        is_carta_ativa = carta_path in cartas_ativas_actions
                    elif carta_tipo == "events":
                        is_carta_ativa = carta_path in cartas_ativas_events
                    
                    # Determinar apresenta√ß√£o da carta
                    if is_carta_ativa and is_valid:
                        # Carta ativa e v√°lida: virada para cima
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_click_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_click_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Carta ATIVA (virada para cima): {carta_tipo} - {os.path.basename(carta_path)}")
                    elif is_valid:
                        # Carta v√°lida mas inativa: virada para baixo mas clic√°vel
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_facedown_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_facedown_handler(carta_path, tipos)
                        
                        # Debugging adicional para cartas inativas
                        if carta_tipo == "actions" and hasattr(self, '_actions_pending_activation'):
                            is_pending = (carta_path in self._actions_pending_activation and 
                                        self._actions_pending_activation[carta_path])
                            if is_pending:
                                print(f"DEBUG: [show_inventory_matrix] Carta INATIVA por sequenciamento (aguardando pr√≥ximo turno): {carta_tipo} - {os.path.basename(carta_path)}")
                            else:
                                print(f"DEBUG: [show_inventory_matrix] Carta INATIVA (n√£o √© primeira na fila): {carta_tipo} - {os.path.basename(carta_path)}")
                        elif carta_tipo == "events" and hasattr(self, '_event_duration_tracking'):
                            tracking_data = self._event_duration_tracking.get(carta_path, {})
                            if tracking_data.get('pending_activation', False):
                                print(f"DEBUG: [show_inventory_matrix] Event INATIVO por sequenciamento (aguardando pr√≥ximo turno): {os.path.basename(carta_path)}")
                            else:
                                print(f"DEBUG: [show_inventory_matrix] Event INATIVO (n√£o √© primeiro na fila): {os.path.basename(carta_path)}")
                        else:
                            print(f"DEBUG: [show_inventory_matrix] Carta INATIVA na fila (pos {absolute_position}): {carta_tipo} - {os.path.basename(carta_path)}")
                    else:
                        # Carta inv√°lida: virada para baixo
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_invalid_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_invalid_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Carta INV√ÅLIDA (pos {absolute_position}): {carta_tipo} - {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Carta colocada na linha {row}, coluna {col} (pos absoluta {absolute_position})")
                    
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar carta {carta_tipo}: {e}")
                    continue
            
            # Adicionar setas de navega√ß√£o para Actions/Events se houver m√∫ltiplas p√°ginas
            if total_pages > 1:
                # Seta esquerda (p√°gina anterior)
                if page > 0:
                    try:
                        arrow_left_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((30, 30)))
                        arrow_left_btn = tk.Label(self, image=arrow_left_img, cursor="hand2", bg="black")
                        arrow_left_btn.image = arrow_left_img
                        arrow_left_btn.place(x=50, rely=0.5, anchor="w")
                        arrow_left_btn.bind("<Button-1>", lambda e: self.show_inventory_matrix(tipos, page - 1, back_callback))
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar seta esquerda: {e}")
                
                # Seta direita (pr√≥xima p√°gina)  
                if page < total_pages - 1:
                    try:
                        # Rotacionar a imagem arrow_left 180 graus para criar seta direita
                        arrow_right_img_pil = Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((30, 30)).rotate(180)
                        arrow_right_img = ImageTk.PhotoImage(arrow_right_img_pil)
                        arrow_right_btn = tk.Label(self, image=arrow_right_img, cursor="hand2", bg="black")
                        arrow_right_btn.image = arrow_right_img
                        arrow_right_btn.place(x=self.winfo_screenwidth() - 50, rely=0.5, anchor="e")
                        arrow_right_btn.bind("<Button-1>", lambda e: self.show_inventory_matrix(tipos, page + 1, back_callback))
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar seta direita: {e}")
        elif set(tipos) == set(["activities", "challenges"]):
            # Organiza√ß√£o especial: Activities na coluna esquerda, Challenges na coluna direita
            # Estrutura igual ao Actions/Events
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            
            print(f"DEBUG: [show_inventory_matrix] Cartas Activities: {len(cartas_activities)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Challenges: {len(cartas_challenges)}")
            
            # DEBUG: Verificar se as cartas est√£o nos invent√°rios corretos
            print("DEBUG: [show_inventory_matrix] === VERIFICA√á√ÉO DE INVENT√ÅRIOS ===")
            for i, carta in enumerate(cartas_activities[:3]):  # Mostrar primeiras 3 Activities
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Activities[{i}]: {basename}")
                # Verificar se realmente √© uma Activity
                if "activity" not in basename.lower() and "activities" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} N√ÉO parece ser uma Activity! ***")
            
            for i, carta in enumerate(cartas_challenges[:3]):  # Mostrar primeiras 3 Challenges
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Challenges[{i}]: {basename}")
                # Verificar se realmente √© uma Challenge
                if "challenge" not in basename.lower() and "challenges" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} N√ÉO parece ser uma Challenge! ***")
            print("DEBUG: [show_inventory_matrix] === FIM VERIFICA√á√ÉO ===")
            
            # Calcular total de cartas para pagina√ß√£o (2 linhas, 1 carta de cada tipo por linha)
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid para manter estrutura 2x2
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna da esquerda (col=0)
            activities_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                activities_to_show.append((i, cartas_activities[i]))
            
            # Determinar posi√ß√µes das cartas Activities baseado no n√∫mero de cartas a mostrar
            activities_row_counter = 0
            for original_idx, carta_path in activities_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar fun√ß√£o auxiliar para corrigir closure problem
                    def make_click_handler_activities(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_activities(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Activity COLUNA ESQUERDA (col=0): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row_counter, column=0, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Activity colocada na linha {activities_row_counter}, coluna 0 (ESQUERDA)")
                    activities_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Activity: {e}")
                    continue
            
            # Colocar Challenges na coluna da direita (col=1)
            challenges_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                challenges_to_show.append((i, cartas_challenges[i]))
            
            # Determinar posi√ß√µes das cartas Challenges baseado no n√∫mero de cartas a mostrar
            challenges_row_counter = 0
            for original_idx, carta_path in challenges_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar fun√ß√£o auxiliar para corrigir closure problem
                    def make_click_handler_challenges(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_challenges(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Challenge COLUNA DIREITA (col=1): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row_counter, column=1, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Challenge colocado na linha {challenges_row_counter}, coluna 1 (DIREITA)")
                    challenges_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Challenge: {e}")
                    continue
        else:
            # Organiza√ß√£o normal para outros tipos
            cartas = []
            for t in tipos:
                cartas_tipo = self.inventario.get(t, [])
                print(f"DEBUG: [show_inventory_matrix] Cartas de {t}: {len(cartas_tipo)}")
                cartas += cartas_tipo
            
            print(f"DEBUG: [show_inventory_matrix] Total de cartas a mostrar: {len(cartas)}")
            # Pagina√ß√£o igual ao Activities/Challenges
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Igual ao Activities/Challenges
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    # Determinar o tipo da carta para verificar se est√° ativa
                    carta_tipo = None
                    if len(tipos) == 1:
                        carta_tipo = tipos[0]
                    else:
                        # Se s√£o m√∫ltiplos tipos, tentar determinar pelo caminho da carta
                        path_lower = carta_path.lower()
                        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
                            carta_tipo = "users"
                        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
                            carta_tipo = "equipments"
                        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
                            carta_tipo = "services"
                    
                    # Verificar se a carta est√° ativa para Users/Equipments/Services
                    # CORRE√á√ÉO: Sempre verificar estado ativo, independentemente de Next Phase
                    # As cartas que foram ativadas em turnos anteriores devem aparecer viradas para cima
                    is_active = False
                    if carta_tipo in ["users", "equipments", "services"]:
                        is_active = self.is_card_active(carta_path, carta_tipo)
                    
                    # Escolher imagem baseada no estado da carta
                    if carta_tipo in ["users", "equipments", "services"]:
                        # Verificar se √© User_1.png - sempre virada para cima
                        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                        
                        if is_user_1:
                            # User_1.png sempre virada para cima
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] User_1.png SEMPRE virada para cima: {os.path.basename(carta_path)}")
                        elif is_active:
                            # Carta ativa: mostrar virada para cima (independentemente de Next Phase)
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} ATIVA (virada para cima): {os.path.basename(carta_path)}")
                        else:
                            # Carta inativa: mostrar virada para baixo usando imagem espec√≠fica da cor do jogador
                            back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                            img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} INATIVA (virada para baixo com cor {self.player_color}): {os.path.basename(carta_path)}")
                    else:
                        # Para outros tipos (activities, etc), mostrar normalmente
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} normal: {os.path.basename(carta_path)}")
                        
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] ERRO ao processar carta {os.path.basename(carta_path)}: {e}")
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_inventory(p, t, pg))
        # Setas de navega√ß√£o √† direita
        if total_pages > 1:
            seta_x = 0.90
            if page > 0:
                seta_cima = tk.Button(self, text="‚ñ≤", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page-1, back_callback))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="‚ñº", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page+1, back_callback))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((self.screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no invent√°rio")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no invent√°rio: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Bot√£o Back centrado na parte inferior - criado ap√≥s a barra para ficar por cima
        # NOVA FUNCIONALIDADE: Desabilitar bot√£o Back durante ROUTER UPGRADE, ROUTER DOWNGRADE ou LINK UPGRADE
        is_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
        is_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
        is_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
        
        if back_callback:
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_callback)
        else:
            def back_to_dashboard():
                # PROTE√á√ÉO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
                self._inventory_opening = False
                # CORRE√á√ÉO CR√çTICA: Restaurar estado ANTES de recriar interface
                # Isto garante que o estado √© preservado corretamente
                saved_state = getattr(self, '_saved_dashboard_state', None)
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                # Restaurar estado imediatamente ap√≥s recriar interface
                if saved_state:
                    self._saved_dashboard_state = saved_state
                    self._restore_dashboard_state()
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard)
        
        # Desabilitar bot√£o se estivermos em contexto ROUTER UPGRADE, ROUTER DOWNGRADE, LINK UPGRADE ou LINK DOWNGRADE
        if is_router_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_UPGRADE] Bot√£o Back DESABILITADO durante contexto ROUTER UPGRADE")
        elif is_router_downgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Bot√£o Back DESABILITADO durante contexto ROUTER DOWNGRADE")
        elif is_link_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_UPGRADE] Bot√£o Back DESABILITADO durante contexto LINK UPGRADE")
        elif getattr(self, '_in_link_downgrade_context', False):
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_DOWNGRADE] Bot√£o Back DESABILITADO durante contexto LINK DOWNGRADE")
        else:
            back_btn.config(state='normal')
            print(f"DEBUG: [INVENTORY] Bot√£o Back HABILITADO (n√£o em contexto ROUTER/LINK)")
            
        back_btn.place(relx=0.5, rely=0.98, anchor="s")
        
        # Salvar refer√™ncia do bot√£o Back para poder reabilitar posteriormente
        self._back_button = back_btn

        # Saldo no canto inferior direito - criado ap√≥s para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))

    def show_card_fullscreen_inventory(self, carta_path, tipos, page=0):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Bot√£o X para fechar
        def voltar_inventario():
            # Se for invent√°rio de Activities/Challenges, volta para show_inventory_matrix_carrossel
            if set(tipos) == set(["activities", "challenges"]):
                self.show_inventory_matrix_carrossel(tipos, page)
            else:
                self.show_inventory_matrix(tipos, page)
        # Bot√£o X para fechar - movido para canto superior esquerdo
        x_btn = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Se for Users, Equipments, Services, Activities ou Challenges, mostrar bot√£o de venda APENAS se estiver numa casa do tipo correspondente
        # Para Activities/Challenges: podem ser vendidas quando est√°s numa casa Activities
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # Determinar o tipo da carta atual PRIMEIRO
        carta_tipo = None
        if len(tipos) == 1:
            carta_tipo = tipos[0]
        elif set(tipos) == set(["activities", "challenges"]):
            # Se √© uma p√°gina Activities/Challenges, determinar tipo pela carta espec√≠fica
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo = "challenges"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "activities" in carta_dirname:
                    carta_tipo = "activities"
                elif "challenges" in carta_dirname:
                    carta_tipo = "challenges"
        elif set(tipos) == set(["actions", "events"]):
            # Se √© uma p√°gina Actions/Events, determinar tipo pela carta espec√≠fica
            carta_basename = os.path.basename(carta_path).lower()
            if "action" in carta_basename or "actions" in carta_basename:
                carta_tipo = "actions"
            elif "event" in carta_basename or "events" in carta_basename:
                carta_tipo = "events"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "actions" in carta_dirname:
                    carta_tipo = "actions"
                elif "events" in carta_dirname:
                    carta_tipo = "events"
        
        print(f"DEBUG: [FULLSCREEN] Carta tipo determinado: '{carta_tipo}' para carta: {os.path.basename(carta_path)} com tipos: {tipos}")
        
        # IMPORTANTE: Se Next Phase estiver ativo, N√ÉO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: N√ÉO pode vender carta do invent√°rio - Next Phase est√° ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se Final Phase estiver ativo, N√ÉO pode vender nenhuma carta
        elif getattr(self, '_final_phase_active', False):
            print(f"DEBUG: N√ÉO pode vender carta do invent√°rio - Final Phase est√° ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se est√° numa casa START, N√ÉO pode vender nenhuma carta
        elif casa_atual_tipo == "start":
            print(f"DEBUG: N√ÉO pode vender carta do invent√°rio - est√° numa casa START (nenhuma venda permitida)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            print(f"DEBUG: Verificando possibilidade de venda no invent√°rio - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # CORRE√á√ÉO: Verificar se pode vender considerando casas de outros jogadores
            current_other_player_house = getattr(self, 'current_other_player_house', False)
            print(f"DEBUG: current_other_player_house = {current_other_player_house}")
            
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo OU numa casa de outro jogador do mesmo tipo
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities s√≥ podem ser vendidas numa casa Activities, Challenges s√≥ numa casa Challenges
                # Incluindo casas de outros jogadores
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
        
        # NOVA FUNCIONALIDADE: Bot√£o verde ‚úì para equipment no contexto REMOVE ROUTER
        # PRIORIDADE M√ÅXIMA: Este bot√£o deve aparecer ANTES de qualquer outro
        # Condi√ß√µes: estamos no contexto REMOVE ROUTER, carta √© equipment
        if (carta_tipo == "equipments" and 
            getattr(self, '_in_remove_router_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto REMOVE ROUTER detectado: {os.path.basename(carta_path)}")
            
            def processar_remove_router():
                """Remove o router selecionado e volta √† interface principal"""
                print(f"DEBUG: [REMOVE_ROUTER_GO] Processando remo√ß√£o do router: {os.path.basename(carta_path)}")
                
                # Remover carta do invent√°rio
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Router removido do invent√°rio")
                    
                    # Devolver carta ao baralho da Store (se h√° refer√™ncia)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Router devolvido ao baralho da Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Erro ao devolver router √† Store: {e}")
                    
                    # Limpar flag do contexto REMOVE ROUTER
                    self._in_remove_router_context = False
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Flag de contexto REMOVE ROUTER limpa")
                    
                    # Voltar √† interface principal
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Voltando √† interface principal")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_GO] ERRO: Router n√£o encontrado no invent√°rio")
            
            # Bot√£o verde ‚úì no canto superior direito para processar remo√ß√£o
            btn_remove_router = tk.Button(
                self, 
                text="‚úì", 
                font=("Helvetica", 24, "bold"), 
                bg="#4CAF50", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                command=processar_remove_router, 
                cursor="hand2", 
                activebackground="#43d17a"
            )
            btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
            print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì verde configurado para remo√ß√£o do router")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para equipment no contexto ROUTER UPGRADE
        # PRIORIDADE: Este bot√£o deve aparecer ANTES de qualquer outro (exceto REMOVE ROUTER)
        # Condi√ß√µes: estamos no contexto ROUTER UPGRADE, carta √© equipment do tipo Small Router correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se √© o Small Router correto para o router_id da Action
            router_upgrade_target_id = getattr(self, '_router_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Router upgrade target ID: {router_upgrade_target_id}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # MODIFICA√á√ÉO: Para ROUTER UPGRADE, verificar se √© o router correto E est√° ativo (virado para cima)
            # Conforme solicitado pelo usu√°rio: "O bot√£o certo vermelho s√≥ aparece na carta virada para cima"
            is_target_router = (equipment_id == router_upgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] NOVA REGRA: Router upgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # CORRE√á√ÉO SOLICITADA: Apenas mostrar bot√£o se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_UPGRADE] Small Router correto E ATIVO encontrado para upgrade")
                
                # Bot√£o vermelho ‚úì no canto superior direito para processar upgrade
                btn_router_upgrade = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para upgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router n√£o √© o target correto - n√£o mostrando bot√£o")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router correto mas INATIVO (virado para baixo) - n√£o mostrando bot√£o conforme solicitado")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE] Condi√ß√µes n√£o atendidas - n√£o mostrando bot√£o")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para equipment no contexto ROUTER DOWNGRADE
        # Condi√ß√µes: estamos no contexto ROUTER DOWNGRADE, carta √© equipment do tipo Medium Router correspondente e ATIVO
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se √© o Medium Router correto para o router_id da Action
            router_downgrade_target_id = getattr(self, '_router_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade target ID: {router_downgrade_target_id}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Verificar se √© o router correto E est√° ativo (virado para cima)
            is_target_router = (equipment_id == router_downgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # Apenas mostrar bot√£o se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_DOWNGRADE] Medium Router correto E ATIVO encontrado para downgrade")
                
                # Bot√£o vermelho ‚úì no canto superior direito para processar downgrade
                btn_router_downgrade = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_downgrade_confirmation(router_downgrade_target_id), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para downgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router n√£o √© o target correto - n√£o mostrando bot√£o")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router correto mas INATIVO (virado para baixo) - n√£o mostrando bot√£o")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Condi√ß√µes n√£o atendidas - n√£o mostrando bot√£o")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para equipment no contexto LINK UPGRADE
        # Condi√ß√µes: estamos no contexto LINK UPGRADE, carta √© equipment do tipo Long Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se √© o Long Link correto para o router_id da Action
            link_upgrade_target_id = getattr(self, '_link_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Link upgrade target ID: {link_upgrade_target_id}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK UPGRADE, verificar se √© o link correto (Long Link)
            is_target_link = (equipment_id == link_upgrade_target_id)
            
            # Mapear equipment_id para nomes de Long Links
            long_link_mapping = {
                1: "Equipment_10.png",  # Long Link 1
                2: "Equipment_11.png",  # Long Link 2
                3: "Equipment_12.png",  # Long Link 3
            }
            
            expected_long_link = long_link_mapping.get(link_upgrade_target_id)
            is_long_link = (os.path.basename(carta_path) == expected_long_link) if expected_long_link else False
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Expected long link: {expected_long_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is long link: {is_long_link}")
            
            # Apenas mostrar bot√£o se link correto
            if is_target_link and is_long_link:
                print(f"DEBUG: [LINK_UPGRADE] Long Link correto encontrado para upgrade")
                
                # Bot√£o vermelho ‚úì no canto superior direito para processar upgrade
                btn_link_upgrade = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para upgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_UPGRADE] Link n√£o √© o target correto - n√£o mostrando bot√£o")
                elif not is_long_link:
                    print(f"DEBUG: [LINK_UPGRADE] Equipment n√£o √© Long Link - n√£o mostrando bot√£o")
                else:
                    print(f"DEBUG: [LINK_UPGRADE] Condi√ß√µes n√£o atendidas - n√£o mostrando bot√£o")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para equipment no contexto LINK DOWNGRADE
        # Condi√ß√µes: estamos no contexto LINK DOWNGRADE, carta √© equipment do tipo Short Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se √© o Short Link correto para o router_id da Action
            link_downgrade_target_id = getattr(self, '_link_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Link downgrade target ID: {link_downgrade_target_id}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK DOWNGRADE, verificar se √© o link correto (Short Link)
            is_target_link = (equipment_id == link_downgrade_target_id)
            
            # Mapear equipment_id para nomes de Short Links
            short_link_mapping = {
                1: "Equipment_7.png",   # Short Link 1
                2: "Equipment_8.png",   # Short Link 2
                3: "Equipment_9.png",   # Short Link 3
            }
            
            expected_short_link = short_link_mapping.get(link_downgrade_target_id)
            is_short_link = (os.path.basename(carta_path) == expected_short_link) if expected_short_link else False
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Expected short link: {expected_short_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is short link: {is_short_link}")
            
            # Apenas mostrar bot√£o se link correto
            if is_target_link and is_short_link:
                print(f"DEBUG: [LINK_DOWNGRADE] Short Link correto encontrado para downgrade")
                
                # Bot√£o vermelho ‚úì no canto superior direito para processar downgrade
                btn_link_downgrade = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_downgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para downgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Link n√£o √© o target correto - n√£o mostrando bot√£o")
                elif not is_short_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Equipment n√£o √© Short Link - n√£o mostrando bot√£o")
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE] Condi√ß√µes n√£o atendidas - n√£o mostrando bot√£o")
        
        # Bot√£o de venda com checkmark no canto superior direito (substitui o bot√£o verde picoin)
        # APENAS se N√ÉO for uma carta Activities/Challenges, porque essas t√™m layout especial
        # IMPORTANTE: User_1.png nunca pode ser vendida
        # IMPORTANTE: Cartas ATIVAS (Users/Equipments/Services viradas para cima) nunca podem ser vendidas
        # IMPORTANTE: N√ÉO mostrar se j√° estamos no contexto REMOVE ROUTER
        elif (carta_tipo not in ["activities", "challenges"] and 
              not getattr(self, '_in_remove_router_context', False)):
            
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # NOVA VERIFICA√á√ÉO: Cartas ativas n√£o podem ser vendidas
            is_carta_ativa = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_carta_ativa = self.is_card_active(carta_path, carta_tipo)
            
            if pode_vender and not is_user_1 and not is_carta_ativa:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do invent√°rio - est√° numa casa {casa_atual_tipo}")
                def abrir_confirm():
                    # Guardar informa√ß√µes para navega√ß√£o correta
                    self._origem_venda = "inventario"
                    self._tipos_venda = None
                    self._page_venda = 0
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Bot√£o com checkmark (‚úì) no canto superior direito
                btn_sell = tk.Button(self, text="‚úì", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
                btn_sell.place(relx=0.98, rely=0, anchor="ne")
            elif is_user_1:
                print(f"DEBUG: User_1.png N√ÉO pode ser vendida")
            elif is_carta_ativa:
                print(f"DEBUG: Carta {carta_tipo} ATIVA (virada para cima) N√ÉO pode ser vendida - apenas cartas inativas podem ser vendidas")
            elif not pode_vender:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do invent√°rio - casa atual: {casa_atual_tipo}, necess√°rio: activities (para Activities/Challenges) ou {carta_tipo} (para outros tipos)")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para remover Actions ativas ap√≥s Next Phase
        # Condi√ß√µes: Next Phase ativo, antes de Final Phase, carta Action ativa, p√°gina Actions/Events
        # CORRE√á√ÉO PROBLEMA 1: Verificar se a carta n√£o est√° virada para baixo
        print(f"DEBUG: [FULLSCREEN] Verificando condi√ß√µes para bot√£o vermelho ‚úì:")
        print(f"DEBUG: [FULLSCREEN]   carta_tipo: '{carta_tipo}'")
        print(f"DEBUG: [FULLSCREEN]   tipos: {tipos}")
        print(f"DEBUG: [FULLSCREEN]   set(tipos) == set(['actions', 'events']): {set(tipos) == set(['actions', 'events'])}")
        print(f"DEBUG: [FULLSCREEN]   _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # CORRE√á√ÉO PROBLEMA 1: Verificar se a carta est√° virada para baixo
        carta_basename = os.path.basename(carta_path).lower()
        is_carta_virada_para_baixo = carta_basename.startswith("back_card_")
        
        # CORRE√á√ÉO CR√çTICA: Para cartas Actions, verificar tamb√©m a l√≥gica do sistema
        if carta_tipo == "actions" and not is_carta_virada_para_baixo:
            # Verificar se √© a primeira carta Action e se uma Action foi removida recentemente
            cartas_actions = self.inventario.get("actions", [])
            if cartas_actions and carta_path == cartas_actions[0] and getattr(self, '_action_recently_removed', False):
                is_carta_virada_para_baixo = True
                print(f"DEBUG: [FULLSCREEN] Carta Action detectada como virada para baixo pela l√≥gica do sistema (Action removida recentemente)")
        
        print(f"DEBUG: [FULLSCREEN]   is_carta_virada_para_baixo: {is_carta_virada_para_baixo}")
        
        # CORRE√á√ÉO PROBLEMA 1: Durante gest√£o de pacotes, permitir bot√£o vermelho
        # A gest√£o de pacotes acontece quando _final_phase_gestao_ativa √© True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        print(f"DEBUG: [FULLSCREEN]   gestao_pacotes_ativa: {gestao_pacotes_ativa}")
        print(f"DEBUG: [FULLSCREEN]   final_phase_normal: {final_phase_normal}")
        
        # CORRE√á√ÉO PROBLEMA 1: Durante gest√£o de pacotes, permitir bot√£o vermelho
        # A gest√£o de pacotes acontece quando _final_phase_gestao_ativa √© True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        if (carta_tipo == "actions" and 
            set(tipos) == set(["actions", "events"]) and
            getattr(self, '_next_phase_active', False) and 
            not final_phase_normal and  # CORRE√á√ÉO: Permite durante gest√£o de pacotes
            not is_carta_virada_para_baixo):  # CORRE√á√ÉO: N√ÉO mostrar bot√£o se carta est√° virada para baixo
            
            # Verificar se a carta Action est√° realmente ativa usando o m√©todo oficial
            cartas_ativas_actions = self.get_active_cards_for_type("actions")
            is_action_ativa = carta_path in cartas_ativas_actions
            
            if is_action_ativa:
                print(f"DEBUG: [FULLSCREEN] Action ativa detectada ap√≥s Next Phase: {os.path.basename(carta_path)}")
            else:
                print(f"DEBUG: [FULLSCREEN] Action INATIVA no invent√°rio: {os.path.basename(carta_path)}")
            
            if is_action_ativa:
                print(f"DEBUG: [FULLSCREEN] Action ativa detectada ap√≥s Next Phase: {os.path.basename(carta_path)}")
                
                def mostrar_action_info_overlay():
                    """Mostra overlay com informa√ß√µes da carta Action usando estilo similar ao overlay de Event"""
                    import re
                    import os
                    
                    print(f"DEBUG: [ACTION_INFO] Mostrando informa√ß√µes da Action: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Action da base de dados
                    action_title = "Action Information"
                    action_description = "Description not available"
                    action_target_router = "N/A"
                    action_effect = "Effect description not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Action_43" -> "action_43")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Action_(\d+)', filename)
                            
                            if match:
                                action_id = f"action_{match.group(1)}"
                                action_card = self.card_database.get_action(action_id)
                                
                                if action_card:
                                    action_title = action_card.title
                                    action_description = action_card.description
                                    action_effect = action_card.effect_description
                                    # Determinar o target baseado no router_id e tipo de a√ß√£o
                                    if action_card.router_id:
                                        action_target_router = str(action_card.router_id)
                                    elif ActionType and action_card.action_type in [ActionType.ADD_ROUTER, ActionType.REMOVE_ROUTER]:
                                        # Para ADD/REMOVE ROUTER, mostrar texto espec√≠fico
                                        action_target_router = "New Router" if action_card.action_type == ActionType.ADD_ROUTER else "Last router added"
                                    elif action_card.title in ["ADD ROUTER", "REMOVE ROUTER"]:
                                        # Fallback usando o t√≠tulo quando ActionType n√£o est√° dispon√≠vel
                                        action_target_router = "New Router" if action_card.title == "ADD ROUTER" else "Last router added"
                                    else:
                                        action_target_router = "N/A"
                                    
                                    print(f"DEBUG: [ACTION_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [ACTION_INFO]   Title: {action_title}")
                                    print(f"DEBUG: [ACTION_INFO]   Description: {action_description}")
                                    print(f"DEBUG: [ACTION_INFO]   Router ID: {action_target_router}")
                                    print(f"DEBUG: [ACTION_INFO]   Action Type: {action_card.action_type}")
                                    print(f"DEBUG: [ACTION_INFO]   Effect: {action_effect}")
                                else:
                                    print(f"DEBUG: [ACTION_INFO] Action n√£o encontrada na base de dados: {action_id}")
                            else:
                                print(f"DEBUG: [ACTION_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [ACTION_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de Event)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter refer√™ncia
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informa√ß√£o (centro da tela) - usar pack(expand=True) para dimensionamento din√¢mico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # T√≠tulo (valor do campo title da carta Action)
                    print(f"DEBUG: [ACTION_INFO] Criando t√≠tulo com texto: {repr(action_title)}")
                    title_label = tk.Label(info_frame, text=action_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descri√ß√£o da Action (texto branco)
                    print(f"DEBUG: [ACTION_INFO] Criando descri√ß√£o com texto: {repr(action_description)}")
                    desc_label = tk.Label(info_frame, text=action_description, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target: Mostrar informa√ß√£o apropriada dependendo do tipo de Action
                    print(f"DEBUG: [ACTION_INFO] Criando target com router ID: {repr(action_target_router)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    # Determinar texto do target baseado no tipo de router_id
                    if action_target_router in ["New Router", "Any Router", "Last router added"]:
                        target_text = action_target_router
                    else:
                        target_text = f"Residential Router {action_target_router}"
                    
                    target_label_value = tk.Label(target_frame, text=target_text, 
                                                font=("Helvetica", 13, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Effect description (texto roxo)
                    print(f"DEBUG: [ACTION_INFO] Criando efeito com texto: {repr(action_effect)}")
                    effect_label = tk.Label(info_frame, text=action_effect, 
                                         font=("Helvetica", 12, "bold"), fg="#9966CC", bg="black",
                                         wraplength=600, justify="center")
                    effect_label.pack(pady=(0, 30))
                    
                    # Frame para o bot√£o
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def remover_action_do_inventario():
                        """Remove a carta Action do invent√°rio e aplica seus efeitos (ROUTER UPGRADE/DOWNGRADE)"""
                        print(f"DEBUG: [REMOVE_ACTION] Removendo Action do invent√°rio: {os.path.basename(carta_path)}")
                        
                        # NOVA FUNCIONALIDADE: Aplicar efeitos da carta Action antes de remov√™-la
                        try:
                            if self.card_database:
                                # Extrair ID da carta Action
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Action_(\d+)', filename)
                                
                                if match:
                                    action_id = f"action_{match.group(1)}"
                                    action_card = self.card_database.get_action(action_id)
                                    
                                    if action_card:
                                        print(f"DEBUG: [ACTION_EFFECT] Aplicando efeito da Action {action_card.title}")
                                        print(f"DEBUG: [ACTION_EFFECT] Action Type: {action_card.action_type}")
                                        print(f"DEBUG: [ACTION_EFFECT] Router ID: {action_card.router_id}")
                                        
                                        # Aplicar efeitos espec√≠ficos baseados no tipo de Action
                                        if ActionType and action_card.action_type == ActionType.ROUTER_UPGRADE:
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ROUTER_DOWNGRADE:
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_UPGRADE:
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_DOWNGRADE:
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ADD_ROUTER:
                                            self._aplicar_add_router()
                                        elif ActionType and action_card.action_type == ActionType.REMOVE_ROUTER:
                                            self._aplicar_remove_router()
                                        elif action_card.title == "ROUTER UPGRADE":  # Fallback usando t√≠tulo
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif action_card.title == "ROUTER DOWNGRADE":  # Fallback usando t√≠tulo
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif action_card.title == "LINK UPGRADE":  # Fallback usando t√≠tulo
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif action_card.title == "LINK DOWNGRADE":  # Fallback usando t√≠tulo
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif action_card.title == "ADD ROUTER":  # Fallback usando t√≠tulo
                                            self._aplicar_add_router()
                                        elif action_card.title == "REMOVE ROUTER":  # Fallback usando t√≠tulo
                                            self._aplicar_remove_router()
                                        else:
                                            print(f"DEBUG: [ACTION_EFFECT] Action tipo {action_card.action_type} n√£o implementado ainda")
                                    else:
                                        print(f"DEBUG: [ACTION_EFFECT] Action n√£o encontrada na base de dados: {action_id}")
                                else:
                                    print(f"DEBUG: [ACTION_EFFECT] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [ACTION_EFFECT] Erro ao aplicar efeito da Action: {e}")
                        
                        # Remover carta do invent√°rio
                        if "actions" in self.inventario and carta_path in self.inventario["actions"]:
                            self.inventario["actions"].remove(carta_path)
                            print(f"DEBUG: [REMOVE_ACTION] Carta removida do invent√°rio do jogador")
                            
                            # Marcar que uma Action foi removida para a pr√≥xima carta ficar virada para baixo
                            self._action_recently_removed = True
                            print(f"DEBUG: [REMOVE_ACTION] Flag _action_recently_removed definida para True")
                            
                            # NOVA L√ìGICA: Marcar pr√≥ximas Actions como pendentes de ativa√ß√£o
                            self._mark_next_actions_as_pending()
                            
                            # Devolver carta ao baralho da Store (se h√° refer√™ncia)
                            if hasattr(self, 'store_window') and self.store_window:
                                try:
                                    self.store_window.adicionar_carta_ao_baralho(carta_path, "actions", "neutral")
                                    print(f"DEBUG: [REMOVE_ACTION] Carta devolvida ao baralho da Store")
                                except Exception as e:
                                    print(f"DEBUG: [REMOVE_ACTION] Erro ao devolver carta √† Store: {e}")
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se ADD ROUTER abriu p√°gina de sele√ß√£o
                            if getattr(self, '_in_router_selection_page', False):
                                print(f"DEBUG: [REMOVE_ACTION] ADD ROUTER ativo - mantendo p√°gina de sele√ß√£o de routers")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se REMOVE ROUTER abriu p√°gina de invent√°rio de equipments
                            if getattr(self, '_in_remove_router_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] REMOVE ROUTER ativo - mantendo p√°gina de invent√°rio de equipments")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio Actions/Events
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se ROUTER UPGRADE abriu p√°gina de invent√°rio de equipments
                            if getattr(self, '_in_router_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER UPGRADE ativo - mantendo p√°gina de invent√°rio de equipments")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio Actions/Events
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se ROUTER DOWNGRADE abriu p√°gina de invent√°rio de equipments
                            if getattr(self, '_in_router_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER DOWNGRADE ativo - mantendo p√°gina de invent√°rio de equipments")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio Actions/Events
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se LINK UPGRADE abriu p√°gina de invent√°rio de equipments
                            if getattr(self, '_in_link_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK UPGRADE ativo - mantendo p√°gina de invent√°rio de equipments")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio Actions/Events
                            
                            # CORRE√á√ÉO CR√çTICA: N√ÉO voltar ao invent√°rio se LINK DOWNGRADE abriu p√°gina de invent√°rio de equipments
                            if getattr(self, '_in_link_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK DOWNGRADE ativo - mantendo p√°gina de invent√°rio de equipments")
                                return  # Interrompe aqui, n√£o volta ao invent√°rio Actions/Events
                            
                            # Voltar para a p√°gina de invent√°rio Actions/Events
                            print(f"DEBUG: [REMOVE_ACTION] Voltando para invent√°rio Actions/Events")
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir p√°gina de invent√°rio Actions/Events
                            self.show_inventory_matrix(['actions', 'events'], page)
                        else:
                            print(f"DEBUG: [REMOVE_ACTION] ERRO: Carta n√£o encontrada no invent√°rio Actions")
                    
                    # Bot√£o Go! (roxo para remover a action)
                    ok_button = tk.Button(btn_frame, text="Go!", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=remover_action_do_inventario)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [ACTION_INFO] Overlay de informa√ß√µes da Action criado e exibido")
                
                # Bot√£o verde ‚úì no canto superior direito
                btn_remove = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#4CAF50", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_action_info_overlay, 
                    cursor="hand2", 
                    activebackground="#43d17a"
                )
                btn_remove.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì verde configurado para mostrar overlay de informa√ß√µes da Action")
        
        # NOVA FUNCIONALIDADE: Bot√£o vermelho ‚úì para remover Events expirados
        # Condi√ß√µes: carta Event expirada, p√°gina Actions/Events (INDEPENDENTE de Next Phase)
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not final_phase_normal and  # CORRE√á√ÉO: Permite durante gest√£o de pacotes
              not is_carta_virada_para_baixo):  # CORRE√á√ÉO: N√ÉO mostrar bot√£o se carta est√° virada para baixo
            
            # CORRE√á√ÉO CR√çTICA: Verificar se este Event est√° na posi√ß√£o 0 da fila cronol√≥gica
            chronological_order = self._get_chronological_actions_events_order()
            is_event_do_topo = False
            
            # Apenas o primeiro item da fila (posi√ß√£o 0) pode ser considerado "Event do topo"
            if chronological_order and len(chronological_order) > 0:
                first_entry = chronological_order[0]
                is_event_do_topo = (first_entry['type'] == 'events' and first_entry['path'] == carta_path)
                
                # CORRE√á√ÉO CR√çTICA: Event do topo s√≥ √© realmente "do topo" se estiver ATIVO
                # Verificar se Event est√° ativo no tracking (n√£o pode estar pendente)
                if is_event_do_topo:
                    if (hasattr(self, '_event_duration_tracking') and 
                        carta_path in self._event_duration_tracking):
                        event_data = self._event_duration_tracking[carta_path]
                        is_active = event_data.get('is_active', False)
                        is_pending = event_data.get('pending_activation', False)
                        
                        if not is_active or is_pending:
                            print(f"DEBUG: [FULLSCREEN] Event na posi√ß√£o 0 mas INATIVO ou PENDENTE - n√£o √© considerado 'do topo'")
                            print(f"DEBUG: [FULLSCREEN]   is_active: {is_active}, is_pending: {is_pending}")
                            is_event_do_topo = False
                    else:
                        print(f"DEBUG: [FULLSCREEN] Event na posi√ß√£o 0 mas SEM tracking - n√£o √© considerado 'do topo'")
                        is_event_do_topo = False
            
            print(f"DEBUG: [FULLSCREEN] Event {os.path.basename(carta_path)} est√° na posi√ß√£o 0? {is_event_do_topo}")
            
            if is_event_do_topo:
                # Verificar se o Event expirou
                current_turn = getattr(self, '_current_turn', 0)
                is_event_expirado = False
                
                # GARANTIR que o Event do topo est√° ativo
                self._ensure_active_event_tracking()
                
                # CORRE√á√ÉO: Verificar expira√ß√£o apenas se Event est√° ativo
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    
                    event_data = self._event_duration_tracking[carta_path]
                    is_active = event_data.get('is_active', False)
                    start_turn = event_data.get('start_turn')
                    duration_turns = event_data.get('duration_turns')
                    
                    print(f"DEBUG: [FULLSCREEN] Verificando expira√ß√£o Event {os.path.basename(carta_path)}:")
                    print(f"DEBUG: [FULLSCREEN]   √â ativo? {is_active}")
                    print(f"DEBUG: [FULLSCREEN]   Turno atual: {current_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Turno in√≠cio: {start_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Duration: {duration_turns}")
                    
                    # S√≥ verificar expira√ß√£o se Event est√° ativo e tem start_turn v√°lido
                    if is_active and start_turn is not None and duration_turns is not None:
                        # CORRE√á√ÉO: Verificar se √© dura√ß√£o vari√°vel
                        if duration_turns == "variable":
                            print(f"DEBUG: [FULLSCREEN]   Event com dura√ß√£o vari√°vel - ainda n√£o expirou")
                            print(f"DEBUG: [FULLSCREEN]   Aguardando lan√ßamento do dado para determinar dura√ß√£o")
                            is_event_expirado = False
                        else:
                            turns_elapsed = current_turn - start_turn
                            print(f"DEBUG: [FULLSCREEN]   Turnos decorridos: {turns_elapsed}")
                            print(f"DEBUG: [FULLSCREEN]   Expira neste turno? {turns_elapsed >= duration_turns}")
                            
                            # CORRE√á√ÉO: No turno de expira√ß√£o, mostrar bot√£o ‚úì para remo√ß√£o
                            is_event_expirado = (turns_elapsed >= duration_turns)
                    else:
                        print(f"DEBUG: [FULLSCREEN]   Event n√£o est√° ativo - n√£o calcular expira√ß√£o")
                        is_event_expirado = False
                else:
                    # CORRE√á√ÉO: Se n√£o h√° tracking, tentar obter dados da base de dados
                    print(f"DEBUG: [FULLSCREEN] Event sem tracking - verificando base de dados: {os.path.basename(carta_path)}")
                    
                    # Tentar obter duration da base de dados
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            event_id = self._extract_event_id_from_path(carta_path)
                            if event_id:
                                event_data = self.card_database.get_event(event_id)
                                if event_data:
                                    duration_turns = event_data.duration_turns
                                    
                                    # CORRE√á√ÉO: Verificar se √© dura√ß√£o vari√°vel
                                    if duration_turns == "variable":
                                        print(f"DEBUG: [FULLSCREEN] Event com dura√ß√£o vari√°vel da BD - ainda n√£o expirou")
                                        print(f"DEBUG: [FULLSCREEN]   Event com dura√ß√£o 'variable' N√ÉO deve expirar at√© dado ser lan√ßado")
                                        is_event_expirado = False
                                    else:
                                        # CORRE√á√ÉO CR√çTICA: Para Events com dura√ß√£o fixa SEM tracking,
                                        # n√£o assumir que come√ßaram no turno 1. Em vez disso, 
                                        # considerar que N√ÉO devem expirar sem tracking v√°lido
                                        print(f"DEBUG: [FULLSCREEN] Event com dura√ß√£o fixa ({duration_turns}) mas SEM tracking v√°lido")
                                        print(f"DEBUG: [FULLSCREEN]   CORRE√á√ÉO: Events sem tracking N√ÉO devem expirar automaticamente")
                                        print(f"DEBUG: [FULLSCREEN]   Isto evita expira√ß√£o incorreta de Events com dura√ß√£o vari√°vel j√° processados")
                                        is_event_expirado = False
                                        
                                        # DEBUG: Mostrar o que seria a l√≥gica antiga (incorreta)
                                        old_start_turn = 1
                                        old_turns_elapsed = current_turn - old_start_turn
                                        old_would_expire = (old_turns_elapsed >= duration_turns)
                                        print(f"DEBUG: [FULLSCREEN]   L√ìGICA ANTIGA (incorreta): start_turn={old_start_turn}, elapsed={old_turns_elapsed}, would_expire={old_would_expire}")
                                        print(f"DEBUG: [FULLSCREEN]   L√ìGICA NOVA (correta): Event n√£o expira sem tracking v√°lido")
                        except Exception as e:
                            print(f"DEBUG: [FULLSCREEN] Erro ao obter dados do Event da BD: {e}")
                            is_event_expirado = False
                
                if is_event_expirado:
                    print(f"DEBUG: [FULLSCREEN] Event no turno de expira√ß√£o detectado: {os.path.basename(carta_path)}")
                    
                    def mostrar_overlay_expiracao():
                        """Mostra overlay de confirma√ß√£o para Event expirado"""
                        print(f"DEBUG: [OVERLAY_EVENT] Mostrando overlay de expira√ß√£o para: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_event_expirado(carta_path)
                    
                    # Bot√£o vermelho ‚úì no canto superior direito (aparece no turno de expira√ß√£o)
                    btn_remove_event = tk.Button(
                        self, 
                        text="‚úì", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF4444", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_overlay_expiracao, 
                        cursor="hand2", 
                        activebackground="#CC3333"
                    )
                    btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para mostrar overlay de Event que expira neste turno")
                else:
                    print(f"DEBUG: [FULLSCREEN] Event do topo ainda n√£o expirou: {os.path.basename(carta_path)}")
                    
                    # FUNCIONALIDADE: Bot√£o ‚ìò para mostrar informa√ß√µes do Event n√£o expirado
                    def mostrar_info_event():
                        """Mostra overlay com informa√ß√µes do Event ativo usando o estilo do overlay de ativa√ß√£o"""
                        import re
                        import os
                        
                        print(f"DEBUG: [EVENT_INFO] Mostrando informa√ß√µes do Event: {os.path.basename(carta_path)}")
                        
                        # Obter dados da carta Event da base de dados
                        event_title = "Event Information"
                        event_effect = "Effect description not available"
                        event_target = "Target not available"
                        
                        try:
                            if self.card_database:
                                # Extrair ID da carta (ex: "Event_367" -> "event_367")
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Event_(\d+)', filename)
                                
                                if match:
                                    event_id = f"event_{match.group(1)}"
                                    event_card = self.card_database.get_event(event_id)
                                    
                                    if event_card:
                                        event_title = event_card.title
                                        event_effect = event_card.effect_description
                                        # Determinar o target baseado nos campos target_link e target_queue
                                        if event_card.target_link:
                                            event_target = event_card.target_link
                                        elif event_card.target_queue:
                                            event_target = event_card.target_queue
                                        else:
                                            event_target = "Target not specified"
                                        
                                        print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                        print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                        print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                        print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                    else:
                                        print(f"DEBUG: [EVENT_INFO] Event n√£o encontrado na base de dados: {event_id}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                        
                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativa√ß√£o)
                        for widget in self.winfo_children():
                            widget.destroy()
                        
                        # Definir fundo preto para a janela
                        self.config(bg="black")
                        
                        # Carregar a imagem da carta como fundo
                        try:
                            carta_img = Image.open(carta_path)
                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                            
                            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                            carta_photo = ImageTk.PhotoImage(carta_resized)
                            
                            # Label com a imagem da carta como fundo
                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                            carta_label.image = carta_photo  # Manter refer√™ncia
                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                            
                        except Exception as e:
                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                            self.config(bg="black")
                        
                        # Frame para a dialog de informa√ß√£o (centro da tela) - usar pack(expand=True) para dimensionamento din√¢mico
                        info_frame = tk.Frame(self, bg="black")
                        info_frame.pack(expand=True)
                        
                        # T√≠tulo (roxo)
                        print(f"DEBUG: [EVENT_INFO] Criando t√≠tulo com texto: {repr(event_title)}")
                        title_label = tk.Label(info_frame, text=event_title, 
                                font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                                wraplength=650, justify="center")
                        title_label.pack(pady=(40, 20))
                        
                        # Descri√ß√£o do Event
                        print(f"DEBUG: [EVENT_INFO] Criando descri√ß√£o com texto: {repr(event_effect)}")
                        desc_label = tk.Label(info_frame, text=event_effect, 
                                           font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                           wraplength=600, justify="center")
                        desc_label.pack(pady=(0, 20))
                        
                        # Target do Event
                        print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                        target_frame = tk.Frame(info_frame, bg="black")
                        target_frame.pack(pady=(0, 20))
                        
                        target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                     font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                        target_label_prefix.pack(side="left")
                        
                        target_label_value = tk.Label(target_frame, text=event_target, 
                                                    font=("Helvetica", 13, "bold"), fg="white", bg="black")
                        target_label_value.pack(side="left")
                        
                        # Frame para o bot√£o
                        btn_frame = tk.Frame(info_frame, bg="black")
                        btn_frame.pack(pady=30)
                        
                        def fechar_overlay():
                            print(f"DEBUG: [EVENT_INFO] Fechando overlay de informa√ß√µes")
                            # Ir para a p√°gina de invent√°rio Actions/Events
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir p√°gina de invent√°rio Actions/Events
                            self.show_inventory_matrix(['actions', 'events'])
                        
                        # Bot√£o OK (roxo para combinar com o tema do Event)
                        ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                           bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                        ok_button.pack(pady=10)
                        
                        print(f"DEBUG: [EVENT_INFO] Overlay de informa√ß√µes criado e exibido")
                    
                    # Bot√£o i laranja no canto superior direito (apenas quando Event ainda n√£o expirou)
                    btn_info_event = tk.Button(
                        self, 
                        text="i", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF9800", 
                        fg="black", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_info_event, 
                        cursor="hand2", 
                        activebackground="#E68900"
                    )
                    btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Bot√£o i roxo configurado para informa√ß√µes do Event ativo")
                    
                    # NOVA FUNCIONALIDADE: Verificar se Event do topo tem duration_turns vari√°vel
                    # Se sim, mostrar bot√£o "?" para determinar dura√ß√£o com dado
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            import re
                            # Extrair ID da carta Event
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card and event_card.duration_turns == "variable":
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com dura√ß√£o vari√°vel detectado: {os.path.basename(carta_path)}")
                                    
                                    def mostrar_overlay_dado_duration():
                                        """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar dura√ß√£o")
                                        
                                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informa√ß√£o)
                                        for widget in self.winfo_children():
                                            widget.destroy()
                                        
                                        # Definir fundo preto para a janela
                                        self.config(bg="black")
                                        
                                        # Carregar a imagem da carta como fundo (igual ao overlay do bot√£o "i")
                                        try:
                                            carta_img = Image.open(carta_path)
                                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                            
                                            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                            carta_photo = ImageTk.PhotoImage(carta_resized)
                                            
                                            # Label com a imagem da carta como fundo
                                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                            carta_label.image = carta_photo  # Manter refer√™ncia
                                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                            
                                        except Exception as e:
                                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                            self.config(bg="black")
                                        
                                        # Frame central para o overlay (usar pack(expand=True) para dimensionamento din√¢mico)
                                        overlay_frame = tk.Frame(self, bg="black")
                                        overlay_frame.pack(expand=True)
                                        
                                        # T√≠tulo roxo
                                        title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                             font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                        title_label.pack(pady=(40, 30))
                                        
                                        # Dado (inicialmente em branco)
                                        blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                        dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                        dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                        dice_label.image = dice_img
                                        dice_label.pack(pady=20)
                                        
                                        # Bot√£o Go!
                                        go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                            bg="#005c75", fg="white", width=8)
                                        go_button.pack(pady=20)
                                        
                                        def iniciar_animacao_dado():
                                            """Inicia a anima√ß√£o do dado e define a dura√ß√£o"""
                                            print(f"DEBUG: [VARIABLE_DURATION] Iniciando anima√ß√£o do dado")
                                            
                                            # Esconder bot√£o Go!
                                            go_button.pack_forget()
                                            
                                            # Anima√ß√£o do dado (25 frames + resultado final)
                                            frames = 25
                                            results = [random.randint(1, 6) for _ in range(frames)]
                                            final_result = random.randint(1, 6)
                                            results.append(final_result)
                                            
                                            def animar_frame(frame_index=0):
                                                if frame_index < len(results):
                                                    n = results[frame_index]
                                                    dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                    
                                                    try:
                                                        new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                        dice_label.config(image=new_dice_img)
                                                        dice_label.image = new_dice_img
                                                    except Exception as e:
                                                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                    
                                                    # Pr√≥ximo frame ap√≥s 100ms
                                                    overlay_frame.after(100, animar_frame, frame_index + 1)
                                                else:
                                                    # Anima√ß√£o terminou - aplicar resultado
                                                    print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                    
                                                    # Atualizar duration_turns na base de dados (temporariamente na inst√¢ncia)
                                                    if event_card:
                                                        event_card.duration_turns = final_result
                                                        print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                    
                                                    # Atualizar tracking de dura√ß√£o se Event j√° est√° ativo
                                                    if (hasattr(self, '_event_duration_tracking') and 
                                                        carta_path in self._event_duration_tracking):
                                                        # CORRE√á√ÉO CR√çTICA: PRESERVAR start_turn original - apenas atualizar duration e expires_turn
                                                        # O start_turn deve permanecer como o turno quando o Event foi realmente ativado
                                                        existing_tracking = self._event_duration_tracking[carta_path]
                                                        start_turn_original = existing_tracking.get('start_turn')
                                                        
                                                        # CORRE√á√ÉO: Se start_turn for None, usar turno atual
                                                        if start_turn_original is None:
                                                            turno_atual = max(
                                                                getattr(self, '_current_turn', 0),
                                                                getattr(self, '_current_turn_number', 0),
                                                                getattr(self, '_current_turn_id', 0)
                                                            )
                                                            start_turn_original = turno_atual
                                                            self._event_duration_tracking[carta_path]['start_turn'] = start_turn_original
                                                            print(f"DEBUG: [VARIABLE_DURATION] start_turn era None, definido para turno atual: {start_turn_original}")
                                                        
                                                        # S√≥ atualizar duration_turns e expires_turn baseado no start_turn ORIGINAL
                                                        self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                        # N√ÉO atualizar start_turn - manter o original!
                                                        # self._event_duration_tracking[carta_path]['start_turn'] = turno_atual  # REMOVIDO!
                                                        self._event_duration_tracking[carta_path]['expires_turn'] = start_turn_original + final_result
                                                        
                                                        print(f"DEBUG: [VARIABLE_DURATION] Tracking de dura√ß√£o atualizado:")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {start_turn_original} (PRESERVADO - turno original quando Event foi ativado)")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {start_turn_original + final_result}")
                                                    else:
                                                        # CORRE√á√ÉO: Se n√£o h√° tracking, criar agora com turno atual
                                                        turno_atual = max(
                                                            getattr(self, '_current_turn', 0),
                                                            getattr(self, '_current_turn_number', 0),
                                                            getattr(self, '_current_turn_id', 0)
                                                        )
                                                        
                                                        if not hasattr(self, '_event_duration_tracking'):
                                                            self._event_duration_tracking = {}
                                                        
                                                        self._event_duration_tracking[carta_path] = {
                                                            'start_turn': turno_atual,
                                                            'duration_turns': final_result,
                                                            'expires_turn': turno_atual + final_result,
                                                            'is_active': True
                                                        }
                                                        
                                                        print(f"DEBUG: [VARIABLE_DURATION] Tracking criado para Event de dura√ß√£o vari√°vel:")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {turno_atual} (turno atual - quando dado foi lan√ßado)")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {turno_atual + final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   is_active: True")
                                                    
                                                    # Aguardar 2 segundos antes de fechar
                                                    def fechar_overlay():
                                                        print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay ap√≥s definir dura√ß√£o")
                                                        # Voltar para invent√°rio Actions/Events
                                                        for widget in self.winfo_children():
                                                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                                continue
                                                            widget.destroy()
                                                        self.show_inventory_matrix(['actions', 'events'], page)
                                                    
                                                    overlay_frame.after(2000, fechar_overlay)
                                            
                                            animar_frame()
                                        
                                        go_button.config(command=iniciar_animacao_dado)
                                    
                                    # Bot√£o "?" na mesma posi√ß√£o do bot√£o Player dos Challenges
                                    # (canto inferior direito)
                                    btn_variable_duration = tk.Button(
                                        self, 
                                        text="?", 
                                        font=("Helvetica", 24, "bold"), 
                                        bg="#9966CC", 
                                        fg="white", 
                                        width=2, 
                                        height=1, 
                                        borderwidth=0, 
                                        highlightthickness=0, 
                                        command=mostrar_overlay_dado_duration, 
                                        cursor="hand2", 
                                        activebackground="#7744AA"
                                    )
                                    btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                    print(f"DEBUG: [VARIABLE_DURATION] Bot√£o ? roxo criado para Event do topo com dura√ß√£o vari√°vel")
                                else:
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com dura√ß√£o fixa: {event_card.duration_turns if event_card else 'N/A'}")
                        except Exception as e:
                            print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar dura√ß√£o vari√°vel do Event do topo: {e}")
            else:
                print(f"DEBUG: [FULLSCREEN] Event n√£o √© do topo da lista - bot√£o n√£o mostrado")
        
        # NOVA FUNCIONALIDADE: Para Events n√£o expirados em qualquer posi√ß√£o (n√£o s√≥ do topo)
        # Bot√£o ‚ìò para mostrar informa√ß√µes do Event
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not is_carta_virada_para_baixo):
            
            print(f"DEBUG: [FULLSCREEN] Verificando Event n√£o-do-topo para bot√£o ‚ìò: {os.path.basename(carta_path)}")
            
            # Verificar se o Event ainda est√° ativo (n√£o expirado)
            current_turn = getattr(self, '_current_turn', 0)
            is_event_ativo = True  # Por padr√£o, assume que est√° ativo
            
            if (hasattr(self, '_event_duration_tracking') and 
                carta_path in self._event_duration_tracking):
                
                event_data = self._event_duration_tracking[carta_path]
                start_turn = event_data['start_turn']
                duration_turns = event_data['duration_turns']
                turns_elapsed = current_turn - start_turn
                is_event_ativo = (turns_elapsed < duration_turns)
                
                print(f"DEBUG: [FULLSCREEN] Event tracking - Ativo? {is_event_ativo} (turnos: {turns_elapsed}/{duration_turns})")
            
            if is_event_ativo:
                print(f"DEBUG: [FULLSCREEN] Event ativo detectado - criando bot√£o ?")
                
                def mostrar_info_event_geral():
                    """Mostra overlay com informa√ß√µes do Event ativo usando o estilo do overlay de ativa√ß√£o"""
                    import re
                    import os
                    
                    print(f"DEBUG: [EVENT_INFO] Mostrando informa√ß√µes do Event: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Event da base de dados
                    event_title = "Event Information"
                    event_effect = "Effect description not available"
                    event_target = "Target not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Event_367" -> "event_367")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card:
                                    event_title = event_card.title
                                    event_effect = event_card.effect_description
                                    # Determinar o target baseado nos campos target_link e target_queue
                                    if event_card.target_link:
                                        event_target = event_card.target_link
                                    elif event_card.target_queue:
                                        event_target = event_card.target_queue
                                    else:
                                        event_target = "Target not specified"
                                    
                                    print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                    print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                    print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Event n√£o encontrado na base de dados: {event_id}")
                            else:
                                print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativa√ß√£o)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter refer√™ncia
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informa√ß√£o (centro da tela) - usar pack(expand=True) para dimensionamento din√¢mico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # T√≠tulo (roxo)
                    print(f"DEBUG: [EVENT_INFO] Criando t√≠tulo com texto: {repr(event_title)}")
                    title_label = tk.Label(info_frame, text=event_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descri√ß√£o do Event
                    print(f"DEBUG: [EVENT_INFO] Criando descri√ß√£o com texto: {repr(event_effect)}")
                    desc_label = tk.Label(info_frame, text=event_effect, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target do Event
                    print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 14, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    target_label_value = tk.Label(target_frame, text=event_target, 
                                                font=("Helvetica", 14, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Frame para o bot√£o
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def fechar_overlay():
                        print(f"DEBUG: [EVENT_INFO] Fechando overlay de informa√ß√µes")
                        # Ir para a p√°gina de invent√°rio Actions/Events
                        # Limpa tudo menos a barra superior
                        for widget in self.winfo_children():
                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                continue
                            widget.destroy()
                        # Abrir p√°gina de invent√°rio Actions/Events
                        self.show_inventory_matrix(['actions', 'events'])
                    
                    # Bot√£o OK (roxo para combinar com o tema do Event)
                    ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [EVENT_INFO] Overlay de informa√ß√µes criado e exibido")
                
                # Bot√£o i laranja no canto superior direito (Events n√£o do topo da lista)
                btn_info_event = tk.Button(
                    self, 
                    text="i", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF9800", 
                    fg="black", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_info_event_geral, 
                    cursor="hand2", 
                    activebackground="#E68900"
                )
                btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o i roxo configurado para informa√ß√µes do Event ativo")
                
                # NOVA FUNCIONALIDADE: Verificar se Event tem duration_turns vari√°vel
                # Se sim, mostrar bot√£o "?" para determinar dura√ß√£o com dado
                if hasattr(self, 'card_database') and self.card_database:
                    try:
                        import re
                        # Extrair ID da carta Event
                        filename = os.path.basename(carta_path)
                        match = re.match(r'Event_(\d+)', filename)
                        
                        if match:
                            event_id = f"event_{match.group(1)}"
                            event_card = self.card_database.get_event(event_id)
                            
                            if event_card and event_card.duration_turns == "variable":
                                print(f"DEBUG: [VARIABLE_DURATION] Event com dura√ß√£o vari√°vel detectado: {os.path.basename(carta_path)}")
                                
                                def mostrar_overlay_dado_duration():
                                    """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                    print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar dura√ß√£o")
                                    
                                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informa√ß√£o)
                                    for widget in self.winfo_children():
                                        widget.destroy()
                                    
                                    # Definir fundo preto para a janela
                                    self.config(bg="black")
                                    
                                    # Carregar a imagem da carta como fundo (igual ao overlay do bot√£o "i")
                                    try:
                                        carta_img = Image.open(carta_path)
                                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                        
                                        # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                        carta_photo = ImageTk.PhotoImage(carta_resized)
                                        
                                        # Label com a imagem da carta como fundo
                                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                        carta_label.image = carta_photo  # Manter refer√™ncia
                                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                        
                                    except Exception as e:
                                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                        self.config(bg="black")
                                    
                                    # Frame central para o overlay (usar pack(expand=True) para dimensionamento din√¢mico)
                                    overlay_frame = tk.Frame(self, bg="black")
                                    overlay_frame.pack(expand=True)
                                    
                                    # T√≠tulo roxo
                                    title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                         font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                    title_label.pack(pady=(40, 30))
                                    
                                    # Dado (inicialmente em branco)
                                    blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                    dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                    dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                    dice_label.image = dice_img
                                    dice_label.pack(pady=20)
                                    
                                    # Bot√£o Go!
                                    go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                        bg="#005c75", fg="white", width=8)
                                    go_button.pack(pady=20)
                                    
                                    def iniciar_animacao_dado():
                                        """Inicia a anima√ß√£o do dado e define a dura√ß√£o"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando anima√ß√£o do dado")
                                        
                                        # Esconder bot√£o Go!
                                        go_button.pack_forget()
                                        
                                        # Anima√ß√£o do dado (25 frames + resultado final)
                                        frames = 25
                                        results = [random.randint(1, 6) for _ in range(frames)]
                                        final_result = random.randint(1, 6)
                                        results.append(final_result)
                                        
                                        def animar_frame(frame_index=0):
                                            if frame_index < len(results):
                                                n = results[frame_index]
                                                dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                
                                                try:
                                                    new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                    dice_label.config(image=new_dice_img)
                                                    dice_label.image = new_dice_img
                                                except Exception as e:
                                                    print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                
                                                # Pr√≥ximo frame ap√≥s 100ms
                                                overlay_frame.after(100, animar_frame, frame_index + 1)
                                            else:
                                                # Anima√ß√£o terminou - aplicar resultado
                                                print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                
                                                # Atualizar duration_turns na base de dados (temporariamente na inst√¢ncia)
                                                if event_card:
                                                    event_card.duration_turns = final_result
                                                    print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                
                                                # Atualizar tracking de dura√ß√£o se Event j√° est√° ativo
                                                if (hasattr(self, '_event_duration_tracking') and 
                                                    carta_path in self._event_duration_tracking):
                                                    # CORRE√á√ÉO CR√çTICA: PRESERVAR start_turn original - apenas atualizar duration e expires_turn
                                                    # O start_turn deve permanecer como o turno quando o Event foi realmente ativado
                                                    existing_tracking = self._event_duration_tracking[carta_path]
                                                    start_turn_original = existing_tracking.get('start_turn')
                                                    
                                                    # CORRE√á√ÉO: Se start_turn for None, usar turno atual
                                                    if start_turn_original is None:
                                                        turno_atual = max(
                                                            getattr(self, '_current_turn', 0),
                                                            getattr(self, '_current_turn_number', 0),
                                                            getattr(self, '_current_turn_id', 0)
                                                        )
                                                        start_turn_original = turno_atual
                                                        self._event_duration_tracking[carta_path]['start_turn'] = start_turn_original
                                                        print(f"DEBUG: [VARIABLE_DURATION] start_turn era None, definido para turno atual: {start_turn_original}")
                                                    
                                                    # S√≥ atualizar duration_turns e expires_turn baseado no start_turn ORIGINAL
                                                    self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                    # N√ÉO atualizar start_turn - manter o original!
                                                    # self._event_duration_tracking[carta_path]['start_turn'] = turno_atual  # REMOVIDO!
                                                    self._event_duration_tracking[carta_path]['expires_turn'] = start_turn_original + final_result
                                                    
                                                    print(f"DEBUG: [VARIABLE_DURATION] Tracking de dura√ß√£o atualizado:")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {start_turn_original} (PRESERVADO - turno original quando Event foi ativado)")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {start_turn_original + final_result}")
                                                else:
                                                    # CORRE√á√ÉO: Se n√£o h√° tracking, criar agora com turno atual
                                                    turno_atual = max(
                                                        getattr(self, '_current_turn', 0),
                                                        getattr(self, '_current_turn_number', 0),
                                                        getattr(self, '_current_turn_id', 0)
                                                    )
                                                    
                                                    if not hasattr(self, '_event_duration_tracking'):
                                                        self._event_duration_tracking = {}
                                                    
                                                    self._event_duration_tracking[carta_path] = {
                                                        'start_turn': turno_atual,
                                                        'duration_turns': final_result,
                                                        'expires_turn': turno_atual + final_result,
                                                        'is_active': True
                                                    }
                                                    
                                                    print(f"DEBUG: [VARIABLE_DURATION] Tracking criado para Event de dura√ß√£o vari√°vel:")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {turno_atual} (turno atual - quando dado foi lan√ßado)")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {turno_atual + final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   is_active: True")
                                                
                                                # Aguardar 2 segundos antes de fechar
                                                def fechar_overlay():
                                                    print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay ap√≥s definir dura√ß√£o")
                                                    # Voltar para invent√°rio Actions/Events
                                                    for widget in self.winfo_children():
                                                        if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                            continue
                                                        widget.destroy()
                                                    self.show_inventory_matrix(['actions', 'events'], page)
                                                
                                                overlay_frame.after(2000, fechar_overlay)
                                        
                                        animar_frame()
                                    
                                    go_button.config(command=iniciar_animacao_dado)
                                
                                # Bot√£o "?" na mesma posi√ß√£o do bot√£o Player dos Challenges
                                # (canto inferior direito)
                                btn_variable_duration = tk.Button(
                                    self, 
                                    text="?", 
                                    font=("Helvetica", 24, "bold"), 
                                    bg="#9966CC", 
                                    fg="white", 
                                    width=2, 
                                    height=1, 
                                    borderwidth=0, 
                                    highlightthickness=0, 
                                    command=mostrar_overlay_dado_duration, 
                                    cursor="hand2", 
                                    activebackground="#7744AA"
                                )
                                btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                print(f"DEBUG: [VARIABLE_DURATION] Bot√£o ? roxo criado para Event com dura√ß√£o vari√°vel")
                            else:
                                print(f"DEBUG: [VARIABLE_DURATION] Event com dura√ß√£o fixa: {event_card.duration_turns if event_card else 'N/A'}")
                    except Exception as e:
                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar dura√ß√£o vari√°vel: {e}")
            else:
                # Event expirado - mostrar bot√£o ‚úì vermelho para remo√ß√£o
                print(f"DEBUG: [FULLSCREEN] Event expirado detectado - criando bot√£o ‚úì vermelho")
                
                def remover_event_expirado():
                    """Remove a carta Event expirada do invent√°rio e retorna para o baralho da Store"""
                    print(f"DEBUG: [REMOVE_EVENT] Removendo Event expirado do invent√°rio: {os.path.basename(carta_path)}")
                    
                    # Remover carta do invent√°rio
                    if "events" in self.inventario and carta_path in self.inventario["events"]:
                        self.inventario["events"].remove(carta_path)
                        print(f"DEBUG: [REMOVE_EVENT] Carta removida do invent√°rio do jogador")
                        
                        # Remover do tracking de dura√ß√£o
                        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
                            del self._event_duration_tracking[carta_path]
                            print(f"DEBUG: [REMOVE_EVENT] Event removido do tracking de dura√ß√£o")
                        
                        # Devolver carta ao baralho da Store (se h√° refer√™ncia)
                        if hasattr(self, 'store_window') and self.store_window:
                            try:
                                self.store_window.adicionar_carta_ao_baralho(carta_path, "events", "neutral")
                                print(f"DEBUG: [REMOVE_EVENT] Carta devolvida ao baralho da Store")
                            except Exception as e:
                                print(f"DEBUG: [REMOVE_EVENT] Erro ao devolver carta √† Store: {e}")
                        
                        # Voltar para a p√°gina de invent√°rio Actions/Events
                        print(f"DEBUG: [REMOVE_EVENT] Voltando para invent√°rio Actions/Events")
                        # Obter a p√°gina atual se dispon√≠vel
                        current_page = getattr(self, '_current_inventory_page', 0)
                        self.show_inventory_matrix(["actions", "events"], current_page)
                    else:
                        print(f"DEBUG: [REMOVE_EVENT] ERRO: Carta n√£o encontrada no invent√°rio Events")
                
                # Bot√£o vermelho ‚úì no canto superior direito (aparece quando Event est√° expirado)
                btn_remove_event = tk.Button(
                    self, 
                    text="‚úì", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF4444", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=remover_event_expirado, 
                    cursor="hand2", 
                    activebackground="#CC3333"
                )
                btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úì vermelho configurado para remo√ß√£o de Event expirado")
        else:
            # Debug para quando o bot√£o vermelho n√£o √© criado
            if carta_tipo == "actions":
                print(f"DEBUG: [FULLSCREEN] Bot√£o vermelho ‚úì N√ÉO criado para Actions:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                if gestao_pacotes_ativa:
                    print(f"DEBUG: [FULLSCREEN]   Durante gest√£o de pacotes - bot√£o DEVERIA aparecer!")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Fora da gest√£o de pacotes - verificar outras condi√ß√µes")
            elif carta_tipo == "events":
                print(f"DEBUG: [FULLSCREEN] Bot√£o vermelho ‚úì N√ÉO criado para Events:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                
                # CORRE√á√ÉO: Verificar se √© Event do topo usando ordem cronol√≥gica
                chronological_order = self._get_chronological_actions_events_order()
                is_event_do_topo_debug = False
                # CR√çTICO: Apenas o primeiro item da fila (posi√ß√£o 0) pode ser "Event do topo"
                if chronological_order and len(chronological_order) > 0:
                    first_entry = chronological_order[0]
                    is_event_do_topo_debug = (first_entry['type'] == 'events' and first_entry['path'] == carta_path)
                print(f"DEBUG: [FULLSCREEN]   √â Event do topo cronol√≥gico? {is_event_do_topo_debug}")
                
                # Verificar detalhes da expira√ß√£o
                current_turn = getattr(self, '_current_turn', 0)
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    event_data = self._event_duration_tracking[carta_path]
                    start_turn = event_data['start_turn']
                    duration_turns = event_data['duration_turns']
                    turns_elapsed = current_turn - start_turn
                    is_expired = (turns_elapsed >= duration_turns)
                    print(f"DEBUG: [FULLSCREEN]   Event tracking encontrado - Expirado? {is_expired} (turnos: {turns_elapsed}/{duration_turns})")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Event n√£o encontrado no tracking de dura√ß√£o")
        
        # Para Activities e Challenges, layout especial com bot√µes espec√≠ficos
        # IMPORTANTE: Limpar qualquer estado de venda anterior para garantir comportamento correto
        self._origem_venda = None
        self._tipos_venda = None
        self._page_venda = None
        self._current_sell_page = None
        self._inventario_conjunto = None
        
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [FULLSCREEN] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            print(f"DEBUG: [FULLSCREEN] Casa atual: {getattr(self, 'current_casa_tipo', 'neutral')}")
            print(f"DEBUG: [FULLSCREEN] Next Phase ativo: {getattr(self, '_next_phase_active', False)}")
            
            # Para Activities: bot√£o ‚úî abre p√°gina de confirma√ß√£o de venda (se pode vender)
            # Para Challenges: bot√£o ‚úî aceita para carrossel (comportamento original)
            if carta_tipo == "activities" and pode_vender:
                # Bot√£o ‚úî canto superior direito (para venda)
                btn_certo = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_certo.place(relx=0.98, rely=0, anchor="ne")
                
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informa√ß√µes para navega√ß√£o correta
                    self._origem_venda = "inventario"
                    # Se viemos de um invent√°rio Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._tipos_venda = ["activities", "challenges"]
                        self._inventario_conjunto = True
                        print(f"DEBUG: Guardando contexto invent√°rio conjunto Activities/Challenges")
                    else:
                        self._tipos_venda = None
                        self._inventario_conjunto = False
                        print(f"DEBUG: Guardando contexto invent√°rio individual: {carta_tipo}")
                    # Guardar a p√°gina atual baseada no par√¢metro da fun√ß√£o
                    self._page_venda = page
                    self._current_sell_page = page
                    print(f"DEBUG: Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                btn_certo.config(command=abrir_confirm_activities)
                print(f"DEBUG: [FULLSCREEN] Bot√£o ‚úî configurado para venda de Activities")
            
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                # POSICIONAMENTO ESPEC√çFICO DOS BOT√ïES:
                # - Activities: Switch no canto superior direito
                # - Challenges: Switch no canto inferior direito, Quit no canto superior direito
                
                # BOT√ÉO SWITCH PARA CARROSSEL
                btn_switch_carrossel = None
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [FULLSCREEN] VERIFICA√á√ÉO SWITCH CARROSSEL ({carta_tipo}):")
                print(f"DEBUG: [FULLSCREEN]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [FULLSCREEN]   has_valid_positions: {has_valid_positions}")
                print(f"DEBUG: [FULLSCREEN]   pode_vender: {pode_vender}")
                
                # NOVA VERIFICA√á√ÉO: Para Activities, verificar se h√° Challenges no invent√°rio (restri√ß√£o Activity‚ÜîActivity)
                pode_fazer_troca_activity = True
                if carta_tipo == "activities":
                    challenges_no_inventario = len(self.inventario.get('challenges', []))
                    print(f"DEBUG: [FULLSCREEN] Verificando restri√ß√£o Activity‚ÜîActivity - Challenges no invent√°rio: {challenges_no_inventario}")
                    if challenges_no_inventario > 0:
                        pode_fazer_troca_activity = False
                        print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - Restri√ß√£o Activity‚ÜîActivity ativa (Challenges no invent√°rio)")
                
                if next_phase_active and has_valid_positions and pode_fazer_troca_activity:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_carrossel.image = switch_img  # Manter refer√™ncia
                            
                            # POSICIONAMENTO ESPEC√çFICO POR TIPO:
                            if carta_tipo == "activities":
                                # Activities: Switch no canto superior direito
                                btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                                print(f"DEBUG: [FULLSCREEN] SUCCESS: Bot√£o Switch Activity posicionado no canto superior direito")
                            else:  # carta_tipo == "challenges"
                                # Challenges: Switch no canto inferior direito (m√°ximo canto poss√≠vel)
                                btn_switch_carrossel.place(relx=1.0, rely=1.0, anchor="se")
                                print(f"DEBUG: [FULLSCREEN] SUCCESS: Bot√£o Switch Challenge posicionado no canto inferior direito (m√°ximo canto)")
                            
                            print(f"DEBUG: [FULLSCREEN] SUCCESS: Bot√£o Switch carrossel CRIADO - Next Phase ativo + posi√ß√µes v√°lidas + sem restri√ß√£o Activity‚ÜîActivity")
                        else:
                            print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - imagem n√£o encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_carrossel = None
                        print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - erro ao carregar imagem: {e}")
                else:
                    if not next_phase_active:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - Next Phase N√ÉO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - SEM posi√ß√µes v√°lidas no carrossel")
                    elif carta_tipo == "activities" and not pode_fazer_troca_activity:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Bot√£o Switch carrossel N√ÉO criado - Restri√ß√£o Activity‚ÜîActivity (Challenges no invent√°rio)")
                
                # Configurar comando do bot√£o Switch
                def aceitar_carta():
                    # NOVA L√ìGICA: S√≥ mostrar overlay se vai SUBSTITUIR uma carta (n√£o quando vai colocar numa posi√ß√£o vazia)
                    print("DEBUG: [FULLSCREEN] Verificando se vai substituir carta existente ou colocar em posi√ß√£o vazia")
                    
                    # Obter a posi√ß√£o de destino mais prov√°vel (primeira posi√ß√£o vazia ou acess√≠vel)
                    posicao_destino = None
                    carta_na_posicao_destino = None
                    
                    if hasattr(self, 'carrossel_idx_selecao') and self.carrossel_idx_selecao is not None:
                        # Se h√° uma posi√ß√£o espec√≠fica selecionada, usar essa
                        posicao_destino = self.carrossel_idx_selecao
                    else:
                        # Encontrar a primeira posi√ß√£o acess√≠vel (vazia ou n√£o)
                        if hasattr(self, 'cards'):
                            for i, carta_carrossel in enumerate(self.cards):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                    
                    # Verificar se h√° uma carta real na posi√ß√£o de destino
                    vai_substituir_carta = False
                    if posicao_destino is not None and hasattr(self, 'cards') and posicao_destino < len(self.cards):
                        carta_na_posicao_destino = self.cards[posicao_destino]
                        # Se n√£o √© back_card, significa que h√° uma carta real para substituir
                        if not os.path.basename(carta_na_posicao_destino).startswith("back_card_"):
                            vai_substituir_carta = True
                            print(f"DEBUG: [FULLSCREEN] Vai SUBSTITUIR carta existente na posi√ß√£o {posicao_destino}: {os.path.basename(carta_na_posicao_destino)}")
                        else:
                            print(f"DEBUG: [FULLSCREEN] Vai COLOCAR em posi√ß√£o VAZIA {posicao_destino}")
                    
                    if vai_substituir_carta:
                        print("DEBUG: [FULLSCREEN] Substitui√ß√£o detectada - mostrando overlay de confirma√ß√£o")
                        self._mostrar_overlay_confirmacao_troca(carta_path, [carta_tipo], 0)
                    else:
                        print("DEBUG: [FULLSCREEN] Coloca√ß√£o em posi√ß√£o vazia - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, [carta_tipo], 0)
                
                if btn_switch_carrossel is not None:
                    btn_switch_carrossel.config(command=aceitar_carta)
                    print(f"DEBUG: [FULLSCREEN] Bot√£o Switch configurado para aceitar {carta_tipo} no carrossel")
                
                # BOT√ÉO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase)
                if carta_tipo == "challenges" and not next_phase_active:
                    print(f"DEBUG: [FULLSCREEN] Criando bot√£o Quit Challenge no canto superior direito")
                    
                    # Bot√£o vermelho com s√≠mbolo de check (‚úì) para quit challenge
                    btn_quit_challenge = tk.Button(
                        self, 
                        text="‚úì", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#DC143C", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        cursor="hand2", 
                        activebackground="#B22222"
                    )
                    # Challenge: Quit no canto superior direito
                    btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
                    
                    # Comando do bot√£o quit
                    def mostrar_confirmacao_quit():
                        print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirma√ß√£o de quit para carta: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_quit_challenge(carta_path)
                    
                    btn_quit_challenge.config(command=mostrar_confirmacao_quit)
                    print(f"DEBUG: [FULLSCREEN] SUCCESS: Bot√£o Quit Challenge criado no canto superior direito")
        
        # Para Users, Equipments e Services, adicionar bot√£o de ativa√ß√£o/desativa√ß√£o
        # IMPORTANTE: APENAS ap√≥s Next Phase ser ativado
        elif carta_tipo in ["users", "equipments", "services"]:
            # Verificar se √© User_1.png - tratamento especial
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            if is_user_1:
                # Para User_1.png, n√£o criar nenhum bot√£o adicional al√©m do X
                pass
            else:
                # NOVA FUNCIONALIDADE: Bot√£o vermelho especial para REMOVE ROUTER context
                # Deve aparecer quando estamos no contexto REMOVE ROUTER e a carta est√° ativa
                if (carta_tipo == "equipments" and 
                    getattr(self, '_in_remove_router_context', False) and
                    self.is_card_active(carta_path, carta_tipo)):
                    
                    print(f"DEBUG: [REMOVE_ROUTER] Carta Equipment ativa detectada no contexto REMOVE ROUTER: {os.path.basename(carta_path)}")
                    
                    # Verificar se √© um router ou um link com mesmo ID
                    is_link = self._is_link_card(carta_path)
                    is_removing_links = getattr(self, '_removing_associated_links', False)
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    
                    if is_link and is_removing_links:
                        # Verificar se o link tem o mesmo specific_id do router que foi removido
                        link_id = self._get_equipment_specific_id(carta_path)
                        if str(link_id) == str(router_id_being_removed):
                            print(f"DEBUG: [REMOVE_ROUTER] Link com ID {link_id} corresponde ao router removido {router_id_being_removed}")
                            
                            # Bot√£o vermelho ‚úî para remo√ß√£o do link
                            btn_remove_link = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def remover_link():
                                self.show_remove_link_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_remove_link.config(command=remover_link)
                            btn_remove_link.place(relx=0.98, rely=0, anchor="ne")
                            print(f"DEBUG: [REMOVE_ROUTER] Bot√£o ‚úî vermelho configurado para remo√ß√£o do link")
                        else:
                            print(f"DEBUG: [REMOVE_ROUTER] Link ID {link_id} n√£o corresponde ao router removido {router_id_being_removed}")
                    elif not is_link and not is_removing_links:
                        # Router normal - usar confirma√ß√£o de router
                        btn_remove_router = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                        def remover_router():
                            self.show_remove_router_confirmation(carta_path, carta_tipo, tipos, page)
                        btn_remove_router.config(command=remover_router)
                        btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [REMOVE_ROUTER] Bot√£o ‚úî vermelho configurado para remo√ß√£o do router")
                    
                else:
                    # CORRE√á√ÉO: Bot√µes de ativa√ß√£o/desativa√ß√£o s√≥ aparecem DEPOIS de Next Phase ser ativado
                    # Antes disso, as cartas s√£o apenas para visualiza√ß√£o
                    next_phase_active = getattr(self, '_next_phase_active', False)
                    final_phase_active = getattr(self, '_final_phase_active', False)
                    
                    # CORRE√á√ÉO CR√çTICA: N√ÉO criar bot√µes de ativa√ß√£o/desativa√ß√£o quando estamos em contextos especiais
                    # Os bot√µes vermelhos especiais devem ter prioridade sobre os bot√µes de ativa√ß√£o/desativa√ß√£o
                    in_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
                    in_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
                    in_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
                    in_link_downgrade_context = getattr(self, '_in_link_downgrade_context', False)
                    
                    # NOVA FUNCIONALIDADE: Verificar expira√ß√£o de Services ANTES de criar bot√µes normais
                    if carta_tipo == "services":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Verificando expira√ß√£o para Service: {os.path.basename(carta_path)}")
                        is_expired = self._is_service_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Resultado da verifica√ß√£o de expira√ß√£o: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service EXPIRADO - criando bot√£o vermelho de expira√ß√£o")
                            # Bot√£o certo vermelho para mostrar overlay de expira√ß√£o (mesmo formato que bot√£o de desativa√ß√£o)
                            red_check_btn = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao():
                                print(f"DEBUG: Mostrando overlay de expira√ß√£o para Service {carta_path}")
                                self._mostrar_overlay_service_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao)
                            return  # N√£o criar outros bot√µes se o Service expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service N√ÉO expirado - continuando com l√≥gica normal")
                    
                    # NOVA FUNCIONALIDADE: Verificar expira√ß√£o de Events ANTES de criar bot√µes normais
                    if carta_tipo == "events":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Verificando expira√ß√£o para Event: {os.path.basename(carta_path)}")
                        is_expired = self._is_event_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Resultado da verifica√ß√£o de expira√ß√£o: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event EXPIRADO - criando bot√£o vermelho de expira√ß√£o")
                            # Bot√£o certo vermelho para mostrar overlay de expira√ß√£o (mesmo formato que bot√£o de desativa√ß√£o)
                            red_check_btn = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao_event():
                                print(f"DEBUG: Mostrando overlay de expira√ß√£o para Event {carta_path}")
                                self._mostrar_overlay_event_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao_event)
                            return  # N√£o criar outros bot√µes se o Event expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event N√ÉO expirado - continuando com l√≥gica normal")
                    
                    # S√≥ mostrar bot√µes de ativa√ß√£o/desativa√ß√£o se Next Phase estiver ativo E n√£o estiver em Final Phase E n√£o estiver em contextos especiais
                    if next_phase_active and not final_phase_active and not in_router_upgrade_context and not in_router_downgrade_context and not in_link_upgrade_context and not in_link_downgrade_context:
                        # Verificar se a carta est√° ativa
                        is_active = self.is_card_active(carta_path, carta_tipo)
                        
                        if is_active:
                            # Carta ativa: bot√£o para desativar (vermelho com ‚úî)
                            btn_activate = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def desativar_carta():
                                self.show_deactivation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=desativar_carta)
                        else:
                            # Carta inativa: bot√£o para ativar (verde com ‚úî)
                            btn_activate = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                            def ativar_carta():
                                self.show_activation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=ativar_carta)
                        
                        # Posicionar o bot√£o no canto superior direito
                        btn_activate.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [FULLSCREEN] Bot√£o de ativa√ß√£o/desativa√ß√£o criado para {carta_tipo} - Next Phase ativo")
                    else:
                        print(f"DEBUG: [FULLSCREEN] Bot√£o de ativa√ß√£o/desativa√ß√£o N√ÉO criado para {carta_tipo} - Next Phase: {next_phase_active}, Final Phase: {final_phase_active}, Router Upgrade Context: {in_router_upgrade_context}, Router Downgrade Context: {in_router_downgrade_context}, Link Upgrade Context: {in_link_upgrade_context}, Link Downgrade Context: {in_link_downgrade_context}")

    def show_inventory_for_sell(self, carta_tipo, store_window=None, page=0):
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Verificar se o jogador pode vender cartas deste tipo na casa atual
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        # IMPORTANTE: Se Next Phase estiver ativo, N√ÉO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: N√ÉO pode vender cartas {carta_tipo} do invent√°rio - Next Phase est√° ativo (vendas desabilitadas)")
            # Volta √† Store ou PlayerDashboard se n√£o pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # IMPORTANTE: Se est√° numa casa START, N√ÉO pode vender nenhuma carta
        if casa_atual_tipo == "start":
            print(f"DEBUG: N√ÉO pode vender cartas {carta_tipo} do invent√°rio - est√° numa casa START (nenhuma venda permitida)")
            # Volta √† Store ou PlayerDashboard se n√£o pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # Normalizar o tipo da casa atual (equipments vs equipment)
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        # Verificar se pode vender nesta casa (no invent√°rio pr√≥prio, qualquer cor serve)
        # Activities s√≥ podem ser vendidas numa casa Activities, Challenges s√≥ numa casa Challenges
        pode_vender_tipo = False
        if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
            pode_vender_tipo = (casa_atual_tipo == carta_tipo)
        
        if not pode_vender_tipo:
            print(f"DEBUG: N√ÉO pode vender cartas {carta_tipo} do invent√°rio - casa atual: {casa_atual_tipo}, necess√°rio: {carta_tipo}")
            # Volta √† Store ou PlayerDashboard se n√£o pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        print(f"DEBUG: Pode vender cartas {carta_tipo} do invent√°rio - est√° numa casa {casa_atual_tipo}")
        
        # Garantir que a janela est√° vis√≠vel e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que n√£o est√° minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store est√° escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se n√£o, cri√°-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar n√£o existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # For√ßa update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com pagina√ß√£o
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no invent√°rio: {len(cartas)}")
        
        # Pagina√ß√£o
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimens√µes que outras p√°ginas de invent√°rio
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                # CORRE√á√ÉO: Verificar se a carta est√° ativa antes de permitir venda
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas n√£o podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualiza√ß√£o (n√£o pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem op√ß√£o de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualiza√ß√£o (cartas ativas n√£o podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem op√ß√£o de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar p√°gina atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a l√≥gica de verifica√ß√£o adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORRE√á√ÉO: Verificar se a carta est√° ativa para determinar como mostr√°-la
                # Cartas ATIVAS devem aparecer viradas para cima (n√£o podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta est√° ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima (mas n√£o pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa: virada para cima (N√ÉO pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (N√ÉO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa: virada para baixo (PODE ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card n√£o existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            
            # CORRE√á√ÉO: Cursor diferente dependendo se a carta pode ser vendida
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # Cartas ativas e User_1.png s√£o apenas para visualiza√ß√£o (cursor normal)
            # Cartas inativas podem ser vendidas (cursor hand2)
            if is_user_1 or is_active:
                cursor_type = "arrow"  # Cursor normal para cartas que n√£o podem ser vendidas
            else:
                cursor_type = "hand2"  # Cursor de m√£o para cartas que podem ser vendidas
            
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas dispon√≠veis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navega√ß√£o (se houver mais de uma p√°gina)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (p√°gina anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="‚ñ≤", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (p√°gina seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="‚ñº", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # For√ßa update final para garantir que tudo √© exibido
        self.update_idletasks()
        self.update()
        
        # Bot√£o voltar
        if store_window:
            def voltar_para_store():
                print("DEBUG: PlayerDashboard voltar_para_store chamado")
                try:
                    # Primeiro, esconde o PlayerDashboard
                    print("DEBUG: Escondendo PlayerDashboard...")
                    self.withdraw()
                    
                    # Aguarda um pouco para garantir que foi escondido
                    print("DEBUG: Aguardando para processar volta √† Store...")
                    self.after(100, lambda: self._process_back_to_store(store_window))
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao iniciar volta para store: {e}")
                    import traceback
                    traceback.print_exc()
                    
            def _process_back_to_store(store_window):
                print("DEBUG: Processando volta √† Store...")
                try:
                    # Verificar se a Store ainda existe
                    if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                        print("DEBUG: Store existe, for√ßando exibi√ß√£o...")
                        # For√ßa a Store a aparecer
                        store_window.deiconify()
                        store_window.state('normal')
                        store_window.lift()
                        store_window.focus_force()
                        
                        # CORRE√á√ÉO: Voltar para a interface principal da Store (n√£o para p√°gina de compra espec√≠fica)
                        print(f"DEBUG: Bot√£o Back - Chamando voltar_para_store da Store...")
                        store_window.after(50, lambda: store_window.voltar_para_store())
                        print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                        
                    else:
                        print("DEBUG: Store n√£o existe mais, voltando ao PlayerDashboard")
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                except Exception as e:
                    print(f"DEBUG: Erro ao processar volta √† Store: {e}")
                    import traceback
                    traceback.print_exc()
                    # Em caso de erro, volta ao PlayerDashboard
                    try:
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    except Exception as fallback_e:
                        print(f"DEBUG: Erro cr√≠tico no fallback: {fallback_e}")
            
            # Adiciona o m√©todo auxiliar √† inst√¢ncia
            self._process_back_to_store = _process_back_to_store
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no invent√°rio de venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no invent√°rio de venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Bot√£o voltar - criado ap√≥s a barra para ficar por cima
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell terminado com sucesso")

    def show_inventory_for_sell_after_sale(self, carta_tipo, store_window=None, page=0):
        """Vers√£o especial de show_inventory_for_sell que ignora verifica√ß√µes de casa ap√≥s uma venda bem-sucedida"""
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell_after_sale chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Garantir que a janela est√° vis√≠vel e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que n√£o est√° minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store est√° escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se n√£o, cri√°-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar n√£o existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # For√ßa update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # T√≠tulo
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com pagina√ß√£o
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no invent√°rio ap√≥s venda: {len(cartas)}")
        
        # Pagina√ß√£o
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimens√µes que outras p√°ginas de invent√°rio
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                print(f"DEBUG: Carta clicada para venda: {carta_path}")
                
                # Verificar se a carta est√° ativa (n√£o pode ser vendida)
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas n√£o podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualiza√ß√£o (n√£o pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem op√ß√£o de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualiza√ß√£o (cartas ativas n√£o podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem op√ß√£o de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar p√°gina atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a l√≥gica de verifica√ß√£o adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORRE√á√ÉO: Verificar se a carta est√° ativa para determinar como mostr√°-la
                # Cartas ATIVAS devem aparecer viradas para cima (n√£o podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta est√° ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa - mostrar virada para cima (n√£o pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (N√ÉO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa - mostrar virada para baixo (pode ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card n√£o existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas dispon√≠veis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navega√ß√£o (se houver mais de uma p√°gina)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (p√°gina anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="‚ñ≤", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (p√°gina seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="‚ñº", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no invent√°rio de venda ap√≥s venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no invent√°rio de venda ap√≥s venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Bot√£o voltar - criado ap√≥s a barra para ficar por cima
        def voltar_para_store():
            print("DEBUG: PlayerDashboard voltar_para_store chamado (ap√≥s venda)")
            try:
                # Primeiro, esconde o PlayerDashboard
                print("DEBUG: Escondendo PlayerDashboard...")
                self.withdraw()
                
                # Aguarda um pouco para garantir que foi escondido
                print("DEBUG: Aguardando para processar volta √† Store...")
                self.after(100, lambda: self._process_back_to_store_after_sale(store_window))
                
            except Exception as e:
                print(f"DEBUG: Erro ao iniciar volta para store ap√≥s venda: {e}")
                import traceback
                traceback.print_exc()
        
        def _process_back_to_store_after_sale(store_window):
            print("DEBUG: Processando volta √† Store ap√≥s venda...")
            try:
                # Verificar se a Store ainda existe
                if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                    print("DEBUG: Store existe, for√ßando exibi√ß√£o...")
                    # For√ßa a Store a aparecer
                    store_window.deiconify()
                    store_window.state('normal')
                    store_window.lift()
                    store_window.focus_force()
                    
                    # CORRE√á√ÉO: Voltar para a interface principal da Store (n√£o para p√°gina de compra espec√≠fica)
                    print(f"DEBUG: Bot√£o Back - Chamando voltar_para_store da Store...")
                    store_window.after(50, lambda: store_window.voltar_para_store())
                    print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                    
                else:
                    print("DEBUG: Store n√£o existe mais, voltando ao PlayerDashboard")
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
            except Exception as e:
                print(f"DEBUG: Erro ao processar volta √† Store ap√≥s venda: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, volta ao PlayerDashboard
                try:
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CR√çTICO no fallback ap√≥s venda: {fallback_e}")
                    traceback.print_exc()
        
        # Adiciona o m√©todo auxiliar √† inst√¢ncia
        self._process_back_to_store_after_sale = _process_back_to_store_after_sale
        
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell_after_sale terminado com sucesso")

    def show_card_fullscreen_sell(self, carta_path, carta_tipo, store_window=None):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Bot√£o X para fechar - movido para canto superior esquerdo
        def fechar():
            # CORRE√á√ÉO: Voltar para a p√°gina de invent√°rio correta onde o utilizador estava
            current_page = getattr(self, '_current_sell_page', 0)
            # IMPORTANTE: Usar vers√£o especial que ignora verifica√ß√µes de casa
            self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
        
        x_btn = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=fechar, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o de venda APENAS se estiver numa casa do tipo correspondente
        # Verificar se o jogador est√° numa casa do tipo correspondente (no invent√°rio pr√≥prio, qualquer cor serve)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        print(f"DEBUG: Verificando possibilidade de venda fullscreen no invent√°rio - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}, casa_atual_cor: {casa_atual_cor}, other_player_house: {current_other_player_house}")
        
        # IMPORTANTE: User_1.png NUNCA pode ser vendida
        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
        if is_user_1:
            print(f"DEBUG: User_1.png N√ÉO pode ser vendida - apenas bot√£o X dispon√≠vel")
            pode_vender = False
        else:
            # CORRE√á√ÉO: Verificar se a carta est√° ATIVA (cartas ativas nunca podem ser vendidas)
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            
            if is_active:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} - carta est√° ATIVA (cartas ativas n√£o podem ser vendidas)")
                pode_vender = False
            # IMPORTANTE: Se Next Phase est√° ativo, tamb√©m n√£o pode vender (dupla verifica√ß√£o)
            elif getattr(self, '_next_phase_active', False):
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do invent√°rio - Next Phase est√° ativo (vendas desabilitadas)")
                pode_vender = False
            # IMPORTANTE: Se est√° numa casa de outro jogador, PODE vender cartas INATIVAS do invent√°rio do tipo correspondente
            elif current_other_player_house:
                print(f"DEBUG: Casa de outro jogador detectada - verificando se pode vender {carta_tipo} INATIVO")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Em casas de outros jogadores, pode vender se o tipo da casa corresponder ao tipo da carta E carta est√° INATIVA
                if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                        print(f"DEBUG: PODE vender carta {carta_tipo} INATIVA - est√° numa casa {casa_atual_tipo} de outro jogador")
                    else:
                        print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} - casa {casa_atual_tipo} n√£o corresponde")
            else:
                # L√≥gica original para casas pr√≥prias ou neutras - s√≥ pode vender cartas INATIVAS
                print(f"DEBUG: Casa pr√≥pria ou neutra - verificando regras normais (apenas cartas INATIVAS)")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Verificar se pode vender cartas INATIVAS
                if carta_tipo in ["users", "equipments", "services"]:
                    # Para estas cartas, precisa estar na casa do mesmo tipo E carta deve estar INATIVA
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                elif carta_tipo in ["activities", "challenges"]:
                    # Activities s√≥ podem ser vendidas numa casa Activities, Challenges s√≥ numa casa Challenges
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
        
        # Bot√£o de venda com checkmark no canto superior direito (substitui o bot√£o verde picoin)
        if pode_vender:
            if current_other_player_house:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do invent√°rio - est√° numa casa {casa_atual_tipo} de outro jogador ({casa_atual_cor})")
            else:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do invent√°rio - est√° numa casa {casa_atual_tipo}")
            def abrir_confirm():
                self.show_sell_confirmation(carta_path, carta_tipo, store_window)
            
            # Bot√£o com checkmark (‚úì) no canto superior direito
            btn_sell = tk.Button(self, text="‚úì", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
            btn_sell.place(relx=0.98, rely=0, anchor="ne")
        else:
            # Verificar motivo espec√≠fico para n√£o poder vender
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            next_phase_active = getattr(self, '_next_phase_active', False)
            
            if is_user_1:
                print(f"DEBUG: User_1.png - apenas bot√£o X dispon√≠vel (nunca pode ser vendida)")
            elif is_active:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} - carta est√° ATIVA (cartas ativas n√£o podem ser vendidas)")
            elif next_phase_active:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do invent√°rio - Next Phase ativo (vendas desabilitadas)")
            elif current_other_player_house:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do invent√°rio - casa de outro jogador ({casa_atual_cor}) do tipo {casa_atual_tipo}, necess√°rio: {carta_tipo}")
            else:
                print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do invent√°rio - casa atual: {casa_atual_tipo}, necess√°rio: {carta_tipo}")

    def show_sell_confirmation(self, carta_path, carta_tipo, store_window=None):
        import tkinter.messagebox
        
        # LOGGING DETALHADO PARA DEBUG
        print(f"DEBUG: [VENDA IN√çCIO] ===== PROCESSO DE VENDA INICIADO =====")
        print(f"DEBUG: [VENDA IN√çCIO] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [VENDA IN√çCIO] Tipo: {carta_tipo}")
        print(f"DEBUG: [VENDA IN√çCIO] Store fornecida: {store_window is not None}")
        if store_window:
            print(f"DEBUG: [VENDA IN√çCIO] Store ID: {getattr(store_window, '_store_id', 'Sem ID')}")
            print(f"DEBUG: [VENDA IN√çCIO] Player cor: {self.player_color}")
            print(f"DEBUG: [VENDA IN√çCIO] Store casa_cor: {getattr(store_window, 'casa_cor', 'N√£o definida')}")
            print(f"DEBUG: [VENDA IN√çCIO] Store casa_tipo: {getattr(store_window, 'casa_tipo', 'N√£o definido')}")
        
        # Definir vari√°veis necess√°rias
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # PRIMEIRO: Limpar tudo e mostrar a carta em fullscreen como fundo (igual √† compra)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        
        # Mostrar a carta em fullscreen como fundo (igual √† imagem de compra)
        try:
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            
            # √Årea dispon√≠vel: toda a tela (igual √† compra)
            available_width = screen_width
            available_height = screen_height
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(available_width/img_w, available_height/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Carta em fullscreen como fundo
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # Manter refer√™ncia para evitar garbage collection
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
            print("DEBUG: Carta carregada em fullscreen como fundo")
            
        except Exception as e:
            print(f"DEBUG: ERRO ao carregar carta para fundo: {e}")
            # Mostrar um placeholder em caso de erro
            carta_real_lbl = tk.Label(self, text="Erro ao carregar carta", font=("Helvetica", 20), fg="red", bg="black")
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
        
        # SEGUNDO: Frame de confirma√ß√£o (igual ao layout da compra na imagem)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        tk.Label(confirm_frame, text="Are you sure you want to sell?", font=("Helvetica", 16, "bold"), fg="white", bg="black").pack(pady=(40, 20))
        
        # Saldo atual (igual √† confirma√ß√£o de compra)
        tk.Label(confirm_frame, text=f"Your balance: {self.saldo}", font=("Helvetica", 16), fg="yellow", bg="black").pack(pady=(0, 10))
        
        # Valor da carta (usando base de dados integrada)
        valor = self._extrair_valor_venda_carta(carta_path)
        if valor is None:
            print("DEBUG: Valor n√£o encontrado, usando fallback")
            valor = self._extrair_valor_fallback(carta_path)
        
        value_frame = tk.Frame(confirm_frame, bg="black")
        value_frame.pack(pady=(0, 30))
        
        tk.Label(value_frame, text="Card value: ", 
                font=("Helvetica", 16), fg="white", bg="black").pack(side="left")
        tk.Label(value_frame, text=str(valor), 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(side="left", padx=(5, 5))
        
        # √çcone da moeda (igual √† confirma√ß√£o de compra)
        try:
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            picoin_lbl = tk.Label(value_frame, image=picoin_img, bg="black")
            picoin_lbl.image = picoin_img
            picoin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar √≠cone da moeda: {e}")
        
        # Frame para os bot√µes (igual √† confirma√ß√£o de compra)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack()
        
        def confirmar():
            print("DEBUG: Confirmar venda - in√≠cio")
            print(f"DEBUG: Vari√°veis de controle - _inventario_conjunto: {getattr(self, '_inventario_conjunto', 'None')}")
            print(f"DEBUG: Vari√°veis de controle - _tipos_venda: {getattr(self, '_tipos_venda', 'None')}")
            print(f"DEBUG: Vari√°veis de controle - _current_sell_page: {getattr(self, '_current_sell_page', 'None')}")
            try:
                # CORRE√á√ÉO: L√≥gica de venda correta
                # Player vende a carta: perde a carta, ganha dinheiro
                # Store compra a carta: ganha a carta, perde dinheiro
                if valor is not None and valor > 0:
                    # Player recebe o dinheiro pela venda
                    self.saldo += valor
                    print(f"DEBUG: Player vendeu carta por {valor}, novo saldo: {self.saldo}")
                    
                    # NOVO: Sincronizar saldo com servidor
                    self.sync_score_with_server(f"venda carta +{valor}")
                    
                    # Store paga pela carta (perde dinheiro)
                    if store_window:
                        store_window.saldo -= valor
                        print(f"DEBUG: Store pagou {valor}, novo saldo: {store_window.saldo}")
                        
                        # IMPORTANTE: Devolver a carta aos baralhos da Store (sincroniza√ß√£o)
                        # CORRE√á√ÉO: Especificar a cor do jogador que est√° vendendo
                        if hasattr(store_window, 'adicionar_carta_ao_baralho'):
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] ===== ADICIONANDO CARTA DE VOLTA √Ä STORE =====")
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Carta: {os.path.basename(carta_path)}")
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Tipo: {carta_tipo}")
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Cor do jogador vendedor: {self.player_color}")
                            
                            # Determinar a cor correta para adicionar a carta
                            cor_carta = self._get_color_from_path(carta_path)
                            # As cartas vendidas sempre v√£o para o baralho da cor do jogador
                            if not cor_carta:
                                cor_carta = self.player_color
                            
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Cor da carta determinada: {cor_carta}")
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Casa atual da Store: tipo='{store_window.casa_tipo}', cor='{store_window.casa_cor}'")
                            
                            # Estado ANTES da adi√ß√£o
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_antes = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] ANTES: {cartas_antes} cartas de {carta_tipo} na cor {cor_carta}")
                            else:
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] ANTES: Baralho {cor_carta}/{carta_tipo} n√£o existe ou vazio")
                            
                            # CHAMAR A FUN√á√ÉO DE ADICIONAR
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Chamando store_window.adicionar_carta_ao_baralho()")
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] Par√¢metros: carta_path={os.path.basename(carta_path)}, carta_tipo={carta_tipo}, carta_cor={cor_carta}")
                            
                            # CORRE√á√ÉO ADICIONAL: Verificar se a fun√ß√£o existe e cham√°-la com try/except
                            try:
                                store_window.adicionar_carta_ao_baralho(carta_path, carta_tipo, cor_carta)
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] adicionar_carta_ao_baralho executada COM SUCESSO")
                            except Exception as e:
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] ERRO ao chamar adicionar_carta_ao_baralho: {e}")
                                # Fallback manual de sincroniza√ß√£o
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] Executando sincroniza√ß√£o manual...")
                                if hasattr(store_window, 'cartas'):
                                    if cor_carta not in store_window.cartas:
                                        store_window.cartas[cor_carta] = {}
                                    if carta_tipo not in store_window.cartas[cor_carta]:
                                        store_window.cartas[cor_carta][carta_tipo] = []
                                    if carta_path not in store_window.cartas[cor_carta][carta_tipo]:
                                        store_window.cartas[cor_carta][carta_tipo].append(carta_path)
                                        print(f"DEBUG: [VENDA EXECU√á√ÉO] Carta adicionada manualmente ao baralho local")
                                    
                                    # Sincroniza√ß√£o com baralho global
                                    try:
                                        from Store import baralhos
                                        if baralhos and cor_carta in baralhos and carta_tipo in baralhos[cor_carta]:
                                            if carta_path not in baralhos[cor_carta][carta_tipo]:
                                                baralhos[cor_carta][carta_tipo].append(carta_path)
                                                print(f"DEBUG: [VENDA EXECU√á√ÉO] Carta adicionada manualmente ao baralho global")
                                    except Exception as global_sync_error:
                                        print(f"DEBUG: [VENDA EXECU√á√ÉO] Erro na sincroniza√ß√£o global: {global_sync_error}")
                            
                            
                            # Estado DEPOIS da adi√ß√£o
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_depois = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] DEPOIS: {cartas_depois} cartas de {carta_tipo} na cor {cor_carta}")
                                
                                # Verificar se a carta espec√≠fica est√° l√°
                                carta_encontrada = carta_path in store_window.cartas[cor_carta][carta_tipo]
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] Carta {os.path.basename(carta_path)} encontrada no baralho: {carta_encontrada}")
                                
                                # Listar algumas cartas para debug
                                cartas_sample = [os.path.basename(c) for c in store_window.cartas[cor_carta][carta_tipo][-3:]]
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] √öltimas 3 cartas no baralho: {cartas_sample}")
                            else:
                                print(f"DEBUG: [VENDA EXECU√á√ÉO] DEPOIS: Baralho {cor_carta}/{carta_tipo} ainda n√£o existe!")
                            
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] ===== ADI√á√ÉO CONCLU√çDA =====")
                        else:
                            print(f"DEBUG: [VENDA EXECU√á√ÉO] ERRO: Store n√£o tem m√©todo adicionar_carta_ao_baralho")
                
                # Remove carta do invent√°rio do Player
                if carta_tipo in self.inventario and carta_path in self.inventario[carta_tipo]:
                    self.inventario[carta_tipo].remove(carta_path)
                    print(f"DEBUG: Carta removida do invent√°rio do Player: {carta_path}")
                
                print(f"DEBUG: Venda confirmada - Player saldo: {self.saldo}")
                
                # CORRE√á√ÉO: Voltar para a p√°gina de invent√°rio correta onde o utilizador estava
                # Se viemos de um invent√°rio Activities/Challenges conjunto, voltar para esse
                if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                    print("DEBUG: Voltando para invent√°rio conjunto Activities/Challenges")
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORRE√á√ÉO: Verificar se a p√°gina ainda √© v√°lida ap√≥s a venda
                    cartas_totais = []
                    for t in self._tipos_venda:
                        cartas_totais += self.inventario.get(t, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                    # IMPORTANTE: Garantir que current_page e total_pages s√£o n√∫meros v√°lidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_matrix_carrossel com tipos: {self._tipos_venda}, page: {current_page}")
                    self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
                else:
                    print("DEBUG: Voltando para invent√°rio do tipo espec√≠fico")
                    # Caso normal: voltar para invent√°rio do tipo espec√≠fico
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORRE√á√ÉO: Verificar se a p√°gina ainda √© v√°lida ap√≥s a venda
                    cartas_restantes = self.inventario.get(carta_tipo, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_restantes) + cards_per_page - 1) // cards_per_page) if cartas_restantes else 1
                    # IMPORTANTE: Garantir que current_page e total_pages s√£o n√∫meros v√°lidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas restantes: {len(cartas_restantes)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_for_sell_after_sale com carta_tipo: {carta_tipo}, page: {current_page}")
                    # IMPORTANTE: Usar vers√£o especial que ignora verifica√ß√µes de casa para voltar ap√≥s venda
                    self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
                
                # Limpar vari√°veis de controle
                self._origem_venda = None
                self._tipos_venda = None
                self._page_venda = None
                self._current_sell_page = None
                self._inventario_conjunto = None
                
                print("DEBUG: Venda confirmada com sucesso - limpeza conclu√≠da")
                
            except Exception as e:
                print(f"DEBUG: ERRO na confirma√ß√£o: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, tentar voltar √† interface principal
                try:
                    print("DEBUG: Tentando voltar √† interface principal ap√≥s erro")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CR√çTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar venda - carta_tipo: {carta_tipo}")
            
            # CORRE√á√ÉO: Voltar para a p√°gina de invent√°rio correta onde o utilizador estava
            # Se viemos de um invent√°rio Activities/Challenges conjunto, voltar para esse
            if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                print("DEBUG: Voltando para invent√°rio conjunto Activities/Challenges")
                current_page = getattr(self, '_current_sell_page', 0)
                # CORRE√á√ÉO: Verificar se a p√°gina ainda √© v√°lida (mesmo sem venda, por seguran√ßa)
                cartas_totais = []
                for t in self._tipos_venda:
                    cartas_totais += self.inventario.get(t, [])
                cards_per_page = 4
                total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                # IMPORTANTE: Garantir que current_page e total_pages s√£o n√∫meros v√°lidos
                if current_page is None:
                    current_page = 0
                if total_pages is None:
                    total_pages = 1
                current_page = min(current_page, total_pages - 1)
                print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
            else:
                # Caso normal: voltar para invent√°rio do tipo espec√≠fico
                current_page = getattr(self, '_current_sell_page', 0)
                # IMPORTANTE: Garantir que current_page √© um n√∫mero v√°lido
                if current_page is None:
                    current_page = 0
                # IMPORTANTE: Para cancelamento, usar fun√ß√£o normal que mostra todas as cartas
                print(f"DEBUG: Cancelamento - chamando show_inventory_for_sell normal com carta_tipo: {carta_tipo}, page: {current_page}")
                self.show_inventory_for_sell(carta_tipo, store_window, current_page)
            
            # Limpar vari√°veis de controle
            self._origem_venda = None
            self._tipos_venda = None
            self._page_venda = None
            self._current_sell_page = None
            self._inventario_conjunto = None
            
        # Bot√µes No e Yes (posi√ß√µes trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Bot√µes de confirma√ß√£o criados - Yes e No")
        print(f"DEBUG: Fun√ß√£o confirmar configurada: {confirmar}")
        print(f"DEBUG: Fun√ß√£o cancelar configurada: {cancelar}")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def _voltar_inventario_apos_ativacao(self, tipos, page):
        """M√©todo auxiliar para voltar ao invent√°rio ap√≥s ativa√ß√£o"""
        try:
            # Recriar a TopBar
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada ap√≥s ativa√ß√£o")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio
            self.show_inventory_matrix(tipos, page)
            
        except Exception as e:
            print(f"DEBUG: Erro ao voltar ao invent√°rio: {e}")

    def _voltar_inventario_e_verificar_bandwidth(self, tipos, page):
        """M√©todo para voltar ao invent√°rio e verificar BANDWIDTH ap√≥s mostrar invent√°rio"""
        try:
            # Primeiro, ir para o invent√°rio
            self._voltar_inventario_apos_ativacao(tipos, page)
            
            # Verificar BANDWIDTH AP√ìS mostrar o invent√°rio (com delay para garantir que interface carregou)
            def verificar_bandwidth_apos_inventario():
                if not self._has_active_bandwidth_services():
                    print(f"DEBUG: User ativado mas BANDWIDTH n√£o encontrado - mostrando erro sobre invent√°rio")
                    # Mostrar mensagem de erro sobre o invent√°rio
                    self._show_bandwidth_required_message(tipos, page)
            
            # Verificar ap√≥s 100ms para garantir que invent√°rio foi carregado
            self.after(100, verificar_bandwidth_apos_inventario)
            
        except Exception as e:
            print(f"DEBUG: Erro ao voltar ao invent√°rio e verificar BANDWIDTH: {e}")

    def _voltar_inventario_sem_ativar_e_mostrar_erro_bandwidth(self, tipos, page):
        """M√©todo para mostrar erro BANDWIDTH diretamente (tela dedicada que funciona no Raspberry Pi)"""
        print(f"DEBUG: [BANDWIDTH_ERROR] === MOSTRANDO TELA DE ERRO BANDWIDTH ===")
        print(f"DEBUG: [BANDWIDTH_ERROR] Tipos: {tipos}, Page: {page}")
        print(f"DEBUG: Tentativa de ativar User BLOQUEADA - Nenhum Service BANDWIDTH ativo")
        
        # Mostrar tela de erro DIRETAMENTE (abordagem que garante visibilidade no Raspberry Pi)
        self._show_bandwidth_required_message(tipos, page)

    def show_activation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma p√°gina de confirma√ß√£o para ativa√ß√£o de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirma√ß√£o de ativa√ß√£o para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela (igual √† venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual √† venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento din√¢mico, igual √†s p√°ginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Activation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirma√ß√£o
        tk.Label(confirm_frame, text="Do you want to activate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando ativa√ß√£o da carta {carta_path}")
            
            # NOVA VERIFICA√á√ÉO BANDWIDTH LOGO NO IN√çCIO para cartas User
            if carta_tipo in ["user", "users"]:
                print(f"DEBUG: [ACTIVATION] Carta User detectada - verificando BANDWIDTH")
                
                if not self._has_active_bandwidth_services():
                    print(f"DEBUG: [BANDWIDTH_ERROR] User activation BLOCKED - No active BANDWIDTH services")
                    # Mostrar novo overlay de erro sequencial (substitui o overlay de ativa√ß√£o)
                    self._show_bandwidth_error_overlay(tipos, page)
                    return
                
                print(f"DEBUG: [ACTIVATION] BANDWIDTH verificado OK - procedendo com ativa√ß√£o User")
            
            try:
                # CORRE√á√ÉO CR√çTICA: Para cartas Equipment, mostrar loading screen IMEDIATAMENTE
                if carta_tipo in ["equipment", "equipments"]:
                    print(f"DEBUG: [ACTIVATION] Carta Equipment detectada - mostrando loading screen IMEDIATAMENTE")
                    
                    # Obter object_name da carta
                    object_name = get_equipment_object_name(carta_path, self.card_database)
                    
                    if object_name:
                        print(f"DEBUG: [ACTIVATION] Criando loading screen para object: {object_name}")
                        
                        # CRIAR LOADING SCREEN IMEDIATAMENTE - ANTES DE TUDO
                        loading_window = create_yolo_loading_screen(self, object_name)
                        
                        if loading_window:
                            print(f"DEBUG: [ACTIVATION] Loading screen criado - executando ativa√ß√£o em background")
                            
                            # Fun√ß√£o para processar ativa√ß√£o depois do loading screen estar ativo
                            def processar_ativacao_com_yolo():
                                try:
                                    # Ativar a carta
                                    self.activate_card(carta_tipo, carta_path)
                                    print(f"DEBUG: [ACTIVATION] Carta ativada - iniciando YOLO")
                                    
                                    # Executar script YOLO (sem criar loading screen novamente)
                                    detection_success = execute_detection_script_direct(object_name, self, loading_window)
                                    
                                    if detection_success:
                                        print(f"DEBUG: [ACTIVATION] Script YOLO iniciado com sucesso")
                                    else:
                                        print(f"DEBUG: [ACTIVATION] AVISO: Script YOLO falhou - fechando loading screen")
                                        if loading_window:
                                            loading_window.destroy()
                                        
                                        self._voltar_inventario_apos_ativacao(tipos, page)
                                        
                                except Exception as e:
                                    print(f"DEBUG: [ACTIVATION] ERRO na ativa√ß√£o: {e}")
                                    if loading_window:
                                        loading_window.destroy()
                                    
                                    self._voltar_inventario_apos_ativacao(tipos, page)
                            
                            # Executar ativa√ß√£o ap√≥s 100ms (loading screen j√° est√° vis√≠vel)
                            self.after(100, processar_ativacao_com_yolo)
                            
                        else:
                            print(f"DEBUG: [ACTIVATION] ERRO: Loading screen n√£o foi criado - continuando normalmente")
                            
                            # Fallback: ativa√ß√£o normal se loading screen falhar
                            self.activate_card(carta_tipo, carta_path)
                            self._voltar_inventario_apos_ativacao(tipos, page)
                    else:
                        print(f"DEBUG: [ACTIVATION] AVISO: Object name n√£o encontrado - ativa√ß√£o normal")
                        
                        # Ativa√ß√£o normal se n√£o conseguir obter object_name
                        self.activate_card(carta_tipo, carta_path)
                        self._voltar_inventario_apos_ativacao(tipos, page)
                else:
                    # Para cartas n√£o-Equipment, ativa√ß√£o normal
                    print(f"DEBUG: [ACTIVATION] Carta n√£o-Equipment - ativa√ß√£o normal")
                    self.activate_card(carta_tipo, carta_path)
                    self._voltar_inventario_apos_ativacao(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar ativa√ß√£o: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o invent√°rio
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada ap√≥s erro na ativa√ß√£o")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar ap√≥s erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CR√çTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar ativa√ß√£o - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao invent√°rio
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada ap√≥s cancelar ativa√ß√£o")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio
            self.show_inventory_matrix(tipos, page)
            
        # Bot√µes No e Yes (posi√ß√µes trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Bot√µes de confirma√ß√£o de ativa√ß√£o criados - Yes e No")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_deactivation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma p√°gina de confirma√ß√£o para desativa√ß√£o de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirma√ß√£o de desativa√ß√£o para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela (igual √† venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual √† venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento din√¢mico, igual √†s p√°ginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Deactivation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirma√ß√£o
        tk.Label(confirm_frame, text="Do you want to deactivate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando desativa√ß√£o da carta {carta_path}")
            try:
                # NOVA FUNCIONALIDADE: Criar loading screen ANTES de qualquer a√ß√£o para Equipment
                if carta_tipo in ["equipment", "equipments"]:
                    print(f"DEBUG: [DEACTIVATION] Carta Equipment detectada - criando loading screen")
                    
                    # Obter object_name da carta
                    object_name = get_equipment_object_name(carta_path, self.card_database)
                    
                    if object_name:
                        print(f"DEBUG: [DEACTIVATION] Criando loading screen para object: {object_name}")
                        
                        # Criar loading screen imediatamente
                        loading_window = create_yolo_loading_screen(self, object_name)
                        
                        if loading_window:
                            print(f"DEBUG: [DEACTIVATION] Loading screen criado com sucesso")
                            
                            # Desativar a carta
                            self.deactivate_card(carta_path, carta_tipo)
                            
                            # Executar script de detec√ß√£o diretamente com loading screen existente
                            detection_success = execute_detection_script_direct(object_name, self, loading_window)
                            
                            if detection_success:
                                print(f"DEBUG: [DEACTIVATION] Script de detec√ß√£o executado com sucesso")
                            else:
                                print(f"DEBUG: [DEACTIVATION] AVISO: Script de detec√ß√£o falhou")
                                # Fechar loading screen em caso de erro
                                if loading_window:
                                    loading_window.destroy()
                        else:
                            print(f"DEBUG: [DEACTIVATION] ERRO: N√£o foi poss√≠vel criar loading screen")
                            # Fallback sem loading screen
                            self.deactivate_card(carta_path, carta_tipo)
                    else:
                        print(f"DEBUG: [DEACTIVATION] AVISO: Object name n√£o encontrado para carta Equipment")
                        # Fallback sem detec√ß√£o
                        self.deactivate_card(carta_path, carta_tipo)
                else:
                    # Para cartas que n√£o s√£o Equipment, desativar normalmente
                    self.deactivate_card(carta_path, carta_tipo)
                
                # Para cartas n√£o-Equipment, recriar TopBar e voltar ao invent√°rio
                if carta_tipo not in ["equipment", "equipments"]:
                    # Recriar a TopBar antes de voltar ao invent√°rio
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada ap√≥s confirmar desativa√ß√£o")
                    except Exception as e:
                        print(f"DEBUG: Erro ao recriar TopBar: {e}")
                    
                    # Voltar para a p√°gina de invent√°rio
                    self.show_inventory_matrix(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar desativa√ß√£o: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o invent√°rio
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada ap√≥s erro na desativa√ß√£o")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar ap√≥s erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CR√çTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar desativa√ß√£o - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao invent√°rio
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada ap√≥s cancelar desativa√ß√£o")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio
            self.show_inventory_matrix(tipos, page)
            
        # Bot√µes No e Yes (posi√ß√µes trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Bot√µes de confirma√ß√£o de desativa√ß√£o criados - Yes e No")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_remove_router_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirma√ß√£o espec√≠fica para remo√ß√£o de router no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Mostrando confirma√ß√£o de remo√ß√£o do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Router Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Do you want to remove the router {router_id}?"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Confirmando remo√ß√£o do router {router_id}")
            try:
                # Remover carta do invent√°rio
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido do invent√°rio")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (p√°gina de invent√°rio de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao enviar router para Store: {e}")
                    
                    # Verificar se h√° links ativos com o mesmo specific_id
                    links_ativos_mesmo_id = self._find_active_links_with_same_id(router_id)
                    
                    if links_ativos_mesmo_id:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Links ativos encontrados com ID {router_id}: {len(links_ativos_mesmo_id)}")
                        # Manter contexto ativo para remo√ß√£o de links
                        self._in_remove_router_context = True
                        # Adicionar flag espec√≠fica para indicar que estamos agora removendo links
                        self._removing_associated_links = True
                        self._router_id_being_removed = router_id
                        # Voltar ao invent√°rio de equipments para remover links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Nenhum link ativo encontrado com ID {router_id}")
                        # Limpar flag do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        # Voltar √† interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Voltando √† interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO: Router n√£o encontrado no invent√°rio")
                    # Em caso de erro, voltar ao invent√°rio
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao confirmar remo√ß√£o: {e}")
                # Em caso de erro, voltar ao invent√°rio
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Cancelando remo√ß√£o do router")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Bot√µes No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Overlay de confirma√ß√£o de remo√ß√£o criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_router_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirma√ß√£o espec√≠fica para upgrade de router no contexto ROUTER UPGRADE"""
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Mostrando confirma√ß√£o de upgrade do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Router Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Confirmando upgrade do router {router_id}")
            try:
                # Mapeamento: Small Router -> Medium Router
                equipment_mapping = {
                    1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
                    2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
                    3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
                }
                
                if router_id not in equipment_mapping:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Router ID {router_id} n√£o suportado")
                    return
                
                small_router, medium_router = equipment_mapping[router_id]
                
                # Verificar se o jogador j√° tem o Medium Router correspondente no invent√°rio
                equipments_inventory = self.inventario.get("equipments", [])
                medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
                
                if medium_router_exists:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERROR: {medium_router} j√° existe no invent√°rio - upgrade n√£o aplicado")
                    # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Small Router do invent√°rio e ativos
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido do invent√°rio")
                    
                    # Remover da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido da lista de equipments ativos")
                    
                    # Construir caminho para Medium Router (usar mesma estrutura de diret√≥rio)
                    base_dir = os.path.dirname(carta_path)
                    medium_router_path = os.path.join(base_dir, medium_router)
                    
                    # Adicionar Medium Router ao invent√°rio (virado para baixo)
                    self.inventario["equipments"].append(medium_router_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] {medium_router} adicionado ao invent√°rio (virado para baixo)")
                    
                    # Enviar Small Router para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao enviar Small Router para Store: {e}")
                    
                    # Limpar flags do contexto ROUTER UPGRADE
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    
                    # Voltar √† p√°gina de invent√°rio de Equipments
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] SUCCESS: Router Upgrade aplicado com sucesso!")
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Voltando √† p√°gina de invent√°rio de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERRO: Small Router n√£o encontrado no invent√°rio")
                    # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao confirmar upgrade: {e}")
                # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                self._in_router_upgrade_context = False
                self._router_upgrade_target_id = None
                # REABILITAR BOT√ÉO BACK quando Ok √© clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [ROUTER_UPGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas bot√£o Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Overlay de confirma√ß√£o de upgrade criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_router_downgrade_confirmation(self, router_id):
        """Mostra confirma√ß√£o espec√≠fica para downgrade de router no contexto ROUTER DOWNGRADE"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Mostrando confirma√ß√£o de downgrade do Router ID: {router_id}")
        
        # Salvar estado antes de limpar widgets
        self._save_dashboard_state()
        
        # Obter carta Equipment que est√° sendo processada para downgrade
        carta_path = None
        try:
            # Mapear router_id para carta Equipment correspondente
            router_to_equipment = {
                1: "Equipment_4.png",  # Medium Router 1
                2: "Equipment_5.png",  # Medium Router 2  
                3: "Equipment_6.png",  # Medium Router 3
            }
            
            if router_id in router_to_equipment:
                equipment_filename = router_to_equipment[router_id]
                # Encontrar caminho completo da carta no invent√°rio
                for eq_path in self.inventario.get("equipments", []):
                    if os.path.basename(eq_path) == equipment_filename:
                        carta_path = eq_path
                        break
                        
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta encontrada para fundo: {carta_path}")
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao obter carta para fundo: {e}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (similar ao overlay de upgrade)
        if carta_path and os.path.exists(carta_path):
            try:
                carta_img = Image.open(carta_path)
                screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                
                # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
                ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                carta_photo = ImageTk.PhotoImage(carta_resized)
                
                # Label com a imagem da carta como fundo
                carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                carta_label.image = carta_photo  # Manter refer√™ncia
                carta_label.place(relx=0.5, rely=0.5, anchor="center")
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta carregada como fundo: {os.path.basename(carta_path)}")
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
                self.config(bg="black")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Nenhuma carta encontrada para fundo, usando fundo preto")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Router Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Confirmando downgrade do router {router_id}")
            try:
                # Processar efetivamente o downgrade
                self._processar_router_downgrade(router_id)
                
                # CORRE√á√ÉO CR√çTICA: Limpar flags do contexto ROUTER DOWNGRADE ANTES de abrir invent√°rio
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Limpando flags de contexto...")
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] SUCCESS: Router Downgrade aplicado com sucesso!")
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Voltando ao invent√°rio normal de equipamentos")
                
                # CORRE√á√ÉO: Voltar ao invent√°rio normal de equipments (n√£o espec√≠fico para downgrade)
                # Isso garante que o bot√£o Back e bot√µes de ativa√ß√£o/desativa√ß√£o funcionem normalmente
                self.show_inventory_matrix(["equipments"])
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar ao dashboard principal
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Apenas bot√£o Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Overlay de confirma√ß√£o de downgrade criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_remove_link_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirma√ß√£o espec√≠fica para remo√ß√£o de link no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Mostrando confirma√ß√£o de remo√ß√£o do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Link {link_id} is going to be removed"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Confirmando remo√ß√£o do link {link_id}")
            try:
                # Remover carta do invent√°rio
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido do invent√°rio")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (p√°gina de invent√°rio de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao enviar link para Store: {e}")
                    
                    # Verificar se h√° mais links ativos com o mesmo ID
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    links_restantes = self._find_active_links_with_same_id(router_id_being_removed) if router_id_being_removed else []
                    
                    if links_restantes:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Ainda h√° {len(links_restantes)} link(s) ativo(s) com ID {router_id_being_removed}")
                        # Continuar no contexto de remo√ß√£o de links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Todos os links com ID {router_id_being_removed} foram removidos")
                        # Limpar flags do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        self._removing_associated_links = False
                        self._router_id_being_removed = None
                        # Voltar √† interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Voltando √† interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] ERRO: Link n√£o encontrado no invent√°rio")
                    # Em caso de erro, voltar ao invent√°rio
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao confirmar remo√ß√£o: {e}")
                # Em caso de erro, voltar ao invent√°rio
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Cancelando remo√ß√£o do link")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Bot√µes No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao_link)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao_link)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Overlay de confirma√ß√£o de remo√ß√£o de link criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def _find_active_links_with_same_id(self, router_id):
        """Encontra links ativos com o mesmo specific_id do router removido"""
        try:
            links_ativos = []
            
            # Verificar equipments ativos
            for carta_path in self.active_equipments:
                if self._is_link_card(carta_path):
                    link_id = self._get_equipment_specific_id(carta_path)
                    if str(link_id) == str(router_id):
                        links_ativos.append(carta_path)
                        print(f"DEBUG: [FIND_ACTIVE_LINKS] Link ativo encontrado: {os.path.basename(carta_path)} com ID {link_id}")
            
            return links_ativos
        except Exception as e:
            print(f"DEBUG: [FIND_ACTIVE_LINKS] Erro ao procurar links ativos: {e}")
            return []

    def _is_link_card(self, carta_path):
        """Verifica se uma carta √© do tipo Link (Short Link ou Long Link)"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_7.png" -> "equipment_7")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    equipment_id = f"equipment_{match.group(1)}"
                    equipment_card = self.card_database.get_equipment(equipment_id)
                    
                    if equipment_card:
                        return equipment_card.category == "Link"
            
            # Fallback: verificar pelo n√∫mero da carta
            # Equipment_7 a Equipment_12 s√£o Links
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                return 7 <= card_num <= 12
                
        except Exception as e:
            print(f"DEBUG: [IS_LINK_CARD] Erro ao verificar se carta √© link: {e}")
        
        return False

    def _get_equipment_specific_id(self, carta_path):
        """Obt√©m o specific_id de uma carta de equipment da base de dados"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_2.png" -> "2")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    card_num = int(match.group(1))
                    
                    # Mapear n√∫mero da carta para equipment_id na base de dados
                    if 1 <= card_num <= 3:
                        # Small Router
                        equipment_id = f"small_router_{card_num}_red"  # Usar cor gen√©rica
                    elif 4 <= card_num <= 6:
                        # Medium Router
                        equipment_id = f"medium_router_{card_num-3}_red"  # Usar cor gen√©rica
                    elif 7 <= card_num <= 9:
                        # Short Link
                        equipment_id = f"short_link_{card_num-6}_red"  # Usar cor gen√©rica
                    elif 10 <= card_num <= 12:
                        # Long Link
                        equipment_id = f"long_link_{card_num-9}_red"  # Usar cor gen√©rica
                    else:
                        equipment_id = None
                    
                    if equipment_id:
                        equipment_card = self.card_database.get_equipment(equipment_id)
                        
                        if equipment_card:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment {equipment_id} specific_id: {equipment_card.specific_id}")
                            return equipment_card.specific_id
                        else:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment n√£o encontrado na base de dados: {equipment_id}")
                    else:
                        print(f"DEBUG: [SPECIFIC_ID] N√∫mero de carta inv√°lido: {card_num}")
                else:
                    print(f"DEBUG: [SPECIFIC_ID] Erro ao extrair ID do filename: {filename}")
        except Exception as e:
            print(f"DEBUG: [SPECIFIC_ID] Erro ao obter specific_id: {e}")
        
        # Fallback: extrair specific_id baseado no n√∫mero da carta
        try:
            import re
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                # Calcular specific_id baseado no mapeamento
                if 1 <= card_num <= 3:
                    return card_num  # Small Router: 1, 2, 3
                elif 4 <= card_num <= 6:
                    return card_num - 3  # Medium Router: 1, 2, 3
                elif 7 <= card_num <= 9:
                    return card_num - 6  # Short Link: 1, 2, 3
                elif 10 <= card_num <= 12:
                    return card_num - 9  # Long Link: 1, 2, 3
        except:
            pass
        
        return "N/A"

    def _voltar_ao_inventario_equipments(self, tipos, page):
        """M√©todo auxiliar para voltar ao invent√°rio de equipments com TopBar"""
        try:
            # Recriar a TopBar
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [REMOVE_ROUTER_CONFIRM] TopBar recriada")
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao recriar TopBar: {e}")
            
            # Voltar para a p√°gina de invent√°rio
            self.show_inventory_matrix(tipos, page)
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO CR√çTICO no fallback: {e}")
            # √öltima tentativa: voltar √† interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    # Corrigir aceita√ß√£o de carta Challenge/Activity para adicionar ao carrossel
    def aceitar_carta_challenge_activity(self, carta_path, carta_tipo):
        # Chamar isto ao aceitar uma carta Challenge/Activity
        
        # CORRE√á√ÉO CR√çTICA: Registar turno de in√≠cio se for Challenge
        if carta_tipo == 'challenges' or 'Challenge' in os.path.basename(carta_path):
            # CORRE√á√ÉO CR√çTICA RASPBERRY PI: Detectar se estamos em ambiente Pi e ajustar turno se necess√°rio
            universal_paths = get_universal_paths()
            is_raspberry_pi = universal_paths['environment'] == 'raspberry_pi'
            
            # CORRE√á√ÉO ESPEC√çFICA: Se no Pi o turno parece estar 1 √† frente do esperado, ajustar
            turno_aceitacao = self._current_turn_number
            
            if is_raspberry_pi:
                # No Raspberry Pi, verificar se o turno atual parece estar incrementado demais
                # Corre√ß√£o para Raspberry Pi: garantir que o turno registado √© o turno atual real
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Turno atual: {turno_aceitacao}")
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Mantendo turno correto para registo")
                
                # CORRE√á√ÉO: No Raspberry Pi, usar o turno atual tal como est√°
                # O problema anterior era que est√°vamos a subtrair 1, causando registo incorreto
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - TURNO MANTIDO: {turno_aceitacao}")
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Challenge ser√° registado com turno {turno_aceitacao}")
            
            self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
            print(f"DEBUG: [aceitar_carta_challenge_activity] Challenge {os.path.basename(carta_path)} registado para turno {turno_aceitacao} (original: {self._current_turn_number})")
        
        self.adicionar_carta_carrossel(carta_path, carta_tipo)
        # ... resto do fluxo de aceita√ß√£o ...
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_link_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirma√ß√£o espec√≠fica para upgrade de link no contexto LINK UPGRADE"""
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Mostrando confirma√ß√£o de upgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Ok clicado - executando upgrade com detec√ß√£o YOLO")
            self._executar_link_upgrade(carta_path, link_id)
        
        # Apenas bot√£o Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Overlay de confirma√ß√£o de upgrade criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    def show_link_downgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirma√ß√£o espec√≠fica para downgrade de link no contexto LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Mostrando confirma√ß√£o de downgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o m√°ximo poss√≠vel da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter refer√™ncia
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirma√ß√£o (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # T√≠tulo
        tk.Label(confirm_frame, text="Link Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os bot√µes
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Confirmando downgrade do link {link_id}")
            try:
                # Mapeamento: Short Link -> Long Link
                equipment_mapping = {
                    1: ("Equipment_7.png", "Equipment_10.png"),   # Short Link 1 -> Long Link 1
                    2: ("Equipment_8.png", "Equipment_11.png"),   # Short Link 2 -> Long Link 2
                    3: ("Equipment_9.png", "Equipment_12.png"),   # Short Link 3 -> Long Link 3
                }
                
                if link_id not in equipment_mapping:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Link ID {link_id} n√£o suportado")
                    return
                
                short_link, long_link = equipment_mapping[link_id]
                
                # Verificar se o jogador j√° tem o Long Link correspondente no invent√°rio
                equipments_inventory = self.inventario.get("equipments", [])
                long_link_exists = any(os.path.basename(eq) == long_link for eq in equipments_inventory)
                
                if long_link_exists:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ERROR: {long_link} j√° existe no invent√°rio - downgrade n√£o aplicado")
                    # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Short Link do invent√°rio
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link removido do invent√°rio")
                    
                    # Construir caminho para Long Link (usar mesma estrutura de diret√≥rio)
                    base_dir = os.path.dirname(carta_path)
                    long_link_path = os.path.join(base_dir, long_link)
                    
                    # Adicionar Long Link ao invent√°rio (fica inativo por padr√£o)
                    self.inventario["equipments"].append(long_link_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] {long_link} adicionado ao invent√°rio (inativo)")
                    
                    # Enviar Short Link para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao enviar Short Link para Store: {e}")
                    
                    # Limpar flags do contexto LINK DOWNGRADE
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    
                    # Voltar √† p√°gina de invent√°rio de Equipments
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] SUCCESS: Link Downgrade aplicado com sucesso!")
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Voltando √† p√°gina de invent√°rio de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ERRO: Short Link n√£o encontrado no invent√°rio")
                    # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOT√ÉO BACK quando Ok √© clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar √† p√°gina de invent√°rio de Equipments
                self._in_link_downgrade_context = False
                self._link_downgrade_target_id = None
                # REABILITAR BOT√ÉO BACK quando Ok √© clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [LINK_DOWNGRADE] Bot√£o Back REABILITADO ap√≥s clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas bot√£o Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Overlay de confirma√ß√£o de downgrade criado")
        
        # Force update para garantir que os bot√µes est√£o vis√≠veis
        self.update_idletasks()
        self.update()

    # Corrigir fullscreen do carrossel: bot√£o X volta sempre √† interface principal
    def show_card_fullscreen_carrossel(self, carta_path):
        print(f"DEBUG: [FULLSCREEN] === FUN√á√ÉO show_card_fullscreen_carrossel CHAMADA ===")
        print(f"DEBUG: [FULLSCREEN] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [FULLSCREEN] Caminho completo: {carta_path}")
        
        # CORRE√á√ÉO CR√çTICA: Salvar estado da interface ANTES de destruir widgets
        print(f"DEBUG: [FULLSCREEN] === SALVANDO ESTADO ANTES DE FULLSCREEN ===")
        self._save_dashboard_state()
        
        # Preservar valores das barras de progresso ANTES de destruir os widgets
        saved_progress_values = {}
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            try:
                for stat in self.progress_bars:
                    # Verificar se o widget ainda existe antes de acessar seus valores
                    if self.progress_bars[stat].winfo_exists():
                        saved_progress_values[stat] = {
                            'value': self.progress_bars[stat]['value'],
                            'maximum': self.progress_bars[stat]['maximum']
                        }
                print(f"DEBUG: Valores das barras preservados antes de fullscreen: {saved_progress_values}")
            except Exception as e:
                print(f"DEBUG: Erro ao preservar valores das barras: {e}")
        
        # CORRE√á√ÉO CR√çTICA: Usar estado salvo da dashboard em vez de verificar widgets atuais
        # Os widgets podem ter sido recriados ou removidos entre o salvamento do estado e o fullscreen
        botoes_plus_visiveis = {
            'rxd_visivel': False,
            'lost_visivel': False
        }
        botao_seta_visivel = False
        
        # Verificar se temos estado salvo da dashboard
        if hasattr(self, '_saved_dashboard_state'):
            state = self._saved_dashboard_state
            controles_estavam_visiveis = state.get('controles_gestao_visiveis', False)
            seta_estava_visivel = state.get('botao_seta_visivel', False)
            
            # NOVA L√ìGICA: Usar flags espec√≠ficas dos bot√µes se dispon√≠veis
            btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
            btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [FULLSCREEN] Estado salvo da dashboard:")
            print(f"DEBUG: [FULLSCREEN]   controles_gestao_visiveis: {controles_estavam_visiveis}")
            print(f"DEBUG: [FULLSCREEN]   botao_seta_visivel: {seta_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_seta_visivel: {btn_seta_estava_visivel}")
            
            # Priorizar flags espec√≠ficas sobre flags gen√©ricas
            if btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel:
                botoes_plus_visiveis = {
                    'rxd_visivel': btn_plus_rxd_estava_visivel,
                    'lost_visivel': btn_plus_lost_estava_visivel
                }
                print(f"DEBUG: [FULLSCREEN] Usando flags espec√≠ficas dos bot√µes +")
            elif controles_estavam_visiveis:
                # Fallback para l√≥gica anterior
                botoes_plus_visiveis = {
                    'rxd_visivel': True,
                    'lost_visivel': True
                }
                print(f"DEBUG: [FULLSCREEN] Usando flag gen√©rica - assumindo ambos os bot√µes + ativos")
            
            # Para bot√£o seta, priorizar flag espec√≠fica
            if btn_seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Bot√£o seta estava vis√≠vel (flag espec√≠fica)")
            elif seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Bot√£o seta estava vis√≠vel (flag gen√©rica)")
        else:
            print(f"DEBUG: [FULLSCREEN] WARNING: Estado da dashboard n√£o encontrado - usando detec√ß√£o de widgets atual")
            # Fallback para detec√ß√£o atual se n√£o temos estado salvo
            botoes_plus_visiveis = {
                'rxd_visivel': hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None and self._btn_plus_rxd.winfo_exists(),
                'lost_visivel': hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None and self._btn_plus_lost.winfo_exists()
            }
            botao_seta_visivel = hasattr(self, '_btn_seta') and self._btn_seta is not None and self._btn_seta.winfo_exists()
        
        print(f"DEBUG: [FULLSCREEN] Estado FINAL dos bot√µes + preservado: {botoes_plus_visiveis}")
        print(f"DEBUG: [FULLSCREEN] Estado FINAL do bot√£o seta preservado: {botao_seta_visivel}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Bot√£o X para fechar - canto superior esquerdo (cinza)
        def voltar_dashboard():
            print(f"DEBUG: [FULLSCREEN X] Iniciando retorno do fullscreen para dashboard")
            print(f"DEBUG: [FULLSCREEN X] Estado preservado: gestao_ativa={getattr(self, '_final_phase_gestao_ativa', False)}")
            
            # Preservar sele√ß√£o da carta do carrossel ao voltar do fullscreen
            selected_carta = getattr(self, 'selected_carousel_card', None)
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [FULLSCREEN X] Recriando interface principal...")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # Restaurar sele√ß√£o da carta ap√≥s recriar interface
            if selected_carta is not None and selected_index is not None:
                self.selected_carousel_card = selected_carta
                self.selected_carousel_index = selected_index
                print(f"DEBUG: [FULLSCREEN X] Sele√ß√£o da carta restaurada: √≠ndice {selected_index}")
            
            # RESTAURAR ESTADO USANDO O SISTEMA NOVO DE CAPTURA IMEDIATA
            print(f"DEBUG: [FULLSCREEN X] Chamando _restore_dashboard_state()...")
            self._restore_dashboard_state()
            
            # Restaurar valores das barras de progresso ap√≥s recriar interface
            if saved_progress_values and hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                for stat, values in saved_progress_values.items():
                    if stat in self.progress_bars and stat in self.progress_labels:
                        self.progress_bars[stat]['maximum'] = values['maximum']
                        self.progress_bars[stat]['value'] = values['value']
                        self.progress_labels[stat]['text'] = str(int(values['value']))
                print(f"DEBUG: [FULLSCREEN X] Valores das barras restaurados: {saved_progress_values}")
        x_btn = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_dashboard, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o Switch no canto superior direito com imagem switch_card.png
        # S√ì APARECE EM ACTIVITIES/CHALLENGES DURANTE NEXT PHASE (MAS N√ÉO DURANTE FINAL PHASE)
        # CORRE√á√ÉO PROBLEMA 2: Verificar tipo da carta para restringir funcionalidade
        switch_btn = None
        
        # Verificar se √© uma carta de Activity ou Challenge
        carta_name = os.path.basename(carta_path).lower()
        is_activity_or_challenge = ("activity" in carta_name or "challenge" in carta_name)
        is_activity_card = "activity" in carta_name
        is_challenge_card = "challenge" in carta_name
        next_phase_active = getattr(self, '_next_phase_active', False)
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICA√á√ÉO BOT√ÉO SWITCH ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] carta_name: {carta_name}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] final_phase_active: {final_phase_active}")
        
        # NOVA VERIFICA√á√ÉO: Verificar se h√° cartas dispon√≠veis para troca no invent√°rio
        has_available_cards_for_switch = False
        if is_activity_or_challenge and next_phase_active and not final_phase_active:
            # CORRE√á√ÉO: Para Activities no carrossel, verificar se h√° outras Activities no invent√°rio
            # Activity s√≥ pode trocar com Activity quando N√ÉO h√° Challenges no invent√°rio
            if is_activity_card:
                activity_cards = self.inventario.get("activities", [])
                challenge_cards = self.inventario.get("challenges", [])
                # APLICAR MESMA RESTRI√á√ÉO: Activity N√ÉO pode trocar se h√° Challenges no invent√°rio
                if len(challenge_cards) > 0:
                    has_available_cards_for_switch = False
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - N√ÉO pode trocar: h√° {len(challenge_cards)} Challenges no invent√°rio (restri√ß√£o Activity‚ÜíActivity)")
                else:
                    has_available_cards_for_switch = len(activity_cards) > 0
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - pode trocar: {len(activity_cards)} Activities no invent√°rio, 0 Challenges")
            
            # CORRE√á√ÉO CR√çTICA: Para Challenges no carrossel, verificar se h√° OUTRAS CHALLENGES no invent√°rio
            # Challenge s√≥ pode trocar com outra Challenge
            elif is_challenge_card:
                challenge_cards = self.inventario.get("challenges", [])
                has_available_cards_for_switch = len(challenge_cards) > 0
                print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge card - Challenges no invent√°rio: {len(challenge_cards)}, pode trocar: {has_available_cards_for_switch}")
        
        # RESTRI√á√ÉO: No Next Phase, s√≥ Activities podem ser trocadas (Challenges n√£o)
        # Challenges no carrossel devem ser apenas visualizadas, n√£o trocadas
        # MODIFICA√á√ÉO: Mostrar switch para Challenges tamb√©m, mas com funcionalidade limitada
        # NOVA RESTRI√á√ÉO: S√≥ mostrar switch se h√° cartas dispon√≠veis para troca
        should_show_switch = (is_activity_or_challenge and next_phase_active and 
                            not final_phase_active and has_available_cards_for_switch)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] has_available_cards_for_switch: {has_available_cards_for_switch}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] should_show_switch: {should_show_switch}")
        
        # Durante Final Phase, n√£o mostrar bot√£o Switch
        # Durante Next Phase, s√≥ mostrar para Activities (n√£o para Challenges)
        if should_show_switch:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    switch_btn = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    switch_btn.image = switch_img  # Manter refer√™ncia
                    
                    # NOVA FUNCIONALIDADE: Mover switch para canto inferior direito se √© Challenge (m√°ximo canto)
                    if is_challenge_card:
                        switch_btn.place(relx=1.0, rely=1.0, anchor="se")  # Canto inferior direito (m√°ximo canto poss√≠vel)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Bot√£o Switch posicionado no canto inferior direito (Challenge - m√°ximo canto)")
                    else:
                        switch_btn.place(relx=0.98, rely=0, anchor="ne")  # Canto superior direito (Activity)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Bot√£o Switch posicionado no canto superior direito (Activity)")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - imagem switch_card.png n√£o encontrada em {switch_img_path}")
            except Exception as e:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - erro ao carregar imagem: {e}")
        else:
            if not has_available_cards_for_switch:
                if is_challenge_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - N√£o h√° Activities no invent√°rio para trocar")
                elif is_activity_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - N√£o h√° Challenges no invent√°rio para trocar")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - Carta n√£o √© Activity nem Challenge")
            elif is_challenge_card and next_phase_active:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - Challenge n√£o pode ser trocada no Next Phase")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Bot√£o Switch N√ÉO criado - condi√ß√µes n√£o atendidas")
        
        # Configurar comando do bot√£o Switch (abrir invent√°rio para troca)
        def abrir_inventario_troca():
            # CORRE√á√ÉO PROBLEMA 2: Verifica√ß√µes de seguran√ßa adicionais
            print(f"DEBUG: [abrir_inventario_troca] Iniciando verifica√ß√µes para carta: {os.path.basename(carta_path)}")
            
            # Verificar se a carta atual n√£o √© uma carta virada para baixo
            if "back_card" in os.path.basename(carta_path).lower():
                print("DEBUG: [abrir_inventario_troca] ERROR: N√£o √© poss√≠vel trocar uma carta virada para baixo")
                return
            
            # NOVA VERIFICA√á√ÉO: S√≥ permitir troca se for Activity
            carta_basename = os.path.basename(carta_path).lower()
            if "challenge" in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ERROR: Challenges do carrossel n√£o podem ser trocadas no Next Phase")
                return
            
            if "activity" not in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ERROR: S√≥ Activities podem ser trocadas")
                return
            
            # Verificar se Next Phase est√° ativo
            if not getattr(self, '_next_phase_active', False):
                print("DEBUG: [abrir_inventario_troca] ERROR: Troca s√≥ permitida durante Next Phase")
                return
            
            print(f"DEBUG: [abrir_inventario_troca] SUCCESS: Verifica√ß√µes passaram - abrindo invent√°rio para troca")
            
            # Guardar a carta atual do carrossel para troca
            self.carta_carrossel_para_troca = carta_path
            # Encontrar o √≠ndice da carta no carrossel
            try:
                self.carrossel_idx_selecao = self.cards.index(carta_path)
                print(f"DEBUG: [abrir_inventario_troca] Carta encontrada no carrossel √≠ndice: {self.carrossel_idx_selecao}")
            except ValueError:
                print(f"DEBUG: [abrir_inventario_troca] WARNING:  Carta n√£o encontrada no carrossel - usando √≠ndice 0")
                self.carrossel_idx_selecao = 0
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        
        if switch_btn is not None:
            switch_btn.config(command=abrir_inventario_troca)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Bot√£o Switch configurado para abrir invent√°rio de troca")
        
        # NOVA FUNCIONALIDADE: Bot√£o Quit Challenge (canto superior direito, vermelho com unicode ‚úì)
        # CORRE√á√ÉO: Se Challenge na Final Phase, mostrar bot√£o completion em vez de quit
        quit_btn = None
        
        # Verificar se Challenge atingiu Final Phase (n_turns completos)
        challenge_na_final_phase = False
        if is_challenge_card:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge detectado - verificando Final Phase")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] === ESTADO COMPLETO DO SISTEMA ===")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge path: {carta_path}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge basename: {os.path.basename(carta_path)}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _current_turn_number: {self._current_turn_number}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _challenge_start_turns: {self._challenge_start_turns}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] dados_carta retornados: {dados_carta}")
            
            if dados_carta:
                n_turns = dados_carta.get('n_turns', 0)
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns da carta extra√≠do: {n_turns}")
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns tipo: {type(n_turns)}")
                
                if n_turns > 0:
                    # Verificar quantos turnos passaram desde que foi ativada
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === CALCULANDO TURNOS DECORRIDOS ===")
                    turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed retornado: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed tipo: {type(turns_elapsed)}")
                    
                    # COMPARA√á√ÉO CR√çTICA
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === COMPARA√á√ÉO CR√çTICA ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed >= n_turns: {turns_elapsed >= n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed > 1: {turns_elapsed > 1}")
                    
                    # CORRE√á√ÉO: Overlay s√≥ aparece quando completar n_turns E n√£o estar no turno de ativa√ß√£o
                    challenge_na_final_phase = (turns_elapsed >= n_turns) and (turns_elapsed > 1)
                    
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICA√á√ÉO FINAL PHASE CHALLENGE ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge: {os.path.basename(carta_path)}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns limite: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase (calculado): {challenge_na_final_phase}")
                    
                    # DETALHES ADICIONAIS PARA DEBUG
                    if carta_path in self._challenge_start_turns:
                        start_turn = self._challenge_start_turns[carta_path]
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Registo encontrado - Start turn: {start_turn}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] C√°lculo: {self._current_turn_number} - {start_turn} + 1 = {turns_elapsed}")
                    else:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] WARNING: SEM REGISTO DE IN√çCIO - usando turno padr√£o")
                    
                    # EXEMPLOS ESPEC√çFICOS PARA DEBUG
                    if "Challenge_12" in os.path.basename(carta_path) and n_turns == 2:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_12 (n_turns=2) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 2")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Est√° na Final Phase? {challenge_na_final_phase}")
                    
                    if "Challenge_13" in os.path.basename(carta_path) and n_turns == 4:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_13 (n_turns=4) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 4")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Est√° na Final Phase? {challenge_na_final_phase}")
                    
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge sem n_turns v√°lido ({n_turns})")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] N√£o foi poss√≠vel obter dados da carta Challenge")
        else:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] N√£o √© uma carta Challenge")
        
        # CORRE√á√ÉO: Remover completamente todos os bot√µes Challenge no fullscreen
        # Os bot√µes roxos (‚Üí) foram removidos conforme solicitado pelo utilizador
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === BOT√ïES CHALLENGE REMOVIDOS ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase: {challenge_na_final_phase}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Todos os bot√µes Challenge foram removidos do fullscreen")

    # --- Carrossel: come√ßa vazio e s√≥ adiciona Activities/Challenges aceites ---
    def adicionar_carta_carrossel(self, carta_path, carta_tipo):
        # CORRE√á√ÉO CR√çTICA: Remover duplo registo de Challenge
        # O tracking do Challenge j√° foi feito em aceitar_carta_challenge_activity
        # Este m√©todo deve apenas adicionar ao carrossel visual, n√£o registar novamente
        
        # Inicializar carrossel se n√£o existir
        if not hasattr(self, 'carrossel'):
            self.carrossel = []
            print("DEBUG: [CARROSSEL] self.carrossel inicializado como lista vazia")
        
        if carta_tipo in ["activities", "challenges"] and carta_path not in self.carrossel:
            self.carrossel.append(carta_path)
            print(f"DEBUG: [CARROSSEL] Carta adicionada √† lista: {os.path.basename(carta_path)}")
            
            # CORRE√á√ÉO: Reset dos valores quando carta √© adicionada ao carrossel
            posicao_carrossel = len(self.carrossel) - 1  # √öltima posi√ß√£o adicionada
            self._reset_card_values_on_activation(carta_path, posicao_carrossel)
            
            # CORRE√á√ÉO CR√çTICA: N√ÉO registar Challenge novamente aqui!
            # O tracking j√° foi feito em aceitar_carta_challenge_activity
            if carta_tipo == "challenges":
                print(f"DEBUG: [CARROSSEL] Challenge {os.path.basename(carta_path)} TRACKING J√Å FEITO - n√£o registar novamente")
                print(f"DEBUG: [CARROSSEL] Tracking atual: {self._challenge_start_turns}")
            
            self.atualizar_carrossel()

    def atualizar_carrossel(self):
        # Atualiza o carrossel para mostrar apenas as cartas em self.carrossel
        # (Implementa√ß√£o depende do teu m√©todo atual, mas deve usar self.carrossel)
        pass

    # No m√©todo onde o jogador aceita uma carta de Activities ou Challenges:
    # Chamar self.adicionar_carta_carrossel(carta_path, carta_tipo)
    
    def _check_user_inventory_for_carousel_access(self):
        """
        Verifica que User IDs o jogador tem no invent√°rio e se est√£o virados para cima (ativos ou vis√≠veis).
        User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
        Durante Next Phase, s√≥ conta cartas User que estejam viradas para cima.
        """
        user_ids = []
        user_cards = self.inventario.get("users", [])
        next_phase_active = getattr(self, '_next_phase_active', False)
        
        for carta_path in user_cards:
            carta_name = os.path.basename(carta_path)
            if carta_name.startswith("User_") and carta_name.endswith(".png"):
                try:
                    # Extrair n√∫mero do nome: User_2.png -> 2
                    numero_str = carta_name.replace("User_", "").replace(".png", "")
                    numero = int(numero_str)
                    
                    # Verificar se a carta est√° virada para cima
                    is_face_up = False
                    if numero == 1:
                        # User_1.png sempre virada para cima
                        is_face_up = True
                    elif next_phase_active:
                        # Durante Next Phase, verificar se a carta est√° ativa (virada para cima)
                        is_face_up = self.is_card_active(carta_path, "users")
                    else:
                        # Antes de Next Phase, todas as cartas (exceto User_1) est√£o viradas para baixo
                        is_face_up = False
                    
                    # S√≥ adicionar √† lista se estiver virada para cima
                    if is_face_up:
                        # User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
                        user_id = numero - 1
                        if user_id >= 1:  # User ID come√ßa em 1
                            user_ids.append(user_id)
                            print(f"DEBUG: User_{numero}.png ATIVO - User ID {user_id} dispon√≠vel para carrossel")
                    else:
                        print(f"DEBUG: User_{numero}.png INATIVO - User ID n√£o dispon√≠vel para carrossel")
                        
                except (ValueError, IndexError):
                    continue
        
        # Cache dos User IDs para performance
        self._cached_user_ids = sorted(user_ids)
        print(f"DEBUG: User IDs ativos/vis√≠veis encontrados no invent√°rio: {self._cached_user_ids}")
        return self._cached_user_ids
    
    def _can_access_carousel_position(self, carrossel_idx):
        """
        Verifica se o jogador pode aceder a uma posi√ß√£o espec√≠fica do carrossel durante Next Phase.
        S√≥ pode clicar numa carta virada para baixo se tiver o User ID correspondente.
        Posi√ß√£o 0 (primeira carta da esquerda) requer User ID 1, posi√ß√£o 1 requer User ID 2, etc.
        """
        if not getattr(self, '_next_phase_active', False):
            # Se Next Phase n√£o est√° ativo, pode aceder a qualquer posi√ß√£o
            return True
        
        # Durante Next Phase, verificar se tem o User ID necess√°rio
        required_user_id = carrossel_idx + 1  # Posi√ß√£o 0 -> User ID 1, posi√ß√£o 1 -> User ID 2, etc.
        user_ids = self._check_user_inventory_for_carousel_access()
        
        can_access = required_user_id in user_ids
        print(f"DEBUG: Posi√ß√£o {carrossel_idx} requer User ID {required_user_id}, tem acesso: {can_access}")
        return can_access
    
    def _has_valid_carousel_positions(self):
        """
        Verifica se h√° posi√ß√µes v√°lidas no carrossel onde o jogador pode colocar cartas.
        Durante Next Phase, s√≥ pode colocar cartas em posi√ß√µes que correspondem a User IDs ativos.
        """
        next_phase_active = getattr(self, '_next_phase_active', False)
        print(f"DEBUG: [_has_valid_carousel_positions] === INICIANDO VERIFICA√á√ÉO ===")
        print(f"DEBUG: [_has_valid_carousel_positions] Next Phase ativo: {next_phase_active}")
        
        if not next_phase_active:
            # Se Next Phase n√£o est√° ativo, sempre pode colocar cartas
            print(f"DEBUG: [_has_valid_carousel_positions] Next Phase INATIVO - retornando True")
            return True
        
        # Durante Next Phase, verificar se h√° pelo menos uma posi√ß√£o acess√≠vel
        user_ids = self._check_user_inventory_for_carousel_access()
        print(f"DEBUG: [_has_valid_carousel_positions] User IDs dispon√≠veis: {user_ids}")
        
        # Verificar se h√° cartas viradas para baixo em posi√ß√µes com User IDs correspondentes
        valid_positions_found = False
        for i, carta_path in enumerate(self.cards):
            carta_basename = os.path.basename(carta_path)
            is_back_card = carta_basename.startswith("back_card_")
            required_user_id = i + 1  # Posi√ß√£o 0 -> User ID 1, etc.
            has_user_id = required_user_id in user_ids
            
            print(f"DEBUG: [_has_valid_carousel_positions] Pos {i}: '{carta_basename}' -> back_card: {is_back_card}, req_user_id: {required_user_id}, has_user: {has_user_id}")
            
            if is_back_card and has_user_id:
                print(f"DEBUG: [_has_valid_carousel_positions] SUCCESS: Posi√ß√£o {i} V√ÅLIDA para User ID {required_user_id}")
                valid_positions_found = True
        
        if not valid_positions_found:
            print("DEBUG: [_has_valid_carousel_positions] ERROR: NENHUMA posi√ß√£o v√°lida no carrossel")
        
        print(f"DEBUG: [_has_valid_carousel_positions] === RESULTADO: {valid_positions_found} ===")
        return valid_positions_found
    
    def _teste_adicionar_user_cards(self):
        """
        Fun√ß√£o de teste para adicionar cartas User/Equipment/Service ao invent√°rio para testar o sistema de ativa√ß√£o.
        Esta fun√ß√£o pode ser removida em produ√ß√£o.
        """
        # Simular caminhos de cartas para teste (usar a cor do player)
        color_name = self.player_color.capitalize()  # Red, Blue, Green, Yellow
        
        test_cards = {
            "users": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_2.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_3.png",
            ],
            "equipments": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_2.png",
            ],
            "services": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_2.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_5.png",
            ]
        }
        
        # Adicionar ao invent√°rio para teste
        for card_type, card_paths in test_cards.items():
            for carta_path in card_paths:
                if os.path.exists(carta_path) and carta_path not in self.inventario[card_type]:
                    self.inventario[card_type].append(carta_path)
                    print(f"DEBUG: [TESTE] Carta {card_type} adicionada ao invent√°rio: {os.path.basename(carta_path)}")
        
        # Atualizar cache e destaques se necess√°rio
        self._check_user_inventory_for_carousel_access()
        # IMPORTANTE: S√≥ atualizar destaques se estivermos na interface principal e Next Phase estiver ativo
        # Evita erro de widgets destru√≠dos durante transi√ß√µes
        if (getattr(self, '_next_phase_active', False) and 
            hasattr(self, 'card_labels') and 
            self.card_labels and 
            not getattr(self, '_inventory_opening', False)):
            try:
                self._update_carousel_highlights()
            except Exception as e:
                print(f"DEBUG: [TESTE] Erro ao atualizar destaques do carrossel: {e}")
        
        print(f"DEBUG: [TESTE] Invent√°rio atual ap√≥s adicionar cartas de teste:")
        for tipo, cartas in self.inventario.items():
            if cartas:
                print(f"DEBUG: [TESTE]   {tipo}: {len(cartas)} cartas")
                for carta in cartas[:3]:  # Mostrar primeiras 3
                    print(f"DEBUG: [TESTE]     - {os.path.basename(carta)}")
        
        print(f"DEBUG: [TESTE] Estado inicial das cartas ativas:")
        print(f"DEBUG: [TESTE]   Users ativos: {[os.path.basename(c) for c in self.active_users]} (m√°x: {self.max_users})")
        print(f"DEBUG: [TESTE]   Equipments ativos: {[os.path.basename(c) for c in self.active_equipments]} (sem limite)")
        print(f"DEBUG: [TESTE]   Services ativos: {[os.path.basename(c) for c in self.active_services]} (sem limite)")
        print(f"DEBUG: [TESTE] NOTA: Ativa√ß√£o s√≥ funciona ap√≥s clicar 'Next Phase'")
        print(f"DEBUG: [TESTE] Invent√°rio Users atual: {[os.path.basename(c) for c in self.inventario['users']]}")
    
    def _update_carousel_highlights(self):
        """
        Atualiza os destaques roxos das cartas do carrossel baseado nos User IDs dispon√≠veis.
        Chama esta fun√ß√£o quando Next Phase √© ativado ou quando o invent√°rio de Users muda.
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: _update_carousel_highlights - card_labels n√£o existe ou est√° vazio, saltando atualiza√ß√£o")
            return
        
        # Usar a fun√ß√£o de sele√ß√£o que j√° inclui a l√≥gica de User IDs
        self._update_carousel_selection_highlights()
    
    def _debug_force_highlight_update(self):
        """
        Fun√ß√£o de debug para for√ßar atualiza√ß√£o dos destaques do carrossel.
        √ötil para testar o sistema manualmente.
        """
        print("DEBUG: [FOR√áA] For√ßando atualiza√ß√£o dos destaques do carrossel...")
        self._check_user_inventory_for_carousel_access()
        self._update_carousel_highlights()
        print("DEBUG: [FOR√áA] Atualiza√ß√£o dos destaques conclu√≠da")



    def abrir_inventario_para_carrossel(self, carrossel_idx):
        # Verificar se estamos numa casa onde podemos vender Activities ou Challenges
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # PROTE√á√ÉO CONTRA LOOP: Se j√° estamos a mostrar invent√°rio, n√£o abrir novamente
        if getattr(self, '_inventory_opening', False):
            return
        
        # BLOQUEIO DURANTE FINAL PHASE: N√£o permite abrir invent√°rio
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Abertura de invent√°rio BLOQUEADA durante Final Phase")
            return
        
        # CONTROLO DE ACESSO DURANTE NEXT PHASE
        if getattr(self, '_next_phase_active', False):
            if not self._can_access_carousel_position(carrossel_idx):
                print(f"DEBUG: Acesso negado √† posi√ß√£o {carrossel_idx} do carrossel durante Next Phase")
                return
        
        # IMPORTANTE: Se Next Phase est√° ativo, sempre abrir invent√°rio no modo Next Phase
        if getattr(self, '_next_phase_active', False):
            print("DEBUG: Next Phase ativo - abrindo invent√°rio no modo Next Phase")
            # Abre o invent√°rio de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        # Se estivermos numa casa Activities ou Challenges E Next Phase N√ÉO est√° ativo, mostrar invent√°rio para venda
        elif casa_atual_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Em casa {casa_atual_tipo} - abrindo invent√°rio para venda (Activities + Challenges)")
            self.show_inventory_matrix(["activities", "challenges"], page=0)
        else:
            # CORRE√á√ÉO: Sempre permitir acesso a Activities/Challenges para cartas viradas para baixo
            # mesmo que n√£o esteja numa casa Activities/Challenges - o controlo de venda √© feito dentro do invent√°rio
            print("DEBUG: Abrindo invent√°rio Activities/Challenges - acesso sempre permitido para cartas viradas para baixo")
            
            # NOVA RESTRI√á√ÉO: Verificar se √© tentativa de trocar Activity ativa por outra Activity
            carta_atual_carrossel = self.cards[carrossel_idx] if carrossel_idx < len(self.cards) else None
            
            if (carta_atual_carrossel and 
                "Activity" in os.path.basename(carta_atual_carrossel) and 
                len(self.inventario.get('challenges', [])) > 0):
                
                print("DEBUG: RESTRI√á√ÉO: N√£o √© poss√≠vel trocar Activity ativa enquanto houver Challenges no invent√°rio")
                self._mostrar_mensagem_restricao_activity()
                return
            
            # Abre o invent√°rio de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])

    def show_inventory_matrix_carrossel(self, tipos, page=0):
        print(f"DEBUG: show_inventory_matrix_carrossel chamado - tipos: {tipos}, page: {page}")
        
        # PROTE√á√ÉO CONTRA LOOP: Marcar que estamos a abrir invent√°rio
        self._inventory_opening = True
        
        # Invent√°rio em grelha 2x2 com navega√ß√£o por p√°ginas
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se n√£o, cri√°-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar n√£o existe no carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no carrossel")
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        else:
            title_str = "Activities / Challenges"
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # VERIFICAR SE √â ACTIVITIES/CHALLENGES PARA LAYOUT ESPECIAL EM COLUNAS
        if set(tipos) == set(["activities", "challenges"]):
            print("DEBUG: Activities/Challenges detectado - usando layout em colunas")
            
            # Separar cartas por tipo
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            print(f"DEBUG: Activities: {len(cartas_activities)} cartas, Challenges: {len(cartas_challenges)} cartas")
            
            # Pagina√ß√£o baseada no maior n√∫mero de cartas de qualquer tipo
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna 0 (esquerda)
            activities_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                carta_path = cartas_activities[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row, column=0, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Activity configurada para modo Next Phase na posi√ß√£o ({activities_row}, 0): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Activity adicionada na posi√ß√£o ({activities_row}, 0): {os.path.basename(carta_path)}")
                    
                    activities_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Activity {carta_path}")
                    continue
            
            # Colocar Challenges na coluna 1 (direita)
            challenges_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                carta_path = cartas_challenges[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row, column=1, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Challenge configurado para modo Next Phase na posi√ß√£o ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Challenge adicionado na posi√ß√£o ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    
                    challenges_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Challenge {carta_path}")
                    continue
            
            # Se n√£o h√° cartas em nenhuma das colunas
            if activities_row == 0 and challenges_row == 0:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas dispon√≠veis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.grid(row=0, column=0, columnspan=2, pady=20)
                print("DEBUG: Nenhuma carta de Activities/Challenges - adicionado label 'Sem cartas dispon√≠veis!'")
            
        else:
            # Layout normal para outros tipos (comportamento original)
            cartas = []
            for t in tipos:
                cartas += self.inventario.get(t, [])
            print(f"DEBUG: Cartas encontradas no invent√°rio: {len(cartas)} cartas")
            
            # Pagina√ß√£o
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            print(f"DEBUG: P√°gina {page}/{total_pages-1}, mostrando cartas {start_idx} a {end_idx-1}, cartas na p√°gina: {len(cartas_page)}")
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Reduzido para n√£o tapar o t√≠tulo
            
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                except Exception:
                    print(f"DEBUG: Erro ao carregar carta {carta_path}")
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Verificar se Next Phase est√° ativo para comportamento especial
                if getattr(self, '_next_phase_active', False):
                    # No modo Next Phase, primeira carta clicada vai direto para fullscreen com X e ‚úî
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                    print(f"DEBUG: Carta {idx} configurada para modo Next Phase na posi√ß√£o ({row}, {col}): {os.path.basename(carta_path)}")
                else:
                    # Comportamento normal - ir para sele√ß√£o do carrossel
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                    print(f"DEBUG: Carta {idx} adicionada na posi√ß√£o ({row}, {col}): {os.path.basename(carta_path)}")
            
            if not cartas_page:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas dispon√≠veis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.pack(pady=20)
                print("DEBUG: Nenhuma carta na p√°gina - adicionado label 'Sem cartas dispon√≠veis!'")
        
        # Setas de navega√ß√£o
        if total_pages > 1:
            # Coordenadas para alinhar as setas √† direita da grelha de cartas
            # Assume que a grelha est√° centrada em relx=0.5, ent√£o relx=0.85 fica √† direita
            seta_x = 0.90
            # Seta para cima (‚ñ≤) - parte superior direita da grelha
            if page > 0:
                seta_cima = tk.Button(self, text="‚ñ≤", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page-1))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
                print("DEBUG: Seta para cima adicionada")
            # Seta para baixo (‚ñº) - parte inferior direita da grelha
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="‚ñº", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page+1))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
                print("DEBUG: Seta para baixo adicionada")
        
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X √© a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra colorida se a imagem n√£o existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Bot√£o Back centrado na parte inferior - criado ap√≥s a barra para ficar por cima
        def back_to_dashboard_carrossel():
            # PROTE√á√ÉO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
            self._inventory_opening = False
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard_carrossel)
        back_btn.place(relx=0.5, rely=0.98, anchor="s")

        # Saldo no canto inferior direito - criado ap√≥s para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))
        
        print(f"DEBUG: show_inventory_matrix_carrossel terminado com sucesso")

    def show_card_fullscreen_carrossel_selecao(self, carta_path, tipos, page=0):
        # Mostra carta em fullscreen com bot√µes ‚úî (aceitar) e ‚úñ (cancelar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se n√£o, cri√°-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar n√£o existe no fullscreen carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen carrossel")
        
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Bot√£o ‚úñ canto superior esquerdo - volta para p√°gina de invent√°rio
        def voltar_inventario():
            self.show_inventory_matrix_carrossel(tipos, page)
        btn_x = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        # Bot√£o Switch canto superior direito (APENAS se N√ÉO for Activities vend√°vel)
        # Para Activities vend√°veis, o bot√£o ‚úî ir√° ocupar esta posi√ß√£o
        carta_tipo_temp = "challenges"  # Valor padr√£o
        if set(tipos) == set(["activities", "challenges"]):
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo_temp = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo_temp = "challenges"
        
        # Verificar se √© Activities vend√°vel
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        activities_vendavel = (carta_tipo_temp == "activities" and 
                              not getattr(self, '_next_phase_active', False) and 
                              casa_atual_tipo == "activities")
        
        # S√≥ criar bot√£o Switch se N√ÉO for Activities vend√°vel E se Next Phase estiver ativo E com posi√ß√µes v√°lidas
        next_phase_active = getattr(self, '_next_phase_active', False)
        has_valid_positions = self._has_valid_carousel_positions()
        
        print(f"DEBUG: [CARROSSEL] VERIFICA√á√ÉO SWITCH PRINCIPAL:")
        print(f"DEBUG: [CARROSSEL]   activities_vendavel: {activities_vendavel}")
        print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
        
        if not activities_vendavel and next_phase_active and has_valid_positions:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    btn_switch_carrossel.image = switch_img  # Manter refer√™ncia
                    btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                    
                    # CORRE√á√ÉO: Aplicar a mesma l√≥gica de detec√ß√£o de substitui√ß√£o
                    def switch_com_detecao_substituicao():
                        print("DEBUG: [CARROSSEL_SELECAO] Verificando se vai substituir carta no carrossel")
                        
                        # Detectar posi√ß√£o de destino
                        posicao_destino = self.carrossel_idx_selecao
                        if posicao_destino is None:
                            # Se n√£o h√° sele√ß√£o espec√≠fica, usar primeira posi√ß√£o acess√≠vel
                            for i in range(len(self.cards)):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                        
                        # Verificar se a posi√ß√£o de destino cont√©m uma carta real (n√£o back_card)
                        vai_substituir_carta = False
                        if posicao_destino is not None and posicao_destino < len(self.cards):
                            carta_na_posicao_destino = self.cards[posicao_destino]
                            vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                        
                        if vai_substituir_carta:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai substituir carta existente - mostrando overlay de confirma√ß√£o")
                            self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                        else:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai colocar em posi√ß√£o vazia - indo diretamente para aceitar carta")
                            self.aceitar_carta_carrossel(carta_path, tipos, page)
                    
                    btn_switch_carrossel.config(command=switch_com_detecao_substituicao)
                    print(f"DEBUG: [CARROSSEL] SUCCESS: Bot√£o Switch principal CRIADO - condi√ß√µes atendidas")
                else:
                    btn_switch_carrossel = None
                    print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch principal N√ÉO criado - imagem n√£o encontrada em {switch_img_path}")
            except Exception as e:
                btn_switch_carrossel = None
                print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch principal N√ÉO criado - erro ao carregar imagem: {e}")
        else:
            btn_switch_carrossel = None
            if activities_vendavel:
                print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch principal N√ÉO criado - Activities vend√°vel ir√° usar posi√ß√£o para bot√£o ‚úî")
            elif not next_phase_active:
                print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch principal N√ÉO criado - Next Phase N√ÉO ATIVO")
            elif not has_valid_positions:
                print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch principal N√ÉO criado - SEM posi√ß√µes v√°lidas no carrossel")
        
        # Adicionar l√≥gica de venda (igual ao show_card_fullscreen_inventory)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # IMPORTANTE: Se Next Phase estiver ativo, N√ÉO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: N√ÉO pode vender carta do carrossel - Next Phase est√° ativo (vendas desabilitadas)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            # Determinar o tipo da carta atual
            carta_tipo = None
            if len(tipos) == 1:
                carta_tipo = tipos[0]
            elif set(tipos) == set(["activities", "challenges"]):
                # Se √© uma p√°gina Activities/Challenges, determinar tipo pela carta espec√≠fica
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename or "activities" in carta_basename:
                    carta_tipo = "activities"
                elif "challenge" in carta_basename or "challenges" in carta_basename:
                    carta_tipo = "challenges"
                else:
                    # Tentar determinar pelo caminho da pasta
                    carta_dirname = os.path.dirname(carta_path).lower()
                    if "activities" in carta_dirname:
                        carta_tipo = "activities"
                    elif "challenges" in carta_dirname:
                        carta_tipo = "challenges"
            
            print(f"DEBUG: Verificando possibilidade de venda carrossel - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # Verificar se pode vender
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities s√≥ podem ser vendidas numa casa Activities, Challenges s√≥ numa casa Challenges
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
        
        # Adicionar l√≥gica de venda (igual ao show_card_fullscreen_inventory)
        # IMPORTANTE: Para Activities e Challenges, usar layout especial sem bot√£o picoin verde
        if pode_vender and carta_tipo not in ["activities", "challenges"]:
            print(f"DEBUG: Pode vender carta {carta_tipo} do carrossel - est√° numa casa {casa_atual_tipo}")
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((48,48)))
            def abrir_confirm():
                # Guardar informa√ß√µes para navega√ß√£o correta
                self._origem_venda = "carrossel"
                self._tipos_venda = tipos
                self._page_venda = page
                self._current_sell_page = page
                # CORRE√á√ÉO: Se viemos de um invent√°rio Activities/Challenges, guardar isso
                if set(tipos) == set(["activities", "challenges"]):
                    self._inventario_conjunto = True
                else:
                    self._inventario_conjunto = False
                print(f"DEBUG: Iniciando venda do carrossel - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
            btn_picoin = tk.Button(self, image=picoin_img, bg="#4CAF50", borderwidth=0, command=abrir_confirm, cursor="hand2")
            btn_picoin.image = picoin_img  # type: ignore[attr-defined]
            btn_picoin.place(relx=0, rely=1, anchor="sw")
        elif pode_vender and carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Carta {carta_tipo} pode ser vendida mas usa layout especial - bot√£o ‚úî j√° configurado acima")
        else:
            print(f"DEBUG: N√ÉO pode vender carta {carta_tipo} do carrossel - casa atual: {casa_atual_tipo}, necess√°rio: {carta_tipo}")
        
        # Para Activities e Challenges no carrossel, aplicar layout especial similar ao invent√°rio
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [CARROSSEL] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            
            # Para Activities que podem ser vendidas, reconfigurar o bot√£o Switch para venda
            if carta_tipo == "activities" and pode_vender:
                # Substituir comando do bot√£o Switch para abrir venda em vez de aceitar para carrossel
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informa√ß√µes para navega√ß√£o correta
                    self._origem_venda = "carrossel"
                    self._tipos_venda = tipos
                    self._page_venda = page
                    self._current_sell_page = page
                    # Se viemos de um invent√°rio Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._inventario_conjunto = True
                    else:
                        self._inventario_conjunto = False
                    print(f"DEBUG: [CARROSSEL] Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Criar bot√£o de venda adicional (‚úî) para Activities vend√°veis na mesma posi√ß√£o padr√£o
                btn_venda_activities = tk.Button(self, text="‚úî", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_venda_activities.place(relx=0.98, rely=0, anchor="ne")  # Posi√ß√£o consistente com invent√°rio
                btn_venda_activities.config(command=abrir_confirm_activities)
                print(f"DEBUG: [CARROSSEL] Bot√£o ‚úî criado para venda de Activities na posi√ß√£o padr√£o")
                
                # Reposicionar bot√£o Switch para baixo para n√£o conflitar
                # IMPORTANTE: S√ì APARECE DURANTE NEXT PHASE E COM POSI√á√ïES V√ÅLIDAS
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [CARROSSEL] VERIFICA√á√ÉO SWITCH ADICIONAL (Activities):")
                print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
                
                if next_phase_active and has_valid_positions:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_adicional = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_adicional.image = switch_img  # Manter refer√™ncia
                            btn_switch_adicional.place(relx=1, rely=1, anchor="se")
                            print(f"DEBUG: [CARROSSEL] SUCCESS: Bot√£o Switch adicional CRIADO - Next Phase ativo + posi√ß√µes v√°lidas")
                        else:
                            btn_switch_adicional = None
                            print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch adicional N√ÉO criado - imagem n√£o encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_adicional = None
                        print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch adicional N√ÉO criado - erro ao carregar imagem: {e}")
                else:
                    btn_switch_adicional = None
                    if not next_phase_active:
                        print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch adicional N√ÉO criado - Next Phase N√ÉO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [CARROSSEL] ERROR: Bot√£o Switch adicional N√ÉO criado - SEM posi√ß√µes v√°lidas no carrossel")
                
                def switch_action():
                    # CORRE√á√ÉO: Aplicar a mesma l√≥gica de detec√ß√£o de progresso
                    print("DEBUG: [CARROSSEL] Verificando progresso do carrossel para Switch adicional")
                    
                    # Verificar se temos cartas ativas no carrossel com progresso
                    carrossel_tem_progresso = False
                    if hasattr(self, 'cards') and hasattr(self, 'card_stats'):
                        for i, carta_carrossel in enumerate(self.cards):
                            if not os.path.basename(carta_carrossel).startswith("back_card_"):
                                # H√° carta ativa no carrossel - verificar se tem progresso
                                if i < len(self.card_stats):
                                    stats = self.card_stats[i]
                                    if stats.get('To send', 0) > 0 or stats.get('Rxd', 0) > 0 or stats.get('Lost', 0) > 0:
                                        carrossel_tem_progresso = True
                                        break
                    
                    if carrossel_tem_progresso:
                        print("DEBUG: [CARROSSEL] Carrossel tem progresso - mostrando overlay de confirma√ß√£o")
                        self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                    else:
                        print("DEBUG: [CARROSSEL] Carrossel sem progresso - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, tipos, page)
                
                if btn_switch_adicional is not None:
                    btn_switch_adicional.config(command=switch_action)
                    print(f"DEBUG: [CARROSSEL] Bot√£o Switch adicional configurado para Activities")
            
            # Para Challenges ou Activities que n√£o podem ser vendidas, manter comportamento original do Switch
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                print(f"DEBUG: [CARROSSEL] Bot√£o Switch mant√©m comportamento original para {carta_tipo} (aceitar no carrossel)")
        
        # BOT√ÉO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase) - INVENT√ÅRIO
        if carta_tipo == "challenges" and not getattr(self, '_next_phase_active', False):
            print(f"DEBUG: [CARROSSEL_INVENTARIO] Criando bot√£o Quit Challenge no canto superior direito")
            
            # Bot√£o vermelho com s√≠mbolo de check (‚úì) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="‚úì", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            
            # Posi√ß√£o espec√≠fica para invent√°rio - verificar se h√° bot√£o Switch no canto superior direito
            if btn_switch_carrossel is not None:
                # Se h√° bot√£o Switch, posicionar o quit Challenge ligeiramente abaixo
                btn_quit_challenge.place(relx=0.98, rely=0.08, anchor="ne")
            else:
                # Se n√£o h√° bot√£o Switch, posicionar no canto superior direito
                btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do bot√£o quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE_INVENTARIO] Iniciando confirma√ß√£o de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [CARROSSEL_INVENTARIO] SUCCESS: Bot√£o Quit Challenge criado no canto superior direito")

    def aceitar_carta_carrossel(self, carta_path, tipos, page=0):
        # NOVA RESTRI√á√ÉO: Verificar se √© tentativa de trocar Challenge por outra carta que n√£o seja Activity
        idx = getattr(self, 'carrossel_idx_selecao', 0)
        carta_carrossel_atual = getattr(self, 'carta_carrossel_para_troca', None)
        
        # CORRE√á√ÉO: Se carta_carrossel_atual √© None, verificar se √© uma posi√ß√£o back_card
        if carta_carrossel_atual is None and hasattr(self, 'cards') and idx < len(self.cards):
            carta_na_posicao = self.cards[idx]
            if os.path.basename(carta_na_posicao).startswith("back_card_"):
                carta_carrossel_atual = carta_na_posicao
                print(f"DEBUG: [aceitar_carta_carrossel] Posi√ß√£o {idx} √© back_card: {carta_carrossel_atual}")
        
        print(f"DEBUG: [aceitar_carta_carrossel] ===== INICIANDO VERIFICA√á√ÉO DE TROCA =====")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_path (invent√°rio): {carta_path}")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual: {carta_carrossel_atual}")
        print(f"DEBUG: [aceitar_carta_carrossel] carrossel_idx_selecao: {idx}")
        print(f"DEBUG: [aceitar_carta_carrossel] tipos: {tipos}")
        
        # IMPORTANTE: Verificar restri√ß√£o Activity antes de qualquer processamento
        is_inventario_activity = "Activity" in os.path.basename(carta_path)
        if is_inventario_activity:
            challenges_no_inventario = len(self.inventario.get('challenges', []))
            print(f"DEBUG: [aceitar_carta_carrossel] Tentativa de colocar Activity no carrossel")
            print(f"DEBUG: [aceitar_carta_carrossel] Challenges no invent√°rio: {challenges_no_inventario}")
            print(f"DEBUG: [aceitar_carta_carrossel] Lista de Challenges: {[os.path.basename(c) for c in self.inventario.get('challenges', [])]}")
            
            if challenges_no_inventario > 0:
                if carta_carrossel_atual:
                    is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                    if is_carrossel_activity:
                        print("DEBUG: RESTRI√á√ÉO ATIVADA: N√£o √© poss√≠vel trocar Activity ‚Üî Activity quando h√° Challenges no invent√°rio")
                        self._mostrar_mensagem_restricao_activity_activity()
                        return
                else:
                    print("DEBUG: RESTRI√á√ÉO ATIVADA: N√£o √© poss√≠vel colocar Activity no carrossel vazio quando h√° Challenges no invent√°rio")
                    self._mostrar_mensagem_restricao_activity_activity()
                    return
        
        if carta_carrossel_atual:
            # Verificar se √© uma carta back_card (posi√ß√£o vazia)
            is_back_card = os.path.basename(carta_carrossel_atual).startswith("back_card_")
            
            if is_back_card:
                print("DEBUG: [aceitar_carta_carrossel] Posi√ß√£o vazia (back_card) - fazendo coloca√ß√£o simples")
                # √â uma coloca√ß√£o em posi√ß√£o vazia, n√£o uma troca
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORRE√á√ÉO CR√çTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] COLOCA√á√ÉO - Flag posi√ß√£o {idx} atualizada para True (virada para cima)")
                
                # Inicializar card_stats para a carta nova
                print(f"DEBUG: [aceitar_carta_carrossel] COLOCA√á√ÉO - Inicializando card_stats para carta na posi√ß√£o {idx}")
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = new_stats
                        print(f"DEBUG: [aceitar_carta_carrossel] COLOCA√á√ÉO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                    else:
                        print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCA√á√ÉO - card_stats n√£o inicializado ou √≠ndice inv√°lido")
                except Exception as e:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCA√á√ÉO ao obter message_size: {e}")
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de in√≠cio
                if "Challenge" in os.path.basename(carta_path):
                    turno_aceitacao = self._current_turn_number
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Challenge aceite - registando turno {turno_aceitacao}")
                    self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
                
                # CORRE√á√ÉO PROBLEMA 2: SEMPRE resetar valores ao reativar carta no carrossel
                # Isto garante que To send = message_size, Rxd = 0, Lost = 0
                self._reset_card_values_on_activation(carta_path, idx)
                print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] CORRE√á√ÉO APLICADA - Carta sempre resetada ao reativar")
                
                # CORRE√á√ÉO CR√çTICA: Restaurar valores preservados se existirem
                # NOTA: Este c√≥digo ser√° substitu√≠do pelo reset acima para garantir comportamento consistente
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] IGNORANDO valores preservados - sempre resetar: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento mesmo assim
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do mapeamento de preservados")
                    
                    # Tamb√©m remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do backup root")
                
                # Remover carta do invent√°rio
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do invent√°rio {t}")
                        break
                
                print("DEBUG: Coloca√ß√£o conclu√≠da com sucesso!")
            else:
                # √â uma troca real entre duas cartas
                # Verificar tipos das cartas
                is_carrossel_challenge = "Challenge" in os.path.basename(carta_carrossel_atual)
                is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                is_inventario_challenge = "Challenge" in os.path.basename(carta_path)
                
                print(f"DEBUG: [aceitar_carta_carrossel] Verificando restri√ß√µes:")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel √© Challenge: {is_carrossel_challenge}")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel √© Activity: {is_carrossel_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Invent√°rio √© Activity: {is_inventario_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Invent√°rio √© Challenge: {is_inventario_challenge}")
                
                # RESTRI√á√ÉO 1: Challenge s√≥ pode ser trocado por Activity
                if is_carrossel_challenge and not is_inventario_activity:
                    print("DEBUG: RESTRI√á√ÉO: Challenge s√≥ pode ser trocado por Activity")
                    self._mostrar_mensagem_restricao_challenge_activity()
                    return
                
                # Fazer a troca entre a carta do carrossel e a carta selecionada do invent√°rio
                print(f"DEBUG: Fazendo troca - Carta do carrossel: {carta_carrossel_atual}")
                print(f"DEBUG: Carta do invent√°rio: {carta_path}")
                print(f"DEBUG: √çndice do carrossel: {idx}")
                
                # 1. Colocar a carta do invent√°rio no lugar da carta do carrossel
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORRE√á√ÉO CR√çTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] TROCA - Flag posi√ß√£o {idx} atualizada para True (virada para cima)")
                
                # CORRE√á√ÉO PROBLEMA 2: SEMPRE resetar valores ao reativar carta no carrossel (troca)
                # Isto garante que To send = message_size, Rxd = 0, Lost = 0
                self._reset_card_values_on_activation(carta_path, idx)
                print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] CORRE√á√ÉO APLICADA - Carta sempre resetada ao reativar (troca)")
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de in√≠cio
                if "Challenge" in os.path.basename(carta_path):
                    turno_aceitacao = self._current_turn_number
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] Challenge aceite - registando turno {turno_aceitacao}")
                    self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] Challenge registado para tracking: {os.path.basename(carta_path)}")
                
                # CORRE√á√ÉO CR√çTICA: IGNORAR valores preservados - sempre resetar
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] IGNORANDO valores preservados - sempre resetar: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento pois a carta est√° de volta ao carrossel
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do mapeamento de preservados")
                    
                    # Tamb√©m remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do backup root")
                
                # 2. Remover a carta do invent√°rio
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do invent√°rio {t}")
                        break
                
                # 3. Adicionar a carta que estava no carrossel ao invent√°rio (s√≥ se n√£o for back_card)
                if not is_back_card:
                    # Determinar o tipo da carta que estava no carrossel
                    carta_tipo_carrossel = None
                    
                    # Primeiro, verificar se a carta j√° estava no invent√°rio
                    for t in tipos:
                        if carta_carrossel_atual in self.inventario.get(t, []):
                            carta_tipo_carrossel = t
                            break
                    
                    # Se n√£o encontrou, tentar determinar pelo caminho da carta
                    if not carta_tipo_carrossel:
                        carta_basename = os.path.basename(carta_carrossel_atual).lower()
                        carta_dirname = os.path.dirname(carta_carrossel_atual).lower()
                        
                        # Verificar se o nome do arquivo ou pasta cont√©m o tipo
                        for t in tipos:
                            if t in carta_basename or t in carta_dirname:
                                carta_tipo_carrossel = t
                                break
                        
                        # √öltimo recurso: usar o primeiro tipo dispon√≠vel
                        if not carta_tipo_carrossel:
                            carta_tipo_carrossel = tipos[0]
                    
                    # Adicionar a carta do carrossel ao invent√°rio
                    if carta_tipo_carrossel in self.inventario:
                        self.inventario[carta_tipo_carrossel].append(carta_carrossel_atual)
                        print(f"DEBUG: Adicionada carta {carta_carrossel_atual} ao invent√°rio {carta_tipo_carrossel}")
                    else:
                        print(f"DEBUG: ERRO - Tipo {carta_tipo_carrossel} n√£o encontrado no invent√°rio")
                
                # 4. Limpar vari√°veis tempor√°rias
                self.carta_carrossel_para_troca = None
                
                if is_back_card:
                    print("DEBUG: Coloca√ß√£o em posi√ß√£o vazia conclu√≠da com sucesso!")
                else:
                    print("DEBUG: Troca conclu√≠da com sucesso!")
        else:
            print("DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual √© None - fazendo substitui√ß√£o normal")
            # Comportamento original - apenas substitui a carta virada para baixo
            self.cards[idx] = carta_path
            self.selected_card_idx = idx
            
            # CORRE√á√ÉO CR√çTICA: Inicializar card_stats com message_size correto para carta nova
            print(f"DEBUG: [aceitar_carta_carrossel] CORRE√á√ÉO - Inicializando card_stats para nova carta na posi√ß√£o {idx}")
            try:
                message_size = self._get_card_message_size_from_database(carta_path)
                new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = new_stats
                    print(f"DEBUG: [aceitar_carta_carrossel] CORRE√á√ÉO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                else:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO - card_stats n√£o inicializado ou √≠ndice inv√°lido")
            except Exception as e:
                print(f"DEBUG: [aceitar_carta_carrossel] ERRO ao obter message_size: {e}")
                # Fallback para valores padr√£o
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
            
            # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de in√≠cio
            if "Challenge" in os.path.basename(carta_path):
                turno_aceitacao = self._current_turn_number
                print(f"DEBUG: [ACEITAR_CARROSSEL_SUBSTITUICAO] Challenge aceite - registando turno {turno_aceitacao}")
                self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
            
            # CORRE√á√ÉO CR√çTICA: Restaurar valores preservados da Activity se existirem (SOBRESCREVE valores iniciais)
            if (hasattr(self, '_activity_preserved_stats') and 
                carta_path in self._activity_preserved_stats):
                
                preserved_stats = self._activity_preserved_stats[carta_path]
                # Atualizar card_stats com valores preservados (SOBRESCREVE os valores iniciais acima)
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {
                        "To send": preserved_stats["To send"],
                        "Rxd": preserved_stats["Rxd"],
                        "Lost": preserved_stats["Lost"]
                    }
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] SOBREPOSI√á√ÉO - Valores preservados restaurados para posi√ß√£o {idx}: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento pois a carta est√° de volta ao carrossel
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do mapeamento de preservados")
                    
                    # Tamb√©m remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do backup root")
            
            # Remover carta do invent√°rio activities/challenges
            for t in tipos:
                if carta_path in self.inventario.get(t, []):
                    self.inventario[t].remove(carta_path)
        
        # Voltar √† interface principal
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_card_fullscreen_next_phase_selection(self, carta_path, tipos, page=0):
        """
        Mostra carta em fullscreen no modo Next Phase com apenas X e ‚úî
        Usado quando Next Phase est√° ativo e o utilizador clica numa carta do invent√°rio
        """
        print(f"DEBUG: show_card_fullscreen_next_phase_selection chamado - Next Phase ativo")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se n√£o, cri√°-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar n√£o existe no fullscreen Next Phase, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen Next Phase")

        # Mostrar carta em fullscreen
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Bot√£o X no canto superior esquerdo - volta para a p√°gina de invent√°rio Activities/Challenges
        def voltar_inventario():
            print("DEBUG: Voltando para p√°gina de invent√°rio Activities/Challenges do modo Next Phase")
            self.show_inventory_matrix_carrossel(tipos, page)
        
        btn_x = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        
        # Bot√£o Switch no canto superior direito - aceita carta para o carrossel e vai para dashboard
        # APENAS se Final Phase N√ÉO estiver ativo
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        # VERIFICAR SE DEVE MOSTRAR BOT√ÉO SWITCH
        is_activity_card = "Activity" in os.path.basename(carta_path)
        is_challenge_card = "Challenge" in os.path.basename(carta_path)
        challenges_no_inventario = len(self.inventario.get('challenges', []))
        activities_no_inventario = len(self.inventario.get('activities', []))
        
        print(f"DEBUG: [NEXT PHASE] === VERIFICA√á√ÉO BOT√ÉO SWITCH ===")
        print(f"DEBUG: [NEXT PHASE] final_phase_active: {final_phase_active}")
        print(f"DEBUG: [NEXT PHASE] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [NEXT PHASE] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [NEXT PHASE] challenges_no_inventario: {challenges_no_inventario}")
        print(f"DEBUG: [NEXT PHASE] activities_no_inventario: {activities_no_inventario}")
        
        # L√≥gica de disponibilidade do bot√£o switch:
        # CORRE√á√ÉO: Verificar se h√° espa√ßos vazios no carrossel OU cartas para trocar
        # - Se h√° espa√ßos vazios (back_card) em posi√ß√µes acess√≠veis: sempre permitir
        # - Se n√£o h√° espa√ßos vazios: verificar se h√° cartas para trocar
        should_show_switch = False
        
        # Primeiro, verificar se h√° posi√ß√µes vazias acess√≠veis no carrossel
        has_empty_accessible_positions = False
        if hasattr(self, 'cards'):
            user_ids = self._check_user_inventory_for_carousel_access()
            for i, carta_path_carrossel in enumerate(self.cards):
                carta_basename = os.path.basename(carta_path_carrossel)
                is_back_card = carta_basename.startswith("back_card_")
                required_user_id = i + 1
                has_user_id = required_user_id in user_ids
                if is_back_card and has_user_id:
                    has_empty_accessible_positions = True
                    print(f"DEBUG: [NEXT PHASE] Posi√ß√£o {i} vazia e acess√≠vel (User ID {required_user_id})")
                    break
        
        print(f"DEBUG: [NEXT PHASE] has_empty_accessible_positions: {has_empty_accessible_positions}")
        
        # L√ìGICA CORRIGIDA: Activity N√ÉO pode mostrar switch quando h√° Challenges no invent√°rio
        # MESMO que haja posi√ß√µes vazias
        if is_activity_card and challenges_no_inventario > 0:
            should_show_switch = False
            print(f"DEBUG: [NEXT PHASE] ERROR: Activity N√ÉO pode mostrar switch - h√° {challenges_no_inventario} Challenges no invent√°rio (restri√ß√£o Activity‚ÜíActivity sempre aplicada)")
        elif has_empty_accessible_positions:
            # Se h√° posi√ß√µes vazias acess√≠veis E n√£o √© Activity com Challenges, permitir
            should_show_switch = True
            print(f"DEBUG: [NEXT PHASE] SUCCESS: H√° posi√ß√µes vazias acess√≠veis - bot√£o switch permitido (coloca√ß√£o)")
        else:
            # Se n√£o h√° posi√ß√µes vazias, verificar se h√° cartas para trocar
            if is_activity_card:
                # CORRE√á√ÉO: Activity pode trocar com outra Activity do invent√°rio OU com Activity do carrossel
                # Contar Activities totais (invent√°rio + carrossel)
                activities_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Activity" in os.path.basename(carta_carrossel):
                            activities_no_carrossel += 1
                
                total_activities = activities_no_inventario + activities_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Activities no invent√°rio: {activities_no_inventario}, no carrossel: {activities_no_carrossel}, total: {total_activities}")
                
                # Activity pode trocar se h√° pelo menos uma outra Activity (total > 1)
                if total_activities > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] SUCCESS: Activity com {total_activities} Activities dispon√≠veis (invent√°rio + carrossel) - bot√£o switch permitido (troca Activity‚ÜíActivity)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ERROR: Activity sem outras Activities para trocar (total: {total_activities}) - bot√£o switch N√ÉO criado")
            elif is_challenge_card:
                # CORRE√á√ÉO: Challenge pode trocar com outro Challenge do invent√°rio OU com Challenge do carrossel
                # Contar Challenges totais (invent√°rio + carrossel)
                challenges_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Challenge" in os.path.basename(carta_carrossel):
                            challenges_no_carrossel += 1
                
                total_challenges = challenges_no_inventario + challenges_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Challenges no invent√°rio: {challenges_no_inventario}, no carrossel: {challenges_no_carrossel}, total: {total_challenges}")
                
                # Challenge pode trocar se h√° pelo menos um outro Challenge (total > 1)
                if total_challenges > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] SUCCESS: Challenge com {total_challenges} Challenges dispon√≠veis (invent√°rio + carrossel) - bot√£o switch permitido (troca)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ERROR: Challenge sem outros Challenges para trocar (total: {total_challenges}) - bot√£o switch N√ÉO criado")
            else:
                print(f"DEBUG: [NEXT PHASE] ERROR: Carta n√£o √© Activity nem Challenge - bot√£o switch N√ÉO criado")
        
        # S√≥ criar bot√£o switch se Final Phase n√£o estiver ativo E se houver cartas dispon√≠veis para trocar
        if not final_phase_active and should_show_switch:
            def aceitar_carta():
                print("DEBUG: [NEXT PHASE] *** aceitar_carta CHAMADA - SWITCH BUTTON CLICKED! ***")
                print(f"DEBUG: [NEXT PHASE] carta_path: {carta_path}")
                print(f"DEBUG: [NEXT PHASE] tipos: {tipos}")
                print(f"DEBUG: [NEXT PHASE] page: {page}")
                
                # CORRE√á√ÉO: Aplicar a mesma l√≥gica de detec√ß√£o de substitui√ß√£o
                print("DEBUG: [NEXT PHASE] Verificando se vai substituir carta no carrossel")
                
                # Detectar posi√ß√£o de destino
                posicao_destino = getattr(self, 'carrossel_idx_selecao', None)
                if posicao_destino is None:
                    # Se n√£o h√° sele√ß√£o espec√≠fica, usar primeira posi√ß√£o acess√≠vel
                    for i in range(len(self.cards)):
                        if self._can_access_carousel_position(i):
                            posicao_destino = i
                            break
                
                # Verificar se a posi√ß√£o de destino cont√©m uma carta real (n√£o back_card)
                vai_substituir_carta = False
                if posicao_destino is not None and posicao_destino < len(self.cards):
                    carta_na_posicao_destino = self.cards[posicao_destino]
                    vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                
                if vai_substituir_carta:
                    print("DEBUG: [NEXT PHASE] Vai substituir carta existente - mostrando overlay de confirma√ß√£o")
                    self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                else:
                    print("DEBUG: [NEXT PHASE] Vai colocar em posi√ß√£o vazia - indo diretamente para aceitar carta")
                    self.aceitar_carta_carrossel(carta_path, tipos, page)
            
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_next_phase = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    btn_switch_next_phase.image = switch_img  # Manter refer√™ncia
                    print(f"DEBUG: [NEXT PHASE] Bot√£o Switch criado com imagem switch_card.png")
                else:
                    # Fallback para bot√£o texto se imagem n√£o existir
                    btn_switch_next_phase = tk.Button(self, text="‚áÑ", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    print(f"DEBUG: [NEXT PHASE] Bot√£o Switch criado com texto (imagem n√£o encontrada em {switch_img_path})")
            except Exception as e:
                # Fallback para bot√£o texto em caso de erro
                btn_switch_next_phase = tk.Button(self, text="‚áÑ", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                print(f"DEBUG: [NEXT PHASE] Bot√£o Switch criado com texto (erro ao carregar imagem: {e})")
            
            # POSICIONAMENTO ESPEC√çFICO POR TIPO DE CARTA:
            if is_activity_card:
                # Activities: Switch no canto superior direito
                btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [NEXT PHASE] Bot√£o Switch Activity posicionado no canto superior direito")
            else:  # is_challenge_card
                # CORRE√á√ÉO: Challenges: Switch tamb√©m no canto superior direito (ao lado do quit se houver)
                # Se quit button estiver presente, switch fica um pouco mais √† esquerda
                next_phase_active = getattr(self, '_next_phase_active', False)
                if not final_phase_active and not next_phase_active:
                    # Quit button vai estar presente, switch fica mais √† esquerda
                    btn_switch_next_phase.place(relx=0.90, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Bot√£o Switch Challenge posicionado no canto superior direito (√† esquerda do quit)")
                else:
                    # Quit button n√£o vai estar presente, switch pode ficar no canto
                    btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Bot√£o Switch Challenge posicionado no canto superior direito")
            
            print(f"DEBUG: [NEXT PHASE] Bot√£o Switch configurado e posicionado")
        else:
            if not should_show_switch:
                print(f"DEBUG: [NEXT PHASE] Bot√£o Switch N√ÉO criado - sem cartas dispon√≠veis para trocar")
            else:
                print(f"DEBUG: [NEXT PHASE] Bot√£o Switch N√ÉO criado - Final Phase est√° ativo")
        
        # BOT√ÉO QUIT CHALLENGE (apenas para Challenges, canto superior direito)
        # CORRE√á√ÉO: N√£o deve aparecer quando Next Phase est√° ativo OU Final Phase est√° ativo
        next_phase_active = getattr(self, '_next_phase_active', False)
        if is_challenge_card and not final_phase_active and not next_phase_active:
            print(f"DEBUG: [NEXT PHASE] Criando bot√£o Quit Challenge no canto superior direito")
            
            # Bot√£o vermelho com s√≠mbolo de check (‚úì) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="‚úì", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            # Challenge: Quit sempre no canto superior direito
            btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do bot√£o quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirma√ß√£o de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [NEXT PHASE] SUCCESS: Bot√£o Quit Challenge criado no canto superior direito")
        else:
            if next_phase_active:
                print(f"DEBUG: [NEXT PHASE] ERROR: Bot√£o Quit Challenge N√ÉO criado - Next Phase est√° ativo")
            elif final_phase_active:
                print(f"DEBUG: [NEXT PHASE] ERROR: Bot√£o Quit Challenge N√ÉO criado - Final Phase est√° ativo")
            elif not is_challenge_card:
                print(f"DEBUG: [NEXT PHASE] ERROR: Bot√£o Quit Challenge N√ÉO criado - n√£o √© carta Challenge")
        
        print("DEBUG: Fullscreen Next Phase configurado - apenas X dispon√≠vel durante Final Phase")

    def add_more_action_event_cards(self, min_actions=5, min_events=6):
        """
        Adiciona mais cartas de Actions/Events ao invent√°rio se houver poucas.
        Usa filtragem baseada na base de dados para adicionar apenas cartas v√°lidas.
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [add_more_action_event_cards] Base de dados n√£o dispon√≠vel")
            return
        
        player_color = self.player_color.lower()
        base_path = "/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster"
        
        # Verificar Actions - N√ÉO ADICIONAR mais Actions, manter apenas Action_31.png e Action_46.png
        current_actions = len(self.inventario.get("actions", []))
        print(f"DEBUG: [add_more_action_event_cards] Actions atuais: {current_actions} (mantendo apenas Action_31.png e Action_46.png, n√£o adicionando mais)")
        
        # Verificar Events
        current_events = len(self.inventario.get("events", []))
        if current_events < min_events:
            print(f"DEBUG: [add_more_action_event_cards] Events insuficientes ({current_events}/{min_events}), adicionando mais...")
            events_path = os.path.join(base_path, "Events", "Residential-level")
            if os.path.exists(events_path):
                try:
                    files = os.listdir(events_path)
                    event_files = [os.path.join(events_path, f) for f in files if f.lower().endswith('.png')]
                    
                    valid_events = []
                    for card_file in event_files:
                        filename = os.path.basename(card_file)
                        match = re.search(r'Event_(\d+)\.', filename)
                        if match:
                            # ESPECIAL: Incluir APENAS Event_55 e Event_14
                            if filename == "Event_55.png" or filename == "Event_14.png":
                                if card_file not in self.inventario.get("events", []):
                                    valid_events.append(card_file)
                                    print(f"DEBUG: [add_more_action_event_cards] Event PERMITIDO: {filename}")
                            else:
                                print(f"DEBUG: [add_more_action_event_cards] Event IGNORADO (n√£o √© Event_55 nem Event_14): {filename}")
                    
                    # Adicionar cartas at√© atingir o m√≠nimo
                    needed = min_events - current_events
                    for i in range(min(needed, len(valid_events))):
                        self.inventario["events"].append(valid_events[i])
                        print(f"DEBUG: [add_more_action_event_cards] Event adicionado: {os.path.basename(valid_events[i])}")
                
                except Exception as e:
                    print(f"DEBUG: [add_more_action_event_cards] Erro ao adicionar Events: {e}")
        
        print(f"DEBUG: [add_more_action_event_cards] Resultado final - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def _filter_action_event_cards(self, cartas_paths, card_type):
        """
        Filtra cartas de Actions/Events baseado no target e player_choice.
        Mostra cartas que:
        1. T√™m target igual √† cor do jogador atual, OU
        2. T√™m target None e player_choice True (jogador pode escolher alvo), OU
        3. T√™m target None e player_choice False/None (carta fica sempre com quem a tirou)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print(f"DEBUG: [_filter_action_event_cards] Base de dados n√£o dispon√≠vel - mostrando todas as cartas")
            return cartas_paths
        
        filtered_cards = []
        player_color = self.player_color.lower()
        
        for carta_path in cartas_paths:
            try:
                # Extrair ID da carta do nome do arquivo
                filename = os.path.basename(carta_path)
                if card_type == "actions":
                    # Action_1.png -> action_1
                    match = re.search(r'Action_(\d+)\.', filename)
                    if match:
                        card_id = f"action_{match.group(1)}"
                        card_data = self.card_database.get_action(card_id)
                    else:
                        continue
                elif card_type == "events":
                    # Event_1.png -> event_1
                    match = re.search(r'Event_(\d+)\.', filename)
                    if match:
                        card_id = f"event_{match.group(1)}"
                        card_data = self.card_database.get_event(card_id)
                    else:
                        continue
                else:
                    continue
                
                if card_data:
                    # Para Events, usar target_player; para Actions, usar target
                    if card_type == "events":
                        target = getattr(card_data, 'target_player', None)
                    else:
                        target = getattr(card_data, 'target', None)
                    player_choice = getattr(card_data, 'player_choice', False)
                    
                    # CRIT√âRIO DE FILTRAGEM CORRIGIDO:
                    # 1. Target espec√≠fico igual √† cor do jogador
                    # 2. Target None com player_choice True (jogador escolhe alvo)
                    # 3. Target None com player_choice False/None (carta fica com quem tirou)
                    if (target == player_color or 
                        (target is None and player_choice) or 
                        (target is None and not player_choice)):
                        filtered_cards.append(carta_path)
                        if target == player_color:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target={target} - direcionada para jogador)")
                        elif target is None and player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=True - jogador escolhe)")
                        elif target is None and not player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=False - fica com quem tirou)")
                    else:
                        print(f"DEBUG: [_filter_action_event_cards] Carta REJEITADA: {filename} (target={target}, player_choice={player_choice} - n√£o aplic√°vel)")
                else:
                    print(f"DEBUG: [_filter_action_event_cards] Carta n√£o encontrada na base de dados: {card_id}")
                    
            except Exception as e:
                print(f"DEBUG: [_filter_action_event_cards] Erro ao processar carta {filename}: {e}")
                continue
        
        print(f"DEBUG: [_filter_action_event_cards] Resultado final {card_type}: {len(filtered_cards)}/{len(cartas_paths)} cartas")
        return filtered_cards

    def reload_action_event_inventory(self):
        """
        Fun√ß√£o de conveni√™ncia para recarregar o invent√°rio de Actions/Events
        com mais cartas v√°lidas para o jogador atual.
        """
        print("DEBUG: [reload_action_event_inventory] Recarregando invent√°rio de Actions/Events...")
        
        # Limpar invent√°rio atual (opcional)
        # self.inventario["actions"] = []
        # self.inventario["events"] = []
        
        # Adicionar mais cartas
        self.add_more_action_event_cards(min_actions=10, min_events=12)
        
        print(f"DEBUG: [reload_action_event_inventory] Invent√°rio atualizado - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def processar_challenge_aceite(self, carta_challenge_path):
        """
        Processa a aceita√ß√£o de uma carta Challenge implementando a l√≥gica complexa de substitui√ß√£o:
        - Se h√° Activities ativas no carrossel: substitui uma Activity (com reset de valores)
        - Se h√° m√∫ltiplas Activities: jogador escolhe qual substituir
        - Se s√≥ h√° Challenges ativas: Challenge vai para invent√°rio
        - Activity substitu√≠da vai para invent√°rio Activities/Challenges
        """
        print(f"DEBUG: [processar_challenge_aceite] Processando Challenge: {os.path.basename(carta_challenge_path)}")
        
        # CORRE√á√ÉO PROBLEMA 1: Verificar se Challenge j√° foi processado para evitar duplo processamento
        if hasattr(self, '_challenge_sendo_processado') and self._challenge_sendo_processado == carta_challenge_path:
            print(f"DEBUG: [processar_challenge_aceite] WARNING:  Challenge j√° est√° sendo processado - ignorando chamada duplicada")
            return
        
        # Marcar Challenge como sendo processado
        self._challenge_sendo_processado = carta_challenge_path
        
        # FECHAR A STORE se estiver aberta
        if hasattr(self, 'store_window') and self.store_window:
            print(f"DEBUG: [processar_challenge_aceite] Fechando Store...")
            try:
                self.store_window.destroy()
                self.store_window = None
                print(f"DEBUG: [processar_challenge_aceite] Store fechada com sucesso")
            except Exception as e:
                print(f"DEBUG: [processar_challenge_aceite] Erro ao fechar Store: {e}")
        
        # Desabilitar bot√£o Store (Challenge aceite)
        self.disable_store_button()
        print(f"DEBUG: [processar_challenge_aceite] Bot√£o Store desabilitado")
        
        try:
            # REGISTRO TEMPORAL: Challenge aceite no turno atual
            turno_aceitacao_real = self._current_turn_number
            print(f"DEBUG: [processar_challenge_aceite] Registando Challenge com turno espec√≠fico: {turno_aceitacao_real}")
            self._register_challenge_start_turn(carta_challenge_path, turno_especifico=turno_aceitacao_real)
            
            print(f"DEBUG: [processar_challenge_aceite] Challenge {os.path.basename(carta_challenge_path)} registado para turno {turno_aceitacao_real}")
            print(f"DEBUG: [processar_challenge_aceite] _current_turn_number atual: {self._current_turn_number}")
            print(f"DEBUG: [processar_challenge_aceite] Turno de registo usado: {turno_aceitacao_real}")
            
            # BACKUP M√öLTIPLO E ROBUSTO para garantir persist√™ncia durante toda a opera√ß√£o
            try:
                # Backup no master
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_challenge_start_turns_backup'):
                        self.master._challenge_start_turns_backup = {}
                    self.master._challenge_start_turns_backup[carta_challenge_path] = turno_aceitacao_real
                    print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no master backup com turno {turno_aceitacao_real}")
                
                # NOVO: Backup no root (principal)
                if hasattr(self, 'winfo_toplevel'):
                    root = self.winfo_toplevel()
                    if root:
                        if not hasattr(root, '_backup_challenge_tracking'):
                            root._backup_challenge_tracking = {}
                        root._backup_challenge_tracking[carta_challenge_path] = turno_aceitacao_real
                        print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no root backup com turno {turno_aceitacao_real}")
                
                # NOVO: Backup imediato no _backup_turn_counters para persistir durante reconstru√ß√µes
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_backup_turn_counters'):
                        self.master._backup_turn_counters = {}
                    if '_challenge_start_turns' not in self.master._backup_turn_counters:
                        self.master._backup_turn_counters['_challenge_start_turns'] = {}
                    self.master._backup_turn_counters['_challenge_start_turns'][carta_challenge_path] = turno_aceitacao_real
                    print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no _backup_turn_counters com turno {turno_aceitacao_real}")
                
                print(f"DEBUG: [processar_challenge_aceite] ‚úì TRACKING TOTALMENTE PROTEGIDO com 3 backups independentes")
                
            except Exception as e:
                print(f"DEBUG: [processar_challenge_aceite] Erro no backup m√∫ltiplo: {e}")
            
            # Primeiro, garantir que Challenge est√° no invent√°rio
            if 'challenges' not in self.inventario:
                self.inventario['challenges'] = []
            if carta_challenge_path not in self.inventario['challenges']:
                self.inventario['challenges'].append(carta_challenge_path)
                print(f"DEBUG: [processar_challenge_aceite] Challenge adicionado ao invent√°rio")
            
            # Verificar Activities ativas no carrossel
            activities_ativas = []
            for i, carta_carrossel in enumerate(self.cards):
                if carta_carrossel and "Activity" in os.path.basename(carta_carrossel):
                    activities_ativas.append((i, carta_carrossel))
            
            print(f"DEBUG: [processar_challenge_aceite] Activities ativas encontradas: {len(activities_ativas)}")
            for idx, carta in activities_ativas:
                print(f"DEBUG: [processar_challenge_aceite]   Posi√ß√£o {idx}: {os.path.basename(carta)}")
            
            if len(activities_ativas) == 0:
                # Caso 1: N√£o h√° Activities ativas - Challenge vai direto para invent√°rio
                print("DEBUG: [processar_challenge_aceite] Nenhuma Activity ativa - Challenge vai para invent√°rio")
                # Challenge j√° foi adicionado ao invent√°rio acima
                
            elif len(activities_ativas) == 1:
                # Caso 2: Uma Activity ativa - substitui automaticamente
                idx_activity, carta_activity = activities_ativas[0]
                print(f"DEBUG: [processar_challenge_aceite] Uma Activity ativa - substituindo automaticamente posi√ß√£o {idx_activity}")
                self._substituir_activity_por_challenge(idx_activity, carta_activity, carta_challenge_path)
                
            else:
                # Caso 3: M√∫ltiplas Activities ativas - jogador escolhe
                print(f"DEBUG: [processar_challenge_aceite] {len(activities_ativas)} Activities ativas - jogador deve escolher")
                self._mostrar_selecao_activity_para_substituir(activities_ativas, carta_challenge_path)
                
        finally:
            # Limpar marcador de processamento ap√≥s 2 segundos para permitir futuras opera√ß√µes
            self.after(2000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [processar_challenge_aceite] Marcador de processamento ser√° limpo em 2 segundos")
    
    def _substituir_activity_por_challenge(self, idx_carrossel, carta_activity_path, carta_challenge_path):
        """
        Executa a substitui√ß√£o de uma Activity por uma Challenge no carrossel:
        - CORRECCI√ìN: Reseta card_stats e barras de progresso para valores da nova Challenge
        - Move Activity para invent√°rio
        - Remove Challenge do invent√°rio
        - Coloca Challenge no carrossel
        """
        try:
            print(f"DEBUG: [_substituir_activity_por_challenge] IN√çCIO - Substituindo Activity posi√ß√£o {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Activity: {os.path.basename(carta_activity_path)}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge: {os.path.basename(carta_challenge_path)}")
            
            # 1. RESETAR VALORES DA ACTIVITY (To send volta ao inicial, Rxd e Lost = 0)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Resetando valores...")
            self._resetar_valores_activity(carta_activity_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Valores resetados")
            
            # 2. MOVER ACTIVITY PARA INVENT√ÅRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Movendo Activity para invent√°rio...")
            if 'activities' not in self.inventario:
                self.inventario['activities'] = []
            if carta_activity_path not in self.inventario['activities']:
                self.inventario['activities'].append(carta_activity_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Activity movida para invent√°rio")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Activity movida")
            
            # 3. REMOVER CHALLENGE DO INVENT√ÅRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Removendo Challenge do invent√°rio...")
            if carta_challenge_path in self.inventario.get('challenges', []):
                self.inventario['challenges'].remove(carta_challenge_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Challenge removido do invent√°rio")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Challenge removido")
            
            # 4. COLOCAR CHALLENGE NO CARROSSEL
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Colocando Challenge no carrossel...")
            self.cards[idx_carrossel] = carta_challenge_path
            
            # CORRE√á√ÉO CR√çTICA: Atualizar flag da carta como virada para cima (True)
            if not hasattr(self, 'card_face_up_flags'):
                self.card_face_up_flags = [False, False, False, False]
            if idx_carrossel < len(self.card_face_up_flags):
                self.card_face_up_flags[idx_carrossel] = True
                print(f"DEBUG: [_substituir_activity_por_challenge] Flag posi√ß√£o {idx_carrossel} atualizada para True (virada para cima)")
            
            # CORRE√á√ÉO CR√çTICA: GARANTIR REGISTO IMEDIATO E BACKUP SEGURO
            print(f"DEBUG: [_substituir_activity_por_challenge] === VERIFICA√á√ÉO CR√çTICA DO TRACKING ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Estado atual do tracking: {self._challenge_start_turns}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Procurando registo para: {os.path.basename(carta_challenge_path)}")
            
            # CORRE√á√ÉO FUNDAMENTAL: Primeiro tentar recuperar do backup antes de verificar tracking local
            turno_ja_registado = None
            challenge_basename = os.path.basename(carta_challenge_path)
            
            # 1. Verificar tracking local
            turno_ja_registado = self._challenge_start_turns.get(carta_challenge_path)
            
            # 2. Se n√£o encontrou por caminho exato, procurar por basename
            if turno_ja_registado is None:
                for tracked_path, turno in self._challenge_start_turns.items():
                    if os.path.basename(tracked_path) == challenge_basename:
                        turno_ja_registado = turno
                        print(f"DEBUG: [_substituir_activity_por_challenge] Challenge encontrado por basename: {turno}")
                        # Migrar chave para caminho correto
                        del self._challenge_start_turns[tracked_path]
                        self._challenge_start_turns[carta_challenge_path] = turno
                        print(f"DEBUG: [_substituir_activity_por_challenge] Chave migrada para caminho correto")
                        break
            
            # 3. NOVO: Se n√£o encontrou no tracking local, tentar recuperar dos backups
            if turno_ja_registado is None:
                print(f"DEBUG: [_substituir_activity_por_challenge] [WARNING] Challenge n√£o encontrado no tracking local - tentando backups...")
                
                # Verificar backup no root
                try:
                    if hasattr(self, 'winfo_toplevel'):
                        root = self.winfo_toplevel()
                        if root and hasattr(root, '_backup_challenge_tracking'):
                            for backup_path, backup_turno in root._backup_challenge_tracking.items():
                                if os.path.basename(backup_path) == challenge_basename:
                                    turno_ja_registado = backup_turno
                                    print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì Challenge recuperado do backup ROOT: turno {backup_turno}")
                                    break
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao verificar backup ROOT: {e}")
                
                # Verificar backup no master
                if turno_ja_registado is None:
                    try:
                        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup'):
                            for backup_path, backup_turno in self.master._challenge_start_turns_backup.items():
                                if os.path.basename(backup_path) == challenge_basename:
                                    turno_ja_registado = backup_turno
                                    print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì Challenge recuperado do backup MASTER: turno {backup_turno}")
                                    break
                    except Exception as e:
                        print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao verificar backup MASTER: {e}")
                
                # Se encontrou nos backups, restaurar no tracking local
                if turno_ja_registado is not None:
                    self._challenge_start_turns[carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì Tracking restaurado dos backups: {challenge_basename} = turno {turno_ja_registado}")
            
            if turno_ja_registado is not None:
                print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì Challenge {challenge_basename} tem tracking: turno {turno_ja_registado}")
                print(f"DEBUG: [_substituir_activity_por_challenge] PRESERVANDO turno de registo existente - N√ÉO sobrescrever!")
            else:
                # FALLBACK CR√çTICO: Se n√£o foi registado em lugar nenhum, registar AGORA com turno atual
                print(f"DEBUG: [_substituir_activity_por_challenge] [ERROR] Challenge N√ÉO encontrado em local nenhum - REGISTANDO AGORA!")
                
                turno_aceitacao = self._current_turn_number
                self._register_challenge_start_turn(carta_challenge_path, turno_especifico=turno_aceitacao)
                turno_ja_registado = turno_aceitacao
                print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì Challenge {challenge_basename} registado para turno {turno_aceitacao}")
            
            # BACKUP IMEDIATO AP√ìS VERIFICA√á√ÉO/REGISTO
            print(f"DEBUG: [_substituir_activity_por_challenge] === BACKUP IMEDIATO P√ìS-REGISTO ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Tracking final antes do backup: {self._challenge_start_turns}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge_13 no tracking: {carta_challenge_path in self._challenge_start_turns}")
            if carta_challenge_path in self._challenge_start_turns:
                print(f"DEBUG: [_substituir_activity_por_challenge] Turno registado: {self._challenge_start_turns[carta_challenge_path]}")
            
            # BACKUP ADICIONAL IMEDIATO no master/root para garantir persist√™ncia
            try:
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_challenge_start_turns_backup_imediato'):
                        self.master._challenge_start_turns_backup_imediato = {}
                    self.master._challenge_start_turns_backup_imediato[carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì BACKUP IMEDIATO no master: Challenge_13={turno_ja_registado}")
                
                if hasattr(self, 'winfo_toplevel'):
                    root = self.winfo_toplevel()
                    if root:
                        if not hasattr(root, '_challenge_start_turns_backup_imediato'):
                            root._challenge_start_turns_backup_imediato = {}
                        root._challenge_start_turns_backup_imediato[carta_challenge_path] = turno_ja_registado
                        print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì BACKUP IMEDIATO no root: Challenge_13={turno_ja_registado}")
                
                # BACKUP CR√çTICO ADICIONAL: Salvar tamb√©m no _backup_turn_counters para garantir persist√™ncia durante reconstru√ß√£o
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_backup_turn_counters'):
                        self.master._backup_turn_counters = {}
                    if '_challenge_start_turns' not in self.master._backup_turn_counters:
                        self.master._backup_turn_counters['_challenge_start_turns'] = {}
                    self.master._backup_turn_counters['_challenge_start_turns'][carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ‚úì BACKUP ADICIONAL no _backup_turn_counters: {carta_challenge_path}={turno_ja_registado}")
                
            except Exception as e:
                print(f"DEBUG: [_substituir_activity_por_challenge] ERRO no backup imediato: {e}")
            
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge colocado no carrossel posi√ß√£o {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Challenge colocado")
            
            # 5. CORRE√á√ÉO CR√çTICA: RESETAR card_stats PARA A NOVA CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 5: Resetando card_stats para Challenge...")
            challenge_message_size = self._get_card_message_size_from_database(carta_challenge_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Message size da Challenge: {challenge_message_size}")
            
            # Resetar card_stats[idx_carrossel] com valores da Challenge
            if idx_carrossel < len(self.card_stats):
                self.card_stats[idx_carrossel] = {
                    "To send": challenge_message_size,  # Novo message_size da Challenge
                    "Rxd": 0,                          # Sempre 0 para nova carta
                    "Lost": 0                          # Sempre 0 para nova carta
                }
                print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: card_stats[{idx_carrossel}] resetado:")
                print(f"DEBUG: [_substituir_activity_por_challenge]   To send: {challenge_message_size}")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Rxd: 0")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Lost: 0")
            
            # 6. CORRE√á√ÉO CR√çTICA: ATUALIZAR BARRAS DE PROGRESSO PARA A CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 6: Atualizando barras para Challenge...")
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Configurar barra To send com message_size da Challenge
                if "To send" in self.progress_bars:
                    self.progress_bars["To send"].configure(maximum=challenge_message_size)
                    self.progress_bars["To send"].set(challenge_message_size)  # Barra 100% cheia
                    self.progress_labels["To send"].config(text=str(challenge_message_size))
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra To send: {challenge_message_size}/{challenge_message_size}")
                
                # Resetar Rxd para 0
                if "Rxd" in self.progress_bars:
                    self.progress_bars["Rxd"].set(0)
                    self.progress_labels["Rxd"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra Rxd: 0")
                
                # Resetar Lost para 0
                if "Lost" in self.progress_bars:
                    self.progress_bars["Lost"].set(0)
                    self.progress_labels["Lost"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra Lost: 0")
                
                # For√ßar atualiza√ß√£o visual
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        self.progress_bars[stat].update_idletasks()
                        self.progress_bars[stat].update()
                    if stat in self.progress_labels:
                        self.progress_labels[stat].update_idletasks()
                        self.progress_labels[stat].update()
                
                self.update_idletasks()
                self.update()
                print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barras atualizadas e refreshed")
            
            # 7. LIMPAR ESTADO DE SELE√á√ÉO E PROCESSAMENTO PARA EVITAR CONFLITOS
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Limpando estado de sele√ß√£o...")
            if hasattr(self, 'selected_carousel_card'):
                self.selected_carousel_card = None
            if hasattr(self, 'selected_carousel_index'):
                self.selected_carousel_index = None
            if hasattr(self, 'carta_carrossel_para_troca'):
                self.carta_carrossel_para_troca = None
            if hasattr(self, 'carrossel_idx_selecao'):
                self.carrossel_idx_selecao = None
            print(f"DEBUG: [_substituir_activity_por_challenge] Estado de sele√ß√£o limpo")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Estado limpo")
            
            # 8. BACKUP CR√çTICO DOS CONTADORES ANTES DA RECONSTRU√á√ÉO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8a: BACKUP CR√çTICO dos contadores...")
            self._backup_turn_counters_before_reconstruction()
            print(f"DEBUG: [_substituir_activity_por_challenge] Backup dos contadores conclu√≠do")
            
            # 8b. ATUALIZAR INTERFACE (se estiver vis√≠vel)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8b: Atualizando interface...")
            
            # CORRE√á√ÉO CR√çTICA RASPBERRY PI: Sistema de backup m√∫ltiplas camadas
            # Garantir que o Challenge rec√©m-registado √© preservado antes da reconstru√ß√£o da interface
            print(f"DEBUG: [_substituir_activity_por_challenge] === BACKUP EMERGENCY M√öLTIPLAS CAMADAS ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Tracking antes da interface: {self._challenge_start_turns}")
            
            # CAMADA 1: Emergency backup no master (original)
            if hasattr(self, 'master') and self.master is not None:
                if not hasattr(self.master, '_challenge_tracking_emergency_backup'):
                    self.master._challenge_tracking_emergency_backup = {}
                self.master._challenge_tracking_emergency_backup.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 1: Emergency backup no master: {len(self.master._challenge_tracking_emergency_backup)} itens")
            
            # CAMADA 2: Super backup no master
            if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
                self.master._super_challenge_backup.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 2: Super backup no master: {len(self.master._super_challenge_backup)} itens")
            
            # CAMADA 3: Super backup no root
            try:
                if hasattr(self.master.master, '_super_challenge_backup'):
                    self.master.master._super_challenge_backup.update(self._challenge_start_turns)
                    print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 3: Super backup no root: {len(self.master.master._super_challenge_backup)} itens")
            except:
                print("DEBUG: [_substituir_activity_por_challenge] CAMADA 3: Root n√£o acess√≠vel, pulando")
            
            # CAMADA 4: Backup registry na inst√¢ncia
            if hasattr(self, '_challenge_backup_registry'):
                self._challenge_backup_registry.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 4: Backup registry na inst√¢ncia: {len(self._challenge_backup_registry)} itens")
            
            # CAMADA 5: Vari√°vel tempor√°ria global (√∫ltimo recurso)
            import builtins
            if not hasattr(builtins, '_global_challenge_backup'):
                builtins._global_challenge_backup = {}
            builtins._global_challenge_backup.update(self._challenge_start_turns)
            print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 5: Backup global: {len(builtins._global_challenge_backup)} itens")
            
            print(f"DEBUG: [_substituir_activity_por_challenge] TODAS AS CAMADAS DE BACKUP CRIADAS COM SUCESSO")
            
            if hasattr(self, 'card_labels') and self.card_labels:
                try:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Chamando playerdashboard_interface...")
                    # Recriar interface para mostrar mudan√ßas
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface atualizada")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao atualizar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback interface: {traceback.format_exc()}")
            else:
                print(f"DEBUG: [_substituir_activity_por_challenge] N√£o h√° card_labels - criando interface diretamente...")
                try:
                    # BACKUP CR√çTICO DOS CONTADORES ANTES DA CRIA√á√ÉO
                    self._backup_turn_counters_before_reconstruction()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface criada diretamente")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao criar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback cria√ß√£o: {traceback.format_exc()}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8: Interface processada")
            
            # 9. LIMPAR MARCADOR DE PROCESSAMENTO DEPOIS DE UM BREVE DELAY
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 9: Programando limpeza...")
            self.after(1000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: SUBSTITUI√á√ÉO COMPLETA")
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Challenge {os.path.basename(carta_challenge_path)} substitui Activity na posi√ß√£o {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Valores resetados: To send={challenge_message_size}, Rxd=0, Lost=0")
            
        except Exception as e:
            print(f"DEBUG: [_substituir_activity_por_challenge] ERRO CR√çTICO: {e}")
            import traceback
            print(f"DEBUG: [_substituir_activity_por_challenge] Traceback completo: {traceback.format_exc()}")
            # Em caso de erro, tentar voltar √† interface principal
            try:
                print(f"DEBUG: [_substituir_activity_por_challenge] Tentando recuperar interface...")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                print(f"DEBUG: [_substituir_activity_por_challenge] Interface recuperada")
            except Exception as e2:
                print(f"DEBUG: [_substituir_activity_por_challenge] ERRO ao recuperar interface: {e2}")
    
    def _resetar_valores_activity(self, carta_activity_path):
        """
        Reseta os valores de uma Activity interrompida por Challenge:
        - To send volta ao valor inicial (message_size)
        - Rxd (recebidos) = 0
        - Lost (perdidos) = 0
        """
        print(f"DEBUG: [_resetar_valores_activity] Resetando valores para {os.path.basename(carta_activity_path)}")
        
        try:
            # Verificar se as barras de progresso existem
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print(f"DEBUG: [_resetar_valores_activity] Barras de progresso n√£o inicializadas")
                return
            
            # Obter message_size da carta para resetar "To send"
            message_size = self._get_card_message_size(carta_activity_path)
            print(f"DEBUG: [_resetar_valores_activity] Message size da Activity: {message_size}")
            
            # RESETAR "To send" para valor inicial (message_size)
            if "To send" in self.progress_bars:
                self.progress_bars["To send"]["value"] = message_size
                self.progress_bars["To send"]["maximum"] = message_size
                if "To send" in self.progress_labels:
                    self.progress_labels["To send"]["text"] = str(message_size)
                print(f"DEBUG: [_resetar_valores_activity] To send resetado para {message_size}")
            
            # RESETAR "Rxd" para 0
            if "Rxd" in self.progress_bars:
                self.progress_bars["Rxd"]["value"] = 0
                if "Rxd" in self.progress_labels:
                    self.progress_labels["Rxd"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Rxd resetado para 0")
            
            # RESETAR "Lost" para 0
            if "Lost" in self.progress_bars:
                self.progress_bars["Lost"]["value"] = 0
                if "Lost" in self.progress_labels:
                    self.progress_labels["Lost"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Lost resetado para 0")
            
            # For√ßar atualiza√ß√£o visual das barras
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars:
                    self.progress_bars[stat].update()
                if stat in self.progress_labels:
                    self.progress_labels[stat].update()
            
            print(f"DEBUG: [_resetar_valores_activity] Reset completo - Activity interrompida")
            
        except Exception as e:
            print(f"DEBUG: [_resetar_valores_activity] ERRO ao resetar valores: {e}")
            import traceback
            traceback.print_exc()
    
    def _mostrar_selecao_activity_para_substituir(self, activities_ativas, carta_challenge_path):
        """
        Mostra interface para jogador escolher qual Activity substituir quando h√° m√∫ltiplas ativas.
        """
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Mostrando sele√ß√£o para {len(activities_ativas)} Activities")
        
        # Limpar widgets
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # T√≠tulo
        title = tk.Label(self, text="Choose Activity to Replace", font=("Helvetica", 20, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Subt√≠tulo
        subtitle = tk.Label(self, text=f"Replace with: {os.path.basename(carta_challenge_path)}", 
                           font=("Helvetica", 14), fg="yellow", bg="black")
        subtitle.place(relx=0.5, y=100, anchor="n")
        
        # Frame para as Activities
        selection_frame = tk.Frame(self, bg="black")
        selection_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 100, 140
        
        # Mostrar cada Activity ativa como op√ß√£o clic√°vel
        for i, (idx_carrossel, carta_activity_path) in enumerate(activities_ativas):
            try:
                img = ImageTk.PhotoImage(Image.open(carta_activity_path).resize((card_w, card_h)))
                
                # Label da carta
                carta_lbl = tk.Label(selection_frame, image=img, bg="black", cursor="hand2", 
                                   highlightthickness=2, highlightcolor="yellow")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=0, column=i, padx=15, pady=10)
                
                # Label com posi√ß√£o no carrossel
                pos_lbl = tk.Label(selection_frame, text=f"Position {idx_carrossel + 1}", 
                                 font=("Helvetica", 12, "bold"), fg="white", bg="black")
                pos_lbl.grid(row=1, column=i, pady=(5, 0))
                
                # Bind do clique para executar substitui√ß√£o
                def fazer_substituicao(idx=idx_carrossel, carta=carta_activity_path):
                    try:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ===== CLIQUE DETECTADO =====")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Jogador escolheu posi√ß√£o {idx}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Activity: {os.path.basename(carta)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Challenge: {os.path.basename(carta_challenge_path)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Chamando _substituir_activity_por_challenge...")
                        self._substituir_activity_por_challenge(idx, carta, carta_challenge_path)
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] _substituir_activity_por_challenge conclu√≠da")
                    except Exception as e:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO ao executar substitui√ß√£o: {e}")
                        import traceback
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Traceback: {traceback.format_exc()}")
                        # Em caso de erro, voltar √† interface principal
                        try:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Tentando recuperar com playerdashboard_interface...")
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface recuperada com sucesso")
                        except Exception as e2:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO cr√≠tico ao voltar √† interface: {e2}")
                
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Binding clique para Activity {i}: {os.path.basename(carta_activity_path)}")
                
                # Testar se o widget responde a eventos b√°sicos de hover primeiro
                def on_enter(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse entrou na Activity {pos}")
                    lbl.config(highlightbackground="yellow")
                def on_leave(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse saiu da Activity {pos}")
                    lbl.config(highlightbackground="black")
                    
                carta_lbl.bind("<Enter>", on_enter)
                carta_lbl.bind("<Leave>", on_leave)
                
                # Bind de clique com debug detalhado
                carta_lbl.bind("<Button-1>", lambda e, f=fazer_substituicao, pos=i: (
                    print(f"DEBUG: [LAMBDA] ===== CLIQUE RECEBIDO ====="),
                    print(f"DEBUG: [LAMBDA] Widget: {e.widget}"),
                    print(f"DEBUG: [LAMBDA] Coordenadas: x={e.x}, y={e.y}"),
                    print(f"DEBUG: [LAMBDA] Activity posi√ß√£o: {pos}"),
                    print(f"DEBUG: [LAMBDA] Executando fun√ß√£o de substitui√ß√£o..."),
                    f(),
                    print(f"DEBUG: [LAMBDA] Fun√ß√£o executada!")
                )[-1])
                
                # Verificar se os widgets est√£o realmente vis√≠veis e interativos
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widget Activity {i} criado:")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Widget: {carta_lbl}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Posi√ß√£o: {carta_lbl.winfo_x()}, {carta_lbl.winfo_y()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Tamanho: {carta_lbl.winfo_width()}x{carta_lbl.winfo_height()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Cursor: {carta_lbl.cget('cursor')}")
                
            except Exception as e:
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Erro ao carregar Activity {carta_activity_path}: {e}")
        
        # Bot√£o cancelar
        cancel_btn = tk.Button(self, text="Cancel", font=("Helvetica", 14, "bold"), 
                              bg="#F44336", fg="white", width=8,
                              command=lambda: (print("DEBUG: [_mostrar_selecao_activity_para_substituir] Bot√£o Cancel clicado"), 
                                             self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)))
        cancel_btn.place(relx=0.5, rely=0.8, anchor="center")
        
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface de sele√ß√£o criada")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widgets criados: {len(self.winfo_children())} widgets")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Aguardando clique do jogador...")

    def _mostrar_mensagem_restricao_activity(self):
        """
        Mostra mensagem informando que n√£o √© poss√≠vel trocar Activity ativa 
        enquanto houver Challenges no invent√°rio.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity] Mostrando mensagem de restri√ß√£o")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # T√≠tulo da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot replace active Activity\nwhile Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Bot√£o OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar ap√≥s 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_challenge_activity(self):
        """
        Mostra mensagem informando que Challenge s√≥ pode ser trocado por Activity.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_challenge_activity] Mostrando mensagem de restri√ß√£o")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # T√≠tulo da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Challenge can only be\nreplaced with Activity", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Bot√£o OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar ap√≥s 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_activity_activity(self):
        """
        Mostra mensagem informando que Activity s√≥ pode ser trocada por outra Activity 
        se n√£o h√° Challenges no invent√°rio.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity_activity] Mostrando mensagem de restri√ß√£o")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=450, height=220)
        
        # T√≠tulo da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot swap Activity ‚Üî Activity\nwhen Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Submensagem
        submessage_lbl = tk.Label(overlay_frame, 
                                text="Use Challenges first", 
                                font=("Helvetica", 12), fg="lightgray", bg="black", justify="center")
        submessage_lbl.pack(pady=5)
        
        # Bot√£o OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=15)
        
        # Auto-fechar ap√≥s 4 segundos (mais tempo para ler a mensagem)
        self.after(4000, fechar_mensagem)

    def show_card_fullscreen_readonly(self, carta_path, carta_tipo):
        """
        Mostra uma carta em fullscreen apenas para visualiza√ß√£o (sem op√ß√µes de venda).
        Usado para cartas ativas (viradas para cima) que n√£o podem ser vendidas.
        """
        print(f"DEBUG: show_card_fullscreen_readonly chamado para {os.path.basename(carta_path)} (tipo: {carta_tipo})")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        
        try:
            # Carrega e redimensiona a imagem
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Mostra a carta centralizada
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
            # Fun√ß√£o para voltar ao invent√°rio
            def voltar_inventario():
                # Volta para a p√°gina de invent√°rio do tipo correspondente
                if hasattr(self, '_current_sell_page') and self._current_sell_page is not None:
                    page = self._current_sell_page
                else:
                    page = 0
                # CORRE√á√ÉO: Usar vers√£o especial after_sale para manter consist√™ncia de estado
                self.show_inventory_for_sell_after_sale(carta_tipo, None, page)
            
            # Bot√£o X para fechar - canto superior esquerdo
            x_btn = tk.Button(self, text="‚úñ", font=("Helvetica", 24, "bold"), 
                            bg="#AAAAAA", fg="white", width=2, height=1, 
                            borderwidth=0, highlightthickness=0, 
                            command=voltar_inventario, cursor="hand2", 
                            activebackground="#CCCCCC")
            x_btn.place(relx=0.02, rely=0, anchor="nw")
            
        except Exception as e:
            print(f"DEBUG: Erro ao mostrar carta readonly: {e}")
            # Em caso de erro, volta ao invent√°rio
            page = getattr(self, '_current_sell_page', 0)
            if page is None:
                page = 0
            self.show_inventory_for_sell(carta_tipo, None, page)
    
    def show_game_result_screen(self, game_data):
        """
        Mostra a tela de resultado final do jogo com o vencedor e ranking
        
        Args:
            game_data: Dicion√°rio com dados completos da mensagem game_finished
        """
        # Limpar toda a interface
        for widget in self.winfo_children():
            widget.destroy()
        
        self.configure(bg="black")
        
        # Carregar e adicionar padr√£o de rede igual ao das p√°ginas Create/Join Game
        try:
            # Tentar carregar a imagem do padr√£o de rede
            possible_network_pattern_paths = [
                os.path.join(IMG_DIR, "network_pattern.png"),  # Caminho padr√£o
                os.path.join("/home/joaorebolo2/netmaster_menu/img", "network_pattern.png"),  # Raspberry Pi
            ]
            
            network_pattern_img = None
            for pattern_path in possible_network_pattern_paths:
                try:
                    if os.path.exists(pattern_path):
                        # Carregar e redimensionar para a largura da tela
                        pattern_img = Image.open(pattern_path)
                        screen_width = 800  # Largura padr√£o
                        new_height = 120  # Altura fixa
                        
                        network_pattern_img = ImageTk.PhotoImage(
                            pattern_img.resize((screen_width, new_height), Image.LANCZOS)
                        )
                        print(f"DEBUG: [GAME_RESULT] Network pattern carregado: {pattern_path}")
                        break
                except Exception as e:
                    print(f"DEBUG: [GAME_RESULT] Erro ao carregar network pattern de {pattern_path}: {e}")
                    continue
            
            if network_pattern_img:
                # Padr√£o superior - posicionado mais acima
                top_pattern = tk.Label(self, image=network_pattern_img, bg="black")
                top_pattern.image = network_pattern_img  # manter refer√™ncia
                top_pattern.place(x=0, y=-55, width=800, height=120, anchor="nw")
                print("DEBUG: [GAME_RESULT] Top pattern adicionado com sucesso")
                
                # Padr√£o inferior - posicionado mais para baixo no ecr√£
                bottom_pattern = tk.Label(self, image=network_pattern_img, bg="black")
                bottom_pattern.image = network_pattern_img  # manter refer√™ncia
                bottom_pattern.place(x=0, y=450, width=800, height=120, anchor="nw")
                print("DEBUG: [GAME_RESULT] Bottom pattern adicionado com sucesso")
            else:
                print("DEBUG: [GAME_RESULT] Network pattern n√£o encontrado")
                
        except Exception as e:
            print(f"DEBUG: [GAME_RESULT] Erro ao carregar/adicionar network patterns: {e}")
        
        # Logo NetMaster (mesmo posicionamento e dimens√£o do menu principal)
        # Verificar se temos as imagens do menu system dispon√≠veis
        use_netmaster_img = False
        netmaster_img = None
        
        try:
            # Tentar carregar a mesma imagem que o IntegratedMenuSystem usa
            logo_path = os.path.join(IMG_DIR, "logo_netmaster_icon_v3.png")
            if os.path.exists(logo_path):
                logo_img = Image.open(logo_path)
                logo_resized = logo_img.resize((140, 55), Image.LANCZOS)
                netmaster_img = ImageTk.PhotoImage(logo_resized)
                use_netmaster_img = True
        except Exception as e:
            print(f"DEBUG: [GAME_RESULT] Erro ao carregar logo: {e}")
        
        if use_netmaster_img and netmaster_img:
            logo_label = tk.Label(self, image=netmaster_img, bg="black")
            logo_label.image = netmaster_img  # manter refer√™ncia
            logo_label.place(relx=0.5, y=10, anchor="n")
        else:
            # Fallback para texto
            logo_label = tk.Label(self, text="NetMaster", font=("Helvetica", 20, "bold"), bg="black", fg="white")
            logo_label.place(relx=0.5, y=10, anchor="n")
        
        # T√≠tulo principal - GAME FINISHED em vermelho
        title_text = "GAME FINISHED"
        title_label = tk.Label(
            self, 
            text=title_text,
            font=("Helvetica", 24, "bold"),
            fg="red",  # Mudado de "gold" para "red"
            bg="black"
        )
        title_label.place(relx=0.5, rely=0.22, anchor="center")
        
        # Frame principal para conte√∫do central
        content_frame = tk.Frame(self, bg="black")
        content_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # CORRE√á√ÉO: Extrair game_result dos dados da mensagem
        game_result = game_data.get('game_result', {})
        
        # DEBUG: Verificar dados recebidos
        print(f"DEBUG: [GAME_RESULT] Dados completos recebidos: {game_data}")
        print(f"DEBUG: [GAME_RESULT] game_result: {game_result}")
        if 'winner' in game_result:
            print(f"DEBUG: [GAME_RESULT] Winner data: {game_result['winner']}")
        if 'ranking' in game_result:
            print(f"DEBUG: [GAME_RESULT] Ranking data: {game_result['ranking']}")
        
        # Verificar se h√° dados do jogo
        if not game_result or 'winner' not in game_result:
            # Fallback se n√£o h√° dados de resultado
            error_label = tk.Label(
                content_frame,
                text="Game finished but no result data available",
                font=("Helvetica", 20),
                fg="red",
                bg="black"
            )
            error_label.pack(pady=50)
            return
        
        # Informa√ß√µes do vencedor (sem mostrar score)
        winner = game_result['winner']
        winner_text = f"WINNER: {winner['player_name']}"
        winner_label = tk.Label(
            content_frame,
            text=winner_text,
            font=("Helvetica", 28, "bold"),
            fg="lime",
            bg="black"
        )
        winner_label.pack(pady=(0, 30))  # Aumentado o pady de 10 para 30 para compensar a remo√ß√£o do score
        
        # Lista do ranking (sem t√≠tulo "FINAL RANKING")
        for player_rank in game_result['ranking']:
            position = player_rank['position']
            name = player_rank['player_name']
            score = player_rank['score']
            color = player_rank['player_color']
            is_winner = player_rank['is_winner']
            
            # Posi√ß√µes sem emojis
            if position == 1:
                pos_text = "1st"
                text_color = "gold"
            elif position == 2:
                pos_text = "2nd"
                text_color = "silver"
            elif position == 3:
                pos_text = "3rd"
                text_color = "#CD7F32"  # bronze
            else:
                pos_text = f"{position}th"
                text_color = "white"
            
            # Destacar se √© o jogador atual
            if color.lower() == self.player_color.lower():
                text_color = "lime"
                name = f">>> {name} <<<"
            
            rank_text = f"{pos_text} {name} - {score} PICoins"
            rank_label = tk.Label(
                content_frame,
                text=rank_text,
                font=("Helvetica", 16, "bold" if is_winner else "normal"),
                fg=text_color,
                bg="black"
            )
            rank_label.pack(pady=3)
        
        print(f"DEBUG: [GAME_RESULT] Tela de resultado mostrada:")
        print(f"DEBUG: [GAME_RESULT]   Vencedor: {winner['player_name']} ({winner['score']} pontos)")
        print(f"DEBUG: [GAME_RESULT]   Total jogadores: {game_result['total_players']}")
    
    
    
    def return_to_main_menu(self):
        """Volta ao menu principal"""
        print("DEBUG: [GAME_RESULT] Voltando ao menu principal...")
        
        # Fechar a janela atual
        self.destroy()
        
        # Voltar ao menu principal
        try:
            root = self.master
            if root:
                # Limpar a janela principal
                for widget in root.winfo_children():
                    widget.destroy()
                
                # Recriar o sistema de menu
                menu_system = IntegratedMenuSystem(root)
                menu_system.show_main_menu()
        except Exception as e:
            print(f"DEBUG: [GAME_RESULT] Erro ao voltar ao menu: {e}")
            # Em caso de erro, pelo menos fechar a aplica√ß√£o graciosamente
            import sys
            sys.exit(0)

    def show_waiting_for_turn_screen(self, current_player_name, current_player_color):
        """Mostra tela de espera quando n√£o √© a vez do jogador"""
        print(f"[WAITING] [WAITING] Mostrando tela de espera para {current_player_name} ({current_player_color})")
        
        # Limpar a interface atual
        for widget in self.winfo_children():
            widget.destroy()
        
        self.configure(bg="black")
        
        # Obter dimens√µes da tela e configurar fullscreen como na interface principal
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)  # Remove barra de t√≠tulo
        self.attributes("-fullscreen", True)  # Garante fullscreen
        
        # Criar TopBar usando a cor do PR√ìPRIO jogador (n√£o do jogador atual)
        # CORRE√á√ÉO: Usar player_color (pr√≥prio jogador) em vez de current_player_color
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            print(f"DEBUG: [WAITING] Tentando carregar TopBar de: {topbar_img_path}")
            
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [WAITING] TopBar criada com sucesso!")
            else:
                print(f"DEBUG: [WAITING] Arquivo TopBar n√£o encontrado, criando fallback")
                # Criar barra superior fallback
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [WAITING] TopBar fallback criada!")
        except Exception as e:
            print(f"DEBUG: [WAITING] ERRO ao criar TopBar: {e}")
            # Criar barra superior fallback em caso de erro
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
            self.topbar_label = topbar_frame
            print("DEBUG: [WAITING] TopBar fallback criada ap√≥s erro!")
        
        # √çcones dos outros jogadores (esquerda) - seguindo o padr√£o da interface principal
        session_players = self.get_session_players_icons()
        for idx, player_info in enumerate(session_players):
            if idx < len(USER_ICONS):
                try:
                    # Usar √≠cone baseado na cor do jogador da sess√£o
                    color_icon_map = {
                        "red": "red_user_icon.png",
                        "blue": "blue_user_icon.png", 
                        "green": "green_user_icon.png",
                        "yellow": "yellow_user_icon.png"
                    }
                    
                    icon_name = color_icon_map.get(player_info.get('color', 'red'), "red_user_icon.png")
                    icon_path = os.path.join(IMG_DIR, icon_name)
                    
                    if os.path.exists(icon_path):
                        icon_img = ImageTk.PhotoImage(Image.open(icon_path).resize((30,30)))
                        lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                        lbl.image = icon_img
                        lbl.place(x=5+idx*40, y=20)
                        print(f"DEBUG: [WAITING] [ICONS] √çcone criado para {player_info.get('name')} ({player_info.get('color')})")
                    else:
                        print(f"DEBUG: [WAITING] [ICONS] √çcone n√£o encontrado: {icon_path}")
                except Exception as e:
                    print(f"DEBUG: [WAITING] [ICONS] Erro ao criar √≠cone {idx}: {e}")
                    # Fallback para √≠cone padr√£o se houver erro
                    if idx < len(USER_ICONS):
                        icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                        lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                        lbl.image = icon_img
                        lbl.place(x=5+idx*40, y=20)

        # Nome do jogador (centro) - seguindo o padr√£o da interface principal
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # --- BARRA INFERIOR COM IMAGEM (seguindo o padr√£o da interface principal) ---
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: [WAITING] Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: [WAITING] Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem n√£o existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        # Saldo no canto inferior direito (sobre a BelowBar) - seguindo o padr√£o da interface principal
        self.after(100, lambda: self.create_coin_saldo_overlay_waiting(screen_width, screen_height, self.saldo))
        
        # Texto principal: "Waiting for your turn..." (movido para cima)
        waiting_text = tk.Label(
            self,
            text="Waiting for your turn...",
            font=("Helvetica", 24, "bold"),
            fg="white",
            bg="black"
        )
        waiting_text.place(relx=0.5, rely=0.35, anchor="center")
        
        # Subtexto com informa√ß√£o de quem est√° jogando (movido para cima)
        current_player_text = tk.Label(
            self,
            text=f"{current_player_name} is playing",
            font=("Helvetica", 20),
            fg="gray",
            bg="black"
        )
        current_player_text.place(relx=0.5, rely=0.45, anchor="center")
        
        # Loading wheel animada
        self.create_loading_wheel_waiting(screen_width, screen_height)
        
        # *** GARANTIR QUE O TIMER APARECE NA TELA DE ESPERA ***
        # O timer agora √© controlado pelo servidor, ent√£o deve estar sempre presente
        print(f"[SESSION_TIMER] Verificando timer na tela de espera...")
        
        # Garantir que existe session_timer_active e session_time_remaining
        if not hasattr(self, 'session_timer_active'):
            self.session_timer_active = True  # For√ßar timer ativo em multiplayer
            print(f"[SESSION_TIMER] session_timer_active definido como True (tela de espera)")
        
        if not hasattr(self, 'session_time_remaining'):
            # Calcular tempo restante baseado na sess√£o
            if hasattr(netmaster_client, 'session_data') and netmaster_client.session_data:
                duration_minutes = netmaster_client.session_data.get('duration_minutes', 15)
                self.session_time_remaining = duration_minutes * 60  # converter para segundos
                print(f"[SESSION_TIMER] session_time_remaining definido como {self.session_time_remaining}s (tela de espera)")
            else:
                self.session_time_remaining = 900  # 15 minutos padr√£o
                print(f"[SESSION_TIMER] session_time_remaining definido como padr√£o: 900s (tela de espera)")
        
        # Sempre criar o display do timer na tela de espera
        print(f"[SESSION_TIMER] Criando timer display na tela de espera (FOR√áADO)")
        self.after(500, lambda: self.create_session_timer_display(self))
        
        # IMPORTANTE: N√ÉO iniciar countdown local - apenas display
        # O timer ser√° atualizado via timer_sync do servidor
    
    def create_player_icons_waiting(self, screen_width, screen_height):
        """Cria √≠cones dos jogadores no canto superior esquerdo da tela de espera"""
        icon_size = 50
        start_x = 20
        start_y = 20
        spacing = 60
        
        # Mapear cores para √≠cones
        color_icon_map = {
            "red": "red_user_icon.png",
            "blue": "blue_user_icon.png",
            "green": "green_user_icon.png", 
            "yellow": "yellow_user_icon.png"
        }
        
        # Mostrar √≠cone do jogador atual
        my_icon_path = os.path.join(IMG_DIR, color_icon_map.get(self.player_color, "red_user_icon.png"))
        if os.path.exists(my_icon_path):
            icon_pil = Image.open(my_icon_path)
            icon_pil = icon_pil.resize((icon_size, icon_size), Image.Resampling.LANCZOS)
            icon_img = ImageTk.PhotoImage(icon_pil)
            icon_label = tk.Label(self, image=icon_img, bg="black")
            icon_label.image = icon_img
            icon_label.place(x=start_x, y=start_y)
        
        # Mostrar √≠cones dos outros jogadores
        x_offset = spacing
        for other_player in self.other_players:
            if x_offset + start_x > 300:  # Limitar para n√£o sair da tela
                break
                
            other_icon_path = os.path.join(IMG_DIR, color_icon_map.get(other_player.color, "red_user_icon.png"))
            if os.path.exists(other_icon_path):
                other_icon_pil = Image.open(other_icon_path)
                other_icon_pil = other_icon_pil.resize((icon_size, icon_size), Image.Resampling.LANCZOS)
                other_icon_img = ImageTk.PhotoImage(other_icon_pil)
                other_icon_label = tk.Label(self, image=other_icon_img, bg="black")
                other_icon_label.image = other_icon_img
                other_icon_label.place(x=start_x + x_offset, y=start_y)
                
            x_offset += spacing
    
    def create_loading_wheel_waiting(self, screen_width, screen_height):
        """Cria roda de loading animada na tela de espera"""
        self.waiting_loading_angle = 0
        self.waiting_loading_active = True
        
        # Canvas para a roda de loading (movido para cima)
        canvas_size = 80
        self.waiting_canvas = tk.Canvas(
            self,
            width=canvas_size,
            height=canvas_size,
            bg="black",
            highlightthickness=0
        )
        self.waiting_canvas.place(relx=0.5, rely=0.6, anchor="center")
        
        # Iniciar anima√ß√£o
        self.animate_waiting_loading()
    
    def animate_waiting_loading(self):
        """Anima a roda de loading na tela de espera"""
        if not self.waiting_loading_active or not hasattr(self, 'waiting_canvas'):
            return
            
        try:
            # Limpar canvas
            self.waiting_canvas.delete("all")
            
            # Desenhar c√≠rculo de loading
            center = 40
            radius = 30
            
            # Desenhar arcos
            for i in range(8):
                angle = (self.waiting_loading_angle + i * 45) % 360
                
                # Calcular intensidade baseada na posi√ß√£o
                intensity = 255 - (i * 30)
                if intensity < 50:
                    intensity = 50
                    
                color = f"#{intensity:02x}{intensity:02x}{intensity:02x}"
                
                # Desenhar arc
                start_angle = angle
                extent = 45
                
                self.waiting_canvas.create_arc(
                    center - radius, center - radius,
                    center + radius, center + radius,
                    start=start_angle, extent=extent,
                    outline=color, width=4, style="arc"
                )
            
            # Atualizar √¢ngulo
            self.waiting_loading_angle = (self.waiting_loading_angle + 15) % 360
            
            # Agendar pr√≥xima frame
            self.after(100, self.animate_waiting_loading)
            
        except Exception as e:
            print(f"DEBUG: Erro na anima√ß√£o de loading: {e}")
    
    
    def create_coin_saldo_overlay_waiting(self, screen_width, screen_height, saldo):
        """Cria o overlay do coin e saldo para a tela de espera"""
        try:
            coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
            coin_lbl.image = coin_img
            coin_lbl.place(x=screen_width-100, y=30)
            coin_lbl.lift()  # Garante que fica por cima
            
            saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
            saldo_lbl.place(x=screen_width-70, y=30)
            saldo_lbl.lift()  # Garante que fica por cima
            
            print(f"DEBUG: [WAITING] Overlay coin/saldo criado com sucesso - saldo: {saldo}")
        except Exception as e:
            print(f"DEBUG: [WAITING] Erro ao criar overlay coin/saldo: {e}")
    
    def stop_waiting_animations(self):
        """Para todas as anima√ß√µes da tela de espera"""
        self.waiting_loading_active = False

    # *** HANDLERS PARA MULTIPLAYER ***
    
    def on_multiplayer_turn_changed(self, data):
        """Handler para mudan√ßas de turno durante o jogo"""
        print(f"[DASHBOARD_TURN_CHANGED] *** MUDAN√áA DE TURNO RECEBIDA NO DASHBOARD ***")
        print(f"[DASHBOARD_TURN_CHANGED] Data: {data}")
        
        current_player_id = data.get('current_player_id')
        current_player_name = data.get('current_player_name', 'Unknown')
        current_player_color = data.get('current_player_color', 'unknown')
        player_order = data.get('player_order', [])
        current_turn_index = data.get('current_turn_index', 0)
        
        print(f"[DASHBOARD_TURN_CHANGED] Jogador atual: {current_player_name} ({current_player_color})")
        print(f"[DASHBOARD_TURN_CHANGED] Meu player_id: {getattr(netmaster_client, 'player_id', None)}")
        
        # Verificar se √© a vez deste jogador
        my_player_id = getattr(netmaster_client, 'player_id', None)
        is_my_turn = (current_player_id == my_player_id)
        
        def update_ui():
            if is_my_turn:
                print(f"[DASHBOARD_TURN_CHANGED] ‚úì √â o meu turno! Mudando para dice roll screen")
                # √â a minha vez - ir para dice roll
                self.waiting_for_turn = False
                
                # Obter par√¢metros necess√°rios para show_dice_roll_screen
                player_name = current_player_name
                saldo = getattr(self, 'saldo', 1000)  # Usar saldo actual ou default
                
                # Construir lista de outros jogadores
                other_players = []
                session_data = getattr(netmaster_client, 'session_data', {})
                players = session_data.get('players', {})
                for pid, pdata in players.items():
                    if pid != my_player_id:  # Excluir o pr√≥prio jogador
                        other_players.append({
                            'name': pdata.get('name', 'Unknown'),
                            'color': pdata.get('color', 'white'),
                            'id': pid
                        })
                
                # Obter dimens√µes da janela
                screen_width = self.winfo_screenwidth()
                screen_height = self.winfo_screenheight()
                
                print(f"[DASHBOARD_TURN_CHANGED] Par√¢metros: player_name={player_name}, saldo={saldo}, outros_jogadores={len(other_players)}")
                self.show_dice_roll_screen(player_name, saldo, other_players, screen_width, screen_height)
            else:
                print(f"[DASHBOARD_TURN_CHANGED] Continuo aguardando - mostrando waiting screen para {current_player_name}")
                # Continuar aguardando - atualizar waiting screen
                self.waiting_for_turn = True
                self.current_turn_player_id = current_player_id
                self.show_waiting_for_turn_screen(current_player_name, current_player_color)
        
        self.after(0, update_ui)
    
    def on_player_joined(self, data):
        """Handler para quando jogador entra na sess√£o durante o jogo"""
        print(f"[DASHBOARD_PLAYER_JOINED] Jogador entrou na sess√£o: {data}")
        # TODO: Atualizar lista de jogadores se necess√°rio
    
    def on_player_left(self, data):
        """Handler para quando jogador sai da sess√£o durante o jogo"""
        print(f"[DASHBOARD_PLAYER_LEFT] Jogador saiu da sess√£o: {data}")
        # TODO: Atualizar lista de jogadores se necess√°rio
    
    def on_heartbeat_ack(self, data):
        """Handler para acknowledgment do heartbeat"""
        # Implementa√ß√£o simples - apenas log se necess√°rio
        pass
    
    def on_timer_sync(self, data):
        """Handler para sincroniza√ß√£o do timer de sess√£o - apenas aceita atualiza√ß√µes do servidor"""
        try:
            # Verificar se a atualiza√ß√£o vem do servidor
            source = data.get('source')
            if source != 'server':
                print(f"[TIMER_SYNC] Ignorando timer_sync n√£o-servidor (source: {source})")
                return
            
            # Receber atualiza√ß√£o do timer do servidor
            time_remaining = data.get('time_remaining', 0)
            
            print(f"[TIMER_SYNC] Recebida atualiza√ß√£o do timer do SERVIDOR: {time_remaining:.1f}s")
            
            # Atualizar estado local do timer (mas n√£o executar countdown pr√≥prio)
            self.session_time_remaining = time_remaining
            self.session_timer_active = True  # Timer sempre ativo se vem do servidor
            
            # Atualizar display imediatamente se existir
            if hasattr(self, 'session_timer_label') and self.session_timer_label:
                self.update_timer_display()
                
        except Exception as e:
            print(f"[TIMER_SYNC] Erro ao processar sincroniza√ß√£o do timer: {e}")
    
    def _verificar_cartas_pendentes(self):
        """
        NOVO SISTEMA: Verifica no servidor se h√° cartas Actions/Events armazenadas para este jogador
        Chamado quando o jogador inicia sua vez (interface principal)
        """
        print(f"[PENDING_CARDS] *** VERIFICANDO CARTAS PENDENTES PARA {self.player_color} ***")
        
        # Verifica√ß√£o corrigida da conex√£o
        if not hasattr(__main__, 'netmaster_client') or not __main__.netmaster_client:
            print(f"[PENDING_CARDS] NetMaster client n√£o existe - pulando verifica√ß√£o")
            return
            
        if not hasattr(__main__.netmaster_client, 'connected') or not __main__.netmaster_client.connected:
            print(f"[PENDING_CARDS] Cliente n√£o conectado - pulando verifica√ß√£o")
            return
            
        if not hasattr(__main__.netmaster_client, 'player_id') or not __main__.netmaster_client.player_id:
            print(f"[PENDING_CARDS] Player ID n√£o dispon√≠vel - pulando verifica√ß√£o")
            return
        
        try:
            # Mensagem para solicitar cartas pendentes
            message = {
                'type': 'get_pending_cards',
                'player_id': __main__.netmaster_client.player_id,
                'player_color': self.player_color
            }
            
            print(f"[PENDING_CARDS] Solicitando cartas pendentes ao servidor: {message}")
            print(f"[PENDING_CARDS] Player ID: {__main__.netmaster_client.player_id}")
            print(f"[PENDING_CARDS] Session ID: {getattr(__main__.netmaster_client, 'session_id', 'N/A')}")
            
            # Enviar solicita√ß√£o ao servidor usando threading para compatibilidade com Tkinter
            import threading
            import asyncio
            
            def enviar_mensagem():
                try:
                    # Criar novo loop de eventos para esta thread
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    
                    # Executar o envio da mensagem
                    resultado = loop.run_until_complete(__main__.netmaster_client.send_message(message))
                    
                    print(f"[PENDING_CARDS] Mensagem enviada com sucesso: {resultado}")
                    
                    # Fechar o loop
                    loop.close()
                    
                except Exception as e:
                    print(f"[PENDING_CARDS] Erro ao enviar mensagem em thread: {e}")
                    import traceback
                    print(f"[PENDING_CARDS] Traceback: {traceback.format_exc()}")
            
            # Executar em thread separada
            thread = threading.Thread(target=enviar_mensagem, daemon=True)
            thread.start()
            
        except Exception as e:
            print(f"[PENDING_CARDS] ERROR: Erro ao verificar cartas pendentes: {e}")
            import traceback
            print(f"[PENDING_CARDS] Traceback: {traceback.format_exc()}")
    
    def on_pending_cards_received(self, data):
        """
        NOVO SISTEMA: Handler para receber cartas pendentes do servidor
        Adiciona as cartas ao invent√°rio do jogador
        """
        print(f"[PENDING_CARDS] *** RECEBIDAS CARTAS PENDENTES: {data} ***")
        
        try:
            pending_cards = data.get('cards', [])
            
            if not pending_cards:
                print(f"[PENDING_CARDS] Nenhuma carta pendente para {self.player_color}")
                return
            
            print(f"[PENDING_CARDS] Processando {len(pending_cards)} cartas pendentes")
            
            # Processar cada carta pendente
            for card_data in pending_cards:
                try:
                    card_path = card_data.get('card_path')
                    card_type = card_data.get('card_type', '').lower()  # 'actions' ou 'events'
                    from_player = card_data.get('from_player', 'Unknown')
                    
                    print(f"[PENDING_CARDS] Processando carta: {card_path} de {from_player} (tipo: {card_type})")
                    
                    # Adicionar carta ao invent√°rio apropriado usando o m√©todo existente
                    if card_type in ['actions', 'events']:
                        self.adicionar_carta_inventario(card_path, card_type)
                        print(f"[PENDING_CARDS] ‚úì {card_type.title()} adicionada ao invent√°rio")
                        
                        # CR√çTICO: Verificar posi√ß√£o na fila ap√≥s adi√ß√£o
                        is_first = self._is_first_card_in_actions_events_queue(card_path)
                        is_active = self.is_card_active(card_path, card_type)
                        print(f"[PENDING_CARDS] VERIFICA√á√ÉO: {os.path.basename(card_path)}")
                        print(f"[PENDING_CARDS]   - √â primeira na fila? {is_first}")
                        print(f"[PENDING_CARDS]   - Est√° ativa? {is_active}")
                        
                        if is_active and not is_first:
                            print(f"[PENDING_CARDS] INCONSIST√äNCIA: Carta ativa mas n√£o √© primeira na fila!")
                        elif not is_active and is_first:
                            print(f"[PENDING_CARDS] INCONSIST√äNCIA: Carta primeira na fila mas n√£o ativa!")
                        elif is_active and is_first:
                            print(f"[PENDING_CARDS] ‚úì CORRETO: Carta primeira na fila e ativa")
                        else:
                            print(f"[PENDING_CARDS] ‚úì CORRETO: Carta n√£o √© primeira na fila e n√£o est√° ativa")
                    else:
                        print(f"[PENDING_CARDS] Tipo de carta desconhecido: {card_type}")
                    
                except Exception as card_error:
                    print(f"[PENDING_CARDS] ERROR: Erro ao processar carta individual: {card_error}")
                    continue
            
            print(f"[PENDING_CARDS] ‚úì SUCCESS: Todas as cartas pendentes processadas")
            
            # ADICIONAL: Mostrar estado final da fila cronol√≥gica
            if hasattr(self, '_actions_events_order'):
                print(f"[PENDING_CARDS] FILA FINAL Actions/Events ({len(self._actions_events_order)} cartas):")
                for i, entry in enumerate(self._actions_events_order):
                    card_name = os.path.basename(entry['path'])
                    card_type = entry['type']
                    timestamp = entry.get('timestamp', 0)
                    is_active = self.is_card_active(entry['path'], card_type)
                    status = "ATIVA" if is_active else "INATIVA"
                    print(f"[PENDING_CARDS]   {i+1}. {card_name} ({card_type}) - t{timestamp} - {status}")
            else:
                print(f"[PENDING_CARDS] Nenhuma fila Actions/Events definida")
            
        except Exception as e:
            print(f"[PENDING_CARDS] ERROR: Erro ao processar cartas pendentes: {e}")
            import traceback
            print(f"[PENDING_CARDS] Traceback: {traceback.format_exc()}")

    def on_card_returned_to_store(self, data):
        """
        Handler para quando uma carta √© devolvida √† Store porque o jogador alvo n√£o estava na sess√£o
        """
        try:
            print(f"[CARD_RETURN] *** CARTA DEVOLVIDA √Ä STORE ***")
            print(f"[CARD_RETURN] Data: {data}")
            
            reason = data.get('reason', 'Unknown')
            message = data.get('message', '')
            card_path = data.get('card_path', '')
            card_type = data.get('card_type', '')
            status = data.get('status', '')
            
            print(f"[CARD_RETURN] Motivo: {reason}")
            print(f"[CARD_RETURN] Mensagem: {message}")
            print(f"[CARD_RETURN] Carta: {card_path}")
            print(f"[CARD_RETURN] Tipo: {card_type}")
            print(f"[CARD_RETURN] Status: {status}")
            
            if reason == 'target_player_not_in_session':
                print(f"[CARD_RETURN] ‚úì Carta devolvida √† Store - jogador alvo n√£o estava na sess√£o")
                print(f"[CARD_RETURN] A carta {card_type} est√° novamente dispon√≠vel na Store")
                
                # Opcionalmente, mostrar uma mensagem ao jogador
                # Pode implementar um popup ou notifica√ß√£o visual aqui
                
            else:
                print(f"[CARD_RETURN] Motivo de devolu√ß√£o desconhecido: {reason}")
            
            print(f"[CARD_RETURN] *** PROCESSAMENTO CONCLU√çDO ***")
            
        except Exception as e:
            print(f"[CARD_RETURN] ERROR: Erro ao processar carta devolvida: {e}")
            import traceback
            print(f"[CARD_RETURN] Traceback: {traceback.format_exc()}")
    
    def sync_score_with_server(self, reason=""):
        """Sincroniza o saldo atual com o servidor"""
        print(f"DEBUG: [SCORE_SYNC] Iniciando sincroniza√ß√£o: {reason}")
        try:
            # Verificar se temos acesso ao cliente global
            import __main__
            
            # Debug: verificar exist√™ncia do cliente
            has_client = hasattr(__main__, 'netmaster_client')
            print(f"DEBUG: [SCORE_SYNC] __main__.netmaster_client existe: {has_client}")
            
            if not has_client:
                print(f"[SCORE_SYNC] AVISO: __main__.netmaster_client n√£o existe - saldo n√£o sincronizado ({reason})")
                return
            
            netmaster_client = __main__.netmaster_client
            print(f"DEBUG: [SCORE_SYNC] netmaster_client: {netmaster_client}")
            
            if not netmaster_client:
                print(f"[SCORE_SYNC] AVISO: __main__.netmaster_client √© None - saldo n√£o sincronizado ({reason})")
                return
            
            # Debug: verificar conex√£o
            is_connected = getattr(netmaster_client, 'connected', False)
            print(f"DEBUG: [SCORE_SYNC] netmaster_client.connected: {is_connected}")
                
            if not is_connected:
                print(f"[SCORE_SYNC] AVISO: N√£o conectado ao servidor - saldo n√£o sincronizado ({reason})")
                return
            
            print(f"DEBUG: [SCORE_SYNC] Cliente encontrado e conectado")
            
            # Obter informa√ß√µes do jogador
            player_id = getattr(netmaster_client, 'player_id', None)
            session_id = getattr(netmaster_client, 'session_id', None)
            
            print(f"DEBUG: [SCORE_SYNC] player_id: {player_id}, session_id: {session_id}")
            
            if not player_id:
                print(f"[SCORE_SYNC] AVISO: player_id n√£o dispon√≠vel - saldo n√£o sincronizado ({reason})")
                return
            
            # Enviar atualiza√ß√£o de saldo para o servidor
            score_update_message = {
                'type': 'update_player_score',
                'player_id': player_id,
                'score': self.saldo,
                'session_id': session_id,
                'reason': reason  # Para debug/logging
            }
            
            print(f"DEBUG: [SCORE_SYNC] Mensagem a enviar: {score_update_message}")
            
            # Usar threading para n√£o bloquear a UI
            def send_score_update():
                try:
                    import asyncio
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(netmaster_client.send_message(score_update_message))
                    loop.close()
                    print(f"[SCORE_SYNC] ‚úì Saldo sincronizado: {self.saldo} PICoins ({reason})")
                except Exception as e:
                    print(f"[SCORE_SYNC] ‚ùå Erro ao sincronizar saldo: {e}")
            
            threading.Thread(target=send_score_update, daemon=True).start()
            
        except Exception as e:
            print(f"[SCORE_SYNC] Erro na sincroniza√ß√£o de saldo: {e}")

# Exemplo de uso integrado com menu:
if __name__ == "__main__":
    print("A iniciar aplica√ß√£o NetMaster integrada...")
    root = tk.Tk()
    root.attributes("-fullscreen", True)
    root.title("NetMaster")
    root.configure(bg="black")
    
    # Inicializar sistema de menu integrado
    menu_system = IntegratedMenuSystem(root)
    menu_system.show_main_menu()
    
    # Verificar GPIO KEY1 para sair
    check_gpio_key(root)
    
    root.mainloop()