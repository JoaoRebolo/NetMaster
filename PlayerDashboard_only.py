import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import os
import re
import traceback
import subprocess
import json
try:
    import RPi.GPIO as GPIO
except ImportError:
    # Mock para ambiente de desenvolvimento sem GPIO
    class MockGPIO:
        BCM = "BCM"
        IN = "IN"
        PUD_UP = "PUD_UP"
        LOW = False
        @staticmethod
        def setmode(mode): pass
        @staticmethod  
        def setup(pin, mode, pull_up_down=None): pass
        @staticmethod
        def input(pin): return True
        @staticmethod
        def cleanup(): pass
    GPIO = MockGPIO()
import random
from Store import StoreWindow
# Importar utilitários para detecção de Raspberry Pi
from raspberry_pi_utils import get_universal_paths, find_existing_path, get_possible_raspberry_pi_paths
# Importar sistema de integração da base de dados
try:
    from card_integration import IntegratedCardDatabase
    from cards_database import ActionType
    print("DEBUG: IntegratedCardDatabase e ActionType importadas com sucesso")
except ImportError as e:
    print(f"DEBUG: ERRO ao importar IntegratedCardDatabase ou ActionType: {e}")
    IntegratedCardDatabase = None
    ActionType = None

# Obter caminhos universais usando os utilitários
universal_paths = get_universal_paths()
IMG_DIR = universal_paths['img_dir']
print(f"DEBUG: Usando IMG_DIR: {IMG_DIR} (ambiente: {universal_paths['environment']})")

# Detectar automaticamente onde estão as cartas
def detect_cartas_base_dir():
    """Detecta automaticamente o diretório base das cartas usando caminhos universais"""
    # Usar os caminhos universais já detectados
    universal_paths = get_universal_paths()
    
    # CORREÇÃO ESPECÍFICA: Se estivermos no Raspberry Pi, forçar o caminho correto
    if universal_paths['environment'] == 'raspberry_pi':
        raspberry_cartas_dir = "/home/joaorebolo2/netmaster_menu/img/cartas"
        if os.path.exists(raspberry_cartas_dir):
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Usando caminho correto: {raspberry_cartas_dir}")
            return raspberry_cartas_dir
        else:
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Caminho esperado não existe: {raspberry_cartas_dir}")
            print(f"DEBUG: [detect_cartas_base_dir] RASPBERRY PI - Usando fallback: {universal_paths['cartas_dir']}")
            return universal_paths['cartas_dir']
    
    # Para desenvolvimento local, usar a lógica original
    # Testar se o diretório base tem a estrutura esperada de cartas
    test_paths = [
        os.path.join(universal_paths['base_dir'], "Activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Users", "Residential-level"),  
        os.path.join(universal_paths['base_dir'], "Events", "Residential-level")
    ]
    
    if any(os.path.exists(test_path) for test_path in test_paths):
        print(f"DEBUG: Usando diretório de cartas: {universal_paths['base_dir']}")
        return universal_paths['base_dir']
    
    # Se não encontrar na estrutura esperada, tentar o diretório de cartas
    if os.path.exists(universal_paths['cartas_dir']):
        print(f"DEBUG: Usando diretório de cartas alternativo: {universal_paths['cartas_dir']}")
        return os.path.dirname(universal_paths['cartas_dir'])
    
    print("DEBUG: Nenhum diretório de cartas encontrado, usando base_dir como fallback")
    return universal_paths['base_dir']

def detect_player_inventory_base_dir():
    """Detecta automaticamente o diretório base do inventário do jogador"""
    # Usar os utilitários universais
    universal_paths = get_universal_paths()
    
    print(f"DEBUG: [detect_player_inventory_base_dir] Ambiente detectado: {universal_paths['environment']}")
    print(f"DEBUG: [detect_player_inventory_base_dir] Verificando diretórios possíveis...")
    print(f"DEBUG: [detect_player_inventory_base_dir] Diretório base: {universal_paths['base_dir']}")
    
    # CORREÇÃO ESPECÍFICA: Se estivermos no Raspberry Pi, forçar o caminho correto
    if universal_paths['environment'] == 'raspberry_pi':
        raspberry_cartas_dir = "/home/joaorebolo2/netmaster_menu/img/cartas"
        if os.path.exists(raspberry_cartas_dir):
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Usando caminho correto: {raspberry_cartas_dir}")
            return raspberry_cartas_dir
        else:
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Caminho esperado não existe: {raspberry_cartas_dir}")
            print(f"DEBUG: [detect_player_inventory_base_dir] RASPBERRY PI - Usando fallback: {universal_paths['cartas_dir']}")
            return universal_paths['cartas_dir']
    
    # Para desenvolvimento local, usar a lógica original
    # Testar se o diretório base tem a estrutura esperada
    test_paths = [
        os.path.join(universal_paths['base_dir'], "Activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Users", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "Events", "Residential-level"),
        # Para Raspberry Pi, testar também estrutura alternativa
        os.path.join(universal_paths['base_dir'], "activities", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "users", "Residential-level"),
        os.path.join(universal_paths['base_dir'], "events", "Residential-level")
    ]
    
    print(f"DEBUG: [detect_player_inventory_base_dir] Testando caminhos:")
    for j, test_path in enumerate(test_paths):
        exists = os.path.exists(test_path)
        print(f"DEBUG: [detect_player_inventory_base_dir]   Teste {j+1}: {test_path} -> {exists}")
        
        if exists:
            print(f"DEBUG: [detect_player_inventory_base_dir] Encontrado inventário em: {universal_paths['base_dir']}")
            return universal_paths['base_dir']
    
    print("DEBUG: Nenhum diretório de inventário do jogador encontrado!")
    print(f"DEBUG: Usando fallback: {universal_paths['base_dir']}")
    return universal_paths['base_dir']

CARTAS_BASE_DIR = detect_cartas_base_dir()
COIN_IMG = os.path.join(IMG_DIR, "picoin.png")
USER_ICONS = [
    os.path.join(IMG_DIR, "red_user_icon.png"),
    os.path.join(IMG_DIR, "green_user_icon.png"),
    os.path.join(IMG_DIR, "blue_user_icon.png"),
    os.path.join(IMG_DIR, "yellow_user_icon.png"),
]

CARD_IMG = os.path.join(IMG_DIR, "cartas", "back_card.png")

# GPIO setup para botão KEY1
KEY1_PIN = 23
GPIO.setmode(GPIO.BCM)
GPIO.setup(KEY1_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

BOARD = [
    # Top row (left to right)
    ("start", "neutral"),      # 0 canto azul
    ("users", "blue"),         # 1
    ("actions", "neutral"),     # 2 (cinzento)
    ("equipments", "blue"),     # 3
    ("challenges", "neutral"), # 4 (cinzento)
    ("activities", "red"),      # 5
    ("events", "neutral"),     # 6 (cinzento)
    ("services", "red"),       # 7

    # Right column (top to bottom)
    ("start", "neutral"),      # 8 canto vermelho
    ("users", "red"),          # 9
    ("actions", "neutral"),     # 10 (cinzento)
    ("equipments", "red"),      # 11
    ("challenges", "neutral"), # 12 (cinzento)
    ("activities", "yellow"),   # 13
    ("events", "neutral"),     # 14 (cinzento)
    ("services", "yellow"),    # 15

    # Bottom row (right to left)
    ("start", "neutral"),      # 16 canto amarelo
    ("users", "yellow"),       # 17
    ("actions", "neutral"),     # 18 (cinzento)
    ("equipments", "yellow"),   # 19
    ("challenges", "neutral"), # 20 (cinzento)
    ("activities", "green"),    # 21
    ("events", "neutral"),     # 22 (cinzento)
    ("services", "green"),     # 23

    # Left column (bottom to top)
    ("start", "neutral"),      # 24 canto verde
    ("users", "green"),        # 25
    ("actions", "neutral"),     # 26 (cinzento)
    ("equipments", "green"),    # 27
    ("challenges", "neutral"), # 28 (cinzento)
    ("activities", "blue"),     # 29
    ("events", "neutral"),     # 30 (cinzento)
    ("services", "blue"),      # 31
]
NUM_CASAS = len(BOARD)

START_POSITIONS = {
    "blue": 0,
    "red": 8,
    "yellow": 16,
    "green": 24
}

def check_gpio_key(root):
    if GPIO.input(KEY1_PIN) == GPIO.LOW:
        GPIO.cleanup()
        root.destroy()
    root.after(100, lambda: check_gpio_key(root))
    
def mostrar_carta_fullscreen_root(root, carta_path, selected_card_idx=0):
    # Limpa tudo do root
    for widget in root.winfo_children():
        widget.destroy()
    root.configure(bg="black")

    pil_img = Image.open(carta_path)
    img_w, img_h = pil_img.size
    max_w, max_h = root.winfo_screenwidth(), root.winfo_screenheight()
    ratio = min(max_w/img_w, max_h/img_h)
    new_w, new_h = int(img_w*ratio), int(img_h*ratio)
    pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

    carta_img = ImageTk.PhotoImage(pil_img)
    carta_real_lbl = tk.Label(root, image=carta_img, bg="black")
    carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
    carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

    # Botão de fechar (X)
    x_img_path = os.path.join(os.path.dirname(__file__), "img", "X_button.png")
    x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
    x_btn = tk.Label(root, image=x_img, cursor="hand2", bg="black")
    x_btn.image = x_img  # type: ignore[attr-defined]
    x_btn.place(relx=0.98, rely=0.02, anchor="ne")

    def fechar():
        carta_real_lbl.destroy()
        x_btn.destroy()
        # Restaura o dashboard mantendo a carta selecionada
        PlayerDashboard(root, player_color="green", saldo=1000, other_players=["red", "blue", "yellow"], selected_card_idx=selected_card_idx)
    x_btn.bind("<Button-1>", lambda e: fechar())

def make_card_callback(parent, idx):
    def callback(event):
        # Remove destaque de todas as cartas
        for lbl in parent.card_labels:
            try:
                if lbl.winfo_exists():
                    lbl.config(highlightthickness=0)
            except tk.TclError:
                continue
            # lbl.selected = False  # Removido para linter
        # Destaca a carta clicada
        clicked_label = event.widget
        try:
            if clicked_label.winfo_exists():
                clicked_label.config(highlightbackground="#8000FF", highlightcolor="#8000FF", highlightthickness=4)
        except tk.TclError:
            pass
        # clicked_label.selected = True  # Removido para linter
        parent.selected_label = clicked_label # Adicionado para armazenar a referência
        parent.selected_card_idx = idx
        parent.update_progress_bars_for_card(idx)
    return callback

def get_equipment_object_name(carta_path, card_database=None):
    """
    Obtém o object_name de uma carta Equipment para usar na deteção de objetos.
    
    Args:
        carta_path: Caminho para a carta Equipment (ex: "/path/Equipment_1.png")
        card_database: Instância da base de dados de cartas (opcional)
        
    Returns:
        Object name para deteção (ex: "router_simples_vermelho") ou None se não encontrado
    """
    try:
        if not card_database:
            # Criar instância temporária da base de dados se necessário
            from card_integration import IntegratedCardDatabase
            card_database = IntegratedCardDatabase(".")
        
        # Extrair informações do caminho da carta
        filename = os.path.basename(carta_path)
        
        # Determinar cor baseada no diretório
        color = None
        if "/Blue/" in carta_path or "/blue/" in carta_path:
            color = "blue"
        elif "/Red/" in carta_path or "/red/" in carta_path:
            color = "red"
        elif "/Green/" in carta_path or "/green/" in carta_path:
            color = "green"
        elif "/Yellow/" in carta_path or "/yellow/" in carta_path:
            color = "yellow"
        
        if not color:
            print(f"DEBUG: [OBJECT_NAME] Não foi possível determinar cor para {carta_path}")
            return None
        
        # Mapear filename para equipment_id na base de dados
        # Equipment_1.png, Equipment_2.png, Equipment_3.png -> small_router_1_color
        # Equipment_4.png, Equipment_5.png, Equipment_6.png -> medium_router_1_color
        # Equipment_7.png, Equipment_8.png, Equipment_9.png -> short_link_1_color
        # Equipment_10.png, Equipment_11.png, Equipment_12.png -> long_link_1_color
        
        match = re.match(r'Equipment_(\d+)\.png', filename)
        if not match:
            print(f"DEBUG: [OBJECT_NAME] Formato de filename inválido: {filename}")
            return None
        
        equipment_num = int(match.group(1))
        
        # Mapear número para tipo e ID específico
        if 1 <= equipment_num <= 3:
            equipment_type = "small_router"
            specific_id = equipment_num
        elif 4 <= equipment_num <= 6:
            equipment_type = "medium_router"
            specific_id = equipment_num - 3
        elif 7 <= equipment_num <= 9:
            equipment_type = "short_link"
            specific_id = equipment_num - 6
        elif 10 <= equipment_num <= 12:
            equipment_type = "long_link"
            specific_id = equipment_num - 9
        else:
            print(f"DEBUG: [OBJECT_NAME] Número de equipment inválido: {equipment_num}")
            return None
        
        # Construir equipment_id
        equipment_id = f"{equipment_type}_{specific_id}_{color}"
        
        # Obter carta da base de dados
        equipment_result = card_database.get_equipment_with_file(equipment_id)
        
        if equipment_result:
            equipment_card, file_path = equipment_result
            if hasattr(equipment_card, 'object_name') and equipment_card.object_name:
                print(f"DEBUG: [OBJECT_NAME] Object name encontrado para {filename}: {equipment_card.object_name}")
                return equipment_card.object_name
            else:
                print(f"DEBUG: [OBJECT_NAME] EquipmentCard encontrado mas sem object_name: {equipment_id}")
                return None
        else:
            print(f"DEBUG: [OBJECT_NAME] Equipment não encontrado na base de dados para equipment_id: {equipment_id}")
            return None
            
    except Exception as e:
        print(f"DEBUG: [OBJECT_NAME] Erro ao obter object_name: {e}")
        return None

def create_yolo_loading_screen(parent_window, object_name):
    """
    Cria uma tela de loading fullscreen que aparece durante a inicialização do YOLO.
    
    Args:
        parent_window: Janela principal do PlayerDashboard
        object_name: Nome do objeto sendo detectado
        
    Returns:
        Janela de loading criada
    """
    try:
        # Criar janela de loading como Toplevel
        loading_window = tk.Toplevel(parent_window)
        loading_window.title("YOLO Detection Loading")
        loading_window.configure(bg="black")
        
        # Configurar fullscreen
        screen_width = parent_window.winfo_screenwidth()
        screen_height = parent_window.winfo_screenheight()
        loading_window.geometry(f"{screen_width}x{screen_height}+0+0")
        loading_window.overrideredirect(True)
        loading_window.attributes("-fullscreen", True)
        
        # Garantir que a janela fica sempre no topo
        loading_window.attributes("-topmost", True)
        loading_window.lift()
        loading_window.focus_force()
        
        # Frame principal centralizado
        main_frame = tk.Frame(loading_window, bg="black")
        main_frame.pack(expand=True, fill="both")
        
        # Container para conteúdo centralizado
        content_frame = tk.Frame(main_frame, bg="black")
        content_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Título principal
        title_label = tk.Label(content_frame, 
                              text="YOLO Object Detection", 
                              font=("Helvetica", 20, "bold"), 
                              fg="#8A2BE2", 
                              bg="black")
        title_label.pack(pady=(0, 20))
        
        # Subtítulo com objeto sendo detectado - texto explicativo em branco
        init_label = tk.Label(content_frame, 
                             text="Initializing detection for:", 
                             font=("Helvetica", 15), 
                             fg="white", 
                             bg="black")
        init_label.pack(pady=(0, 5))
        
        # Nome do objeto em ciano para destaque
        object_label = tk.Label(content_frame, 
                               text=object_name, 
                               font=("Helvetica", 15), 
                               fg="#00FFFF", 
                               bg="black")
        object_label.pack(pady=(0, 25))
        
        # Indicador de loading animado
        loading_label = tk.Label(content_frame, 
                                text="Loading", 
                                font=("Helvetica", 18, "bold"), 
                                fg="#FFD700", 
                                bg="black")
        loading_label.pack(pady=(0, 20))
        
        # Barra de progresso visual simples
        progress_frame = tk.Frame(content_frame, bg="black")
        progress_frame.pack(pady=(0, 30))
        
        # Criar barra de progresso usando labels
        progress_bars = []
        for i in range(8):
            bar = tk.Label(progress_frame, text="█", font=("Helvetica", 20), 
                          fg="#333333", bg="black")
            bar.pack(side="left", padx=2)
            progress_bars.append(bar)
        
        # Mensagem de status
        status_label = tk.Label(content_frame, 
                               text="Starting camera and loading AI model...", 
                               font=("Helvetica", 14), 
                               fg="#CCCCCC", 
                               bg="black")
        status_label.pack(pady=(0, 10))
        
        # Mensagem informativa
        info_label = tk.Label(content_frame, 
                             text="This may take a few seconds", 
                             font=("Helvetica", 12, "italic"), 
                             fg="#888888", 
                             bg="black")
        info_label.pack()
        
        # Animação do loading
        loading_states = ["Loading", "Loading.", "Loading..", "Loading..."]
        loading_index = 0
        
        progress_index = 0
        progress_colors = ["#FF0000", "#FF4500", "#FFD700", "#00FF00"]
        
        def animate_loading():
            nonlocal loading_index, progress_index
            
            # Animar texto de loading
            loading_label.config(text=loading_states[loading_index])
            loading_index = (loading_index + 1) % len(loading_states)
            
            # Animar barra de progresso
            # Reset todas as barras
            for bar in progress_bars:
                bar.config(fg="#333333")
            
            # Iluminar barras progressivamente
            for i in range((progress_index % 16) // 2 + 1):
                if i < len(progress_bars):
                    color_idx = min(i, len(progress_colors) - 1)
                    progress_bars[i].config(fg=progress_colors[color_idx])
            
            progress_index += 1
            
            # Continuar animação se a janela ainda existe
            try:
                loading_window.after(300, animate_loading)
            except tk.TclError:
                # Janela foi destruída
                pass
        
        # Iniciar animação
        animate_loading()
        
        # Forçar atualização da interface
        loading_window.update_idletasks()
        loading_window.update()
        
        print(f"DEBUG: [LOADING] Loading screen criado com sucesso")
        
        return loading_window
        
    except Exception as e:
        print(f"DEBUG: [LOADING] Erro ao criar loading screen: {e}")
        return None

def execute_detection_script_direct(object_name, parent_window=None, existing_loading_window=None):
    """
    Executa o script YOLO diretamente com loading screen já existente.
    
    Args:
        object_name: Nome do objeto para deteção
        parent_window: Janela principal 
        existing_loading_window: Loading screen já criado
    
    Returns:
        True se o script executou com sucesso, False caso contrário
    """
    try:
        # Usar os utilitários universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION_DIRECT] Simulando execução do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            # Simular delay e fechar loading screen
            if existing_loading_window:
                def close_loading_and_return():
                    existing_loading_window.destroy()
                    if parent_window:
                        parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
                parent_window.after(3000, close_loading_and_return)
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe
        if not os.path.exists(script_path):
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION_DIRECT] Script não encontrado")
                return False
        
        print(f"DEBUG: [DETECTION_DIRECT] Executando: {script_path} {object_name}")
        
        # Tornar o script executável
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION_DIRECT] Script iniciado (PID: {process.pid})")
        
        # Monitorar script com loading screen existente
        if parent_window and existing_loading_window:
            def check_yolo_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO deve estar inicializado - fechar loading screen
                    print(f"DEBUG: [DETECTION_DIRECT] Fechando loading screen - YOLO inicializando")
                    existing_loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclusão
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            parent_window.after(1000, check_script_completion)
                        else:
                            print(f"DEBUG: [DETECTION_DIRECT] YOLO terminou - restaurando interface")
                            parent_window.deiconify()
                            parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
                    
                    parent_window.after(1000, check_script_completion)
                else:
                    # Script terminou antes de inicializar
                    existing_loading_window.destroy()
                    parent_window._voltar_inventario_apos_ativacao(['equipments'], 0)
            
            # Aguardar 4.5 segundos para YOLO inicializar
            parent_window.after(4500, check_yolo_initialization)
        
        return True
        
    except Exception as e:
        print(f"DEBUG: [DETECTION_DIRECT] Erro: {e}")
        if existing_loading_window:
            existing_loading_window.destroy()
        return False

def execute_detection_with_continuation(object_name, parent_window, loading_window, continuation_callback):
    """
    Executa o script YOLO com loading screen e chama callback quando terminar.
    
    Args:
        object_name: Nome do objeto para deteção
        parent_window: Janela principal 
        loading_window: Loading screen já criado
        continuation_callback: Função a chamar quando detecção terminar
    
    Returns:
        True se o script executou com sucesso, False caso contrário
    """
    try:
        # Usar os utilitários universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION_CONTINUATION] Simulando execução do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            # Simular delay e chamar callback
            if loading_window:
                def close_loading_and_continue():
                    loading_window.destroy()
                    continuation_callback()
                parent_window.after(3000, close_loading_and_continue)
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe
        if not os.path.exists(script_path):
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION_CONTINUATION] Script não encontrado")
                return False
        
        print(f"DEBUG: [DETECTION_CONTINUATION] Executando: {script_path} {object_name}")
        
        # Tornar o script executável
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION_CONTINUATION] Script iniciado (PID: {process.pid})")
        
        # Monitorar script com loading screen existente
        if parent_window and loading_window:
            def check_yolo_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO deve estar inicializado - fechar loading screen
                    print(f"DEBUG: [DETECTION_CONTINUATION] Fechando loading screen - YOLO inicializando")
                    loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclusão
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            parent_window.after(1000, check_script_completion)
                        else:
                            print(f"DEBUG: [DETECTION_CONTINUATION] YOLO terminou - chamando callback")
                            parent_window.deiconify()
                            continuation_callback()
                    
                    parent_window.after(1000, check_script_completion)
                else:
                    # Script terminou antes de inicializar
                    loading_window.destroy()
                    continuation_callback()
            
            # Aguardar 4.5 segundos para YOLO inicializar
            parent_window.after(4500, check_yolo_initialization)
        
        return True
        
    except Exception as e:
        print(f"DEBUG: [DETECTION_CONTINUATION] Erro: {e}")
        if loading_window:
            loading_window.destroy()
        return False

def execute_detection_script(object_name, parent_window=None):
    """
    Executa o script detection_fullscreen.sh com o object_name especificado.
    
    Args:
        object_name: Nome do objeto para deteção (ex: "router_simples_vermelho")
        parent_window: Referência à janela principal para controle de visibilidade
        
    Returns:
        True se o script executou com sucesso, False caso contrário
    """
    try:
        # Usar os utilitários universais para detectar ambiente e caminhos
        universal_paths = get_universal_paths()
        
        if universal_paths['environment'] != 'raspberry_pi':
            print(f"DEBUG: [DETECTION] Simulando execução do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
            return True
        
        # Usar o caminho do script detectado automaticamente
        script_path = universal_paths['detection_script']
        
        # Verificar se existe, senão tentar caminhos alternativos
        if not os.path.exists(script_path):
            # Tentar encontrar em caminhos possíveis usando os utilitários
            alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
            alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
            
            script_path = None
            for path in alternative_paths:
                if os.path.exists(path):
                    script_path = path
                    print(f"DEBUG: [DETECTION] Script encontrado em: {script_path}")
                    break
            
            if not script_path:
                print(f"DEBUG: [DETECTION] Script não encontrado em nenhum dos caminhos:")
                for path in alternative_paths[:5]:  # Mostrar apenas os primeiros 5 para não poluir o log
                    print(f"DEBUG: [DETECTION]   - {path}")
                print(f"DEBUG: [DETECTION]   ... e {len(alternative_paths)-5} outros caminhos")
                return False
        else:
            print(f"DEBUG: [DETECTION] Script encontrado em: {script_path}")
        
        # Executar o script
        print(f"DEBUG: [DETECTION] Executando: {script_path} {object_name}")
        
        # Tornar o script executável
        subprocess.run(['chmod', '+x', script_path], check=True)
        
        # CORREÇÃO: Executar script SEM capturar saída para mostrar interface YOLO no LCD
        print(f"DEBUG: [DETECTION] Iniciando detecção com interface visual no LCD...")
        
        # NOVA FUNCIONALIDADE: Criar loading screen antes de esconder interface Python
        loading_window = None
        if parent_window:
            print(f"DEBUG: [DETECTION] Criando loading screen...")
            loading_window = create_yolo_loading_screen(parent_window, object_name)
        
        # Executar script em background
        process = subprocess.Popen([script_path, object_name])
        
        print(f"DEBUG: [DETECTION] Script iniciado em background (PID: {process.pid})")
        print(f"DEBUG: [DETECTION] Interface YOLO deve aparecer em alguns segundos...")
        print(f"DEBUG: [DETECTION] Loading screen ativa até YOLO inicializar")
        
        # Monitorar inicialização do YOLO e conclusão do script
        if parent_window and loading_window:
            def check_yolo_initialization():
                # Verificar se o YOLO já inicializou (processo ainda rodando + tempo suficiente)
                poll_result = process.poll()
                if poll_result is None:
                    # Processo ainda está rodando - verificar se já passou tempo suficiente para YOLO inicializar
                    # Após 4-5 segundos, assumir que YOLO já inicializou e esconder loading screen
                    print(f"DEBUG: [DETECTION] YOLO deve estar inicializado - escondendo loading screen")
                    loading_window.destroy()
                    parent_window.withdraw()  # Esconder interface Python agora
                    
                    # Continuar monitorando conclusão do script
                    def check_script_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            # Processo ainda está rodando - verificar novamente em 1 segundo
                            parent_window.after(1000, check_script_completion)
                        else:
                            # Processo terminou - restaurar interface Python
                            print(f"DEBUG: [DETECTION] Script YOLO terminou (código: {poll_result})")
                            print(f"DEBUG: [DETECTION] Restaurando interface Python...")
                            parent_window.deiconify()  # Mostrar janela novamente
                    
                    # Começar monitoramento de conclusão
                    parent_window.after(1000, check_script_completion)
                else:
                    # Processo já terminou antes do YOLO inicializar - limpar loading screen
                    print(f"DEBUG: [DETECTION] Script terminou antes do YOLO inicializar (código: {poll_result})")
                    loading_window.destroy()
                    parent_window.deiconify()
            
            # Aguardar 9-10 segundos para YOLO inicializar antes de esconder loading screen
            parent_window.after(9500, check_yolo_initialization)
        
        # Retornar sucesso imediatamente - script roda em background
        return True
            
    except subprocess.TimeoutExpired:
        print(f"DEBUG: [DETECTION] Script timeout após 120 segundos")
        return False
    except Exception as e:
        print(f"DEBUG: [DETECTION] Erro ao executar script: {e}")
        return False

class PlayerDashboard(tk.Toplevel):
    def __init__(self, root, player_color, saldo, other_players, player_name="Player", selected_card_idx=0):
        super().__init__(root)
        self.player_color = player_color 
        self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        self.selected_card_idx = selected_card_idx
        self.progress_bars = {}
        self.title("")
        self.configure(bg="black")
        self.player_name = player_name
        self.saldo = saldo
        self.other_players = other_players
        self.card_idx = 0

        # Garantir flags de interação desbloqueadas ao iniciar um novo turno/interface
        self._final_phase_active = False
        self._next_phase_active = False
        self._final_phase_gestao_ativa = False
        
        # Flags para controlar quando carta foi removida e próxima deve ficar virada para baixo
        self._action_recently_removed = False
        self._event_recently_removed = False
        
        # Variáveis para controlar a casa atual (para o botão Store)
        self.current_casa_tipo = "neutral"
        self.current_casa_cor = "neutral"
        self.current_other_player_house = False  # Se está numa casa de outro jogador
        
        self.cards = [
        # Carrossel inicial: cartas viradas para baixo, cor do jogador
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"),
        ]
        self.card_stats = [
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
            {"To send": 0, "Rxd": 0, "Lost": 0},
        ]
        
        # NOVA FUNCIONALIDADE: Sistema de flags para rastrear estado das cartas no carrossel
        # True = carta virada para cima (ativa), False = carta virada para baixo (inativa/back_card)
        self.card_face_up_flags = [False, False, False, False]
        print(f"DEBUG: [INIT] Sistema de flags de cartas inicializado: {self.card_face_up_flags}")
        
        # CORREÇÃO: Restaurar estatísticas preservadas do turno anterior (se existirem)
        if hasattr(root, '_backup_card_stats') and hasattr(root, '_backup_cards'):
            print("DEBUG: [INIT] Encontradas estatísticas preservadas do turno anterior")
            
            # Restaurar estatísticas
            if len(root._backup_card_stats) == len(self.card_stats):
                for i, backup_stats in enumerate(root._backup_card_stats):
                    self.card_stats[i] = {
                        'To send': backup_stats['To send'],
                        'Rxd': backup_stats['Rxd'],
                        'Lost': backup_stats['Lost']
                    }
                    print(f"DEBUG: [INIT] Carta {i} estatísticas restauradas: To send={backup_stats['To send']}, Rxd={backup_stats['Rxd']}, Lost={backup_stats['Lost']}")
            
            # Restaurar caminhos das cartas
            if len(root._backup_cards) == len(self.cards):
                for i, backup_path in enumerate(root._backup_cards):
                    self.cards[i] = backup_path
                    print(f"DEBUG: [INIT] Carta {i} path restaurado: {os.path.basename(backup_path) if backup_path else 'None'}")
            
            # CORREÇÃO CRÍTICA: Restaurar mapeamento de Activities preservadas
            if hasattr(root, '_activity_preserved_stats'):
                self._activity_preserved_stats = root._activity_preserved_stats.copy()
                print(f"DEBUG: [INIT] Mapeamento de Activities preservadas restaurado: {len(self._activity_preserved_stats)} entries")
                for activity_path, stats in self._activity_preserved_stats.items():
                    print(f"DEBUG: [INIT] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # Não limpar já aqui: serão atualizados no end_turn e preservados entre interfaces
            print("DEBUG: [INIT] Backups preservados para consistência entre interfaces")
        else:
            print("DEBUG: [INIT] Nenhuma estatística preservada encontrada - usando valores padrão")
        
        self.inventario = {
            "users": [],
            "equipments": [],
            "services": [],
            "actions": [],
            "events": [],
            "challenges": [], 
            "activities": [],
        }

        # CORREÇÃO CRÍTICA: Inicializar carrossel para evitar erros em adicionar_carta_carrossel
        self.carrossel = []
        print("DEBUG: [INIT] self.carrossel inicializado como lista vazia")

        # Variável para controlar se o botão Store deve estar desabilitado
        self._store_button_disabled = False
        
        # Variável para controlar se um Challenge foi aceite (esconde Next Phase)
        self._challenge_accepted = False
        
        # Inicializar base de dados integrada para valores das cartas
        try:
            if IntegratedCardDatabase:
                self.card_database = IntegratedCardDatabase(".")
                print("DEBUG: Base de dados de cartas inicializada com sucesso")
            else:
                self.card_database = None
                print("DEBUG: Base de dados de cartas não disponível")
        except Exception as e:
            print(f"DEBUG: ERRO ao inicializar base de dados: {e}")
            self.card_database = None
        
        # Variável para controlar se Next Phase está ativo (desabilita vendas)
        self._next_phase_active = False
        
        # Variável para controlar se Next Phase foi ativado manualmente pelo jogador (esconde botão Store)
        self._next_phase_manually_activated = False
        
        # Variável para controlar se Final Phase está ativo (bloqueia ativação/desativação de cartas)
        self._final_phase_active = False
        
        # Variável para controlar se o botão End Turn deve ser mostrado (só após clicar Final Phase)
        self._show_end_turn_button = False
        
        # NOVA VARIÁVEL: Flag para controlar se Final Phase foi clicado NESTE turno específico
        # Evita restauração automática de gestão de pacotes em turnos subsequentes
        self._final_phase_clicked_this_turn = False
        
        # NOVO: ID do turno em que Final Phase foi clicado (para evitar cross-turn contamination)
        self._final_phase_turn_id = None

        # SISTEMA DE CONTROLE DE RATE_MAX POR TURNO
        # Variáveis que resetam a cada turno para controlar quantos pacotes foram processados
        self._rxd_processed_this_turn = {}    # {carta_path: quantidade_processada}
        self._lost_processed_this_turn = {}   # {carta_path: quantidade_processada}
        self._current_turn_id = 1             # ID do turno atual para controle

        # PROTEÇÃO CONTRA LOOP: Flag para evitar abrir inventário recursivamente
        self._inventory_opening = False
        
        # Flag para controlar se overlay de completion está ativo
        self._completion_overlay_active = False
        
        # Cache de User IDs para controlo do carrossel durante Next Phase
        self._cached_user_ids = []

        # SISTEMA DE TRACKING TEMPORAL PARA CHALLENGES
        # CORREÇÃO CRÍTICA: Não inicializar vazio se já existe tracking preservado
        # Isto evita perder o tracking durante reconstruções da interface
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}  # {carta_path: turno_inicio}
            print(f"DEBUG: [CHALLENGE_INIT] Challenge tracking inicializado vazio")
        else:
            print(f"DEBUG: [CHALLENGE_INIT] Challenge tracking já existe: {self._challenge_start_turns}")
        
        # SUPER BACKUP CRÍTICO: Sistema de backup múltiplas camadas para Raspberry Pi
        # Garante que o tracking nunca seja perdido, independentemente do ambiente
        if not hasattr(self.master, '_super_challenge_backup'):
            self.master._super_challenge_backup = {}
            print("DEBUG: [SUPER_BACKUP] Super backup inicializado no master")
        if not hasattr(root, '_super_challenge_backup'):
            root._super_challenge_backup = {}
            print("DEBUG: [SUPER_BACKUP] Super backup inicializado no root")
        
        # Backup global adicional (para casos extremos)
        if not hasattr(self, '_challenge_backup_registry'):
            self._challenge_backup_registry = {}
            print("DEBUG: [SUPER_BACKUP] Backup registry inicializado na instância")
        
        # SISTEMA DE TRACKING DE INTERAÇÕES DO JOGADOR COM CARTAS
        # Registra quando jogador clica em botões +, independente dos valores escolhidos
        self._cartas_interagidas_jogador = set()  # {carta_path} - cartas que tiveram interação do jogador
        
        # CORREÇÃO CRÍTICA: Flag para controlar incrementação de turnos
        self._coming_from_end_turn = False  # True apenas quando vindo de end_turn
        
        # CORREÇÃO CRÍTICA: Preservar contadores de turnos entre sessões
        # Restaurar contadores de turnos preservados ou inicializar em 1
        
        # Detectar ambiente para debug específico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        print(f"DEBUG: [TURN_INIT] ======= INICIALIZAÇÃO DOS CONTADORES DE TURNO =======")
        print(f"DEBUG: [TURN_INIT] AMBIENTE: {ambiente}")
        print(f"DEBUG: [TURN_INIT] Universal paths: {universal_paths}")
        print(f"DEBUG: [TURN_INIT] Verificando se há contadores preservados no root...")
        print(f"DEBUG: [TURN_INIT] Root object: {root}")
        print(f"DEBUG: [TURN_INIT] Root type: {type(root)}")
        print(f"DEBUG: [TURN_INIT] hasattr(root, '_backup_turn_counters'): {hasattr(root, '_backup_turn_counters')}")
        if hasattr(root, '_backup_turn_counters'):
            print(f"DEBUG: [TURN_INIT] _backup_turn_counters found: {root._backup_turn_counters}")
        print(f"DEBUG: [TURN_INIT] hasattr(root, '_backup_challenge_tracking'): {hasattr(root, '_backup_challenge_tracking')}")
        if hasattr(root, '_backup_challenge_tracking'):
            print(f"DEBUG: [TURN_INIT] _backup_challenge_tracking found: {root._backup_challenge_tracking}")
        
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            print(f"DEBUG: [TURN_INIT] Contadores encontrados: {backup_counters}")
            self._current_turn_number = backup_counters.get('_current_turn_number', 1)
            self._current_turn = backup_counters.get('_current_turn', 1)
            self._current_turn_id = backup_counters.get('_current_turn_id', 1)
            print(f"DEBUG: [TURN_RESTORE] Contadores de turnos restaurados:")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_number (Challenges): {self._current_turn_number}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn (Events): {self._current_turn}")
            print(f"DEBUG: [TURN_RESTORE]   _current_turn_id (Processing): {self._current_turn_id}")
            
            # CORREÇÃO CRÍTICA: Restaurar tracking de Challenges do backup de reconstrução
            print(f"DEBUG: [CHALLENGE_TRACKING] === RESTAURANDO TRACKING DE CHALLENGES DO BACKUP ===")
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking atual na instância: {getattr(self, '_challenge_start_turns', {})}")
            backup_challenge_tracking = backup_counters.get('_challenge_start_turns', {})
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking encontrado no backup: {backup_challenge_tracking}")
            
            # PRIORIDADE: Se já há tracking na instância atual, preservar e mesclar com backup
            if hasattr(self, '_challenge_start_turns') and self._challenge_start_turns:
                print(f"DEBUG: [CHALLENGE_TRACKING] PRESERVANDO tracking existente na instância")
                # Mesclar backup com tracking existente (existente tem prioridade)
                for path, turn in backup_challenge_tracking.items():
                    if path not in self._challenge_start_turns:
                        self._challenge_start_turns[path] = turn
                        print(f"DEBUG: [CHALLENGE_TRACKING] Adicionado do backup: {os.path.basename(path)} -> turno {turn}")
                    else:
                        print(f"DEBUG: [CHALLENGE_TRACKING] Preservado existente: {os.path.basename(path)} -> turno {self._challenge_start_turns[path]}")
            else:
                # Se não há tracking existente, restaurar do backup
                self._challenge_start_turns = backup_challenge_tracking.copy()
                print(f"DEBUG: [CHALLENGE_TRACKING] Tracking restaurado do backup: {self._challenge_start_turns}")
            
            # CORREÇÃO CRÍTICA: Restaurar turnos reais de Services do backup
            backup_service_turns = backup_counters.get('_service_real_activation_turns', {})
            print(f"DEBUG: [SERVICE_TRACKING] === RESTAURANDO TURNOS REAIS DE SERVICES DO BACKUP ===")
            print(f"DEBUG: [SERVICE_TRACKING] Turnos reais encontrados no backup: {backup_service_turns}")
            
            if backup_service_turns:
                self._service_real_activation_turns = backup_service_turns.copy()
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais de Services restaurados: {self._service_real_activation_turns}")
                for path, turn in self._service_real_activation_turns.items():
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(path)} -> turno real {turn}")
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Nenhum turno real de Service encontrado no backup")
            
            # CORREÇÃO CRÍTICA: Sincronizar root._backup_challenge_tracking após restaurar
            if self._challenge_start_turns:
                root._backup_challenge_tracking = self._challenge_start_turns.copy()
                print(f"DEBUG: [CHALLENGE_TRACKING] root._backup_challenge_tracking sincronizado: {self._challenge_start_turns}")
                print(f"DEBUG: [CHALLENGE_TRACKING] NOTA: Limpeza órfã será executada no próximo reset de turno")
        else:
            self._current_turn_number = 1     # Contador de turnos do jogador
            self._current_turn = 1           # Contador de turnos para o sistema de Events (começa em 1)
            self._current_turn_id = 1        # ID do turno atual para controle
            print(f"DEBUG: [TURN_INIT] Contadores de turnos inicializados em 1 (primeiro jogo)")
            
            # CORREÇÃO CRÍTICA: Inicializar turnos reais de Services vazios se não há backup
            print(f"DEBUG: [SERVICE_TRACKING] === INICIALIZANDO TURNOS REAIS DE SERVICES (SEM BACKUP) ===")
            if not hasattr(self, '_service_real_activation_turns'):
                self._service_real_activation_turns = {}
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais de Services inicializados vazios")
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Turnos reais já existem: {self._service_real_activation_turns}")
            
            # CORREÇÃO CRÍTICA: Restaurar tracking de Challenges se existir no root (não backup)
            print(f"DEBUG: [CHALLENGE_TRACKING] === RESTAURANDO TRACKING DE CHALLENGES (SEM BACKUP) ===")
            print(f"DEBUG: [CHALLENGE_TRACKING] Tracking atual na instância: {getattr(self, '_challenge_start_turns', {})}")
            
            # PRIORIDADE: Se já há tracking na instância atual, preservar
            if hasattr(self, '_challenge_start_turns') and self._challenge_start_turns:
                print(f"DEBUG: [CHALLENGE_TRACKING] PRESERVANDO tracking existente na instância: {self._challenge_start_turns}")
                # Ainda assim verificar se há backup no root para mesclar
                if hasattr(root, '_backup_challenge_tracking'):
                    root_backup = root._backup_challenge_tracking
                    print(f"DEBUG: [CHALLENGE_TRACKING] Mesclando com backup do root: {root_backup}")
                    for path, turn in root_backup.items():
                        if path not in self._challenge_start_turns:
                            self._challenge_start_turns[path] = turn
                            print(f"DEBUG: [CHALLENGE_TRACKING] Adicionado do root: {os.path.basename(path)} -> turno {turn}")
            else:
                # Se não há tracking existente, tentar restaurar do root
                if hasattr(root, '_backup_challenge_tracking'):
                    self._challenge_start_turns = root._backup_challenge_tracking.copy()
                    print(f"DEBUG: [CHALLENGE_TRACKING] Tracking restaurado do root: {self._challenge_start_turns}")
                else:
                    self._challenge_start_turns = {}
                    print(f"DEBUG: [CHALLENGE_TRACKING] Nenhum tracking encontrado - inicializando vazio")
            
        print(f"DEBUG: [TURN_INIT] ======= CONTADORES FINAIS =======")
        print(f"DEBUG: [TURN_INIT] _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [TURN_INIT] _current_turn: {self._current_turn}")
        print(f"DEBUG: [TURN_INIT] _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [TURN_INIT] _challenge_start_turns: {self._challenge_start_turns}")
        print(f"DEBUG: [TURN_INIT] ======= FIM INICIALIZAÇÃO =======")
        
        # SISTEMA DE TRACKING TEMPORAL PARA EVENTS
        # CORREÇÃO CRÍTICA: Restaurar tracking de Events do backup se existir
        print(f"DEBUG: [EVENT_TRACKING] === INICIALIZANDO TRACKING DE EVENTS ===")
        
        # Inicializar estruturas básicas
        self._event_start_turns = {}     # {carta_path: turno_inicio}
        self._event_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # NOVO: Sistema de backup para Events (similar aos Challenges)
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            
            # Restaurar tracking de Events do backup
            backup_event_tracking = backup_counters.get('_event_duration_tracking', {})
            backup_event_start_turns = backup_counters.get('_event_start_turns', {})
            
            print(f"DEBUG: [EVENT_TRACKING] Tracking de Events encontrado no backup:")
            print(f"DEBUG: [EVENT_TRACKING]   _event_duration_tracking: {backup_event_tracking}")
            print(f"DEBUG: [EVENT_TRACKING]   _event_start_turns: {backup_event_start_turns}")
            
            if backup_event_tracking:
                self._event_duration_tracking = backup_event_tracking.copy()
                print(f"DEBUG: [EVENT_TRACKING] ✅ _event_duration_tracking restaurado do backup")
                
                # Log detalhado do tracking restaurado
                for path, tracking in self._event_duration_tracking.items():
                    print(f"DEBUG: [EVENT_TRACKING]   {os.path.basename(path)}:")
                    print(f"DEBUG: [EVENT_TRACKING]     start_turn: {tracking.get('start_turn')}")
                    print(f"DEBUG: [EVENT_TRACKING]     duration_turns: {tracking.get('duration_turns')}")
                    print(f"DEBUG: [EVENT_TRACKING]     expires_turn: {tracking.get('expires_turn')}")
                    print(f"DEBUG: [EVENT_TRACKING]     is_active: {tracking.get('is_active')}")
            
            if backup_event_start_turns:
                self._event_start_turns = backup_event_start_turns.copy()
                print(f"DEBUG: [EVENT_TRACKING] ✅ _event_start_turns restaurado do backup")
        else:
            print(f"DEBUG: [EVENT_TRACKING] Nenhum backup encontrado - tracking inicializado vazio")
        
        # SISTEMA DE TRACKING TEMPORAL PARA SERVICES TEMPORARY
        self._service_start_turns = {}   # {carta_path: turno_inicio}
        self._service_duration_tracking = {} # {carta_path: {'duration_turns': int, 'start_turn': int}}
        
        # NOVO: SISTEMA DE PRESERVAÇÃO DO TURNO REAL DE ATIVAÇÃO DE SERVICES
        # Esta variável preserva o turno em que o Service foi REALMENTE ativado pelo jogador
        # Diferente de _service_start_turns que pode ser recriado durante reconstruções da interface
        self._service_real_activation_turns = {}  # {carta_path: turno_real_de_ativacao}
        
        # SUPER BACKUP CRÍTICO PARA SERVICES (similar aos Challenges)
        # Garante que o tracking de Services nunca seja perdido durante reconstruções
        if not hasattr(self.master, '_super_service_backup'):
            self.master._super_service_backup = {}
        if not hasattr(root, '_super_service_backup'):
            root._super_service_backup = {}
        
        # Backup global adicional para Services (para casos extremos)
        if not hasattr(self, '_service_backup_registry'):
            self._service_backup_registry = {}
        
        # Restaurar tracking de Services consolidado de múltiplos backups
        print(f"DEBUG: [SERVICE_TRACKING] === INICIALIZANDO TRACKING ROBUSTO DE SERVICES ===")
        
        # Consolidar Services de todos os backups temporários
        service_tracking_consolidado = {}
        service_duration_consolidado = {}
        
        # 1. Backup imediato do master
        if hasattr(self.master, '_service_tracking_backup_imediato'):
            backup_data = self.master._service_tracking_backup_imediato
            if backup_data:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando do master_imediato: {len(backup_data)} itens")
                service_tracking_consolidado.update(backup_data)
        
        # 2. Backup do root
        if hasattr(root, '_backup_service_tracking'):
            backup_data = root._backup_service_tracking
            if backup_data:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando do root_backup: {len(backup_data)} itens")
                service_tracking_consolidado.update(backup_data)
        
        # 3. Backup de duration tracking
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            backup_service_duration = backup_counters.get('_service_duration_tracking', {})
            if backup_service_duration:
                print(f"DEBUG: [SERVICE_TRACKING] Consolidando duration tracking: {len(backup_service_duration)} itens")
                service_duration_consolidado.update(backup_service_duration)
        
        # Aplicar consolidação
        if service_tracking_consolidado:
            self._service_start_turns = service_tracking_consolidado.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ✅ Service tracking consolidado restaurado: {len(self._service_start_turns)} itens")
        
        if service_duration_consolidado:
            self._service_duration_tracking = service_duration_consolidado.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ✅ Service duration tracking consolidado restaurado: {len(self._service_duration_tracking)} itens")
        
        # Sincronizar backup principal
        if service_tracking_consolidado or service_duration_consolidado:
            root._backup_service_tracking = self._service_start_turns.copy()
            print(f"DEBUG: [SERVICE_TRACKING] ✅ Backup principal de Services sincronizado")
        
        print(f"DEBUG: [SERVICE_TRACKING] === FIM INICIALIZAÇÃO ROBUSTA DE SERVICES ===")
        
        # SUPER BACKUP CRÍTICO PARA EVENTS (similar aos Challenges)
        # Garante que o tracking de Events nunca seja perdido durante reconstruções
        if not hasattr(self.master, '_super_event_backup'):
            self.master._super_event_backup = {}
        if not hasattr(root, '_super_event_backup'):
            root._super_event_backup = {}
        
        # Backup global adicional para Events (para casos extremos)
        if not hasattr(self, '_event_backup_registry'):
            self._event_backup_registry = {}
        
        # Consolidar Events de todos os backups temporários
        event_tracking_consolidado = {}
        event_duration_consolidado = {}
        
        print(f"DEBUG: [EVENT_TRACKING] === MELHORANDO TRACKING ROBUSTO DE EVENTS ===")
        
        # 1. Backup imediato do master
        if hasattr(self.master, '_event_tracking_backup_imediato'):
            backup_data = self.master._event_tracking_backup_imediato
            if backup_data:
                print(f"DEBUG: [EVENT_TRACKING] Consolidando do master_imediato: {len(backup_data)} itens")
                event_tracking_consolidado.update(backup_data)
        
        # 2. Backup do root
        if hasattr(root, '_backup_event_tracking'):
            backup_data = root._backup_event_tracking
            if backup_data:
                print(f"DEBUG: [EVENT_TRACKING] Consolidando do root_backup: {len(backup_data)} itens")
                event_tracking_consolidado.update(backup_data)
        
        # 3. Backup de duration tracking (já implementado mas melhorado)
        backup_counters = getattr(root, '_backup_turn_counters', {})
        backup_event_duration = backup_counters.get('_event_duration_tracking', {})
        backup_event_start_turns = backup_counters.get('_event_start_turns', {})
        
        if backup_event_duration:
            print(f"DEBUG: [EVENT_TRACKING] Consolidando duration tracking: {len(backup_event_duration)} itens")
            event_duration_consolidado.update(backup_event_duration)
        
        if backup_event_start_turns:
            print(f"DEBUG: [EVENT_TRACKING] Consolidando start turns: {len(backup_event_start_turns)} itens")
            event_tracking_consolidado.update(backup_event_start_turns)
        
        # Aplicar consolidação melhorada
        if event_tracking_consolidado:
            self._event_start_turns.update(event_tracking_consolidado)
            print(f"DEBUG: [EVENT_TRACKING] ✅ Event tracking consolidado melhorado: {len(self._event_start_turns)} itens")
        
        if event_duration_consolidado:
            self._event_duration_tracking.update(event_duration_consolidado)
            print(f"DEBUG: [EVENT_TRACKING] ✅ Event duration tracking consolidado melhorado: {len(self._event_duration_tracking)} itens")
        
        # Sincronizar backup principal
        if event_tracking_consolidado or event_duration_consolidado:
            root._backup_event_tracking = self._event_start_turns.copy()
            print(f"DEBUG: [EVENT_TRACKING] ✅ Backup principal de Events sincronizado")
        
        print(f"DEBUG: [EVENT_TRACKING] === FIM MELHORAMENTO ROBUSTO DE EVENTS ===")
        
        # NOVO: SISTEMA DE TRACKING DE DATA VOLUME PARA SERVICES
        print(f"DEBUG: [DATA_VOLUME] === INICIALIZANDO TRACKING DE DATA VOLUME ===")
        
        # Sistema de tracking de pacotes restantes para Services Data Volume
        self._service_data_volume_tracking = {}  # {carta_path: {'packets_remaining': int, 'original_packets': int}}
        
        # Sistema de overlays de expiração pendentes para Data Volume
        self._pending_data_volume_expiry_overlays = []  # Lista de cartas que devem mostrar overlay no próximo turno
        
        # Backup consolidado para Data Volume
        if hasattr(root, '_backup_turn_counters'):
            backup_counters = root._backup_turn_counters
            backup_data_volume = backup_counters.get('_service_data_volume_tracking', {})
            if backup_data_volume:
                self._service_data_volume_tracking = backup_data_volume.copy()
                print(f"DEBUG: [DATA_VOLUME] ✅ Tracking restaurado do backup: {len(self._service_data_volume_tracking)} itens")
                for path, tracking in self._service_data_volume_tracking.items():
                    print(f"DEBUG: [DATA_VOLUME]   {os.path.basename(path)}: {tracking['packets_remaining']}/{tracking['original_packets']} pacotes")
            
            # Restaurar overlays pendentes
            backup_pending_overlays = backup_counters.get('_pending_data_volume_expiry_overlays', [])
            if backup_pending_overlays:
                self._pending_data_volume_expiry_overlays = backup_pending_overlays.copy()
                print(f"DEBUG: [DATA_VOLUME] ✅ Overlays pendentes restaurados: {len(self._pending_data_volume_expiry_overlays)} itens")
                for path in self._pending_data_volume_expiry_overlays:
                    print(f"DEBUG: [DATA_VOLUME]   Overlay pendente: {os.path.basename(path)}")
            else:
                print(f"DEBUG: [DATA_VOLUME] Nenhum overlay pendente no backup")
        else:
            print(f"DEBUG: [DATA_VOLUME] Nenhum backup encontrado - inicializando tracking vazio")
        
        print(f"DEBUG: [DATA_VOLUME] === FIM INICIALIZAÇÃO DE DATA VOLUME ===")
        
        # INICIALIZAÇÃO DAS LISTAS DE CARTAS ATIVAS (movido do playerdashboard_interface)
        self.active_challenge = None  # Só pode haver 1 challenge ativo
        self.active_users = []        # Lista de users ativos (máx 4)
        self.active_equipments = []   # Lista de equipments ativos (sem limite)
        self.active_services = []     # Lista de services ativos (sem limite)
        self.max_users = 4
        # Equipments e Services não têm limite após Next Phase

        # CONTROLE DE SELEÇÃO DO CARROSSEL
        self.selected_carousel_card = None  # Carta atualmente selecionada
        self.selected_carousel_index = None  # Índice da carta selecionada

        # ADICIONA ISTO:
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        self.screen_width = screen_width
        self.screen_height = screen_height

        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)
        self.attributes("-fullscreen", True)        
        
        # Definir bar_color para botões e barra inferior
        color_map = {
            "green": "#70AD47",
            "yellow": "#F2BA0D",
            "red": "#EE6F68",
            "blue": "#43BEF2"
        }
        self.bar_color = color_map.get(self.player_color.lower(), "#AAAAAA")
        
        self.selected_card_idx = selected_card_idx
        self.store_window = None
        
        # Cargas de cartas usando a nova estrutura: cartas/[tipo]/Residential-level/[cor]/
        def load_cards_from_new_structure(card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Tentar múltiplas estruturas de pastas
            possible_paths = []
            
            # Para cartas que têm cores específicas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estruturas possíveis:
                for color_var in color_variants:
                    # 1. cartas/[tipo]/Residential-level/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level", color_var))
                    # 2. cartas/Residential-[tipo]-[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}-{color_var}"))
                    # 3. cartas/[tipo]/[cor]/
                    possible_paths.append(os.path.join(CARTAS_BASE_DIR, card_type, color_var))
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                possible_paths = [
                    # 1. cartas/[tipo]/Residential-level/
                    os.path.join(CARTAS_BASE_DIR, card_type, "Residential-level"),
                    # 2. cartas/Residential-[tipo]/
                    os.path.join(CARTAS_BASE_DIR, f"Residential-{card_type}"),
                    # 3. cartas/[tipo]/
                    os.path.join(CARTAS_BASE_DIR, card_type)
                ]
            
            # Tentar encontrar cartas em qualquer uma das estruturas possíveis
            for path in possible_paths:
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            break  # Para no primeiro caminho que funcionar
                    except Exception as e:
                        continue
            
            return cards
        
        print("DEBUG: [PlayerDashboard] Iniciando carregamento de cartas do inventário...")
        
        # INVENTÁRIO INICIAL: O jogador deve começar com inventário vazio ou apenas algumas cartas básicas
        # As cartas são adicionadas quando compradas na Store, não carregadas de pastas externas
        
        # Verificar se há cartas do inventário do jogador nas pastas do NetMaster
        def load_player_inventory_cards(card_type, player_color):
            """Carrega cartas do inventário do jogador (não da loja)"""
            cards = []
            # Usar a detecção automática para Raspberry Pi e desenvolvimento local
            base_path = detect_player_inventory_base_dir()
            
            # Para cartas que têm cores específicas
            if card_type in ["equipments", "services", "users", "activities"]:
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Estrutura: NetMaster/[Tipo]/Residential-level/[Cor]/
                folder_mapping = {
                    "users": "Users",
                    "equipments": "Equipments", 
                    "services": "Services",
                    "activities": "Activities"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                
                for color_var in color_variants:
                    path = os.path.join(base_path, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: [PlayerDashboard] Cartas do inventário encontradas em: {path}")
                                break
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                folder_mapping = {
                    "challenges": "Challenges",
                    "actions": "Actions",
                    "events": "Events"
                }
                folder_name = folder_mapping.get(card_type, card_type.capitalize())
                path = os.path.join(base_path, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: [PlayerDashboard] Cartas do inventário encontradas em: {path}")
                    except Exception as e:
                        print(f"DEBUG: [PlayerDashboard] Erro ao carregar {card_type}: {e}")
            
            return cards
        
        # INVENTÁRIO INICIAL VAZIO - o jogador começa sem cartas
        # As cartas só são adicionadas quando compradas na Store
        print("DEBUG: [PlayerDashboard] Inicializando inventário vazio - cartas serão adicionadas via compras na Store")
        
        # OPCIONAL: Se quiseres dar algumas cartas iniciais ao jogador, descomenta isto:
        print("DEBUG: [PlayerDashboard] CHAMANDO add_starter_cards()...")
        self.add_starter_cards()  # ATIVADO - adicionar cartas de exemplo
        print("DEBUG: [PlayerDashboard] add_starter_cards() TERMINADO")

        print(f"DEBUG: [PlayerDashboard] Inventário inicial:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")

        # --- BARRA SUPERIOR COM IMAGEM ---
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            print(f"DEBUG: Tentando carregar TopBar de: {topbar_img_path}")
            
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar criada com sucesso!")
            else:
                print(f"DEBUG: Arquivo TopBar não encontrado, criando fallback")
                # Fallback: criar uma barra colorida simples
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: TopBar fallback criada!")
        except Exception as e:
            print(f"DEBUG: ERRO ao criar TopBar: {e}")
            # Fallback: criar uma barra colorida simples
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
            self.topbar_label = topbar_frame
            print("DEBUG: TopBar fallback criada após erro!")

        # Chama a tela de lançamento de dado
        print("DEBUG: [PlayerDashboard] Chamando show_dice_roll_screen...")
        self.show_dice_roll_screen(player_name, saldo, other_players, screen_width, screen_height)
    
    def _capturar_estado_botoes_imediato(self):
        """Captura o estado atual dos botões + e seta no momento exato"""
        print("DEBUG: [CAPTURA_IMEDIATA] === CAPTURA NO MOMENTO DO CLIQUE ===")
        
        # CORREÇÃO CRÍTICA: Durante Final Phase gestão ativa, preservar o estado dos botões
        # baseado na lógica de gestão, não na existência física dos widgets
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_ativo = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CAPTURA_IMEDIATA] gestao_ativa: {gestao_ativa}, final_phase_ativo: {final_phase_ativo}")
        
        if gestao_ativa and final_phase_ativo:
            print("DEBUG: [CAPTURA_IMEDIATA] MODO GESTÃO ATIVA - Determinando estado baseado na lógica de gestão")
            
            # Durante gestão ativa, determinar que botões DEVEM estar visíveis
            # baseado no estado atual da carta e valores das barras
            estado = self._determinar_estado_gestao_logico()
            
            print(f"DEBUG: [CAPTURA_IMEDIATA] Estado determinado logicamente: {estado}")
            
        else:
            print("DEBUG: [CAPTURA_IMEDIATA] Modo normal - verificando estado físico dos widgets")
            
            # LIMPAR qualquer estado antigo primeiro para evitar interferência
            if hasattr(self, '_estado_botoes_imediato'):
                print("DEBUG: [CAPTURA_IMEDIATA] WARNING: Limpando estado antigo antes de capturar novo")
                self._estado_botoes_imediato = None
            
            print("DEBUG: [CAPTURA_IMEDIATA] Capturando estado dos botões AGORA...")
            
            estado = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            try:
                # NOVA LÓGICA MAIS ROBUSTA: Verificar se botão existe E está visível na tela
                print("DEBUG: [CAPTURA_IMEDIATA] === VERIFICAÇÃO DETALHADA DOS BOTÕES ===")
                
                # Verificar botão + Rxd
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão + Rxd...")
                rxd_existe = hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_rxd existe? {rxd_existe}")
                
                if rxd_existe:
                    try:
                        rxd_winfo_exists = self._btn_plus_rxd.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {rxd_winfo_exists}")
                        
                        if rxd_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            rxd_ismapped = self._btn_plus_rxd.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {rxd_ismapped}")
                            
                            if rxd_ismapped:
                                estado['btn_plus_rxd_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Botão + Rxd está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Rxd existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Rxd foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no + Rxd: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no + Rxd: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Rxd não existe")
                    
                # Verificar botão + Lost
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão + Lost...")
                lost_existe = hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_plus_lost existe? {lost_existe}")
                
                if lost_existe:
                    try:
                        lost_winfo_exists = self._btn_plus_lost.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {lost_winfo_exists}")
                        
                        if lost_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            lost_ismapped = self._btn_plus_lost.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {lost_ismapped}")
                            
                            if lost_ismapped:
                                estado['btn_plus_lost_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Botão + Lost está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Lost existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Lost foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no + Lost: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no + Lost: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão + Lost não existe")
                    
                # Verificar botão seta
                print("DEBUG: [CAPTURA_IMEDIATA] Verificando botão seta...")
                seta_existe = hasattr(self, '_btn_seta') and self._btn_seta is not None
                print(f"DEBUG: [CAPTURA_IMEDIATA]   Atributo _btn_seta existe? {seta_existe}")
                
                if seta_existe:
                    try:
                        seta_winfo_exists = self._btn_seta.winfo_exists()
                        print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_exists(): {seta_winfo_exists}")
                        
                        if seta_winfo_exists:
                            # VERIFICAÇÃO ADICIONAL: Verificar se está mapeado (visível)
                            seta_ismapped = self._btn_seta.winfo_ismapped()
                            print(f"DEBUG: [CAPTURA_IMEDIATA]   winfo_ismapped(): {seta_ismapped}")
                            
                            if seta_ismapped:
                                estado['btn_seta_visivel'] = True
                                print("DEBUG: [CAPTURA_IMEDIATA] Botão seta está VISÍVEL e MAPEADO")
                            else:
                                print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão seta existe mas não está mapeado")
                        else:
                            print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão seta foi destruído")
                    except tk.TclError as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro TclError no seta: {e}")
                    except Exception as e:
                        print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro geral no seta: {e}")
                else:
                    print("DEBUG: [CAPTURA_IMEDIATA] ERROR: Botão seta não existe")
                    
            except Exception as e:
                print(f"DEBUG: [CAPTURA_IMEDIATA] ERROR: Erro durante captura: {e}")
        
        # Guardar estado capturado
        self._estado_botoes_imediato = estado
        print(f"DEBUG: [CAPTURA_IMEDIATA] === RESULTADO FINAL ===")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado capturado: {estado}")
        print(f"DEBUG: [CAPTURA_IMEDIATA] Estado armazenado com timestamp único para evitar conflitos")
    
    def _reset_turn_processing_counters(self):
        """
        Reseta os contadores de processamento por turno para todas as cartas.
        Deve ser chamado no início de cada turno (dice roll screen).
        CORREÇÃO: NÃO incrementar contador aqui - contadores já vêm incrementados do end_turn anterior
        """
        print("DEBUG: [TURN_RESET] === RESETANDO CONTADORES DE PROCESSAMENTO ===")
        print(f"DEBUG: [TURN_RESET] Contadores preservados do end_turn anterior (SINCRONIZADOS):")
        print(f"DEBUG: [TURN_RESET]   _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TURN_RESET]   _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TURN_RESET]   _current_turn_id (Processing): {self._current_turn_id}")
        
        # VERIFICAÇÃO CRÍTICA: Garantir sincronização de todos os contadores
        if not (self._current_turn_number == self._current_turn == self._current_turn_id):
            print(f"DEBUG: [TURN_RESET] ⚠️  WARNING: CONTADORES DESSINCRONIZADOS!")
            # Correção automática para o maior valor
            max_turn = max(self._current_turn_number, self._current_turn, self._current_turn_id)
            self._current_turn_number = max_turn
            self._current_turn = max_turn
            self._current_turn_id = max_turn
            print(f"DEBUG: [TURN_RESET] ✅ CONTADORES SINCRONIZADOS para turno {max_turn}")
        
        # Resetar APENAS os contadores de processamento por turno (não os contadores de turno)
        old_rxd_counters = self._rxd_processed_this_turn.copy()
        old_lost_counters = self._lost_processed_this_turn.copy()
        old_interacoes = getattr(self, '_cartas_interagidas_jogador', set()).copy()
        
        self._rxd_processed_this_turn = {}
        self._lost_processed_this_turn = {}
        self._cartas_interagidas_jogador = set()  # Reset interações do jogador
        
        print(f"DEBUG: [TURN_RESET] Contadores Rxd anteriores: {old_rxd_counters}")
        print(f"DEBUG: [TURN_RESET] Contadores Lost anteriores: {old_lost_counters}")
        print(f"DEBUG: [TURN_RESET] Interações jogador anteriores: {len(old_interacoes)} cartas")
        print(f"DEBUG: [TURN_RESET] SUCCESS: Contadores de processamento resetados - botões + disponíveis")
        print(f"DEBUG: [TURN_RESET] SUCCESS: Interações do jogador resetadas - novo turno limpo")
        
        # NOVA FUNCIONALIDADE: Limpar tracking órfão de Challenges que não estão mais no carrossel
        self._cleanup_orphaned_challenge_tracking()
        
        print("DEBUG: [TURN_RESET] === FIM RESET CONTADORES ===")

    def _get_processed_this_turn(self, carta_path, tipo):
        """
        Retorna quantos pacotes foram processados neste turno para uma carta específica.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost'
        
        Returns:
            int: Quantidade processada neste turno
        """
        if tipo == 'rxd':
            return self._rxd_processed_this_turn.get(carta_path, 0)
        elif tipo == 'lost':
            return self._lost_processed_this_turn.get(carta_path, 0)
        else:
            return 0

    def _increment_processed_this_turn(self, carta_path, tipo, quantidade=1):
        """
        Incrementa o contador de processamento para este turno.
        
        Args:
            carta_path (str): Caminho da carta
            tipo (str): 'rxd' ou 'lost' 
            quantidade (int): Quantidade a incrementar (default: 1)
        """
        print(f"DEBUG: [PROCESSED] Incrementando {tipo} para {os.path.basename(carta_path)}: +{quantidade}")
        
        if tipo == 'rxd':
            current = self._rxd_processed_this_turn.get(carta_path, 0)
            self._rxd_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Rxd processado neste turno: {current} -> {current + quantidade}")
        elif tipo == 'lost':
            current = self._lost_processed_this_turn.get(carta_path, 0)
            self._lost_processed_this_turn[carta_path] = current + quantidade
            print(f"DEBUG: [PROCESSED] Lost processado neste turno: {current} -> {current + quantidade}")

    def _determinar_estado_gestao_logico(self):
        """
        Durante gestão ativa, determina logicamente que botões devem estar visíveis
        baseado no estado das barras e progresso da gestão
        CORREÇÃO: Verificar corretamente os pacotes processados neste turno
        """
        print("DEBUG: [GESTAO_LOGICA] === DETERMINANDO ESTADO LÓGICO DOS BOTÕES ===")
        
        estado = {
            'btn_plus_rxd_visivel': False,
            'btn_plus_lost_visivel': False,
            'btn_seta_visivel': False
        }
        
        try:
            # Obter carta atual da gestão
            carta_atual = self._get_current_actual_card()
            if not carta_atual:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Nenhuma carta atual encontrada")
                return estado
            
            # Obter valores atuais das barras de progresso
            if self.selected_carousel_index is not None and self.selected_carousel_index < len(self.card_stats):
                stats = self.card_stats[self.selected_carousel_index]
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print("DEBUG: [GESTAO_LOGICA] WARNING: Usando valores padrão para barras")
                rxd_atual = 0
                lost_atual = 0
            
            # Obter dados da carta
            rate_max = self._obter_rate_carta(carta_atual)
            carta_dados = self._obter_dados_carta(carta_atual)
            message_size = carta_dados.get('message_size', rate_max) if carta_dados else rate_max
            
            carta_basename = os.path.basename(carta_atual).lower()
            is_challenge = "challenge" in carta_basename
            is_activity = "activity" in carta_basename
            
            print(f"DEBUG: [GESTAO_LOGICA] Carta atual: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [GESTAO_LOGICA] Tipo: {'Challenge' if is_challenge else 'Activity'}")
            print(f"DEBUG: [GESTAO_LOGICA] Rate máximo (por turno): {rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA] Message size (limite total): {message_size}")
            print(f"DEBUG: [GESTAO_LOGICA] Rxd atual: {rxd_atual}, Lost atual: {lost_atual}")
            
            # CORREÇÃO CRÍTICA: Durante gestão de pacotes, verificar contadores POR CARTA
            # O rate_max aplica-se POR CARTA, não globalmente durante gestão
            print(f"DEBUG: [GESTAO_LOGICA] ===== VERIFICAÇÃO DETALHADA DE PROCESSAMENTO =====")
            
            # Durante gestão de pacotes, verificar contadores da carta ESPECÍFICA
            if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                print("DEBUG: [GESTAO_LOGICA] MODO GESTÃO ATIVA - Verificando contadores da carta específica")
                # Verificar contadores apenas para a carta atual sendo gerenciada
                rxd_processed = self._get_processed_this_turn(carta_atual, 'rxd')
                lost_processed = self._get_processed_this_turn(carta_atual, 'lost')
                
                print(f"DEBUG: [GESTAO_LOGICA] Carta específica: {os.path.basename(carta_atual)}")
                print(f"DEBUG: [GESTAO_LOGICA]   Rxd processado: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Lost processado: {lost_processed}")
            else:
                print("DEBUG: [GESTAO_LOGICA] MODO NORMAL - Verificando contadores globais")
                # Fora da gestão, verificar o máximo global (comportamento anterior)
                max_rxd_processed = 0
                max_lost_processed = 0
                
                if hasattr(self, '_rxd_processed_this_turn'):
                    for carta_path, count in self._rxd_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Rxd processados")
                        max_rxd_processed = max(max_rxd_processed, count)
                
                if hasattr(self, '_lost_processed_this_turn'):
                    for carta_path, count in self._lost_processed_this_turn.items():
                        carta_name = os.path.basename(carta_path)
                        print(f"DEBUG: [GESTAO_LOGICA]   {carta_name}: {count} pacotes Lost processados")
                        max_lost_processed = max(max_lost_processed, count)
                
                rxd_processed = max_rxd_processed
                lost_processed = max_lost_processed
                
                print(f"DEBUG: [GESTAO_LOGICA] MÁXIMO GLOBAL processado neste turno:")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Rxd: {rxd_processed}")
                print(f"DEBUG: [GESTAO_LOGICA]   Max Lost: {lost_processed}")
            
            print(f"DEBUG: [GESTAO_LOGICA] ===== FIM VERIFICAÇÃO PROCESSAMENTO =====")
            
            # Verificar se Rxd pode ser incrementado
            pode_incrementar_rxd = (rxd_atual < message_size) and (rxd_processed < rate_max)
            print(f"DEBUG: [GESTAO_LOGICA] Rxd permitido:")
            print(f"DEBUG: [GESTAO_LOGICA]   atual ({rxd_atual}) < message_size ({message_size}): {rxd_atual < message_size}")
            print(f"DEBUG: [GESTAO_LOGICA]   processado ({rxd_processed}) < rate_max ({rate_max}): {rxd_processed < rate_max}")
            print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_rxd}")
            
            if pode_incrementar_rxd:
                estado['btn_plus_rxd_visivel'] = True
                print("DEBUG: [GESTAO_LOGICA] Botão + Rxd deve estar visível")
            else:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Botão + Rxd NÃO deve estar visível")
                if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Carta já processou {rxd_processed}/{rate_max} pacotes Rxd neste turno")
                else:
                    if rxd_atual >= message_size:
                        print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Rxd atual ({rxd_atual}) >= message_size ({message_size})")
                    if rxd_processed >= rate_max:
                        print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Já processou {rxd_processed}/{rate_max} pacotes Rxd neste turno (GLOBALMENTE)")
            
            # Verificar se Lost pode ser incrementado
            if carta_dados:
                drops_allowed = carta_dados.get('drops_allowed', True)
                penalty_per_packet = carta_dados.get('penalty_per_packet', None)
                
                # Determinar se Lost é permitido para esta carta
                if is_challenge:
                    lost_permitido = drops_allowed or (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Challenge - Lost permitido: drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
                else:
                    lost_permitido = (penalty_per_packet is not None)
                    print(f"DEBUG: [GESTAO_LOGICA] Activity - Lost permitido: penalty_per_packet existe ({penalty_per_packet is not None})")
                
                print(f"DEBUG: [GESTAO_LOGICA] Verificando botão Lost:")
                print(f"DEBUG: [GESTAO_LOGICA]   drops_allowed: {drops_allowed}")
                print(f"DEBUG: [GESTAO_LOGICA]   penalty_per_packet: {penalty_per_packet}")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                
                pode_incrementar_lost = (lost_permitido and 
                                       lost_atual < message_size and 
                                       lost_processed < rate_max)
                print(f"DEBUG: [GESTAO_LOGICA] Lost incremento permitido:")
                print(f"DEBUG: [GESTAO_LOGICA]   lost_permitido: {lost_permitido}")
                print(f"DEBUG: [GESTAO_LOGICA]   atual ({lost_atual}) < message_size ({message_size}): {lost_atual < message_size}")
                print(f"DEBUG: [GESTAO_LOGICA]   processado ({lost_processed}) < rate_max ({rate_max}): {lost_processed < rate_max}")
                print(f"DEBUG: [GESTAO_LOGICA]   Resultado final: {pode_incrementar_lost}")
                
                if pode_incrementar_lost:
                    estado['btn_plus_lost_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] Botão + Lost deve estar visível")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ERROR: Botão + Lost NÃO deve estar visível")
                    if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa):
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost não permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Carta já processou {lost_processed}/{rate_max} pacotes Lost neste turno")
                    else:
                        if not lost_permitido:
                            print("DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost não permitido para esta carta")
                        if lost_atual >= message_size:
                            print(f"DEBUG: [GESTAO_LOGICA]   - MOTIVO: Lost atual ({lost_atual}) >= message_size ({message_size})")
                        if lost_processed >= rate_max:
                            print(f"DEBUG: [GESTAO_LOGICA]   - WARNING: MOTIVO: Já processou {lost_processed}/{rate_max} pacotes Lost neste turno (GLOBALMENTE)")
            
            # Verificar se botão seta deve estar visível
            if not estado['btn_plus_rxd_visivel'] and not estado['btn_plus_lost_visivel']:
                # Verificar se há mais cartas para gerir
                total_cartas = len(getattr(self, '_cartas_gestao', []))
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                if carta_atual_idx + 1 < total_cartas:
                    estado['btn_seta_visivel'] = True
                    print("DEBUG: [GESTAO_LOGICA] Botão seta deve estar visível (há mais cartas)")
                else:
                    print("DEBUG: [GESTAO_LOGICA] ERROR: Não há mais cartas para gerir - sem botão seta")
            else:
                print("DEBUG: [GESTAO_LOGICA] ERROR: Botões + ainda disponíveis - botão seta NÃO deve estar visível")
                    
        except Exception as e:
            print(f"DEBUG: [GESTAO_LOGICA] ERROR: Erro geral: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: [GESTAO_LOGICA] Estado lógico determinado: {estado}")
        print("DEBUG: [GESTAO_LOGICA] === FIM DETERMINAÇÃO LÓGICA ===")
        
        return estado
    
    def _get_current_actual_card(self):
        """
        Retorna a carta atual baseada na posição real no carrossel, não na variável cached
        CORREÇÃO CRÍTICA: Durante gestão de pacotes, usar sempre a carta da posição atual
        """
        try:
            print(f"DEBUG: [CURRENT_CARD] ===== DIAGNÓSTICO DETALHADO _get_current_actual_card =====")
            print(f"DEBUG: [CURRENT_CARD] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(_carta_atual_gestao): {hasattr(self, '_carta_atual_gestao')}")
            print(f"DEBUG: [CURRENT_CARD] hasattr(cards): {hasattr(self, 'cards')}")
            print(f"DEBUG: [CURRENT_CARD] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
            print(f"DEBUG: [CURRENT_CARD] len(cards): {len(self.cards) if hasattr(self, 'cards') else 'N/A'}")
            print(f"DEBUG: [CURRENT_CARD] selected_carousel_index: {getattr(self, 'selected_carousel_index', 'N/A')}")
            
            # CORREÇÃO CRÍTICA: Durante gestão de pacotes, priorizar selected_carousel_index
            gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            tem_cards = hasattr(self, 'cards') and self.cards
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [CURRENT_CARD] gestao_ativa: {gestao_ativa}")
            print(f"DEBUG: [CURRENT_CARD] tem_cards: {tem_cards}")
            print(f"DEBUG: [CURRENT_CARD] selected_index: {selected_index}")
            
            # Se estamos em gestão e há um índice selecionado válido, usar esse
            if gestao_ativa and tem_cards and selected_index is not None:
                if selected_index < len(self.cards):
                    carta_real = self.cards[selected_index]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] Gestão ativa - usando selected_carousel_index {selected_index}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ERROR: selected_carousel_index {selected_index} fora dos limites ({len(self.cards)})")
            
            # Se estamos em gestão de pacotes mas sem selected_index, usar _carta_atual_gestao
            if gestao_ativa and tem_cards and hasattr(self, '_carta_atual_gestao'):
                carta_atual_idx = getattr(self, '_carta_atual_gestao', 0)
                print(f"DEBUG: [CURRENT_CARD] carta_atual_idx: {carta_atual_idx}, len(cards): {len(self.cards)}")
                if carta_atual_idx < len(self.cards):
                    carta_real = self.cards[carta_atual_idx]
                    carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                    print(f"DEBUG: [CURRENT_CARD] Gestão ativa - usando _carta_atual_gestao {carta_atual_idx}: {carta_nome}")
                    return carta_real
                else:
                    print(f"DEBUG: [CURRENT_CARD] ERROR: _carta_atual_gestao {carta_atual_idx} fora dos limites ({len(self.cards)})")
            
            # Se não estamos em gestão mas há índice selecionado válido, usar esse
            if tem_cards and selected_index is not None and selected_index < len(self.cards):
                carta_real = self.cards[selected_index]
                carta_nome = carta_real.split('/')[-1] if carta_real else 'None'
                print(f"DEBUG: [CURRENT_CARD] Usando selected_carousel_index normal {selected_index}: {carta_nome}")
                return carta_real
            
            # Fallback para selected_carousel_card se ainda é válida
            carta_cached = getattr(self, 'selected_carousel_card', None)
            carta_cached_nome = carta_cached.split('/')[-1] if carta_cached else 'None'
            print(f"DEBUG: [CURRENT_CARD] carta_cached: {carta_cached_nome}")
            if carta_cached:
                print(f"DEBUG: [CURRENT_CARD] Fallback para carta cached: {carta_cached_nome}")
                return carta_cached
            
            print("DEBUG: [CURRENT_CARD] ERROR: Nenhuma carta atual encontrada")
            print(f"DEBUG: [CURRENT_CARD] ===== FIM DIAGNÓSTICO =====")
            return None
            
        except Exception as e:
            print(f"DEBUG: [CURRENT_CARD] ERRO CRÍTICO na função: {e}")
            import traceback
            print(f"DEBUG: [CURRENT_CARD] Stack trace: {traceback.format_exc()}")
            return getattr(self, 'selected_carousel_card', None)
    
    def _save_dashboard_state(self):
        """Salva o estado atual da interface principal do dashboard"""
        # PROTEÇÃO: Não salvar estado se estivermos numa página especial
        if getattr(self, '_in_router_selection_page', False):
            print("DEBUG: [ESTADO] WARNING: Salvamento de estado cancelado - estamos numa página de seleção de router")
            return
            
        print("DEBUG: [ESTADO] Salvando estado da interface principal...")
        
        # CORREÇÃO CRÍTICA: Preservar valores das barras ANTES de salvar estado
        # Isto é especialmente importante durante gestão de pacotes
        if (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa and
            hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None):
            try:
                # Capturar valores das barras visíveis e preservar em card_stats
                if hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    idx = self.selected_carousel_index
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual,
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [ESTADO] Valores preservados antes de salvar estado:")
                        print(f"DEBUG: [ESTADO]   Carta índice {idx}: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            except Exception as e:
                print(f"DEBUG: [ESTADO] ERROR: Erro ao preservar valores antes de salvar: {e}")
        
        # CORREÇÃO CRÍTICA: NÃO modificar _final_phase_gestao_ativa durante navegação
        # Os widgets são destruídos durante navegação, mas isso não significa que a gestão foi finalizada
        gestao_pretende_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        if gestao_pretende_ativa:
            print("DEBUG: [ESTADO] === PRESERVANDO ESTADO DE GESTÃO DURANTE NAVEGAÇÃO ===")
            print("DEBUG: [ESTADO] _final_phase_gestao_ativa permanece True - apenas navegação temporária")
            print("DEBUG: [ESTADO] Widgets podem estar destruídos mas gestão não foi finalizada pelo usuário")

        state = {
            # Estado do carrossel - CORREÇÃO: Usar carta atual real
            'selected_carousel_card': self._get_current_actual_card(),
            'selected_carousel_index': getattr(self, 'selected_carousel_index', None),
            'destaque_roxo_index': getattr(self, '_carta_atual_gestao', getattr(self, 'selected_carousel_index', None)),  # NOVO: preserva índice do destaque roxo
            'cards': self.cards[:] if hasattr(self, 'cards') else [],
            'card_stats': [stats.copy() for stats in self.card_stats] if hasattr(self, 'card_stats') else [],
            
            # Estado das barras de progresso
            'progress_bar_values': {},
            
            # Estados dos botões e fases
            '_final_phase_active': getattr(self, '_final_phase_active', False),
            '_next_phase_active': getattr(self, '_next_phase_active', False),
            '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
            '_show_end_turn_button': getattr(self, '_show_end_turn_button', False),
            '_challenge_accepted': getattr(self, '_challenge_accepted', False),
            '_store_button_disabled': getattr(self, '_store_button_disabled', False),
            '_next_phase_manually_activated': getattr(self, '_next_phase_manually_activated', False),
            
            # Estado da gestão de pacotes
            '_cartas_gestao': getattr(self, '_cartas_gestao', []),
            '_carta_atual_gestao': getattr(self, '_carta_atual_gestao', 0),
            '_valores_pacotes': getattr(self, '_valores_pacotes', {}),
            
            # Estados de controles visíveis
            'controles_gestao_visiveis': False,
            'botao_seta_visivel': False,
            'final_phase_turn_id': getattr(self, '_final_phase_turn_id', None)  # NOVO: ID do turno
        }
        
        # Salvar valores das barras de progresso se existirem
        if hasattr(self, 'progress_bars'):
            for nome, barra in self.progress_bars.items():
                try:
                    state['progress_bar_values'][nome] = barra.get()
                except:
                    state['progress_bar_values'][nome] = 0
        
        # Verificar se controles de gestão estão visíveis
        print("DEBUG: [ESTADO] === VERIFICAÇÃO DETALHADA DOS CONTROLES ===")
        print(f"DEBUG: [ESTADO] _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # Sistema de flags específicas para cada botão - DETECÇÃO SIMPLES E DIRETA
        state['btn_plus_rxd_visivel'] = False
        state['btn_plus_lost_visivel'] = False
        state['btn_seta_visivel'] = False
        
        print(f"DEBUG: [ESTADO] === VERIFICANDO ESTADO IMEDIATO ===")
        
        # CORREÇÃO CRÍTICA: Usar estado imediato se disponível e NÃO DELETAR ainda
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] SUCCESS: USANDO ESTADO IMEDIATO CAPTURADO ANTES DO CLIQUE:")
            print(f"DEBUG: [ESTADO] Estado original capturado: {self._estado_botoes_imediato}")
            
            # USAR EXATAMENTE o que foi capturado - sem modificações
            state['btn_plus_rxd_visivel'] = self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False)
            state['btn_plus_lost_visivel'] = self._estado_botoes_imediato.get('btn_plus_lost_visivel', False)
            state['btn_seta_visivel'] = self._estado_botoes_imediato.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [ESTADO] Estado usado para save:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {state['btn_seta_visivel']}")
            
            # CRÍTICO: NÃO deletar ainda - preservar para debug e restauração
            print("DEBUG: [ESTADO] SUCCESS: Estado imediato preservado - será limpo apenas após restauração completa")
        else:
            print("DEBUG: [ESTADO] WARNING: Nenhum estado imediato disponível - usando detecção fallback")
            print(f"DEBUG: [ESTADO] === DETECÇÃO SIMPLES DOS BOTÕES ===")
            
            # MÉTODO SIMPLES: Verificar apenas os atributos de classe diretamente
            try:
                # Verificar botão + Rxd
                if (hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None):
                    try:
                        if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                            state['btn_plus_rxd_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Botão + Rxd DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Botão + Rxd existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar + Rxd: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_plus_rxd não existe ou é None")
                    
                # Verificar botão + Lost  
                if (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None):
                    try:
                        if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                            state['btn_plus_lost_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Botão + Lost DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Botão + Lost existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar + Lost: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_plus_lost não existe ou é None")
                    
                # Verificar botão seta
                if (hasattr(self, '_btn_seta') and self._btn_seta is not None):
                    try:
                        if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                            state['btn_seta_visivel'] = True
                            print(f"DEBUG: [ESTADO] SUCCESS: Botão seta DETECTADO (visível e mapeado)")
                        else:
                            print(f"DEBUG: [ESTADO] ERROR: Botão seta existe mas não está mapeado")
                    except tk.TclError as e:
                        print(f"DEBUG: [ESTADO] ERROR: Erro ao verificar seta: {e}")
                else:
                    print(f"DEBUG: [ESTADO] ERROR: Atributo _btn_seta não existe ou é None")
                    
            except Exception as e:
                print(f"DEBUG: [ESTADO] ERROR: Erro geral na detecção: {e}")
        
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETECÇÃO ===")
        
        # Atualizar flags legadas para compatibilidade
        if state['btn_plus_rxd_visivel'] or state['btn_plus_lost_visivel']:
            state['controles_gestao_visiveis'] = True
        if state['btn_seta_visivel']:
            state['botao_seta_visivel'] = True
        
        # Relatório final da detecção
        print(f"DEBUG: [ESTADO] === RESULTADO FINAL DA DETECÇÃO ===")
        print(f"DEBUG: [ESTADO] btn_plus_rxd_visivel: {state['btn_plus_rxd_visivel']}")
        print(f"DEBUG: [ESTADO] btn_plus_lost_visivel: {state['btn_plus_lost_visivel']}")
        print(f"DEBUG: [ESTADO] btn_seta_visivel: {state['btn_seta_visivel']}")
        print(f"DEBUG: [ESTADO] controles_gestao_visiveis: {state.get('controles_gestao_visiveis', False)}")
        print(f"DEBUG: [ESTADO] botao_seta_visivel: {state.get('botao_seta_visivel', False)}")
        
        # CRÍTICO: Preservar tracking de Challenges no estado salvo
        state['_challenge_start_turns'] = self._challenge_start_turns.copy()
        
        self._saved_dashboard_state = state
        print(f"DEBUG: [ESTADO] SUCCESS: Estado salvo com sucesso!")
        print(f"DEBUG: [ESTADO] Carta selecionada: {state.get('selected_carousel_card')}")
        print(f"DEBUG: [ESTADO] Índice selecionado: {state.get('selected_carousel_index')}")
        print(f"DEBUG: [ESTADO] Índice destaque roxo: {state.get('destaque_roxo_index')}")
        print(f"DEBUG: [ESTADO] Final phase active: {state.get('_final_phase_active')}")
        print(f"DEBUG: [ESTADO] Gestão ativa: {state.get('_final_phase_gestao_ativa')}")
        print(f"DEBUG: [ESTADO] Challenge tracking preservado: {state.get('_challenge_start_turns')}")
        print(f"DEBUG: [ESTADO] Botões preservados: rxd={state.get('btn_plus_rxd_visivel')}, lost={state.get('btn_plus_lost_visivel')}, seta={state.get('btn_seta_visivel')}")
        
        # GARANTIA ADICIONAL: Também salvar no estado imediato para fallback
        if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print(f"DEBUG: [ESTADO] SUCCESS: Estado imediato também disponível como backup")
        else:
            print(f"DEBUG: [ESTADO] WARNING: Estado imediato não disponível")
            # Criar backup baseado no estado atual
            self._estado_botoes_imediato = {
                'btn_plus_rxd_visivel': state.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': state.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': state.get('btn_seta_visivel', False)
            }
            print(f"DEBUG: [ESTADO] SUCCESS: Estado imediato criado como backup")
    
    def _restore_gestao_buttons_specifically(self, btn_plus_rxd_visivel, btn_plus_lost_visivel, btn_seta_visivel):
        """
        Método específico para restaurar apenas os botões de gestão que estavam visíveis.
        Este método é chamado após voltar de páginas de inventário ou fullscreen.
        """
        print("DEBUG: [RESTORE_BUTTONS] === RESTAURAÇÃO ESPECÍFICA DE BOTÕES ===")
        print(f"DEBUG: [RESTORE_BUTTONS] Botões a restaurar:")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Rxd: {btn_plus_rxd_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   + Lost: {btn_plus_lost_visivel}")
        print(f"DEBUG: [RESTORE_BUTTONS]   Seta: {btn_seta_visivel}")
        
        # CORREÇÃO CRÍTICA: Se estamos em gestão de pacotes ativa, sempre restaurar o destaque roxo
        # mesmo que não hajam botões específicos para restaurar
        gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        
        # Verificar se há pelo menos um botão para restaurar OU se gestão está ativa
        algum_botao_para_restaurar = btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel
        
        if not algum_botao_para_restaurar and not gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] ERROR: Nenhum botão para restaurar e gestão não ativa")
            return
        
        if not algum_botao_para_restaurar and gestao_ativa:
            print("DEBUG: [RESTORE_BUTTONS] WARNING: Gestão ativa mas nenhum botão específico para restaurar - determinando botões corretos")
            # CORREÇÃO CRÍTICA: Se gestão está ativa mas não há flags específicas,
            # redeterminar que botões devem estar visíveis baseado na carta atual
            estado_logico = self._determinar_estado_gestao_logico()
            btn_plus_rxd_visivel = estado_logico.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_visivel = estado_logico.get('btn_plus_lost_visivel', False) 
            btn_seta_visivel = estado_logico.get('btn_seta_visivel', False)
            print(f"DEBUG: [RESTORE_BUTTONS] Estado redeterminado: rxd={btn_plus_rxd_visivel}, lost={btn_plus_lost_visivel}, seta={btn_seta_visivel}")
            
            # Se ainda não há nenhum botão para restaurar, não há nada a fazer
            if not (btn_plus_rxd_visivel or btn_plus_lost_visivel or btn_seta_visivel):
                print("DEBUG: [RESTORE_BUTTONS] ERROR: Redeterminação também não encontrou botões - cancelando restauração")
                return
        
        # Garantir que a gestão está ativa se há botões para restaurar
        self._final_phase_gestao_ativa = True
        self._final_phase_active = True
        
        # CORREÇÃO FUNDAMENTAL: Restaurar para a carta que ESTAVA sendo gerenciada antes do fullscreen
        # A gestão estava na carta 1 (Challenge_9.png), não na carta 0 (back_card_red.png)
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            carta_gestao_original = self._saved_dashboard_state.get('selected_carousel_index', 1)
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: CORREÇÃO FUNDAMENTAL:")
            print(f"DEBUG: [RESTORE_BUTTONS]   Carta que estava sendo gerenciada: {carta_gestao_original}")
            print(f"DEBUG: [RESTORE_BUTTONS]   Restaurando gestão para esta carta")
            self.selected_carousel_index = carta_gestao_original
            self._carta_atual_gestao = carta_gestao_original
            
            # Atualizar selected_carousel_card se possível
            if (hasattr(self, 'cards') and self.cards and 
                carta_gestao_original < len(self.cards)):
                self.selected_carousel_card = self.cards[carta_gestao_original]
                print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        else:
            # CORREÇÃO PROBLEMA 2: Preservar a posição correta do destaque roxo
            # NÃO redefinir selected_carousel_index se já está definido corretamente
            posicao_destaque_roxo = getattr(self, '_carta_atual_gestao', 1)  # Default para 1, não 0
            
            print(f"DEBUG: [RESTORE_BUTTONS] WARNING: Usando fallback - posição gestão: {posicao_destaque_roxo}")
            self.selected_carousel_index = posicao_destaque_roxo
            self._carta_atual_gestao = posicao_destaque_roxo
            
            # Atualizar selected_carousel_card se possível
            if (hasattr(self, 'cards') and self.cards and 
                posicao_destaque_roxo < len(self.cards)):
                self.selected_carousel_card = self.cards[posicao_destaque_roxo]
                print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Carta selecionada atualizada: {os.path.basename(self.selected_carousel_card)}")
        
        print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: POSIÇÃO GESTÃO CORRIGIDA:")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_index: {self.selected_carousel_index}")
        print(f"DEBUG: [RESTORE_BUTTONS]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [RESTORE_BUTTONS]   selected_carousel_card: {os.path.basename(self.selected_carousel_card) if self.selected_carousel_card else 'None'}")
        
        # CORREÇÃO FUNDAMENTAL: Recriar _cartas_gestao se estiver vazia ou inconsistente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print("DEBUG: [RESTORE_BUTTONS] WARNING: _cartas_gestao vazia - recriando com cartas ativas do carrossel")
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            self._cartas_gestao = cartas_ativas
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: _cartas_gestao recriada: {[os.path.basename(c) for c in cartas_ativas]}")
            
            # Ajustar _carta_atual_gestao se está fora de range
            if self._carta_atual_gestao >= len(self._cartas_gestao):
                self._carta_atual_gestao = len(self._cartas_gestao) - 1 if self._cartas_gestao else 0
                print(f"DEBUG: [RESTORE_BUTTONS] WARNING: _carta_atual_gestao ajustada para: {self._carta_atual_gestao}")
        
        # CORREÇÃO CRÍTICA: Aplicar destaque roxo na posição correta
        if self.selected_carousel_index is not None:
            print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Aplicando destaque roxo na posição: {self.selected_carousel_index}")
            self._adicionar_destaque_roxo(self.selected_carousel_index)
            self._update_carousel_selection_highlights()
        
        # CORREÇÃO CRÍTICA: Remover controles existentes SEM criar botão seta automaticamente
        print("DEBUG: [RESTORE_BUTTONS] Limpando controles existentes sem criar botão seta...")
        self._remover_controles_gestao_silencioso()
        
        # CORREÇÃO FUNDAMENTAL: Obter rate da carta CORRETA (não da fallback)
        carta_para_gestao = self.selected_carousel_card or self._get_current_actual_card()
        rate_max = self._obter_rate_carta(carta_para_gestao)
        dados_carta = self._obter_dados_carta(carta_para_gestao)
        rate_options = dados_carta.get('rate_options', [0, 1])
        print(f"DEBUG: [RESTORE_BUTTONS] SUCCESS: Rate obtido da carta correta {os.path.basename(carta_para_gestao)}: rate_max={rate_max}, rate_options={rate_options}")
        
        # Restaurar botão + Rxd se estava visível
        if btn_plus_rxd_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão + Rxd roxo...")
            
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gestão de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            self._btn_plus_rxd.lift()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Botão + Rxd roxo restaurado")
        
        # Restaurar botão + Lost se estava visível
        if btn_plus_lost_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão + Lost roxo...")
            
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa para gestão de pacotes
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            self._btn_plus_lost.lift()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Botão + Lost roxo restaurado")
        
        # Restaurar botão seta se estava visível
        if btn_seta_visivel:
            print("DEBUG: [RESTORE_BUTTONS] Criando botão seta...")
            self._mostrar_botao_seta()
            print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Botão seta restaurado")
        
        # Garantir que End Turn está disabled
        if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
            self.end_turn_btn.config(state="disabled")
            print("DEBUG: [RESTORE_BUTTONS] End Turn mantido disabled")
        
        # Atualizar barras para a carta atual
        try:
            if self.selected_carousel_index is not None:
                self._atualizar_barras_gestao_carta_atual()
        except Exception as e:
            print(f"DEBUG: [RESTORE_BUTTONS] WARNING: Erro ao atualizar barras: {e}")
        
        print("DEBUG: [RESTORE_BUTTONS] SUCCESS: Restauração específica concluída")

    def _restore_dashboard_state(self):
        """Restaura o estado salvo da interface principal do dashboard"""
        # CORREÇÃO CRÍTICA: Verificar múltiplos locais onde o estado pode estar salvo
        state = None
        
        # 1. Verificar se há estado salvo normal
        if hasattr(self, '_saved_dashboard_state') and self._saved_dashboard_state:
            state = self._saved_dashboard_state
            print("DEBUG: [ESTADO] Estado encontrado em _saved_dashboard_state")
        
        # 2. Verificar se há estado capturado imediatamente (NOVO)
        elif hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
            print("DEBUG: [ESTADO] Usando estado imediato capturado como fallback")
            # Criar estado mínimo baseado na captura imediata
            state = {
                'btn_plus_rxd_visivel': self._estado_botoes_imediato.get('btn_plus_rxd_visivel', False),
                'btn_plus_lost_visivel': self._estado_botoes_imediato.get('btn_plus_lost_visivel', False),
                'btn_seta_visivel': self._estado_botoes_imediato.get('btn_seta_visivel', False),
                '_final_phase_gestao_ativa': getattr(self, '_final_phase_gestao_ativa', False),
                '_final_phase_active': getattr(self, '_final_phase_active', False),
                'selected_carousel_card': getattr(self, 'selected_carousel_card', None),
                'selected_carousel_index': getattr(self, 'selected_carousel_index', None)
            }
        
        # 3. Se não há estado, não há nada para restaurar
        if not state:
            print("DEBUG: [ESTADO] Nenhum estado salvo encontrado - pular restauração")
            return
        print("DEBUG: [ESTADO] Restaurando estado da interface principal...")
        
        # Restaurar estado do carrossel
        self.selected_carousel_card = state.get('selected_carousel_card')
        self.selected_carousel_index = state.get('selected_carousel_index')
        
        # Restaurar cards e stats se necessário
        if state.get('cards'):
            self.cards = state['cards'][:]
        if state.get('card_stats'):
            self.card_stats = [stats.copy() for stats in state['card_stats']]
        
        # Restaurar estados dos botões e fases
        self._final_phase_active = state.get('_final_phase_active', False)
        self._next_phase_active = state.get('_next_phase_active', False)
        self._final_phase_gestao_ativa = state.get('_final_phase_gestao_ativa', False)
        self._show_end_turn_button = state.get('_show_end_turn_button', False)
        self._challenge_accepted = state.get('_challenge_accepted', False)
        self._store_button_disabled = state.get('_store_button_disabled', False)
        self._next_phase_manually_activated = state.get('_next_phase_manually_activated', False)
        
        # Restaurar estado da gestão de pacotes
        self._cartas_gestao = state.get('_cartas_gestao', [])
        self._carta_atual_gestao = state.get('_carta_atual_gestao', 0)
        self._valores_pacotes = state.get('_valores_pacotes', {})
        
        # CRÍTICO: Restaurar tracking de Challenges
        if '_challenge_start_turns' in state:
            self._challenge_start_turns = state['_challenge_start_turns'].copy()
            print(f"DEBUG: [ESTADO] Challenge tracking restaurado: {self._challenge_start_turns}")
        else:
            print(f"DEBUG: [ESTADO] WARNING: Nenhum challenge tracking no estado salvo")
        
        print(f"DEBUG: [ESTADO] Estado restaurado: carta_selecionada={self.selected_carousel_card}, "
              f"final_phase_active={self._final_phase_active}, "
              f"gestao_ativa={self._final_phase_gestao_ativa}, "
              f"controles_visiveis={state.get('controles_gestao_visiveis')}")
        
        # NOVO: Utilizar flags específicas dos botões para restauração precisa
        gestao_ativa = self._final_phase_gestao_ativa
        btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
        btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
        btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
        
        print(f"DEBUG: [ESTADO] Flags específicas detectadas:")
        print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
        print(f"DEBUG: [ESTADO]   btn_seta_visivel: {btn_seta_estava_visivel}")
        
        # Executar restauração após a interface estar pronta
        def restore_gestao_state():
            if gestao_ativa:
                print("DEBUG: [ESTADO] Gestão de pacotes estava ativa - restaurando botões específicos...")
                
                # Verificar se há botões para restaurar
                algum_botao_estava_visivel = btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel or btn_seta_estava_visivel
                
                if algum_botao_estava_visivel:
                    print("DEBUG: [ESTADO] SUCCESS: Botões estavam visíveis - chamando restauração específica")
                    self._restore_gestao_buttons_specifically(
                        btn_plus_rxd_estava_visivel,
                        btn_plus_lost_estava_visivel, 
                        btn_seta_estava_visivel
                    )
                else:
                    print("DEBUG: [ESTADO] WARNING: Gestão ativa mas sem botões visíveis - mantendo gestão e verificando necessidade")
                    # Manter gestão ativa mas verificar se precisa de botões
                    self._final_phase_gestao_ativa = True
                    self._final_phase_active = True
                    
                    # Aplicar destaque roxo se há carta selecionada
                    if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                        print(f"DEBUG: [ESTADO] SUCCESS: Aplicando destaque roxo na posição {self.selected_carousel_index}")
                        self._adicionar_destaque_roxo(self.selected_carousel_index)
                        self._update_carousel_selection_highlights()
                        
                        # Verificar se precisa de botões baseado no estado atual
                        self.after(300, self._verificar_e_mostrar_botao_seta_se_necessario)
                    else:
                        print("DEBUG: [ESTADO] ERROR: Nenhuma carta selecionada para destaque roxo")
            else:
                print("DEBUG: [ESTADO] Gestão não estava ativa - verificando se End Turn deve estar enabled")
                
                # CORREÇÃO CRÍTICA: Se Final Phase está ativo mas gestão não está ativa,
                # significa que a gestão foi finalizada e End Turn deve estar enabled
                if self._final_phase_active and not gestao_ativa:
                    print("DEBUG: [ESTADO] SUCCESS: Final Phase ativo sem gestão - ativando End Turn")
                    self.after(150, self._ativar_botao_end_turn)
                else:
                    print("DEBUG: [ESTADO] Final Phase não ativo - End Turn deve permanecer disabled")
        
        # Executar restauração após a interface estar pronta (delay menor para restauração rápida)
        def restore_and_cleanup():
            # PROTEÇÃO: Não executar se estivermos numa página especial
            if getattr(self, '_in_router_selection_page', False):
                print("DEBUG: [ESTADO] WARNING: Restauração cancelada - estamos numa página de seleção de router")
                return
                
            restore_gestao_state()
            
            # LIMPEZA FINAL: Remover estado imediato após restauração completa
            print("DEBUG: [ESTADO] SUCCESS: LIMPEZA FINAL: Removendo estado imediato após restauração completa")
            if hasattr(self, '_estado_botoes_imediato'):
                self._estado_botoes_imediato = None
                print("DEBUG: [ESTADO] SUCCESS: Estado imediato limpo - sistema pronto para próxima captura")
        
        self.after(100, restore_and_cleanup)
    
    def debug_click_events(self, event=None):
        """Debug para clicks que não são processados"""
        print(f"DEBUG: [debug_click_events] Click detectado na coordenada: x={event.x if event else 'N/A'}, y={event.y if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Widget: {event.widget if event else 'N/A'}")
        print(f"DEBUG: [debug_click_events] Estado da interface: widgets={len(self.winfo_children())}")
        return "break"  # Impede propagação do evento
    
    def add_starter_cards(self):
        """
        Função opcional para dar cartas iniciais ao jogador.
        Adicionado para demonstração das páginas de inventário.
        """
        print("DEBUG: [PlayerDashboard] Adicionando cartas iniciais de demonstração...")
        
        # Usar a detecção automática para Raspberry Pi e desenvolvimento local
        base_path = detect_player_inventory_base_dir()
        print(f"DEBUG: [add_starter_cards] Base path detectado: {base_path}")
        print(f"DEBUG: [add_starter_cards] Player color: {self.player_color}")
        
        # Exemplo: dar 2-3 cartas de cada tipo da cor do jogador
        card_types = {
            "users": "Users",
            "equipments": "Equipments", 
            "services": "Services",
            "activities": "Activities"
        }
        
        color_variants = []
        if self.player_color == "blue":
            color_variants = ["Blue", "blue", "BLUE"]
        elif self.player_color == "green": 
            color_variants = ["Green", "green", "GREEN"]
        elif self.player_color == "red":
            color_variants = ["Red", "red", "RED"]
        elif self.player_color == "yellow":
            color_variants = ["Yellow", "yellow", "YELLOW"]
        else:
            color_variants = ["Blue", "blue"]  # default
        
        for card_type, folder_name in card_types.items():
            print(f"DEBUG: [add_starter_cards] Processando tipo: {card_type} -> pasta: {folder_name}")
            cards_found = False
            for color_var in color_variants:
                # Tentar estrutura do desenvolvimento local: NetMaster/Users/Residential-level/Red/
                path1 = os.path.join(base_path, folder_name, "Residential-level", color_var)
                # Tentar estrutura do Raspberry Pi: /img/cartas/users/Residential-level/Red/
                path2 = os.path.join(base_path, card_type, "Residential-level", color_var)
                
                for path_attempt, path_name in [(path1, "estrutura local"), (path2, "estrutura Raspberry Pi")]:
                    print(f"DEBUG: [add_starter_cards] Tentando {path_name}: {path_attempt}")
                    print(f"DEBUG: [add_starter_cards] Caminho existe? {os.path.exists(path_attempt)}")
                    if os.path.exists(path_attempt):
                        try:
                            files_in_path = os.listdir(path_attempt)
                            print(f"DEBUG: [add_starter_cards] Arquivos encontrados: {files_in_path}")
                            card_files = [os.path.join(path_attempt, f) for f in files_in_path 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            print(f"DEBUG: [add_starter_cards] Arquivos de carta filtrados: {[os.path.basename(f) for f in card_files]}")
                            if card_files:
                                # ESPECIAL: Para Activities, adicionar especificamente Activity_10.png e Activity_8.png se disponíveis
                                if card_type == "activities":
                                    target_activities = ["Activity_10.png", "Activity_8.png"]
                                    activities_added = []
                                    
                                    for target_activity in target_activities:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_activity:
                                                self.inventario[card_type].append(card_file)
                                                activities_added.append(target_activity)
                                                print(f"DEBUG: [add_starter_cards] Activity ESPECÍFICA adicionada: {os.path.basename(card_file)}")
                                                break
                                    
                                    if not activities_added:
                                        print(f"DEBUG: [add_starter_cards] Nenhuma activity específica encontrada, adicionando activities padrão")
                                        # Adicionar 2-3 cartas de activities normais se nenhuma específica estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                elif card_type == "users":
                                    # ESPECIAL: Para Users, adicionar especificamente User_2, User_3 e User_4
                                    target_users = ["User_2.png", "User_3.png", "User_4.png"]
                                    users_added = []
                                    
                                    for target_user in target_users:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_user:
                                                self.inventario[card_type].append(card_file)
                                                users_added.append(target_user)
                                                print(f"DEBUG: [add_starter_cards] User ESPECÍFICO adicionado: {os.path.basename(card_file)}")
                                                break
                                    
                                    if not users_added:
                                        print(f"DEBUG: [add_starter_cards] Nenhum user específico encontrado, adicionando users padrão")
                                        # Adicionar 2-3 cartas de users normais se nenhum específico estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                elif card_type == "services":
                                    # ESPECIAL: Para Services, adicionar especificamente Service_5.png (TEMPORARY), Service_1.png (BANDWIDTH) e Service_2.png (DATA_VOLUME)
                                    target_services = ["Service_5.png", "Service_1.png", "Service_2.png"]
                                    services_added = []
                                    
                                    for target_service in target_services:
                                        for card_file in card_files:
                                            if os.path.basename(card_file) == target_service:
                                                self.inventario[card_type].append(card_file)
                                                services_added.append(target_service)
                                                if target_service == "Service_5.png":
                                                    print(f"DEBUG: [add_starter_cards] Service ESPECÍFICO adicionado: {os.path.basename(card_file)} (TEMPORARY - 4 turnos)")
                                                elif target_service == "Service_1.png":
                                                    print(f"DEBUG: [add_starter_cards] Service ESPECÍFICO adicionado: {os.path.basename(card_file)} (BANDWIDTH - permanente)")
                                                elif target_service == "Service_2.png":
                                                    print(f"DEBUG: [add_starter_cards] Service ESPECÍFICO adicionado: {os.path.basename(card_file)} (DATA_VOLUME - 10 pacotes)")
                                                break
                                    
                                    if not services_added:
                                        print(f"DEBUG: [add_starter_cards] Services específicos não encontrados, adicionando services padrão")
                                        # Adicionar 2-3 cartas de services normais se nenhum específico estiver disponível
                                        max_cards = min(3, len(card_files))
                                        print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas padrão de {card_type}")
                                        for i in range(max_cards):
                                            self.inventario[card_type].append(card_files[i])
                                            print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                    else:
                                        # Adicionar também alguns services normais além dos específicos
                                        remaining_files = [f for f in card_files if os.path.basename(f) not in target_services]
                                        max_additional = min(1, len(remaining_files))  # Reduzir para 1 já que temos 2 específicos
                                        for i in range(max_additional):
                                            self.inventario[card_type].append(remaining_files[i])
                                            print(f"DEBUG: [add_starter_cards] Service adicional adicionado: {os.path.basename(remaining_files[i])}")
                                else:
                                    # Para outros tipos de carta (equipments), usar comportamento normal
                                    max_cards = min(3, len(card_files))
                                    print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas de {card_type}")
                                    for i in range(max_cards):
                                        self.inventario[card_type].append(card_files[i])
                                        print(f"DEBUG: [PlayerDashboard] Carta inicial adicionada: {os.path.basename(card_files[i])} ({card_type})")
                                cards_found = True
                                break
                            else:
                                print(f"DEBUG: [add_starter_cards] Nenhum arquivo de carta encontrado em {path_attempt}")
                        except Exception as e:
                            print(f"DEBUG: [add_starter_cards] Erro ao listar arquivos em {path_attempt}: {e}")
                            continue
                    else:
                        print(f"DEBUG: [add_starter_cards] Caminho não existe: {path_attempt}")
                
                if cards_found:
                    break
            
            if not cards_found:
                print(f"DEBUG: [add_starter_cards] NENHUMA ESTRUTURA FUNCIONOU para {card_type}")
        
        # Adicionar algumas cartas neutras (actions, events, challenges)
        print("DEBUG: [add_starter_cards] Processando cartas neutras...")
        neutral_types = {
            "challenges": "Challenges",
            "actions": "Actions", 
            "events": "Events"
        }
        
        for card_type, folder_name in neutral_types.items():
            # Tentar estrutura do desenvolvimento local: NetMaster/Challenges/Residential-level/
            path1 = os.path.join(base_path, folder_name, "Residential-level")
            # Tentar estrutura do Raspberry Pi: /img/cartas/challenges/Residential-level/
            path2 = os.path.join(base_path, card_type, "Residential-level")
            
            print(f"DEBUG: [add_starter_cards] Processando tipo neutro: {card_type} -> pasta: {folder_name}")
            cards_found = False
            
            for path_attempt, path_name in [(path1, "estrutura local"), (path2, "estrutura Raspberry Pi")]:
                print(f"DEBUG: [add_starter_cards] Tentando {path_name}: {path_attempt}")
                print(f"DEBUG: [add_starter_cards] Caminho neutro existe? {os.path.exists(path_attempt)}")
                if os.path.exists(path_attempt):
                    try:
                        files_in_path = os.listdir(path_attempt)
                        print(f"DEBUG: [add_starter_cards] Arquivos neutros encontrados: {files_in_path}")
                        
                        # ESPECIAL: Para Actions, verificar explicitamente se Action_31.png e Action_46.png existem
                        if card_type == "actions":
                            action_31_path = os.path.join(path_attempt, "Action_31.png")
                            action_46_path = os.path.join(path_attempt, "Action_46.png")
                            print(f"DEBUG: [add_starter_cards] Verificação explícita Action_31.png em: {action_31_path}")
                            print(f"DEBUG: [add_starter_cards] Action_31.png existe? {os.path.exists(action_31_path)}")
                            print(f"DEBUG: [add_starter_cards] Verificação explícita Action_46.png em: {action_46_path}")
                            print(f"DEBUG: [add_starter_cards] Action_46.png existe? {os.path.exists(action_46_path)}")
                            if os.path.exists(action_31_path) and "Action_31.png" not in files_in_path:
                                print(f"DEBUG: [add_starter_cards] WARNING: PROBLEMA: Action_31.png existe no filesystem mas não retornado por listdir!")
                                files_in_path.append("Action_31.png")  # Força a adição
                            if os.path.exists(action_46_path) and "Action_46.png" not in files_in_path:
                                print(f"DEBUG: [add_starter_cards] WARNING: PROBLEMA: Action_46.png existe no filesystem mas não retornado por listdir!")
                                files_in_path.append("Action_46.png")  # Força a adição
                        
                        card_files = [os.path.join(path_attempt, f) for f in files_in_path 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        print(f"DEBUG: [add_starter_cards] Arquivos de carta neutros filtrados: {[os.path.basename(f) for f in card_files]}")
                        if card_files:
                            # Para actions e events, filtrar apenas cartas válidas para o jogador
                            if card_type == "challenges":
                                valid_cards = []
                                
                                # Adicionar challenges genéricos disponíveis
                                for card_file in card_files:
                                    valid_cards.append(card_file)
                                
                                if not valid_cards:
                                    # Se Challenge_3 não estiver disponível, pegar o primeiro Challenge disponível
                                    valid_cards = card_files[:1] if card_files else []
                                    print(f"DEBUG: [add_starter_cards] Challenge_3 não encontrado, usando primeiro disponível: {[os.path.basename(f) for f in valid_cards]}")
                                
                                card_files = valid_cards
                                print(f"DEBUG: [add_starter_cards] Challenges selecionados para adicionar: {[os.path.basename(f) for f in card_files]}")
                                
                            elif card_type in ["actions", "events"] and hasattr(self, 'card_database') and self.card_database:
                                valid_cards = []
                                player_color = self.player_color.lower()
                                
                                for card_file in card_files:
                                    filename = os.path.basename(card_file)
                                    print(f"DEBUG: [add_starter_cards] Verificando arquivo {card_type}: {filename}")
                                    try:
                                        if card_type == "actions":
                                            # ESPECÍFICO: Incluir Action_31.png e Action_46.png
                                            if filename == "Action_31.png":
                                                valid_cards.append(card_file)
                                                print(f"DEBUG: [add_starter_cards] Action FORÇADA (Action_31): {filename}")
                                            elif filename == "Action_46.png":
                                                valid_cards.append(card_file)
                                                print(f"DEBUG: [add_starter_cards] Action FORÇADA (Action_46): {filename}")
                                            else:
                                                print(f"DEBUG: [add_starter_cards] Action IGNORADA (não é Action_31 nem Action_46): {filename}")
                                        elif card_type == "events":
                                            # Event_1.png -> event_1
                                            match = re.search(r'Event_(\d+)\.', filename)
                                            if match:
                                                # ESPECIAL: Incluir APENAS Event_55 e Event_14
                                                if filename == "Event_55.png":
                                                    valid_cards.append(card_file)
                                                    print(f"DEBUG: [add_starter_cards] Event FORÇADO (teste duration variável): {filename}")
                                                elif filename == "Event_14.png":
                                                    valid_cards.append(card_file)
                                                    print(f"DEBUG: [add_starter_cards] Event FORÇADO (Event_14): {filename}")
                                                else:
                                                    print(f"DEBUG: [add_starter_cards] Event IGNORADO (não é Event_55 nem Event_14): {filename}")
                                    except Exception as e:
                                        print(f"DEBUG: [add_starter_cards] Erro ao processar carta {filename}: {e}")
                                
                                card_files = valid_cards
                                print(f"DEBUG: [add_starter_cards] Cartas filtradas para {card_type}: {len(card_files)} válidas de {len(valid_cards)} totais")
                            
                            # Adicionar cartas ao inventário
                            if card_files:
                                if card_type == "events":
                                    max_cards = min(2, len(card_files))  # Máximo 2 events (Event_55 e Event_14)
                                elif card_type == "actions":
                                    max_cards = min(4, len(card_files))  # Máximo 4 actions (Action_70, Action_10, Action_1, Action_16)
                                elif card_type == "challenges":
                                    max_cards = min(2, len(card_files))  # Máximo 2 Challenges
                                else:
                                    max_cards = min(3, len(card_files))
                                
                                print(f"DEBUG: [add_starter_cards] Adicionando {max_cards} cartas neutras de {card_type}")
                                for i in range(max_cards):
                                    carta_path = card_files[i]
                                    
                                    # CORREÇÃO FIFO: Actions e Events devem usar adicionar_carta_inventario()
                                    if card_type in ["actions", "events"]:
                                        print(f"DEBUG: [add_starter_cards] Usando FIFO para {card_type}: {os.path.basename(carta_path)}")
                                        self.adicionar_carta_inventario(carta_path, card_type)
                                        print(f"DEBUG: [add_starter_cards] Carta {card_type} adicionada via FIFO: {os.path.basename(carta_path)}")
                                    else:
                                        # Outros tipos (challenges, equipments, etc.) usam append direto
                                        self.inventario[card_type].append(carta_path)
                                        print(f"DEBUG: [PlayerDashboard] Carta inicial neutra adicionada: {os.path.basename(carta_path)} ({card_type})")
                                    
                                    # Se for uma carta Challenge, registrar no sistema de tracking
                                    if card_type == "challenges":
                                        print(f"DEBUG: [add_starter_cards] Challenge adicionado ao inventário: {os.path.basename(carta_path)}")
                                        print(f"DEBUG: [add_starter_cards] SUCCESS: Challenge estará disponível na página Activities/Challenges")
                                    
                                    # Se for uma carta Event, NÃO criar tracking automático
                                    elif card_type == "events":
                                        print(f"DEBUG: [add_starter_cards] === EVENT ADICIONADO AO INVENTÁRIO ===")
                                        print(f"DEBUG: [add_starter_cards] Event: {os.path.basename(carta_path)}")
                                        print(f"DEBUG: [add_starter_cards] ⚠️  TRACKING NÃO CRIADO - será criado quando Event for ativado")
                                        print(f"DEBUG: [add_starter_cards] ✅  Event adicionado ao inventário via FIFO sem tracking pré-criado")
                                        print(f"DEBUG: [add_starter_cards] === FIM: EVENT NO INVENTÁRIO ===")
                            else:
                                print(f"DEBUG: [add_starter_cards] Nenhuma carta válida encontrada para {card_type} após filtragem")
                            cards_found = True
                            break
                        else:
                            print(f"DEBUG: [add_starter_cards] Nenhum arquivo de carta neutra encontrado em {path_attempt}")
                    except Exception as e:
                        print(f"DEBUG: [PlayerDashboard] Erro ao carregar carta inicial {card_type}: {e}")
                else:
                    print(f"DEBUG: [add_starter_cards] Caminho neutro não existe: {path_attempt}")
            
            if not cards_found:
                print(f"DEBUG: [add_starter_cards] NENHUMA ESTRUTURA NEUTRA FUNCIONOU para {card_type}")
        
        print(f"DEBUG: [PlayerDashboard] Resumo do inventário após cartas iniciais:")
        for tipo, cartas in self.inventario.items():
            print(f"DEBUG: [PlayerDashboard]   {tipo}: {len(cartas)} cartas")
        
        # Verificar se temos as Actions específicas no inventário
        action_31_present = any("Action_31.png" in carta for carta in self.inventario.get("actions", []))
        action_46_present = any("Action_46.png" in carta for carta in self.inventario.get("actions", []))
        print(f"DEBUG: [PlayerDashboard] Action_31.png presente? {action_31_present}")
        print(f"DEBUG: [PlayerDashboard] Action_46.png presente? {action_46_present}")
        
        if action_31_present or action_46_present:
            print(f"DEBUG: [PlayerDashboard] SUCCESS: Actions específicas encontradas! NÃO adicionando Actions extras")
            # Só garantir que há Events suficientes, mas não Actions extras
            current_actions = len(self.inventario.get("actions", []))
            self.add_more_action_event_cards(min_actions=current_actions, min_events=2)  # Manter actions atuais
        else:
            print(f"DEBUG: [PlayerDashboard] WARNING: Actions específicas NÃO encontradas, adicionando Actions padrão")
            # Garantir que há cartas suficientes de Actions/Events  
            self.add_more_action_event_cards(min_actions=6, min_events=2)
        
        # Adicionar Equipment_2.png especificamente ao inventário
        base_path = detect_player_inventory_base_dir()
        
        # CORREÇÃO: Incluir a cor do jogador no caminho do Equipment_2.png
        player_color_capitalized = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        equipment_2_path = os.path.join(base_path, "Equipments", "Residential-level", player_color_capitalized, "Equipment_2.png")
        
        print(f"DEBUG: [PlayerDashboard] Tentando adicionar Equipment_2.png para cor {player_color_capitalized}")
        print(f"DEBUG: [PlayerDashboard] Caminho completo: {equipment_2_path}")
        
        # Verificar se o arquivo existe e adicionar ao inventário se não estiver já lá
        equipment_2_final_path = None
        if os.path.exists(equipment_2_path):
            if equipment_2_path not in self.inventario["equipments"]:
                self.inventario["equipments"].append(equipment_2_path)
                print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_2.png adicionada ao inventário: {equipment_2_path}")
                equipment_2_final_path = equipment_2_path
            else:
                print(f"DEBUG: [PlayerDashboard] Equipment_2.png já estava no inventário")
                equipment_2_final_path = equipment_2_path
        else:
            print(f"DEBUG: [PlayerDashboard] Equipment_2.png não encontrada em: {equipment_2_path}")
            # Fallback: tentar outros caminhos possíveis incluindo variações de cor
            fallback_paths = [
                os.path.join(base_path, "Equipments", "Residential-level", "Equipment_2.png"),  # Sem cor
                os.path.join(base_path, "equipments", "Residential-level", player_color_capitalized, "Equipment_2.png"),  # Minúscula
                os.path.join(os.path.dirname(__file__), "Equipments", "Residential-level", player_color_capitalized, "Equipment_2.png"),
                os.path.join(os.path.dirname(__file__), "equipments", "Residential-level", player_color_capitalized, "Equipment_2.png")
            ]
            
            for fallback_path in fallback_paths:
                print(f"DEBUG: [PlayerDashboard] Testando fallback: {fallback_path}")
                if os.path.exists(fallback_path):
                    if fallback_path not in self.inventario["equipments"]:
                        self.inventario["equipments"].append(fallback_path)
                        print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_2.png adicionada via fallback: {fallback_path}")
                        equipment_2_final_path = fallback_path
                        break
                    else:
                        print(f"DEBUG: [PlayerDashboard] Equipment_2.png já estava no inventário (fallback)")
                        equipment_2_final_path = fallback_path
                        break
        
        # Equipment_2.png adicionada ao inventário mas NÃO ativada automaticamente
        # O jogador deve ativar manualmente para usar REMOVE ROUTER
        if equipment_2_final_path:
            print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_2.png adicionada ao inventário: {os.path.basename(equipment_2_final_path)}")
            print(f"DEBUG: [PlayerDashboard] WARNING: Equipment_2.png deve ser ativada manualmente para usar REMOVE ROUTER")
        else:
            print(f"DEBUG: [PlayerDashboard] WARNING: Equipment_2.png não foi encontrada - REMOVE ROUTER não funcionará")
        
        # Adicionar Equipment_10.png especificamente ao inventário
        equipment_10_path = os.path.join(base_path, "Equipments", "Residential-level", player_color_capitalized, "Equipment_10.png")
        
        print(f"DEBUG: [PlayerDashboard] Tentando adicionar Equipment_10.png para cor {player_color_capitalized}")
        print(f"DEBUG: [PlayerDashboard] Caminho completo: {equipment_10_path}")
        
        # Verificar se o arquivo existe e adicionar ao inventário se não estiver já lá
        equipment_10_final_path = None
        if os.path.exists(equipment_10_path):
            if equipment_10_path not in self.inventario["equipments"]:
                self.inventario["equipments"].append(equipment_10_path)
                print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_10.png adicionada ao inventário: {equipment_10_path}")
                equipment_10_final_path = equipment_10_path
            else:
                print(f"DEBUG: [PlayerDashboard] Equipment_10.png já estava no inventário")
                equipment_10_final_path = equipment_10_path
        else:
            print(f"DEBUG: [PlayerDashboard] Equipment_10.png não encontrada em: {equipment_10_path}")
            # Fallback: tentar outros caminhos possíveis incluindo variações de cor
            fallback_paths_10 = [
                os.path.join(base_path, "Equipments", "Residential-level", "Equipment_10.png"),  # Sem cor
                os.path.join(base_path, "equipments", "Residential-level", player_color_capitalized, "Equipment_10.png"),  # Minúscula
                os.path.join(os.path.dirname(__file__), "Equipments", "Residential-level", player_color_capitalized, "Equipment_10.png"),
                os.path.join(os.path.dirname(__file__), "equipments", "Residential-level", player_color_capitalized, "Equipment_10.png")
            ]
            
            for fallback_path in fallback_paths_10:
                print(f"DEBUG: [PlayerDashboard] Testando fallback Equipment_10: {fallback_path}")
                if os.path.exists(fallback_path):
                    if fallback_path not in self.inventario["equipments"]:
                        self.inventario["equipments"].append(fallback_path)
                        print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_10.png adicionada via fallback: {fallback_path}")
                        equipment_10_final_path = fallback_path
                        break
                    else:
                        print(f"DEBUG: [PlayerDashboard] Equipment_10.png já estava no inventário (fallback)")
                        equipment_10_final_path = fallback_path
                        break
        
        # Equipment_10.png adicionada ao inventário mas NÃO ativada automaticamente
        # O jogador pode ativar manualmente para usar LINK UPGRADE
        if equipment_10_final_path:
            print(f"DEBUG: [PlayerDashboard] SUCCESS: Equipment_10.png adicionada ao inventário: {os.path.basename(equipment_10_final_path)}")
            print(f"DEBUG: [PlayerDashboard] INFO: Equipment_10.png disponível para LINK UPGRADE")
        else:
            print(f"DEBUG: [PlayerDashboard] WARNING: Equipment_10.png não foi encontrada - LINK UPGRADE pode não funcionar")
        
        # CORREÇÃO CRÍTICA: NÃO ativar Events automaticamente durante inicialização
        # O tracking será criado apenas quando o Event for realmente ativado
        if self.inventario.get("events"):
            print("DEBUG: [add_starter_cards] Events encontrados no inventário")
            print("DEBUG: [add_starter_cards] ⚠️  Events NÃO serão ativados automaticamente")
            print("DEBUG: [add_starter_cards] ✅  Tracking será criado quando Event for ativado no jogo")
    
    def _get_card_message_size(self, carta_path):
        """
        Extrai o message_size de uma carta Activity ou Challenge usando a base de dados
        """
        try:
            if not self.card_database:
                print("DEBUG: Base de dados não está disponível")
                return 0
            
            # Tentar determinar se é Activity ou Challenge pelo nome do arquivo
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: Analisando carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair ID da carta Activity
                # Assumindo formato Activity_X.png onde X é o número
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    # Usar o formato correto da base de dados: activity_X_cor
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        print(f"DEBUG: Found activity {activity_id} with message_size: {activity_card.message_size}")
                        return activity_card.message_size
                    else:
                        print(f"DEBUG: Activity {activity_id} não encontrada na base de dados")
                            
            elif "challenge" in carta_basename:
                # Extrair ID da carta Challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        print(f"DEBUG: Found challenge {challenge_id} with message_size: {challenge_card.message_size}")
                        return challenge_card.message_size
                    else:
                        print(f"DEBUG: Challenge {challenge_id} não encontrada na base de dados")
            
            print(f"DEBUG: Could not find message_size for card: {carta_basename}")
            return 0
            
        except Exception as e:
            print(f"DEBUG: Error getting message_size for {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def _get_card_message_size_from_database(self, carta_path):
        """
        CORREÇÃO 2: Função dedicada para obter message_size sempre da base de dados
        Garante que os valores são sempre obtidos da base de dados integrada
        """
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print("DEBUG: [DATABASE] Base de dados não está disponível")
                return 20  # fallback padrão
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [DATABASE] Analisando carta para message_size: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair número da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [DATABASE] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        message_size = getattr(activity_card, 'message_size', 20)
                        print(f"DEBUG: [DATABASE] Activity {activity_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Activity {activity_id} não encontrada")
            
            elif "challenge" in carta_basename:
                # Extrair número do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [DATABASE] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        message_size = getattr(challenge_card, 'message_size', 25)
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} message_size: {message_size}")
                        return message_size
                    else:
                        print(f"DEBUG: [DATABASE] Challenge {challenge_id} não encontrado")
            
            print(f"DEBUG: [DATABASE] Usando fallback para carta: {carta_basename}")
            return 20  # fallback padrão
            
        except Exception as e:
            print(f"DEBUG: [DATABASE] Erro ao obter message_size para {carta_path}: {e}")
            import traceback
            traceback.print_exc()
            return 20  # fallback em caso de erro
    
    def _select_carousel_card(self, card_index, carta_path):
        """
        Seleciona uma carta no carrossel (primeiro clique) ou abre fullscreen (segundo clique)
        """
        print(f"DEBUG: ===== _select_carousel_card CHAMADA =====")
        print(f"DEBUG: card_index={card_index}, carta_path={os.path.basename(carta_path)}")
        
        # CORREÇÃO CRÍTICA: Verificar bloqueio temporário após clique no botão seta
        if getattr(self, '_bloqueio_temporario_carrossel', False):
            print("DEBUG: ERROR: Clique bloqueado temporariamente após botão seta - evitando fullscreen acidental")
            return
        
        # CORREÇÃO: Verificar se estamos em Final Phase com gestão de pacotes ativa
        # APENAS bloquear se estivermos em gestão ativa, não em qualquer Final Phase
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        print(f"DEBUG: Estado atual - gestao_pacotes_ativa: {gestao_pacotes_ativa}, final_phase_normal: {final_phase_normal}")
        
        if gestao_pacotes_ativa:
            print("DEBUG: Gestão de pacotes ativa - verificando se carta tem destaque roxo")
            
            # Só permitir clique na carta que tem destaque roxo
            if hasattr(self, '_carta_destacada_posicao') and self._carta_destacada_posicao == card_index:
                print("DEBUG: Clique permitido - carta tem destaque roxo")
                
                # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DO FULLSCREEN
                self._capturar_estado_botoes_imediato()
                
                # Permitir apenas fullscreen da carta destacada
                self.show_card_fullscreen_carrossel(carta_path)
                return
            else:
                print("DEBUG: Clique bloqueado - carta não tem destaque roxo")
                return
        
        # Verificar se é uma carta virada para baixo (não pode ser selecionada)
        if os.path.basename(carta_path).startswith("back_card_"):
            print(f"DEBUG: Carta virada para baixo não pode ser selecionada")
            return
        
        # CORREÇÃO: Permitir cliques normais em Final Phase (quando não está em gestão de pacotes)
        # Só verificar Next Phase se realmente estiver ativo
        if getattr(self, '_next_phase_active', False) and not final_phase_normal:
            if not self._can_access_carousel_position(card_index):
                print(f"DEBUG: Clique bloqueado - sem permissão durante Next Phase para posição {card_index}")
                return
        
        # Verificar se é Activity ou Challenge
        carta_basename = os.path.basename(carta_path).lower()
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: Carta {carta_basename} não é Activity nem Challenge")
            return
        
        # Se clicar na mesma carta já selecionada, abrir fullscreen
        if (self.selected_carousel_index == card_index and 
            self.selected_carousel_card == carta_path):
            print(f"DEBUG: Segundo clique na carta {card_index} - abrindo fullscreen")
            
            # CORREÇÃO CRÍTICA: Detectar estado dos botões IMEDIATAMENTE antes do fullscreen
            print("DEBUG: [ESTADO] === DETECÇÃO IMEDIATA DOS BOTÕES ===")
            estado_imediato = {
                'btn_plus_rxd_visivel': False,
                'btn_plus_lost_visivel': False,
                'btn_seta_visivel': False
            }
            
            # Detectar estado atual dos botões AGORA
            if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                try:
                    if self._btn_plus_rxd.winfo_exists() and self._btn_plus_rxd.winfo_ismapped():
                        estado_imediato['btn_plus_rxd_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Botão + Rxd DETECTADO como visível")
                except:
                    pass
            
            if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                try:
                    if self._btn_plus_lost.winfo_exists() and self._btn_plus_lost.winfo_ismapped():
                        estado_imediato['btn_plus_lost_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Botão + Lost DETECTADO como visível")
                except:
                    pass
            
            if hasattr(self, '_btn_seta') and self._btn_seta:
                try:
                    if self._btn_seta.winfo_exists() and self._btn_seta.winfo_ismapped():
                        estado_imediato['btn_seta_visivel'] = True
                        print("DEBUG: [ESTADO] SUCCESS: Botão seta DETECTADO como visível")
                except:
                    pass
            
            print(f"DEBUG: [ESTADO] RESULTADO DETECÇÃO IMEDIATA:")
            print(f"DEBUG: [ESTADO]   btn_plus_rxd_visivel: {estado_imediato['btn_plus_rxd_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_plus_lost_visivel: {estado_imediato['btn_plus_lost_visivel']}")
            print(f"DEBUG: [ESTADO]   btn_seta_visivel: {estado_imediato['btn_seta_visivel']}")
            
            # Salvar o estado detectado IMEDIATAMENTE
            self._estado_botoes_imediato = estado_imediato
            
            # CORREÇÃO CRÍTICA: Salvar estado da dashboard antes de abrir fullscreen
            self._save_dashboard_state()
            self.show_card_fullscreen_carrossel(carta_path)
            return
        
        # Primeiro clique: selecionar carta
        print(f"DEBUG: Primeiro clique - Selecionando carta {card_index}: {os.path.basename(carta_path)}")
        
        # Atualizar seleção
        self.selected_carousel_card = carta_path
        self.selected_carousel_index = card_index
        
        # Atualizar destaques visuais
        print(f"DEBUG: Atualizando destaques visuais...")
        self._update_carousel_selection_highlights()
        
        # CORREÇÃO: Verificar se há valores preservados para esta carta antes de atualizar barras
        print(f"DEBUG: ===== VERIFICANDO VALORES PRESERVADOS =====")
        carta_index_in_carrossel = card_index
        if carta_index_in_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[carta_index_in_carrossel]
            print(f"DEBUG: Stats preservadas para carta {carta_index_in_carrossel}: {preserved_stats}")
            
            # CORREÇÃO PROBLEMA 1: SEMPRE atualizar barras diretamente da base de dados primeiro
            # Depois aplicar valores preservados apenas se diferentes de zero
            print(f"DEBUG: UPDATING: ATUALIZANDO BARRAS DA BASE DE DADOS - ANTES FINAL PHASE")
            self._update_progress_bars_from_card(carta_path)
            
            # NOVA LÓGICA: Aplicar valores preservados apenas se diferentes dos defaults
            message_size = self._get_card_message_size_from_database(carta_path)
            rxd_preservado = preserved_stats.get('Rxd', 0)
            lost_preservado = preserved_stats.get('Lost', 0)
            to_send_preservado = preserved_stats.get('To send', message_size)
            
            # Se valores preservados diferem dos defaults da base de dados, aplicar
            if rxd_preservado > 0 or lost_preservado > 0 or to_send_preservado != message_size:
                print(f"DEBUG: STATS: APLICANDO VALORES PRESERVADOS - ANTES FINAL PHASE")
                self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_path)
            else:
                print(f"DEBUG: SUCCESS: VALORES PRESERVADOS SÃO DEFAULTS - MANTENDO BASE DE DADOS")
        else:
            print(f"DEBUG: WARNING: Índice {carta_index_in_carrossel} fora do range de card_stats")
            print(f"DEBUG: UPDATING: ATUALIZANDO BARRAS DIRETAMENTE DA BASE DE DADOS")
            self._update_progress_bars_from_card(carta_path)
        
        print(f"DEBUG: ===== FIM _select_carousel_card =====\n")
    
    def _update_carousel_selection_highlights(self):
        """
        Atualiza os destaques das cartas no carrossel baseado na seleção atual
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: WARNING: card_labels não existe ou está vazio - pulando atualização de destaques")
            return
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights INICIADA =====")
        print(f"DEBUG: selected_carousel_index: {getattr(self, 'selected_carousel_index', None)}")
        print(f"DEBUG: _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        print(f"DEBUG: _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        
        # CORREÇÃO CRÍTICA: Verificar se todos os widgets estão válidos ANTES de processar
        widgets_destruidos = 0
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: WARNING: Widget carta {i} foi destruído, pulando configuração")
                    widgets_destruidos += 1
                    continue
            except tk.TclError:
                print(f"DEBUG: WARNING: Widget carta {i} não é válido (TclError), pulando configuração")
                widgets_destruidos += 1
                continue
        
        # Se muitos widgets foram destruídos, cancelar atualização
        if widgets_destruidos >= len(self.card_labels) // 2:
            print(f"DEBUG: WARNING: Muitos widgets destruídos ({widgets_destruidos}/{len(self.card_labels)}) - cancelando atualização")
            print(f"DEBUG: ===== _update_carousel_selection_highlights CANCELADA =====\n")
            return
        
        for i, lbl in enumerate(self.card_labels):
            if i >= len(self.cards):
                continue
                
            try:
                # CORREÇÃO: Verificar se widget ainda existe antes de configurar
                if not lbl.winfo_exists():
                    print(f"DEBUG: WARNING: Widget carta {i} foi destruído, pulando configuração")
                    continue
            except tk.TclError:
                print(f"DEBUG: WARNING: Widget carta {i} não é válido (TclError), pulando configuração")
                continue
            
            carta_path = self.cards[i]
            is_back_card = os.path.basename(carta_path).startswith("back_card_")
            next_phase_active = getattr(self, '_next_phase_active', False)
            final_phase_active = getattr(self, '_final_phase_active', False)
            gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
            
            # CORREÇÃO: Lógica de destaques mais clara e específica
            highlight_color = "black"
            border_width = 0
            border_color = "black"
            
            # PRIORIDADE 1: Gestão de pacotes (destaque roxo específico) - PRIORIDADE MÁXIMA
            if gestao_pacotes_ativa:
                # CORREÇÃO CRÍTICA: Usar selected_carousel_index como fonte da verdade durante gestão
                # Em vez de confiar apenas em _carta_atual_gestao, usar a posição realmente selecionada
                posicao_gestao_atual = getattr(self, 'selected_carousel_index', None)
                
                # VALIDAÇÃO DUPLA: Verificar também _carta_atual_gestao como backup
                carta_atual_gestao = getattr(self, '_carta_atual_gestao', None)
                
                # Se não temos posição selecionada mas temos gestão ativa, usar a gestão
                if posicao_gestao_atual is None and carta_atual_gestao is not None:
                    if hasattr(self, '_cartas_gestao') and carta_atual_gestao < len(self._cartas_gestao):
                        carta_path_atual = self._cartas_gestao[carta_atual_gestao]
                        # Encontrar posição desta carta no carrossel
                        for idx, carta in enumerate(self.cards):
                            if carta == carta_path_atual:
                                posicao_gestao_atual = idx
                                print(f"DEBUG: Carta gestão encontrada na posição {idx}: {os.path.basename(carta_path_atual)}")
                                break
                
                # APLICAR DESTAQUE: Apenas a posição selecionada/atual deve ter destaque roxo
                if posicao_gestao_atual is not None and i == posicao_gestao_atual:
                    # VERIFICAÇÃO ADICIONAL: Garantir que a carta não é back_card
                    carta_na_posicao = self.cards[i] if i < len(self.cards) else None
                    if carta_na_posicao:
                        carta_basename = os.path.basename(carta_na_posicao).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            highlight_color = "#800080"  # Roxo
                            border_width = 3
                            border_color = "#800080"
                            print(f"DEBUG: Carta {i} - destaque ROXO (gestão de pacotes ativa) - carta atual: {os.path.basename(carta_na_posicao)}")
                        else:
                            highlight_color = "black"
                            border_width = 0
                            border_color = "black"
                            print(f"DEBUG: Carta {i} - sem destaque (gestão ativa mas carta inválida: {carta_basename})")
                    else:
                        highlight_color = "black"
                        border_width = 0
                        border_color = "black"
                        print(f"DEBUG: Carta {i} - sem destaque (gestão ativa mas carta não encontrada)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (gestão de pacotes ativa, não é carta atual)")
            
            # PRIORIDADE 2: Final Phase normal (sem gestão de pacotes)
            elif final_phase_active and not gestao_pacotes_ativa:
                # CORREÇÃO CRÍTICA: Durante Final Phase SEM gestão ativa, NÃO aplicar QUALQUER destaque
                # Após finalizar gestão de pacotes, limpar TODOS os destaques
                # As cartas devem voltar ao estado visual normal (sem destaque)
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - SEM DESTAQUE (Final Phase, gestão finalizada - limpeza completa)")
                
                # CORREÇÃO CRÍTICA: NÃO limpar selected_carousel_index durante Final Phase
                # O índice deve ser preservado para permitir navegação e gestão de pacotes
                # Removida a limpeza automática do selected_carousel_index
            
            # PRIORIDADE 3: Next Phase (cartas viradas para baixo com destaque roxo)
            elif next_phase_active and is_back_card:
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"
                    print(f"DEBUG: Carta {i} - destaque ROXO (Next Phase, pode selecionar)")
                else:
                    highlight_color = "black"
                    border_width = 0
                    border_color = "black"
                    print(f"DEBUG: Carta {i} - sem destaque (Next Phase, não pode selecionar)")
            
            # PRIORIDADE 4: Estado normal (destaque da cor do jogador)
            elif i == self.selected_carousel_index and not is_back_card:
                highlight_color = self.bar_color
                border_width = 3
                border_color = self.player_color.lower()
                print(f"DEBUG: Carta {i} - destaque COR DO JOGADOR (estado normal)")
            
            # PRIORIDADE 5: Sem destaque
            else:
                highlight_color = "black"
                border_width = 0
                border_color = "black"
                print(f"DEBUG: Carta {i} - sem destaque (estado normal)")
            
            try:
                lbl.config(bg=highlight_color, borderwidth=border_width, relief="solid" if border_width > 0 else "flat",
                          highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
                print(f"DEBUG: SUCCESS: Carta {i} configurada: bg={highlight_color}, border={border_width}")
            except tk.TclError as e:
                print(f"DEBUG: ERROR: Widget carta {i} inválido (TclError): {e}")
                continue
            except Exception as e:
                print(f"DEBUG: ERROR: Erro ao configurar carta {i}: {e}")
                continue
        
        print(f"DEBUG: ===== _update_carousel_selection_highlights TERMINADA =====\n")
    
    def _update_progress_bars_from_card(self, carta_path):
        """
        Atualiza as barras de progresso com base nos dados da carta selecionada
        CORREÇÃO: Considera valores preservados para comportamento dinâmico correto
        """
        try:
            print(f"DEBUG: ===== UPDATING: _update_progress_bars_from_card INICIADA =====")
            print(f"DEBUG: CLIPBOARD: Carta selecionada: {os.path.basename(carta_path)}")
            print(f"DEBUG: TARGET: CONTEXTO: Atualizando barras ANTES do Final Phase (comportamento dinâmico)")
            
            # Verificar se as barras de progresso estão inicializadas
            print(f"DEBUG: Verificando inicialização...")
            print(f"DEBUG: hasattr(self, 'progress_bars'): {hasattr(self, 'progress_bars')}")
            print(f"DEBUG: hasattr(self, 'progress_labels'): {hasattr(self, 'progress_labels')}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ERROR: Barras de progresso não inicializadas")
                return
                
            print(f"DEBUG: SUCCESS: Barras de progresso inicializadas")
            print(f"DEBUG: progress_bars keys: {list(self.progress_bars.keys())}")
            print(f"DEBUG: progress_labels keys: {list(self.progress_labels.keys())}")
                
            # Obter message_size da base de dados
            print(f"DEBUG: Extraindo message_size da base de dados...")
            message_size = self._get_card_message_size_from_database(carta_path)
            print(f"DEBUG: STATS: Message size extraído da base de dados: {message_size}")
            
            # CORREÇÃO CRÍTICA: Verificar se existem valores preservados para esta carta
            carta_idx = None
            if hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None:
                carta_idx = self.selected_carousel_index
            elif hasattr(self, 'cards') and self.cards:
                # Procurar o índice da carta no carrossel
                for i, carta_carrossel in enumerate(self.cards):
                    if carta_carrossel and os.path.basename(carta_carrossel) == os.path.basename(carta_path):
                        carta_idx = i
                        break
            
            # Verificar se existem valores preservados
            preserved_stats = None
            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats)):
                preserved_stats = self.card_stats[carta_idx]
                print(f"DEBUG: STATS: VALORES PRESERVADOS ENCONTRADOS para carta {carta_idx}: {preserved_stats}")
            else:
                print(f"DEBUG: STATS: Nenhum valor preservado encontrado - usando valores padrão")
                print(f"DEBUG: STATS: Debug info: carta_idx={carta_idx}, card_stats_len={len(getattr(self, 'card_stats', []))}")
            
            # Verificar se "To send" existe nas barras
            if "To send" not in self.progress_bars:
                print("DEBUG: ERROR: 'To send' não encontrado em progress_bars")
                return
                
            if "To send" not in self.progress_labels:
                print("DEBUG: ERROR: 'To send' não encontrado em progress_labels")
                return
            
            print(f"DEBUG: SUCCESS: 'To send' encontrado em ambas as estruturas")
            
            # Configurar barra "To send"
            try:
                print(f"DEBUG: Atualizando barras de progresso...")
                
                # CORREÇÃO: Definir o message_size como máximo para TODAS as barras (To send, Rxd, Lost)
                # Isso garante precisão visual - barras com mesmo valor ficarão alinhadas
                for bar_name in ["To send", "Rxd", "Lost"]:
                    if bar_name in self.progress_bars:
                        self.progress_bars[bar_name]["maximum"] = message_size
                        print(f"DEBUG: SUCCESS: Máximo da barra '{bar_name}' definido para {message_size}")
                
                # CORREÇÃO: Usar valores preservados se disponíveis, senão usar valor padrão
                if preserved_stats and 'To send' in preserved_stats:
                    to_send_value = preserved_stats['To send']
                    print(f"DEBUG: STATS: USANDO VALOR PRESERVADO para To send: {to_send_value}")
                else:
                    to_send_value = message_size  # Valor padrão (barra cheia)
                    print(f"DEBUG: STATS: USANDO VALOR PADRÃO para To send: {to_send_value}")
                
                # Configurar valor da barra To send
                self.progress_bars["To send"]["value"] = to_send_value
                self.progress_labels["To send"]["text"] = str(to_send_value)
                
                print(f"DEBUG: SUCCESS: Barra 'To send' configurada:")
                print(f"DEBUG:   - Máximo: {message_size}")
                print(f"DEBUG:   - Valor: {to_send_value}")
                print(f"DEBUG:   - Label: '{to_send_value}'")
                
                # CORREÇÃO: Atualizar todas as outras barras (Rxd e Lost) com mesmo máximo e valores preservados
                for bar_name in ['Rxd', 'Lost']:
                    if bar_name in self.progress_bars and bar_name in self.progress_labels:
                        # IMPORTANTE: As barras já foram configuradas com maximum=message_size acima
                        if preserved_stats and bar_name in preserved_stats:
                            # Usar valor preservado
                            preserved_value = preserved_stats[bar_name]
                            self.progress_bars[bar_name]["value"] = preserved_value
                            self.progress_labels[bar_name]["text"] = str(preserved_value)
                            print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor preservado: {preserved_value} (máx: {message_size})")
                        else:
                            # NOVO: Usar valor padrão (buscar no card_stats se disponível)
                            carta_idx = getattr(self, 'selected_carousel_index', None)
                            if (carta_idx is not None and hasattr(self, 'card_stats') and 
                                isinstance(self.card_stats, list) and carta_idx < len(self.card_stats) and
                                bar_name in self.card_stats[carta_idx]):
                                # Usar valor atual do card_stats se disponível
                                current_value = self.card_stats[carta_idx][bar_name]
                                self.progress_bars[bar_name]["value"] = current_value
                                self.progress_labels[bar_name]["text"] = str(current_value)
                                print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor do card_stats: {current_value} (máx: {message_size})")
                            else:
                                # Último recurso: valor padrão 0
                                self.progress_bars[bar_name]["value"] = 0
                                self.progress_labels[bar_name]["text"] = "0"
                                print(f"DEBUG: SUCCESS: {bar_name} atualizada com valor padrão: 0 (máx: {message_size})")
                
                # Forçar atualização visual
                try:
                    for stat_name in ["To send", "Rxd", "Lost"]:
                        if stat_name in self.progress_bars:
                            widget = self.progress_bars[stat_name]
                            widget.update_idletasks()
                            widget.update()
                        if stat_name in self.progress_labels:
                            widget = self.progress_labels[stat_name]
                            widget.update_idletasks()
                            widget.update()
                    
                    # Forçar atualização da janela principal e master
                    self.update_idletasks()
                    self.update()
                    
                    if hasattr(self, 'master') and self.master:
                        self.master.update_idletasks()
                        self.master.update()
                    
                    self.after_idle(lambda: self._force_visual_refresh())
                    print(f"DEBUG: SUCCESS: Atualização visual completa realizada")
                    
                except Exception as visual_error:
                    print(f"DEBUG: WARNING: Erro durante atualização visual: {visual_error}")
                
                # Verificação final
                final_value = self.progress_bars["To send"]["value"]
                final_max = self.progress_bars["To send"]["maximum"]
                final_label = self.progress_labels["To send"]["text"]
                print(f"DEBUG: ===== VERIFICAÇÃO FINAL =====")
                print(f"DEBUG: Máximo final da barra: {final_max}")
                print(f"DEBUG: Valor final da barra: {final_value}")
                print(f"DEBUG: Texto final do label: '{final_label}'")
                print(f"DEBUG: Percentagem da barra: {(final_value/final_max)*100:.1f}%")
                print(f"DEBUG: SUCCESS: SUCESSO - Barra configurada com valores {'preservados' if preserved_stats else 'padrão'}!")
                
            except Exception as update_error:
                print(f"DEBUG: ERROR: Erro ao configurar progress bar: {update_error}")
                import traceback
                traceback.print_exc()
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro geral ao atualizar barras de progresso: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: ===== _update_progress_bars_from_card TERMINADA =====\n")

    def _force_visual_refresh(self):
        """
        Força um refresh visual adicional das barras de progresso
        """
        try:
            print("DEBUG: UPDATING: _force_visual_refresh executando...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if (hasattr(self, 'progress_bars') and stat_name in self.progress_bars and
                    hasattr(self, 'progress_labels') and stat_name in self.progress_labels):
                    
                    # Forçar redesenho dos widgets
                    self.progress_bars[stat_name].update()
                    self.progress_labels[stat_name].update()
            
            self.update()
            print("DEBUG: SUCCESS: _force_visual_refresh concluído")
        except Exception as e:
            print(f"DEBUG: WARNING: Erro em _force_visual_refresh: {e}")

    def _apply_preserved_stats_to_progress_bars(self, preserved_stats, carta_path=None):
        """
        Aplica estatísticas preservadas diretamente às barras de progresso
        CORREÇÃO FUNDAMENTAL: Sempre usar a carta que está na posição do carrossel
        """
        try:
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars INICIADA =====")
            print(f"DEBUG: Aplicando stats preservadas: {preserved_stats}")
            print(f"DEBUG: Carta parametro: {os.path.basename(carta_path) if carta_path else 'N/A'}")
            
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print("DEBUG: ERROR: Barras de progresso não inicializadas")
                return
            
            # CORREÇÃO CRÍTICA: SEMPRE usar a carta que está realmente no carrossel
            carta_real_para_valores = None
            if (hasattr(self, 'selected_carousel_index') and 
                self.selected_carousel_index is not None and 
                hasattr(self, 'cards') and self.cards):
                
                carrossel_index = self.selected_carousel_index
                if carrossel_index < len(self.cards):
                    carta_real_para_valores = self.cards[carrossel_index]
                    carta_nome = os.path.basename(carta_real_para_valores)
                    
                    print(f"DEBUG: WARNING: IMPORTANTE - Carta REAL no carrossel posição {carrossel_index}: {carta_nome}")
                    print(f"DEBUG: WARNING: IMPORTANTE - Aplicando valores À CARTA DO CARROSSEL, não à preservada")
                    
                    # Obter message_size da carta que está REALMENTE no carrossel
                    correct_message_size = self._get_card_message_size_from_database(carta_real_para_valores)
                    print(f"DEBUG: Message size da carta REAL do carrossel: {correct_message_size}")
                else:
                    print(f"DEBUG: WARNING: Índice carrossel inválido: {carrossel_index}")
                    carta_real_para_valores = carta_path
                    correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
            else:
                # Fallback para carta_path se não há carrossel válido
                carta_real_para_valores = carta_path
                correct_message_size = self._get_card_message_size_from_database(carta_path) if carta_path else 4
                print(f"DEBUG: WARNING: Sem seleção carrossel válida, usando carta_path fallback")
            
            print(f"DEBUG: DEFINITIVO - Carta para aplicar valores: {os.path.basename(carta_real_para_valores) if carta_real_para_valores else 'N/A'}")
            print(f"DEBUG: DEFINITIVO - Message size: {correct_message_size}")
            
            # CORREÇÃO CRÍTICA: Validar consistência dos valores preservados
            to_send_preservado = preserved_stats.get("To send", 0)
            rxd_preservado = preserved_stats.get("Rxd", 0)
            lost_preservado = preserved_stats.get("Lost", 0)
            
            # CORREÇÃO FUNDAMENTAL: Sempre recalcular To send baseado em message_size - (Rxd + Lost)
            # Isso garante que To send seja sempre consistente independentemente dos valores preservados
            to_send_correto = max(correct_message_size - (rxd_preservado + lost_preservado), 0)
            
            print(f"DEBUG: VALIDAÇÃO DE CONSISTÊNCIA:")
            print(f"DEBUG:   Message size: {correct_message_size}")
            print(f"DEBUG:   Rxd preservado: {rxd_preservado}")
            print(f"DEBUG:   Lost preservado: {lost_preservado}")
            print(f"DEBUG:   To send preservado: {to_send_preservado}")
            print(f"DEBUG:   To send CORRETO calculado: {to_send_correto}")
            
            # CORREÇÃO: Se To send preservado não está correto, corrigir automaticamente
            if to_send_preservado != to_send_correto:
                print(f"DEBUG: CORREÇÃO AUTOMÁTICA: To send inconsistente!")
                print(f"DEBUG:   Preservado: {to_send_preservado}")
                print(f"DEBUG:   Correto: {to_send_correto}")
                print(f"DEBUG:   Aplicando correção automática...")
                
                # Corrigir os stats preservados
                preserved_stats = preserved_stats.copy()
                preserved_stats["To send"] = to_send_correto
                print(f"DEBUG: SUCCESS: To send corrigido automaticamente: {to_send_correto}")
            else:
                print(f"DEBUG: SUCCESS: To send está consistente: {to_send_preservado}")
            
            # Aplicar cada valor preservado (possivelmente corrigido)
            for stat_name, value in preserved_stats.items():
                if stat_name in self.progress_bars and stat_name in self.progress_labels:
                    try:
                        # CORREÇÃO: Para TODAS as barras, usar o message_size correto da carta atual como máximo
                        # Isso garante precisão visual - barras com mesmo valor ficam alinhadas
                        if correct_message_size is not None:
                            # Primeiro definir o máximo correto para TODAS as barras
                            self.progress_bars[stat_name]["maximum"] = correct_message_size
                            print(f"DEBUG: SUCCESS: Máximo da barra '{stat_name}' corrigido para carta REAL: {correct_message_size}")
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, máximo={correct_message_size}")
                        else:
                            # Fallback para máximo atual
                            current_max = self.progress_bars[stat_name]["maximum"]
                            print(f"DEBUG: Aplicando {stat_name}: valor={value}, máximo={current_max} (fallback)")
                        
                        # Aplicar valores
                        self.progress_bars[stat_name]["value"] = value
                        self.progress_labels[stat_name]["text"] = str(value)
                        
                        # Forçar atualização
                        self.progress_bars[stat_name].update()
                        self.progress_labels[stat_name].update()
                        
                        print(f"DEBUG: SUCCESS: {stat_name} aplicado com sucesso: {value}")
                    except Exception as e:
                        print(f"DEBUG: ERROR: Erro ao aplicar {stat_name}: {e}")
                else:
                    print(f"DEBUG: WARNING: {stat_name} não encontrado nas barras de progresso")
            
            print(f"DEBUG: ===== _apply_preserved_stats_to_progress_bars TERMINADA =====")
            
            # CORREÇÃO: Forçar atualização visual após aplicar valores preservados
            print(f"DEBUG: Forçando atualização visual após aplicar valores preservados...")
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    self.progress_bars[stat_name].update_idletasks()
                    self.progress_bars[stat_name].update()
                if stat_name in self.progress_labels:
                    self.progress_labels[stat_name].update_idletasks()
                    self.progress_labels[stat_name].update()
            
            # Forçar atualização da janela principal
            self.update_idletasks()
            print(f"DEBUG: SUCCESS: Atualização visual de valores preservados realizada")
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro geral em _apply_preserved_stats_to_progress_bars: {e}")
            import traceback
            traceback.print_exc()

    def _sync_card_stats_with_progress_bars(self):
        """
        Sincroniza os valores atuais das barras de progresso com card_stats
        Deve ser chamado sempre que as barras são modificadas
        """
        try:
            if (not hasattr(self, 'selected_carousel_index') or 
                self.selected_carousel_index is None or
                not hasattr(self, 'progress_bars') or 
                not hasattr(self, 'progress_labels')):
                return
            
            carta_index = self.selected_carousel_index
            if carta_index >= len(self.card_stats):
                return
            
            print(f"DEBUG: Sincronizando card_stats[{carta_index}] com barras de progresso")
            
            # Capturar valores atuais das barras
            for stat_name in ["To send", "Rxd", "Lost"]:
                if stat_name in self.progress_bars:
                    current_value = self.progress_bars[stat_name]["value"]
                    old_value = self.card_stats[carta_index][stat_name]
                    
                    # Atualizar card_stats
                    self.card_stats[carta_index][stat_name] = current_value
                    
                    print(f"DEBUG: {stat_name}: {old_value} -> {current_value}")
            
            print(f"DEBUG: SUCCESS: card_stats[{carta_index}] sincronizado: {self.card_stats[carta_index]}")
            
        except Exception as e:
            print(f"DEBUG: ERROR: Erro ao sincronizar card_stats: {e}")
            import traceback
            traceback.print_exc()

    def decrement_to_send_progress(self, packets_sent=1):
        """
        Decrementa a barra 'To send' quando pacotes são enviados.
        Esta função deve ser chamada pelo sistema de jogo quando pacotes são efetivamente enviados.
        
        Args:
            packets_sent (int): Número de pacotes enviados (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "To send" not in self.progress_bars:
                print("DEBUG: Barra 'To send' não disponível para decremento")
                return
            
            current_value = self.progress_bars["To send"]["value"]
            new_value = max(0, current_value - packets_sent)  # Não pode ser negativo
            
            print(f"DEBUG: Decrementando 'To send': {current_value} - {packets_sent} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["To send"]["value"] = new_value
            self.progress_labels["To send"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["To send"].update()
            self.progress_labels["To send"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            # Verificar se todos os pacotes foram enviados
            if new_value == 0:
                print("DEBUG: SUCCESS: Todos os pacotes da mensagem foram enviados! Barra vazia.")
            else:
                percentage = (new_value / self.progress_bars["To send"]["maximum"]) * 100
                print(f"DEBUG: Restam {new_value} pacotes para enviar ({percentage:.1f}% da barra)")
                
        except Exception as e:
            print(f"DEBUG: Erro ao decrementar barra 'To send': {e}")
            import traceback
            traceback.print_exc()

    def increment_rxd_progress(self, packets_received=1):
        """
        Incrementa a barra 'Rxd' quando pacotes são recebidos.
        
        Args:
            packets_received (int): Número de pacotes recebidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Rxd" not in self.progress_bars:
                print("DEBUG: Barra 'Rxd' não disponível para incremento")
                return
            
            current_value = self.progress_bars["Rxd"]["value"]
            new_value = current_value + packets_received
            
            print(f"DEBUG: Incrementando 'Rxd': {current_value} + {packets_received} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Rxd"]["value"] = new_value
            self.progress_labels["Rxd"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["Rxd"].update()
            self.progress_labels["Rxd"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            # NOVO: Data Volume packet consumption logic
            self._consume_data_volume_packets(packets_received)
            
            print(f"DEBUG: SUCCESS: 'Rxd' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Rxd': {e}")
            import traceback
            traceback.print_exc()

    def increment_lost_progress(self, packets_lost=1):
        """
        Incrementa a barra 'Lost' quando pacotes são perdidos.
        
        Args:
            packets_lost (int): Número de pacotes perdidos (default: 1)
        """
        try:
            if not hasattr(self, 'progress_bars') or "Lost" not in self.progress_bars:
                print("DEBUG: Barra 'Lost' não disponível para incremento")
                return
            
            current_value = self.progress_bars["Lost"]["value"]
            new_value = current_value + packets_lost
            
            print(f"DEBUG: Incrementando 'Lost': {current_value} + {packets_lost} = {new_value}")
            
            # Atualizar barra e label
            self.progress_bars["Lost"]["value"] = new_value
            self.progress_labels["Lost"]["text"] = str(new_value)
            
            # Forçar atualização da interface
            self.progress_bars["Lost"].update()
            self.progress_labels["Lost"].update()
            
            # CORREÇÃO: Sincronizar com card_stats para preservar entre turnos
            self._sync_card_stats_with_progress_bars()
            
            print(f"DEBUG: SUCCESS: 'Lost' atualizado para {new_value}")
                
        except Exception as e:
            print(f"DEBUG: Erro ao incrementar barra 'Lost': {e}")
            import traceback
            traceback.print_exc()

    def _extrair_valor_venda_carta(self, carta_path):
        """
        Extrai o valor de venda da carta usando a base de dados integrada
        Similar ao _extrair_valor_carta do Store_v2.py mas retorna sell_cost
        """
        # CORREÇÃO: Verificação adicional para garantir que Services sempre retornam 0
        path_lower = carta_path.lower()
        nome = os.path.basename(carta_path)
        if "/services/" in path_lower or "service_" in nome.lower():
            print(f"DEBUG: Service detectada - forçando valor de venda 0: {nome}")
            return 0
        
        if not self.card_database:
            print("DEBUG: Base de dados não disponível, usando extração por nome de arquivo")
            return self._extrair_valor_fallback(carta_path)
        
        try:
            # Determinar tipo da carta pelo caminho
            carta_tipo = self._get_card_type_from_path(carta_path)
            if not carta_tipo:
                print(f"DEBUG: Tipo de carta não identificado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Mapear arquivo para ID da base de dados
            card_id = self._map_file_to_card_id(carta_path, carta_tipo)
            if not card_id:
                print(f"DEBUG: ID da carta não mapeado para: {carta_path}")
                return self._extrair_valor_fallback(carta_path)
            
            # Obter carta da base de dados
            if carta_tipo == "users":
                card = self.card_database.get_user(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "equipments":
                card = self.card_database.get_equipment(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "services":
                card = self.card_database.get_service(card_id)
                valor = card.sell_cost if card else None
            elif carta_tipo == "activities":
                card = self.card_database.get_activity(card_id)
                valor = card.sell_cost if card else None  # Activities têm sell_cost = 0
            elif carta_tipo == "actions":
                card = self.card_database.get_action(card_id)
                valor = 0 if card else None  # Actions não podem ser vendidas
            else:
                print(f"DEBUG: Tipo de carta não suportado para venda: {carta_tipo}")
                return self._extrair_valor_fallback(carta_path)
            
            if valor is not None:
                print(f"DEBUG: Valor de venda encontrado na base de dados: {valor} para {card_id}")
                return valor
            else:
                print(f"DEBUG: Carta não encontrada na base de dados: {card_id}")
                return self._extrair_valor_fallback(carta_path)
                
        except Exception as e:
            print(f"DEBUG: Erro ao extrair valor da base de dados: {e}")
            return self._extrair_valor_fallback(carta_path)
    
    def _extrair_valor_fallback(self, carta_path):
        """Método fallback para extrair valor do nome do arquivo"""
        try:
            import re
            nome = os.path.basename(carta_path)
            path_lower = carta_path.lower()
            
            # CORREÇÃO: Services sempre têm valor de venda 0, independentemente do fallback
            if "/services/" in path_lower or "service_" in nome.lower():
                print(f"DEBUG: Service detectada no fallback - retornando 0: {nome}")
                return 0
            
            # Para outros tipos, extrair do nome do arquivo
            match = re.search(r'_(\d+)\.', nome)
            if match:
                valor = int(match.group(1))
                print(f"DEBUG: Valor extraído por fallback: {valor}")
                return valor
        except Exception as e:
            print(f"DEBUG: Erro no fallback: {e}")
        return 1  # Valor padrão
    
    def _get_card_type_from_path(self, carta_path):
        """Determina o tipo da carta pelo caminho"""
        path_lower = carta_path.lower()
        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
            return "users"
        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
            return "equipments"
        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
            return "services"
        elif "/activities/" in path_lower or "activity_" in os.path.basename(path_lower):
            return "activities"
        elif "/actions/" in path_lower or "action_" in os.path.basename(path_lower):
            return "actions"
        return None
    
    def _map_file_to_card_id(self, carta_path, carta_tipo):
        """Mapeia arquivo para ID da base de dados"""
        nome = os.path.basename(carta_path)
        cor = self._get_color_from_path(carta_path)
        
        # Fallback para cor se não detectada no caminho
        if not cor:
            cor = self.player_color  # Usar cor do jogador como padrão aqui
        
        if carta_tipo == "users":
            # User_1.png -> contract_red, User_2.png -> 1_red, User_3.png -> 2_red, etc.
            match = re.search(r'User_(\d+)\.', nome)
            if match:
                user_num = int(match.group(1))
                if user_num == 1:  # User_1.png = Residential Contract
                    return f"contract_{cor}"
                elif user_num >= 2:  # User_2.png = user ID 1, User_3.png = user ID 2, etc.
                    return f"{user_num - 1}_{cor}"
        
        elif carta_tipo == "equipments":
            # Equipment_1.png -> small_router_1_red, etc.
            match = re.search(r'Equipment_(\d+)\.', nome)
            if match:
                eq_num = int(match.group(1))
                if 1 <= eq_num <= 3:
                    return f"small_router_{eq_num}_{cor}"
                elif 4 <= eq_num <= 6:
                    return f"medium_router_{eq_num - 3}_{cor}"
                elif 7 <= eq_num <= 9:
                    return f"short_link_{eq_num - 6}_{cor}"
                elif 10 <= eq_num <= 12:
                    return f"long_link_{eq_num - 9}_{cor}"
        
        elif carta_tipo == "services":
            # Service_1.png -> Service_1, Service_2.png -> Service_2, etc.
            # Usar ID direto sem mapeamento complexo
            match = re.search(r'Service_(\d+)\.', nome)
            if match:
                service_num = match.group(1)
                return f"Service_{service_num}"
        
        elif carta_tipo == "activities":
            # Activity_1.png -> activity_1_red, etc.
            match = re.search(r'Activity_(\d+)\.', nome)
            if match:
                activity_num = int(match.group(1))
                return f"activity_{activity_num}_{cor}"
        
        elif carta_tipo == "actions":
            # Action_1.png -> action_1, etc.
            match = re.search(r'Action_(\d+)\.', nome)
            if match:
                action_num = int(match.group(1))
                return f"action_{action_num}"
        
        return None
    
    def _extract_event_id_from_path(self, carta_path):
        """Extrai o ID do Event a partir do caminho da carta"""
        try:
            nome = os.path.basename(carta_path)
            # Event_123.png -> event_123
            import re
            match = re.search(r'Event_(\d+)\.', nome)
            if match:
                event_num = int(match.group(1))
                return f"event_{event_num}"
        except Exception as e:
            print(f"DEBUG: [_extract_event_id_from_path] Erro ao extrair ID do Event: {e}")
        return None
    
    def _get_color_from_path(self, carta_path):
        """Extrai a cor do caminho da carta"""
        path_lower = carta_path.lower()
        if "/red/" in path_lower or "-red" in path_lower:
            return "red"
        elif "/blue/" in path_lower or "-blue" in path_lower:
            return "blue"
        elif "/green/" in path_lower or "-green" in path_lower:
            return "green"
        elif "/yellow/" in path_lower or "-yellow" in path_lower:
            return "yellow"
        return self.player_color  # Usar cor do jogador como padrão
        
    # Cargas de cartas usando a nova estrutura: [tipo]/Residential-level/[cor]/
    def load_cards_from_new_structure(self, card_type, player_color):
            """Carrega cartas da nova estrutura de pastas"""
            cards = []
            
            # Mapear tipo para nome da pasta
            folder_mapping = {
                "users": "Users",
                "equipments": "Equipments", 
                "services": "Services",
                "activities": "Activities",
                "challenges": "Challenges",
                "actions": "Actions",
                "events": "Events"
            }
            
            folder_name = folder_mapping.get(card_type, card_type)
            
            # Para cartas que têm cores específicas (equipments, services, users, activities)
            if card_type in ["equipments", "services", "users", "activities"]:
                # Mapear cor do jogador para diferentes formatos de nome
                color_variants = []
                if player_color == "blue":
                    color_variants = ["Blue", "blue", "BLUE"]
                elif player_color == "green": 
                    color_variants = ["Green", "green", "GREEN"]
                elif player_color == "red":
                    color_variants = ["Red", "red", "RED"]
                elif player_color == "yellow":
                    color_variants = ["Yellow", "yellow", "YELLOW"]
                else:
                    color_variants = ["Blue", "blue"]  # default
                
                # Tentar encontrar cartas na estrutura: [tipo]/Residential-level/[cor]/
                for color_var in color_variants:
                    path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level", color_var)
                    if os.path.exists(path):
                        try:
                            card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                        if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                            if card_files:
                                cards.extend(card_files)
                                print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                                break  # Para no primeiro caminho que funcionar
                        except Exception as e:
                            continue
            else:
                # Para cartas sem cor específica (challenges, events, actions)
                path = os.path.join(CARTAS_BASE_DIR, folder_name, "Residential-level")
                if os.path.exists(path):
                    try:
                        card_files = [os.path.join(path, f) for f in os.listdir(path) 
                                    if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                        if card_files:
                            cards.extend(card_files)
                            print(f"DEBUG: Encontradas {len(card_files)} cartas {card_type} em {path}")
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar {card_type}: {e}")
            
            return cards

    def animate_typing(self, label, text, delay=50, callback=None):
        def _type(i=0):
            if i <= len(text):
                label.config(text=text[:i])
                label.after(delay, _type, i + 1)
            elif callback:
                callback()
        _type()

    def show_dice_roll_screen(self, player_name, saldo, other_players, screen_width, screen_height):
        # Reset da flag de Action removida - novo turno, cartas podem ficar viradas para cima novamente
        # Reset flags de cartas removidas no início de cada turno
        self._action_recently_removed = False
        self._event_recently_removed = False
        print("DEBUG: [DICE_ROLL] Flags _action_recently_removed e _event_recently_removed resetadas para False - novo turno")
        
        # VERIFICAÇÃO AUTOMÁTICA DE SERVICES EXPIRADOS NO INÍCIO DO TURNO
        print("DEBUG: [DICE_ROLL] === VERIFICAÇÃO AUTOMÁTICA DE SERVICES EXPIRADOS NO TURNO ===")
        services_expirados_encontrados = self._verificar_services_expirados_automaticamente()
        print("DEBUG: [DICE_ROLL] === FIM VERIFICAÇÃO AUTOMÁTICA DE SERVICES ===")
        
        # NOVO: Mostrar overlay de Services expirados se encontrados
        if services_expirados_encontrados:
            print("DEBUG: [DICE_ROLL] === SERVICES EXPIRADOS ENCONTRADOS - OVERLAY SERÁ MOSTRADO ===")
            # Mostrar overlay após a tela de dice estar criada
            self.after(1000, self._mostrar_overlay_services_expirados_apos_interface)
        
        # Ativar cartas que estavam pendentes de ativação devido ao sequenciamento
        self._activate_pending_cards()
        
        # NOVO: Resetar contadores de processamento por turno
        self._reset_turn_processing_counters()
        
        # Limpa widgets abaixo da barra superior
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), fg="black", bg=self.bar_color)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Saldo (direita)
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
        coin_lbl.image = coin_img
        coin_lbl.place(x=screen_width-100, y=30)
        saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, y=30)

        # Ícones dos outros jogadores (esquerda)
        for idx, p in enumerate(other_players):
            if idx < len(USER_ICONS):
                icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                lbl.image = icon_img  # type: ignore[attr-defined]
                lbl.place(x=5+idx*40, y=20)

        # Frame central para o dado e frases
        center_frame = tk.Frame(self, bg="black")
        center_frame.place(relx=0.5, rely=0.5, anchor="center")

        lbl1 = tk.Label(center_frame, text="", font=("Helvetica", 22, "bold"), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl1.pack(pady=(0, 10))
        lbl2 = tk.Label(center_frame, text="", font=("Helvetica", 18), bg="black", fg="white", wraplength=int(screen_width*0.8), justify="center")
        lbl2.pack(pady=(0, 30))

        dice_btn = None
        go_btn = None


        if not hasattr(self, "player_pos"):
            self.player_pos = START_POSITIONS.get(self.player_color.lower(), 0)
        player_pos = self.player_pos

        def after_texts():
            nonlocal dice_btn, go_btn
            blank_img_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
            dice_img = ImageTk.PhotoImage(Image.open(blank_img_path).resize((100,100)))
            dice_btn = tk.Label(center_frame, image=dice_img, bg="black")
            dice_btn.image = dice_img  # type: ignore[attr-defined]
            dice_btn.pack(pady=20)

            go_btn = tk.Button(center_frame, text="Go!", font=("Helvetica", 16, "bold"), bg="#005c75", fg="white")

            def roll_animation():
                # CORREÇÃO CRÍTICA: Incrementar turno AQUI quando o jogador lança o dado
                # Apenas incrementar se estivermos vindo de um End Turn (não primeiro turno do jogo)
                # A flag coming_from_end_turn indica que acabamos de terminar um turno
                
                # Detectar ambiente para debug específico
                universal_paths = get_universal_paths()
                ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
                
                coming_from_end_turn = hasattr(self, '_coming_from_end_turn') and self._coming_from_end_turn
                print(f"DEBUG: [DICE_ROLL] AMBIENTE: {ambiente}")
                print(f"DEBUG: [DICE_ROLL] Verificando flag _coming_from_end_turn...")
                print(f"DEBUG: [DICE_ROLL] hasattr(self, '_coming_from_end_turn'): {hasattr(self, '_coming_from_end_turn')}")
                if hasattr(self, '_coming_from_end_turn'):
                    print(f"DEBUG: [DICE_ROLL] self._coming_from_end_turn: {self._coming_from_end_turn}")
                print(f"DEBUG: [DICE_ROLL] coming_from_end_turn: {coming_from_end_turn}")
                
                if coming_from_end_turn:
                    print("DEBUG: [DICE_ROLL] Vindo de END TURN - contadores já foram incrementados no backup!")
                    print(f"DEBUG: [DICE_ROLL] Contadores atuais (já incrementados na inicialização):")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_number: {self._current_turn_number}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn: {self._current_turn}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_id: {self._current_turn_id}")
                    
                    # CRÍTICO: Verificar Challenges que atingiram o tempo limite após incremento
                    try:
                        print(f"DEBUG: [DICE_ROLL] Verificando Challenges que atingiram tempo limite...")
                        self._verificar_challenges_tempo_limite()
                        print(f"DEBUG: [DICE_ROLL] SUCCESS: Verificação de tempo limite executada")
                    except Exception as e:
                        print(f"DEBUG: [DICE_ROLL] ERROR: Erro na verificação de tempo limite: {e}")
                    
                    # NOVO: Verificar Events que expiraram no início do turno
                    try:
                        print(f"DEBUG: [DICE_ROLL] Verificando Events expirados no início do turno {self._current_turn}...")
                        self._verificar_events_expirados()
                        print(f"DEBUG: [DICE_ROLL] SUCCESS: Verificação de Events expirados executada")
                    except Exception as e:
                        print(f"DEBUG: [DICE_ROLL] ERROR: Erro na verificação de Events expirados: {e}")
                    
                    # CORREÇÃO: Limpar flag após processar
                    self._coming_from_end_turn = False
                    print("DEBUG: [DICE_ROLL] Flag _coming_from_end_turn limpa após processar incremento do backup")
                else:
                    print(f"DEBUG: [DICE_ROLL] AMBIENTE: {ambiente}")
                    print("DEBUG: [DICE_ROLL] CRITICAL: Contadores NÃO foram incrementados!")
                    print("DEBUG: [DICE_ROLL] Razão: Primeiro turno ou _coming_from_end_turn = False")
                    print(f"DEBUG: [DICE_ROLL] Estado atual dos contadores (SEM INCREMENTO):")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_number: {self._current_turn_number}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn: {self._current_turn}")
                    print(f"DEBUG: [DICE_ROLL]   _current_turn_id: {self._current_turn_id}")
                    # GARANTIR que a flag está limpa no início do jogo
                    self._coming_from_end_turn = False
                
                # CORREÇÃO CRÍTICA: Verificar se go_btn ainda existe antes de manipular
                try:
                    if go_btn.winfo_exists():
                        go_btn.pack_forget()
                    else:
                        print("DEBUG: [DICE_ROLL] go_btn foi destruído - ignorando pack_forget")
                except tk.TclError as e:
                    print(f"DEBUG: [DICE_ROLL] WARNING: Erro ao ocultar go_btn (widget destruído): {e}")
                except Exception as e:
                    print(f"DEBUG: [DICE_ROLL] WARNING: Erro inesperado ao ocultar go_btn: {e}")
                
                frames = 25
                results = [random.randint(1,6) for _ in range(frames)]
                final = random.randint(1,6)
                results.append(final)

                def animate(i=0,player_color=self.player_color):
                    
                    color_map = {
                    "green": "#70AD47",
                    "yellow": "#F2BA0D",
                    "red": "#EE6F68",
                    "blue": "#43BEF2"
                    }
                    
                    self.bar_color = color_map.get(player_color.lower(), "#AAAAAA")
                    
                    if i < len(results):
                        n = results[i]
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]
                        center_frame.after(100, animate, i+1)
                    else:
                        img_path = os.path.join(IMG_DIR, "dice", f"Dice_{final}.png")
                        img = ImageTk.PhotoImage(Image.open(img_path).resize((100,100)))
                        dice_btn.config(image=img)
                        dice_btn.image = img  # type: ignore[attr-defined]

                        # Esconde as frases imediatamente
                        lbl1.pack_forget()
                        lbl2.pack_forget()

                        steps = final
                        old = self.player_pos
                        new_pos = (old + steps) % NUM_CASAS
                        tipo, casa_cor = BOARD[new_pos]
                        self.player_pos = new_pos
                        
                        # Atualizar variáveis da casa atual para o botão Store
                        self.current_casa_tipo = tipo
                        self.current_casa_cor = casa_cor
                        # Verificar se é casa de outro jogador
                        self.current_other_player_house = (casa_cor != self.player_color.lower() and casa_cor != "neutral")

                        # CORREÇÃO CRÍTICA: Limpar estado Challenge se não estivermos numa casa Challenge
                        if tipo != "challenges":
                            print(f"DEBUG: [MOVIMENTO] Mudou para casa {tipo} {casa_cor} - limpando estado Challenge antigo")
                            self.limpar_estado_challenge_pendente(force_clean=True)
                            print("DEBUG: [MOVIMENTO] Estado Challenge limpo pois não estamos numa casa Challenge")

                        # IMPORTANTE: Reativar botão Store se não for casa Actions/Events/Challenges neutra
                        if not (tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                            self.enable_store_button()
                            print(f"DEBUG: Botão Store reativado - mudou para casa {tipo} {casa_cor}")

                        def mostrar_nome_casa(tipo, casa_cor):
                            # Esconde o dado só agora
                            dice_btn.pack_forget()
                            cor_map = {
                                "green": "#70AD47",
                                "yellow": "#F2BA0D",
                                "red": "#EE6F68",
                                "blue": "#43BEF2",
                                "neutral": "#AAAAAA"
                            }
                            cor = cor_map.get(casa_cor, "#FFFFFF")
                            # Corrigir nome 'equipment' para 'EQUIPMENTS'
                            nome_tipo = tipo.upper()
                            if nome_tipo == "EQUIPMENT":
                                nome_tipo = "EQUIPMENTS"
                            nome_lbl = tk.Label(center_frame, text=nome_tipo, font=("Helvetica", 22, "bold"), fg=cor, bg="black")
                            nome_lbl.pack(pady=10)

                            def depois_nome():
                                nome_lbl.pack_forget()
                                
                                # VERIFICAR SE É CASA START - vai diretamente para interface principal
                                if tipo == "start":
                                    print("DEBUG: [depois_nome] Casa START detectada - indo para interface principal do PlayerDashboard")
                                    # Marcar que está numa casa start (sem botão Store e sem vendas)
                                    self.current_casa_tipo = "start"
                                    self.current_casa_cor = "neutral"
                                    self.current_other_player_house = False
                                    
                                    # IMPORTANTE: Reativar botão Store na casa START (não é Actions/Events neutra)
                                    self.enable_store_button()
                                    print("DEBUG: Botão Store reativado - está na casa START")
                                    
                                    # Ir diretamente para a interface principal sem botão Store
                                    center_frame.destroy()
                                    self.playerdashboard_interface(player_name, saldo, self.other_players, show_store_button=False)
                                    return
                                
                                # VERIFICAR se já existe uma Store antes de criar nova
                                if (hasattr(self, 'store_window') and self.store_window and 
                                    hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                    print("DEBUG: [depois_nome] Store já existe, a reutilizar existente")
                                    print(f"DEBUG: [depois_nome] ID da Store existente: {id(self.store_window)}")
                                    print(f"DEBUG: [depois_nome] Estado fullscreen da Store existente: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                                    
                                    # CRÍTICO: Limpar estado obsoleto da Store antes de reutilizar
                                    if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                        self.store_window._limpar_estado_completo_store()
                                        print("DEBUG: [depois_nome] Estado da Store limpo antes da reutilização")
                                    
                                    # CORREÇÃO: Atualizar informações da casa atual na Store
                                    self.store_window.casa_tipo = tipo
                                    self.store_window.casa_cor = casa_cor
                                    print(f"DEBUG: [depois_nome] Casa atualizada na Store: {tipo} {casa_cor}")
                                    
                                    # CORREÇÃO CRÍTICA: Reconstruir interface da Store após limpeza
                                    if hasattr(self.store_window, 'rebuild_store_interface'):
                                        print("DEBUG: [depois_nome] Reconstruindo interface da Store após reutilização")
                                        self.store_window.rebuild_store_interface()
                                    
                                    # Restaurar Store existente em vez de criar nova
                                    self.store_window.deiconify()
                                    self.store_window.state('normal')
                                    self.store_window.lift()
                                    self.store_window.focus_force()
                                    return
                                
                                if casa_cor == self.player_color.lower() or casa_cor == "neutral":
                                    # Casa própria ou neutra - Store normal
                                    print("DEBUG: [depois_nome] Criando nova Store para casa própria/neutra")
                                    self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self)
                                    print(f"DEBUG: [depois_nome] Nova Store criada com ID: {id(self.store_window)}")
                                    if hasattr(self.store_window, '_store_id'):
                                        print(f"DEBUG: [depois_nome] Store ID único: {self.store_window._store_id}")
                                else:
                                    # Casa de outro jogador - mostra mensagem e depois Store apenas para venda
                                    other_player_lbl = tk.Label(center_frame, text="Square of other player", font=("Helvetica", 18, "bold"), fg="white", bg="black")
                                    other_player_lbl.pack(pady=10)
                                    
                                    def abrir_store_outro_jogador():
                                        other_player_lbl.pack_forget()
                                        
                                        # VERIFICAR se já existe uma Store antes de criar nova (também para outro jogador)
                                        if (hasattr(self, 'store_window') and self.store_window and 
                                            hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                            print("DEBUG: [abrir_store_outro_jogador] Store já existe, a reutilizar existente")
                                            
                                            # CRÍTICO: Limpar estado obsoleto da Store antes de reutilizar
                                            if hasattr(self.store_window, '_limpar_estado_completo_store'):
                                                self.store_window._limpar_estado_completo_store()
                                                print("DEBUG: [abrir_store_outro_jogador] Estado da Store limpo antes da reutilização")
                                            
                                            # CORREÇÃO: Atualizar informações da casa atual na Store
                                            self.store_window.casa_tipo = tipo
                                            self.store_window.casa_cor = casa_cor
                                            self.store_window.other_player_house = True
                                            print(f"DEBUG: [abrir_store_outro_jogador] Casa atualizada na Store: {tipo} {casa_cor} (outro jogador)")
                                            
                                            # CORREÇÃO CRÍTICA: Reconstruir interface da Store após limpeza
                                            if hasattr(self.store_window, 'rebuild_store_interface'):
                                                print("DEBUG: [abrir_store_outro_jogador] Reconstruindo interface da Store após reutilização")
                                                self.store_window.rebuild_store_interface()
                                            
                                            # Restaurar Store existente em vez de criar nova
                                            self.store_window.deiconify()
                                            self.store_window.state('normal')
                                            self.store_window.lift()
                                            self.store_window.focus_force()
                                            center_frame.destroy()
                                            return
                                        
                                        # Para casa de outro jogador, sempre abre a Store mas com restrições
                                        print("DEBUG: [abrir_store_outro_jogador] Criando nova Store para casa de outro jogador")
                                        self.store_window = StoreWindow(self, self.player_color, player_name, saldo, casa_tipo=tipo, casa_cor=casa_cor, inventario=self.inventario, dashboard=self, other_player_house=True)
                                        center_frame.destroy()
                                    
                                    # Espera 2 segundos e depois abre a Store
                                    center_frame.after(2000, abrir_store_outro_jogador)
                            
                            # Espera 2 segundos DEPOIS de mostrar o nome da casa
                            center_frame.after(2000, depois_nome)

                        # Espera 2 segundos ANTES de esconder o dado e mostrar o nome da casa
                        center_frame.after(2000, lambda: mostrar_nome_casa(tipo, casa_cor))

                animate()

            go_btn.config(command=roll_animation)
            go_btn.pack(pady=(0, 5))

        self.animate_typing(lbl1, "It's your turn!", delay=60,
            callback=lambda: self.animate_typing(lbl2, "Roll the dice to start your adventure.", delay=60, callback=after_texts)
        )
        
    def atualizar_carrossel(self):
        # Junta todas as cartas de Activities e Challenges do inventário, sem duplicar
        novas_cartas = []
        for tipo in ["activities", "challenges"]:
            novas_cartas += self.inventario.get(tipo, [])
        # Se não houver cartas, mostra backs
        if not novas_cartas:
            novas_cartas = [CARD_IMG] * 4
        self.cards = novas_cartas
        self.card_idx = 0
        self.selected_card_idx = 0
        
        # NOVA FUNCIONALIDADE: Atualizar flags das cartas baseado no estado atual
        nova_flags = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - flag True (virada para cima)
                nova_flags.append(True)
                print(f"DEBUG: [atualizar_carrossel] Posição {i}: {os.path.basename(carta_path)} -> Flag True (virada para cima)")
            else:
                # Carta back ou vazia - flag False (virada para baixo)
                nova_flags.append(False)
                print(f"DEBUG: [atualizar_carrossel] Posição {i}: back card -> Flag False (virada para baixo)")
        
        # Garantir que temos 4 flags
        while len(nova_flags) < 4:
            nova_flags.append(False)
        
        if not hasattr(self, 'card_face_up_flags'):
            self.card_face_up_flags = [False, False, False, False]
        self.card_face_up_flags = nova_flags[:4]  # Limitar a 4 posições
        print(f"DEBUG: [atualizar_carrossel] card_face_up_flags atualizado: {self.card_face_up_flags}")
        
        # CORREÇÃO CRÍTICA: Inicializar card_stats com valores corretos da base de dados
        print("DEBUG: [atualizar_carrossel] Inicializando card_stats com valores da base de dados...")
        novo_card_stats = []
        for i, carta_path in enumerate(self.cards):
            if carta_path and not carta_path.endswith("back_card.png") and not os.path.basename(carta_path).startswith("back_card_"):
                # Carta real - obter message_size da base de dados
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    carta_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    print(f"DEBUG: [atualizar_carrossel] Carta {i}: {os.path.basename(carta_path)} -> To send: {message_size}")
                except Exception as e:
                    print(f"DEBUG: [atualizar_carrossel] Erro ao obter message_size para {carta_path}: {e}")
                    carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
            else:
                # Carta back ou vazia
                carta_stats = {"To send": 0, "Rxd": 0, "Lost": 0}
                print(f"DEBUG: [atualizar_carrossel] Carta {i}: back card -> valores 0")
            novo_card_stats.append(carta_stats)
        
        # Garantir que temos 4 posições
        while len(novo_card_stats) < 4:
            novo_card_stats.append({"To send": 0, "Rxd": 0, "Lost": 0})
        
        self.card_stats = novo_card_stats[:4]  # Limitar a 4 posições
        print(f"DEBUG: [atualizar_carrossel] card_stats atualizado: {self.card_stats}")
        
        # CORREÇÃO: Preservar seleção do carrossel se ainda é válida
        # Verificar se a carta selecionada ainda existe no carrossel atualizado
        carta_selecionada_preservada = None
        indice_selecionado_preservado = None
        
        if (hasattr(self, 'selected_carousel_card') and self.selected_carousel_card and 
            self.selected_carousel_card in novas_cartas):
            # A carta ainda existe, preservar seleção
            carta_selecionada_preservada = self.selected_carousel_card
            indice_selecionado_preservado = novas_cartas.index(self.selected_carousel_card)
            print(f"DEBUG: [atualizar_carrossel] Preservando seleção: {os.path.basename(carta_selecionada_preservada)} (índice {indice_selecionado_preservado})")
        else:
            print("DEBUG: [atualizar_carrossel] Carta selecionada não existe mais ou não havia seleção - resetando")
        
        # Limpar seleção do carrossel temporariamente para atualização
        self.selected_carousel_card = carta_selecionada_preservada
        self.selected_carousel_index = indice_selecionado_preservado
        
        # Atualizar destaques
        if hasattr(self, 'card_labels') and self.card_labels:
            self._update_carousel_selection_highlights()

    def disable_store_button(self):
        """Desativa o botão Store permanentemente até ser reativado E esconde o botão Next Phase"""
        self._store_button_disabled = True
        # NOVA FUNCIONALIDADE: Esconder botão Next Phase quando Challenge é aceite
        self._challenge_accepted = True
        print("DEBUG: [PlayerDashboard] Botão Store desativado e Challenge aceite - Next Phase será escondido")

    def enable_store_button(self):
        """Reativa o botão Store e reset da flag Challenge"""
        self._store_button_disabled = False
        self._challenge_accepted = False
        print("DEBUG: [PlayerDashboard] Botão Store reativado e flag Challenge resetada")

    def limpar_estado_challenge_pendente(self, force_clean=False):
        """
        Função auxiliar para limpar completamente o estado Challenge pendente.
        Deve ser chamada quando voltamos de uma carta Challenge via botão Player.
        CORREÇÃO: Não limpa _challenge_accepted se um Challenge foi realmente aceite OU se há Challenge pendente.
        Se force_clean=True, limpa sempre independentemente do contexto.
        """
        print("DEBUG: [limpar_estado_challenge_pendente] Iniciando limpeza de estado Challenge")
        print(f"DEBUG: [limpar_estado_challenge_pendente] force_clean: {force_clean}")
        
        # CORREÇÃO: Verificar se Challenge foi aceite antes de limpar flag
        # Se Challenge foi aceite (store_button_disabled = True), NÃO limpar _challenge_accepted
        challenge_foi_aceite = getattr(self, '_store_button_disabled', False)
        
        # NOVA VERIFICAÇÃO: Verificar se há Challenge pendente na Store (via transferência de estado)
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # Se force_clean=True, sempre limpar tudo
        if force_clean:
            print("DEBUG: [limpar_estado_challenge_pendente] LIMPEZA FORÇADA - removendo todos os estados Challenge")
            self._challenge_accepted = False
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FORÇADO - _store_challenge_carta_path limpo: {old_path} -> None")
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] FORÇADO - _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        else:
            # Lógica normal baseada no contexto
            if challenge_foi_aceite:
                print("DEBUG: [limpar_estado_challenge_pendente] Challenge foi aceite - preservando _challenge_accepted = True")
                # Não mexer na flag _challenge_accepted quando Challenge foi aceite
                # IMPORTANTE: Preservar também após substituição Challenge->Activity
            elif challenge_pendente_transferido:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Challenge pendente transferido ({self._store_challenge_carta_path}) - NÃO limpando _challenge_accepted")
                # Também não limpar quando há Challenge pendente transferido via botão Player
            else:
                # CORREÇÃO: Verificar se houve substituição recente Challenge->Activity
                substituicao_recente = getattr(self, '_substituicao_challenge_activity_concluida', False)
                if substituicao_recente:
                    print("DEBUG: [limpar_estado_challenge_pendente] Substituição Challenge->Activity recente - preservando _challenge_accepted = True")
                    # Não resetar _challenge_accepted após substituição Challenge->Activity
                    # Limpar flag de substituição após uso
                    self._substituicao_challenge_activity_concluida = False
                else:
                    # Limpar flag Challenge apenas quando não foi aceite E não há Challenge pendente E não houve substituição
                    self._challenge_accepted = False
                    print("DEBUG: [limpar_estado_challenge_pendente] Nenhum Challenge pendente - limpando _challenge_accepted = False")
            
            # CORREÇÃO CRÍTICA: Sempre limpar variáveis de Challenge pendente para evitar que persistam entre turnos
            if hasattr(self, '_store_challenge_carta_path'):
                old_path = getattr(self, '_store_challenge_carta_path', None)
                self._store_challenge_carta_path = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_path limpo: {old_path} -> None")
            
            if hasattr(self, '_store_challenge_carta_tipo'):
                old_tipo = getattr(self, '_store_challenge_carta_tipo', None)
                self._store_challenge_carta_tipo = None
                print(f"DEBUG: [limpar_estado_challenge_pendente] PlayerDashboard _store_challenge_carta_tipo limpo: {old_tipo} -> None")
        
        # Verificar e limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar estado fullscreen Challenge na Store
                    if hasattr(self.store_window, 'fullscreen_carta_path'):
                        old_path = self.store_window.fullscreen_carta_path
                        self.store_window.fullscreen_carta_path = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_path limpo: {old_path} -> None")
                    if hasattr(self.store_window, 'fullscreen_carta_tipo'):
                        old_tipo = self.store_window.fullscreen_carta_tipo
                        self.store_window.fullscreen_carta_tipo = None
                        print(f"DEBUG: [limpar_estado_challenge_pendente] Store fullscreen_carta_tipo limpo: {old_tipo} -> None")
                    
                    # Limpar backups adicionais se existirem
                    backup_attrs = ['_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                   '_original_carta_path', '_original_carta_tipo']
                    for attr in backup_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: [limpar_estado_challenge_pendente] Store {attr} limpo")
                else:
                    print("DEBUG: [limpar_estado_challenge_pendente] Store não existe mais")
            except Exception as e:
                print(f"DEBUG: [limpar_estado_challenge_pendente] Erro ao verificar Store: {e}")
        else:
            print("DEBUG: [limpar_estado_challenge_pendente] Nenhuma Store ativa para limpar")
        
        print("DEBUG: [limpar_estado_challenge_pendente] Limpeza de estado Challenge concluída")

    def _criar_botao_next_phase(self):
        """Cria o botão Next Phase com toda a lógica necessária"""
        def next_phase_action():
            # MARCAR: Next Phase foi ativado manualmente pelo jogador
            self._next_phase_manually_activated = True
            # Esconde o botão Store
            if hasattr(self, 'btn_store') and self.btn_store:
                self.btn_store.place_forget()
                print("DEBUG: Botão Store escondido")
            # Ativa flag para desativar vendas nas páginas de inventário
            self._next_phase_active = True
            # Atualiza cache dos User IDs para controlo do carrossel
            self._check_user_inventory_for_carousel_access()
            # Atualiza destaques roxos do carrossel
            self._update_carousel_highlights()
            
            # MANTER BARRAS ATUALIZADAS: Atualizar barras de progresso quando Next Phase é ativado
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                print(f"DEBUG: Next Phase - Atualizando barras para carta selecionada: {os.path.basename(self.selected_carousel_card)}")
                self._update_progress_bars_from_card(self.selected_carousel_card)
            else:
                print("DEBUG: Next Phase - Nenhuma carta selecionada para atualizar barras")
            
            print("DEBUG: Next Phase ativado - Store escondido, vendas desativadas, User IDs verificados, destaques e barras atualizadas")
            
            # Esconder o botão Next Phase e criar o botão Final Phase na mesma posição
            if hasattr(self, 'next_phase_btn') and self.next_phase_btn:
                self.next_phase_btn.place_forget()
                print("DEBUG: Botão Next Phase escondido")
            
            # Criar botão Final Phase diretamente aqui em vez de chamar função externa
            self._criar_botao_final_phase()

        def final_phase_action():
            print("DEBUG: Final Phase ativado")
            
            # NOVA FLAG CRÍTICA: Marcar que Final Phase foi clicado NESTE turno
            self._final_phase_clicked_this_turn = True
            self._final_phase_turn_id = getattr(self, '_current_turn_number', 1)  # Associar ao turno atual
            print(f"DEBUG: [FINAL PHASE] Flag _final_phase_clicked_this_turn definida como True para turno {self._final_phase_turn_id}")
            
            # CORREÇÃO CRÍTICA: PRESERVAR valores atuais das barras ANTES de iniciar gestão
            self._preservar_valores_atuais_barras()
            
            # Ativar flag Final Phase para bloquear todas as ações de cartas
            self._final_phase_active = True
            # NOVA FLAG: Ativar flag para mostrar botão End Turn
            self._show_end_turn_button = True
            print("DEBUG: Final Phase ativado - ativação/desativação de cartas bloqueada")
            
            # CORREÇÃO: Verificar se existem cartas ativas ANTES de aplicar destaque roxo
            cartas_ativas = self._obter_cartas_ativas_carrossel()
            print(f"DEBUG: [FINAL PHASE] Cartas ativas encontradas: {len(cartas_ativas)}")
            
            if cartas_ativas:
                # Se há cartas ativas, aplicar destaque roxo na primeira carta ativa
                print("DEBUG: [FINAL PHASE] Ativando destaque roxo na primeira carta ativa")
                self._final_phase_gestao_ativa = True  # Ativar gestão de pacotes
                self._carta_destacada_posicao = 0      # Destacar posição 0
                self.selected_carousel_index = None    # Limpar seleção da cor do jogador
                
                # Atualizar destaques visuais ANTES de iniciar gestão de pacotes
                self._update_carousel_selection_highlights()
                print("DEBUG: [FINAL PHASE] Destaque roxo aplicado na posição 0")
            else:
                # Se não há cartas ativas, não ativar gestão de pacotes nem destaque roxo
                print("DEBUG: [FINAL PHASE] Nenhuma carta ativa - sem destaque roxo")
                self._final_phase_gestao_ativa = False
                self.selected_carousel_index = None    # Limpar seleção da cor do jogador
                
                # Atualizar destaques visuais (sem destaque roxo)
                self._update_carousel_selection_highlights()
            
            # INICIAR SISTEMA DE GESTÃO DE PACOTES
            print("DEBUG: Final Phase - Iniciando sistema de gestão de pacotes")
            
            # Esconder o botão Final Phase e criar End Turn ANTES de iniciar gestão
            try:
                if hasattr(self, 'final_phase_btn') and self.final_phase_btn:
                    self.final_phase_btn.place_forget()
                    print("DEBUG: Botão Final Phase escondido")
            except Exception as e:
                print(f"DEBUG: Erro ao esconder botão Final Phase: {e}")
            
            # Criar botão End Turn ANTES de iniciar gestão de pacotes
            self._criar_botao_end_turn()
            
            # Agora sim iniciar gestão de pacotes (que pode ativar o botão End Turn se necessário)
            self._iniciar_gestao_pacotes()

        # Armazenar as funções como atributos da classe para acesso posterior
        self._next_phase_action = next_phase_action
        self._final_phase_action = final_phase_action

        self.next_phase_btn = tk.Button(
            self,
            text="Next Phase",
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Cinza
            fg="black",
            command=next_phase_action,
            width=10,
        )
        # Posição igual aos botões Back das páginas de inventário
        self.next_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.next_phase_btn.lift()
        print("DEBUG: Botão Next Phase recriado na interface principal")
    
    def _criar_botao_final_phase(self):
        """Cria o botão Final Phase ou End Turn baseado no estado dos Services TEMPORARY e Data Volume"""
        # Verificar se há Services TEMPORARY ativos
        has_temporary_services = self._has_active_temporary_services()
        
        # NOVO: Verificar se há Data Volume services com pacotes disponíveis
        has_data_volume_packets = self._has_active_data_volume_services_with_packets()
        
        if has_temporary_services:
            # Se há Services TEMPORARY ativos, mostrar "Final Phase"
            button_text = "Final Phase"
            print("DEBUG: Services TEMPORARY ativos encontrados - criando botão 'Final Phase'")
        elif has_data_volume_packets:
            # Se há Data Volume services com pacotes, mostrar "Final Phase"
            button_text = "Final Phase"
            print("DEBUG: Data Volume services com pacotes encontrados - criando botão 'Final Phase'")
        else:
            # Se não há Services TEMPORARY ativos nem Data Volume com pacotes, mostrar "End Turn"
            button_text = "End Turn"
            print("DEBUG: Nenhum Service TEMPORARY ativo nem Data Volume com pacotes - criando botão 'End Turn'")
        
        # Determinar se deve usar Final Phase action ou End Turn direto
        use_final_phase_action = has_temporary_services or has_data_volume_packets
        
        self.final_phase_btn = tk.Button(
            self,
            text=button_text,
            font=("Helvetica", 14, "bold"),
            bg="#808080",  # Mesmo cinza do Next Phase
            fg="black",
            command=self._final_phase_action if use_final_phase_action else self._end_turn_direct_action,
            width=10,
        )
        # Mesma posição do botão Next Phase
        self.final_phase_btn.place(relx=0.5, rely=0.98, anchor="s")
        # Garantir que fica por cima de todos os outros elementos
        self.final_phase_btn.lift()
        print(f"DEBUG: Botão '{button_text}' criado na mesma posição")
    
    def _end_turn_direct_action(self):
        """Ação direta para End Turn quando não há Services TEMPORARY ativos"""
        print("DEBUG: [END_TURN_DIRECT] === BOTÃO END TURN DIRETO CLICADO ===")
        
        try:
            # Desabilitar botão imediatamente para evitar duplo clique
            if hasattr(self, 'final_phase_btn') and self.final_phase_btn:
                try:
                    self.final_phase_btn.config(state="disabled", bg="#CCCCCC")
                    print("DEBUG: [END_TURN_DIRECT] Botão End Turn direto desabilitado")
                except tk.TclError:
                    print("DEBUG: [END_TURN_DIRECT] WARNING: Botão já destruído")
            
            # Chamar o método principal end_turn() que faz tudo corretamente
            print("DEBUG: [END_TURN_DIRECT] Chamando self.end_turn()...")
            self.end_turn()
            print("DEBUG: [END_TURN_DIRECT] self.end_turn() executado com sucesso")
            
            # Resetar flags de fase para começar novo turno limpo
            self._next_phase_active = False
            self._final_phase_active = False
            self._final_phase_gestao_ativa = False
            self._challenge_accepted = False
            self._show_end_turn_button = False
            self._next_phase_manually_activated = False
            
            # RESETAR SELEÇÃO: Limpar seleção do carrossel para próximo turno
            self.selected_carousel_index = None
            self.selected_carousel_card = None
            self._carta_destacada_posicao = None
            print("DEBUG: [END_TURN_DIRECT] Flags e seleções resetadas")
            
            # Aguardar um frame para garantir que end_turn() terminou completamente
            self.after(50, self._continue_end_turn_transition)
            
        except Exception as e:
            print(f"DEBUG: [END_TURN_DIRECT] ERROR: Erro em _end_turn_direct_action: {e}")
            import traceback
            traceback.print_exc()
    
    def _gerenciar_botao_end_turn(self, command):
        """Função centralizada para gerenciar criação/atualização do botão End Turn"""
        try:
            # Verificar se botão já existe e está válido
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                try:
                    if self.end_turn_btn.winfo_exists():
                        # Botão existe e é válido, apenas atualizar comando
                        self.end_turn_btn.config(command=command)
                        print("DEBUG: Botão End Turn - comando atualizado")
                        return
                except tk.TclError:
                    # Widget foi destruído, precisamos recriar
                    print("DEBUG: Botão End Turn destruído, recriando...")
                    pass
            
            # Criar novo botão
            self.end_turn_btn = tk.Button(
                self,
                text="End Turn",
                font=("Helvetica", 14, "bold"),
                bg="#808080",
                fg="black",
                command=command,
                width=10,
                state="disabled"  # Sempre começar disabled
            )
            # Mesma posição do botão Final Phase
            self.end_turn_btn.place(relx=0.5, rely=0.98, anchor="s")
            self.end_turn_btn.lift()
            print("DEBUG: Botão End Turn criado com sucesso")
            
        except Exception as e:
            print(f"DEBUG: Erro ao gerenciar botão End Turn: {e}")

    def _criar_botao_end_turn(self):
        """Cria o botão End Turn"""
        def end_turn_action():
            print("DEBUG: [END_TURN_ACTION] === BOTÃO END TURN CLICADO ===")
            
            try:
                # PROTEÇÃO: Desabilitar botão imediatamente para evitar duplo clique
                if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                    try:
                        self.end_turn_btn.config(state="disabled", bg="#CCCCCC")
                        print("DEBUG: [END_TURN_ACTION] Botão End Turn desabilitado")
                    except tk.TclError:
                        print("DEBUG: [END_TURN_ACTION] WARNING: Botão já destruído")
                
                # CORREÇÃO CRÍTICA: Chamar o método principal end_turn() que faz tudo corretamente
                print("DEBUG: [END_TURN_ACTION] Chamando self.end_turn()...")
                self.end_turn()
                print("DEBUG: [END_TURN_ACTION] self.end_turn() executado com sucesso")
                
                # Resetar flags de fase para começar novo turno limpo
                self._next_phase_active = False
                self._final_phase_active = False
                self._final_phase_gestao_ativa = False
                self._challenge_accepted = False
                self._show_end_turn_button = False
                self._next_phase_manually_activated = False
                
                # RESETAR SELEÇÃO: Limpar seleção do carrossel para próximo turno
                self.selected_carousel_index = None
                self.selected_carousel_card = None
                self._carta_destacada_posicao = None
                print("DEBUG: [END_TURN_ACTION] Flags e seleções resetadas")
                
                # CORREÇÃO CRÍTICA: Verificar aplicação de forma mais robusta
                try:
                    # Aguardar um frame para garantir que end_turn() terminou completamente
                    self.after(50, self._continue_end_turn_transition)
                except Exception as e:
                    print(f"DEBUG: [END_TURN_ACTION] ERROR: Erro ao agendar transição: {e}")
                    
            except Exception as e:
                print(f"DEBUG: [END_TURN_ACTION] ERROR: Erro em end_turn_action: {e}")
                import traceback
                traceback.print_exc()

        # Usar o método centralizado para gerenciar o botão
        self._gerenciar_botao_end_turn(end_turn_action)
        print("DEBUG: [CRIAR_END_TURN] Botão End Turn criado com comando configurado")
        
    def _continue_end_turn_transition(self):
        """Continua a transição do End Turn após um delay"""
        print("DEBUG: [END_TURN_TRANSITION] === CONTINUANDO TRANSIÇÃO ===")
        try:
            # Verificar se aplicação ainda existe
            if not (hasattr(self, 'winfo_exists') and self.winfo_exists()):
                print("DEBUG: [END_TURN_TRANSITION] WARNING: Aplicação destruída - abortando transição")
                return
                
            # Obter dimensões da tela
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            
            print("DEBUG: [END_TURN_TRANSITION] Chamando show_dice_roll_screen...")
            self.show_dice_roll_screen(self.player_name, self.saldo, self.other_players, screen_width, screen_height)
            print("DEBUG: [END_TURN_TRANSITION] SUCCESS: Transição para dice roll screen completa")
            
        except tk.TclError as e:
            print(f"DEBUG: [END_TURN_TRANSITION] WARNING: TclError: {e}")
        except Exception as e:
            print(f"DEBUG: [END_TURN_TRANSITION] ERROR: Erro na transição: {e}")
            import traceback
            traceback.print_exc()



    def playerdashboard_interface(self, player_name, saldo, other_players, show_store_button=None):
        try:
            print(f"DEBUG: [INTERFACE] ===== playerdashboard_interface INÍCIO =====")
            print(f"DEBUG: [INTERFACE] player_name: {player_name}, saldo: {saldo}")
            print(f"DEBUG: [INTERFACE] show_store_button: {show_store_button}")
            print(f"DEBUG: [INTERFACE] self existe? {hasattr(self, 'player_name')}")
            
            # CORREÇÃO CRÍTICA: Restaurar contadores de turno se foram feitos backups
            # Isto resolve o problema dos contadores voltarem ao turno 1 após substituições
            self._restore_turn_counters_after_reconstruction()
            
            # VERIFICAÇÃO AUTOMÁTICA DE EVENTS EXPIRADOS
            # Verificar se há Events expirados e mostrar overlay automaticamente POR CIMA da interface
            print("DEBUG: [INTERFACE] === VERIFICAÇÃO AUTOMÁTICA DE EVENTS EXPIRADOS ===")
            events_expirados_encontrados = self._verificar_events_expirados_automaticamente()
            print("DEBUG: [INTERFACE] === FIM VERIFICAÇÃO AUTOMÁTICA ===")
            
            # VERIFICAÇÃO AUTOMÁTICA DE SERVICES EXPIRADOS
            # Verificar se há Services TEMPORARY expirados e mostrar overlay automaticamente POR CIMA da interface
            print("DEBUG: [INTERFACE] === VERIFICAÇÃO AUTOMÁTICA DE SERVICES EXPIRADOS ===")
            services_expirados_encontrados = self._verificar_services_expirados_automaticamente()
            print("DEBUG: [INTERFACE] === FIM VERIFICAÇÃO AUTOMÁTICA DE SERVICES ===")
            
            # NOVO: NÃO interromper criação da interface - overlay aparece por cima
            # Interface principal continua a ser criada normalmente
            if events_expirados_encontrados:
                print("DEBUG: [INTERFACE] === EVENTS EXPIRADOS ENCONTRADOS - OVERLAY SERÁ MOSTRADO POR CIMA ===")
                # Usar after() para mostrar overlay após a interface estar criada
                self.after(500, self._mostrar_overlay_events_expirados_apos_interface)
            
            if services_expirados_encontrados:
                print("DEBUG: [INTERFACE] === SERVICES EXPIRADOS ENCONTRADOS - OVERLAY SERÁ MOSTRADO POR CIMA ===")
                # Usar after() para mostrar overlay após a interface estar criada
                # Delay maior para que apareça após os events (se houver)
                delay = 800 if events_expirados_encontrados else 500
                self.after(delay, self._mostrar_overlay_services_expirados_apos_interface)
            
            # NOVA FUNCIONALIDADE: Limpar tracking órfão sempre ao entrar na interface principal
            # Isto garante que Challenges completados/expirados não permanecem no tracking
            print("DEBUG: [INTERFACE] === LIMPEZA ÓRFÃ NA INTERFACE ===")
            self._cleanup_orphaned_challenge_tracking()
            print("DEBUG: [INTERFACE] === FIM LIMPEZA ÓRFÃ ===")
            
            # PROTEÇÃO CONTRA LOOP: Limpar flag quando entra na interface principal
            self._inventory_opening = False
            print(f"DEBUG: [INTERFACE] Flag inventory_opening limpa")
            
            # LIMPEZA: Limpar flags de contexto especial quando volta ao dashboard
            if hasattr(self, '_in_remove_router_context'):
                self._in_remove_router_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_remove_router_context limpa")
            
            if hasattr(self, '_in_router_upgrade_context'):
                self._in_router_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_upgrade_context limpa")
            
            if hasattr(self, '_in_link_upgrade_context'):
                self._in_link_upgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_upgrade_context limpa")
            
            if hasattr(self, '_in_link_downgrade_context'):
                self._in_link_downgrade_context = False
                print(f"DEBUG: [INTERFACE] Flag _in_link_downgrade_context limpa")
            
            if hasattr(self, '_in_router_selection_page'):
                self._in_router_selection_page = False
                print(f"DEBUG: [INTERFACE] Flag _in_router_selection_page limpa")
            
            # DETECÇÃO AUTOMÁTICA DE FASE: Verificar se o jogador deve estar numa fase avançada
            # com base no estado do jogo (cartas selecionadas, User IDs no inventário, etc.)
            # IMPORTANTE: Apenas aplicar quando NÃO está a vir da página de lançamento de dado
            
            # CORREÇÃO CRÍTICA: _turn_number deve ser sempre sincronizado com _current_turn_number
            # Remover lógica de incremento independente que causava dessincronização
            self._turn_number = getattr(self, '_current_turn_number', 1)
            print(f"DEBUG: [INTERFACE] Turn number sincronizado com _current_turn_number: {self._turn_number}")
            
            # FLUXO CORRETO: Sempre começar com página de dado, independentemente do turno
            # A detecção de fase só deve acontecer quando vem diretamente de uma Store/inventário
            coming_from_dice_page = getattr(self, '_coming_from_dice', False)
            print(f"DEBUG: [INTERFACE] Coming from dice page: {coming_from_dice_page}")
            
            if coming_from_dice_page:
                # Reset da flag para evitar loops
                self._coming_from_dice = False
                print(f"DEBUG: [INTERFACE] Vindo da página de dado - turno correto: {self._turn_number}")
            else:
                # CORREÇÃO: NÃO incrementar _turn_number aqui - apenas sincronizar
                # O incremento real acontece no end_turn() via _increment_turn_counter()
                print(f"DEBUG: [INTERFACE] Navegação entre páginas - turno atual: {self._turn_number}")
            
            print(f"DEBUG: [INTERFACE] Preparando para limpar widgets...")
            
        except Exception as e:
            print(f"DEBUG: [INTERFACE] ERRO CRÍTICO no início da playerdashboard_interface: {e}")
            import traceback
            print(f"DEBUG: [INTERFACE] Traceback: {traceback.format_exc()}")
            return
            # NOTA: Restauração automática de fase DESATIVADA para permitir controlo manual
            # O jogador deve clicar explicitamente nos botões Next Phase e Final Phase
            print(f"DEBUG: [FASE] Restauração automática desativada - flags controladas manualmente")
        
        # CORREÇÃO: Distinguir entre NOVO TURNO e navegação dentro do mesmo turno
        # IMPORTANTE: Só limpar estado Challenge em NOVOS TURNOS para evitar persistência entre turnos
        # Para navegação dentro do turno (via botão Player), preservar estado Challenge
        challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                        hasattr(self, '_store_challenge_carta_tipo') and
                                        self._store_challenge_carta_tipo == "challenges")
        
        # DETECÇÃO DE NOVO TURNO: Verificar se está a vir da página de lançamento de dado
        coming_from_dice_page = getattr(self, '_coming_from_dice', False)
        
        print(f"DEBUG: [INTERFACE] === ANÁLISE DE ESTADO CHALLENGE ===")
        print(f"DEBUG: [INTERFACE] coming_from_dice_page: {coming_from_dice_page}")
        print(f"DEBUG: [INTERFACE] challenge_pendente_transferido: {challenge_pendente_transferido}")
        if challenge_pendente_transferido:
            print(f"DEBUG: [INTERFACE] Challenge path: {getattr(self, '_store_challenge_carta_path', 'None')}")
        
        if coming_from_dice_page:
            # NOVO TURNO: Sempre limpar estado Challenge antigo para evitar persistência entre turnos
            # Isto resolve o problema relatado onde Challenge do turno 1 aparecia no turno 2
            print("DEBUG: [INTERFACE] NOVO TURNO detectado - limpeza automática de estado Challenge antigo")
            self.limpar_estado_challenge_pendente(force_clean=True)
            print("DEBUG: [INTERFACE] Estado Challenge antigo limpo FORÇADAMENTE - início de novo turno")
        elif challenge_pendente_transferido:
            # NAVEGAÇÃO NO MESMO TURNO: Verificar se estamos ainda numa casa Challenge
            casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
            if casa_atual_tipo == "challenges":
                # Preservar estado Challenge transferido via botão Player apenas se ainda estivermos numa casa Challenge
                print(f"DEBUG: [INTERFACE] NAVEGAÇÃO NO TURNO EM CASA CHALLENGE - preservando Challenge transferido: {self._store_challenge_carta_path}")
                print("DEBUG: [INTERFACE] Estado Challenge preservado para permitir voltar à Store")
            else:
                # Se não estivermos numa casa Challenge, limpar o estado
                print(f"DEBUG: [INTERFACE] NAVEGAÇÃO NO TURNO FORA DE CASA CHALLENGE (casa atual: {casa_atual_tipo}) - limpando Challenge transferido")
                self.limpar_estado_challenge_pendente(force_clean=True)
                print("DEBUG: [INTERFACE] Estado Challenge limpo pois não estamos numa casa Challenge")
        else:
            # SEM CHALLENGE PENDENTE: Limpeza normal (equivalente ao comportamento anterior)
            print("DEBUG: [INTERFACE] Sem Challenge pendente - limpeza normal")
            self.limpar_estado_challenge_pendente()
            print("DEBUG: [INTERFACE] Estado Challenge limpo via função auxiliar - limpeza normal")
        
        print(f"DEBUG: [INTERFACE] === FIM ANÁLISE DE ESTADO CHALLENGE ===")
        
        # TESTE: Adicionar User cards para testar o sistema de controlo do carrossel
        # Esta linha pode ser removida em produção
        self._teste_adicionar_user_cards()
        
        # LIMPEZA: Remover cartas Actions/Events que foram incorretamente adicionadas ao inventário
        # (cartas destinadas a outros jogadores que não deveriam ficar no inventário do remetente)
        print("DEBUG: [INTERFACE] Iniciando limpeza de cartas Actions/Events incorretas...")
        self._limpar_cartas_actions_events_incorretas()
        print("DEBUG: [INTERFACE] Limpeza de cartas Actions/Events concluída")
        
        # CORREÇÃO CRÍTICA: Se há Challenge pendente transferido, SEMPRE mostrar botão Store
        # Isto tem prioridade sobre qualquer parâmetro show_store_button
        if challenge_pendente_transferido and hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path:
            show_store_button = True
            print("DEBUG: Challenge pendente detectado - forçando botão Store para permitir voltar")
            # NÃO atualizar _store_button_disabled quando há Challenge pendente
        elif show_store_button is None:
            # Se show_store_button não for especificado, usar o estado atual
            show_store_button = not self._store_button_disabled
        else:
            # Atualizar o estado baseado no parâmetro fornecido APENAS se não há Challenge pendente
            self._store_button_disabled = not show_store_button
            
        self.atualizar_carrossel()
        # Limpar todos os widgets existentes (exceto a barra superior se existir)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue  # Manter a barra superior
            widget.destroy()
        
        # Barra superior com imagem
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.overrideredirect(True)  # Remove barra de título
        self.attributes("-fullscreen", True)  # Garante fullscreen (opcional)
        
        # Criar TopBar se não existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [playerdashboard_interface] Tentando carregar TopBar de: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [playerdashboard_interface] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [playerdashboard_interface] Arquivo TopBar não encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [playerdashboard_interface] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [playerdashboard_interface] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [playerdashboard_interface] TopBar fallback criada após erro!")
        
        # Ícones dos outros jogadores (esquerda)
        for idx, p in enumerate(other_players):
            if idx < len(USER_ICONS):
                icon_img = ImageTk.PhotoImage(Image.open(USER_ICONS[idx]).resize((30,30)))
                lbl = tk.Label(self, image=icon_img, bg=self.bar_color)
                lbl.image = icon_img  # type: ignore[attr-defined]
                lbl.place(x=5+idx*40, y=20)

        # Nome do jogador (centro)
        name_lbl = tk.Label(self, text=player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")

        # Botão da Store no canto superior direito para ir à Store (apenas se show_store_button for True)
        self._store_btn_widget = None
        # CORREÇÃO: Não esconder botão Store apenas porque Next Phase foi detectado automaticamente
        # Só esconder se Next Phase foi ativado explicitamente pelo jogador
        next_phase_manually_activated = getattr(self, '_next_phase_manually_activated', False)
        
        # CORREÇÃO CRÍTICA: Se há Challenge pendente, SEMPRE mostrar botão Store
        # Isto tem prioridade sobre qualquer estado de Next Phase
        has_challenge_pendente = (challenge_pendente_transferido and 
                                hasattr(self, '_store_challenge_carta_path') and 
                                self._store_challenge_carta_path)
        
        if show_store_button and (not next_phase_manually_activated or has_challenge_pendente):
            # Debug da decisão
            if has_challenge_pendente:
                print("DEBUG: Botão Store criado devido a Challenge pendente (prioridade sobre Next Phase)")
            elif not next_phase_manually_activated:
                print("DEBUG: Botão Store criado - condições normais atendidas")
            
            def abrir_store():
                """Abre a Store seguindo o mesmo padrão do botão Player"""
                print("DEBUG: Botão Store pressionado - abrindo Store")
                print(f"DEBUG: [abrir_store] Verificando se Store existe...")
                print(f"DEBUG: [abrir_store] hasattr store_window: {hasattr(self, 'store_window')}")
                if hasattr(self, 'store_window'):
                    print(f"DEBUG: [abrir_store] store_window não é None: {self.store_window is not None}")
                    if self.store_window:
                        print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                        print(f"DEBUG: [abrir_store] tem fullscreen_carta_path: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                        if hasattr(self.store_window, 'fullscreen_carta_path'):
                            print(f"DEBUG: [abrir_store] fullscreen_carta_path valor: {getattr(self.store_window, 'fullscreen_carta_path', 'NOT_SET')}")
                
                try:
                    # CORREÇÃO IMPORTANTE: Só restaurar carta Challenge se estivermos numa casa Challenge
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo):
                        print(f"DEBUG: [abrir_store] Carta Challenge encontrada no PlayerDashboard: {self._store_challenge_carta_path}")
                        print(f"DEBUG: [abrir_store] Casa atual: tipo={casa_tipo}, cor={casa_cor}")
                        
                        # SÓ restaurar Challenge se estivermos numa casa Challenge
                        if casa_tipo == "challenges":
                            print("DEBUG: [abrir_store] Estamos numa casa Challenge - restaurando carta Challenge")
                            
                            # Verificar se Store existe e pode ser restaurada
                            if (hasattr(self, 'store_window') and self.store_window and 
                                hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                                print("DEBUG: [abrir_store] Store existente encontrada - transferindo estado Challenge")
                                # Transferir estado de volta para a Store
                                self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                                self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                                self.store_window._original_carta_path = self._store_challenge_carta_path
                                self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                                
                                # Restaurar Store com carta Challenge
                                self.store_window.voltar_para_store()
                                self.withdraw()
                                
                                # Limpar estado do PlayerDashboard
                                self._store_challenge_carta_path = None
                                self._store_challenge_carta_tipo = None
                                print("DEBUG: [abrir_store] Store restaurada com carta Challenge")
                                return
                            else:
                                print("DEBUG: [abrir_store] Store não existe - criando nova com estado Challenge")
                                # Store não existe, criar nova com estado Challenge já definido
                                # (continua para criação abaixo)
                        else:
                            print(f"DEBUG: [abrir_store] NÃO estamos numa casa Challenge (estamos em {casa_tipo}) - LIMPANDO estado Challenge")
                            # Limpar estado Challenge pois não estamos numa casa Challenge
                            self._store_challenge_carta_path = None
                            self._store_challenge_carta_tipo = None
                            print("DEBUG: [abrir_store] Estado Challenge limpo - continuando criação normal da Store")
                    
                    # Verificar se já existe uma Store com estado de fullscreen guardado
                    elif (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists() and
                        hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print(f"DEBUG: Store existente encontrada com estado fullscreen - restaurando carta: {self.store_window.fullscreen_carta_path}")
                        print(f"DEBUG: [abrir_store] ID da Store existente: {id(self.store_window)}")
                        if hasattr(self.store_window, '_store_id'):
                            print(f"DEBUG: [abrir_store] Store ID único: {self.store_window._store_id}")
                        print(f"DEBUG: [abrir_store] Chamando voltar_para_store() na Store existente...")
                        # Restaurar Store existente com estado de fullscreen
                        self.store_window.voltar_para_store()
                        # Esconder PlayerDashboard enquanto Store está aberta
                        self.withdraw()
                        print("DEBUG: Store existente restaurada com sucesso")
                        return
                    else:
                        # Debug das condições que falharam
                        print("DEBUG: [abrir_store] Condições de Store existente com fullscreen:")
                        print(f"DEBUG: [abrir_store] hasattr(self, 'store_window'): {hasattr(self, 'store_window')}")
                        if hasattr(self, 'store_window'):
                            print(f"DEBUG: [abrir_store] self.store_window is not None: {self.store_window is not None}")
                            if self.store_window:
                                print(f"DEBUG: [abrir_store] store_window.winfo_exists(): {hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()}")
                                print(f"DEBUG: [abrir_store] tem fullscreen_carta_path attr: {hasattr(self.store_window, 'fullscreen_carta_path')}")
                                if hasattr(self.store_window, 'fullscreen_carta_path'):
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path value: {self.store_window.fullscreen_carta_path}")
                                    print(f"DEBUG: [abrir_store] fullscreen_carta_path is truthy: {bool(self.store_window.fullscreen_carta_path)}")
                        print("DEBUG: [abrir_store] Store existente NÃO tem estado fullscreen válido - criando nova")
                    
                    # Verificar se existe Store sem estado fullscreen
                    if (hasattr(self, 'store_window') and self.store_window and 
                        hasattr(self.store_window, 'winfo_exists') and self.store_window.winfo_exists()):
                        print("DEBUG: [abrir_store] Store existe mas sem estado fullscreen - reutilizando")
                        self.store_window.voltar_para_store()
                        self.withdraw()
                        return
                    
                    # Importar Store aqui para evitar imports circulares
                    from Store import StoreWindow
                    # Usar as mesmas informações da casa atual (se disponível)
                    casa_tipo = getattr(self, 'current_casa_tipo', 'neutral')
                    casa_cor = getattr(self, 'current_casa_cor', 'neutral')
                    current_other_player_house = getattr(self, 'current_other_player_house', False)
                    
                    print(f"DEBUG: Criando nova Store - casa_tipo: {casa_tipo}, casa_cor: {casa_cor}, other_player_house: {current_other_player_house}")
                    
                    # IMPORTANTE: Reativar botão Store se não estiver numa casa Actions/Events/Challenges neutra
                    if not (casa_tipo in ["actions", "events", "challenges"] and casa_cor == "neutral"):
                        self.enable_store_button()
                        print("DEBUG: Botão Store reativado - não está numa casa Actions/Events/Challenges neutra")
                    
                    # Criar nova janela da Store
                    self.store_window = StoreWindow(
                        self.master,
                        self.player_color,
                        self.player_name,
                        self.saldo,
                        casa_tipo=casa_tipo,
                        casa_cor=casa_cor,
                        inventario=self.inventario,
                        dashboard=self,
                        other_player_house=current_other_player_house
                    )
                    print(f"DEBUG: Nova Store criada via botão Store com ID: {id(self.store_window)}")
                    if hasattr(self.store_window, '_store_id'):
                        print(f"DEBUG: Store ID único (botão Store): {self.store_window._store_id}")
                    
                    # CORREÇÃO: Só transferir carta Challenge se estivermos numa casa Challenge
                    if (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                        hasattr(self, '_store_challenge_carta_tipo') and self._store_challenge_carta_tipo and
                        casa_tipo == "challenges"):
                        print(f"DEBUG: Transferindo estado Challenge para nova Store (casa Challenge): {self._store_challenge_carta_path}")
                        self.store_window.fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window.fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._backup_fullscreen_carta_path = self._store_challenge_carta_path
                        self.store_window._backup_fullscreen_carta_tipo = self._store_challenge_carta_tipo
                        self.store_window._original_carta_path = self._store_challenge_carta_path
                        self.store_window._original_carta_tipo = self._store_challenge_carta_tipo
                        
                        # Limpar estado do PlayerDashboard
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                        print("DEBUG: Estado Challenge transferido para nova Store")
                    elif (hasattr(self, '_store_challenge_carta_path') and self._store_challenge_carta_path and
                          casa_tipo != "challenges"):
                        print(f"DEBUG: Limpando estado Challenge pois não estamos numa casa Challenge (estamos em {casa_tipo})")
                        self._store_challenge_carta_path = None
                        self._store_challenge_carta_tipo = None
                    
                    # Esconder PlayerDashboard enquanto Store está aberta
                    self.withdraw()
                    
                    # Se há estado Challenge, restaurar carta imediatamente
                    if (hasattr(self.store_window, 'fullscreen_carta_path') and self.store_window.fullscreen_carta_path):
                        print("DEBUG: Restaurando carta Challenge na nova Store")
                        self.store_window.voltar_para_store()  # Vai ativar restaurar_carta_fullscreen_pendente()
                    
                    print("DEBUG: Nova Store criada com sucesso")
                except Exception as e:
                    print(f"DEBUG: Erro ao abrir Store: {e}")
                    import traceback
                    traceback.print_exc()

            try:
                # Carregar ícone da Store
                store_icon_path = os.path.join(IMG_DIR, "Store_button_icon.png")
                store_icon_img = ImageTk.PhotoImage(Image.open(store_icon_path).resize((30, 30)))
                self.btn_store = tk.Button(self, image=store_icon_img, bg=self.bar_color, relief="flat", borderwidth=0, 
                                     command=abrir_store, cursor="hand2", activebackground=self.bar_color,
                                     highlightthickness=0)
                self.btn_store.image = store_icon_img  # Manter referência para evitar garbage collection
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")  # Mesma posição do botão Player na Store
                print("DEBUG: Botão Store criado com ícone Store_button_icon.png")
            except Exception as e:
                print(f"DEBUG: Erro ao carregar Store_button_icon.png: {e}")
                # Fallback para botão de texto se não conseguir carregar a imagem
                self.btn_store = tk.Button(self, text="STORE", font=("Helvetica", 20), bg=self.bar_color, fg="black", 
                                     relief="flat", borderwidth=0, command=abrir_store, cursor="hand2",
                                     activebackground=self.bar_color, activeforeground="black", highlightthickness=0)
                self.btn_store.place(x=screen_width-15, y=20, anchor="ne")
                print("DEBUG: Botão Store criado com ícone de fallback")
        else:
            # Debug melhorado para explicar porque não foi criado
            if not show_store_button:
                print(f"DEBUG: Botão Store NÃO criado - show_store_button=False")
            elif next_phase_manually_activated and not has_challenge_pendente:
                print(f"DEBUG: Botão Store NÃO criado - Next Phase ativo e sem Challenge pendente")
            else:
                print(f"DEBUG: Botão Store NÃO criado - razão desconhecida (show_store_button={show_store_button}, next_phase_manually_activated={next_phase_manually_activated}, has_challenge_pendente={has_challenge_pendente})")
            self.btn_store = None  # Inicializar como None quando não é criado

        # --- NOVO LAYOUT ---

        # Espaço extra antes dos botões
        self.after(0, lambda: self.update())  # Garante update do layout antes de calcular altura
        tk.Frame(self, height=5, bg="black").pack()  # reduzido para menos espaço

        # 1. Botões grandes (layout igual ao carrossel)
        btns_frame = tk.Frame(self, bg="black")
        btns_frame.pack(pady=(12, 18))  # Reduz espaço acima, mantém abaixo
        card_width, card_height = 85, 120  # Igual ao carrossel

        btn_info = [
            ("Users", self.bar_color, "users"),
            ("Equip.", self.bar_color, "equipments"),
            ("Services", self.bar_color, "services"),
            ("Actions/\nEvents", self.bar_color, "actions_events")
        ]

        self.action_buttons = []
        for text, color, inv_key in btn_info:
            btn_font = ("Helvetica", 13, "bold")
            if text.startswith("Services"):
                btn_font = ("Helvetica", 12, "bold")  # Fonte menor só para "Services"
            btn = tk.Button(
                btns_frame, text=text, font=btn_font,
                wraplength=70,
                bg=color, fg="black", activebackground="white", activeforeground="black",
                bd=0, highlightthickness=0
            )
            btn.pack(side=tk.LEFT, padx=2, ipady=22, expand=True, fill="both")
            self.action_buttons.append(btn)
            # Associar inventário correto - CORREÇÃO: usar default parameter para evitar closure problem
            if inv_key == "actions_events":
                print(f"DEBUG: Configurando botão '{text}' para Actions/Events")
                def actions_events_handler():
                    print(f"DEBUG: *** BOTÃO ACTIONS/EVENTS CLICADO ***")
                    # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DE PROCESSAR
                    self._capturar_estado_botoes_imediato()
                    
                    # NOVO: Verificar se há TODOS os events expirados primeiro
                    events_expirados = self._encontrar_todos_events_expirados()
                    if events_expirados:
                        print(f"DEBUG: [ACTIONS_EVENTS_BUTTON] {len(events_expirados)} events expirados encontrados - iniciando overlays sequenciais")
                        self._mostrar_overlays_events_expirados_sequencial(events_expirados, 0)
                    else:
                        print(f"DEBUG: [ACTIONS_EVENTS_BUTTON] Nenhum event expirado, abrindo inventário normal")
                        self.show_inventory_matrix(["actions", "events"])
                btn.config(command=actions_events_handler)
            else:
                print(f"DEBUG: Configurando botão '{text}' para tipo '{inv_key}'")
                if inv_key == "services":
                    # Handler especial para Services - verifica se há serviços expirados primeiro
                    def services_handler():
                        print(f"DEBUG: *** BOTÃO SERVICES CLICADO ***")
                        # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DE PROCESSAR
                        self._capturar_estado_botoes_imediato()
                        
                        # NOVO: Verificar se há TODOS os serviços expirados primeiro
                        services_expirados = self._encontrar_todos_services_expirados()
                        if services_expirados:
                            print(f"DEBUG: [SERVICE_BUTTON] {len(services_expirados)} serviços expirados encontrados - iniciando overlays sequenciais")
                            self._mostrar_overlays_services_expirados_sequencial(services_expirados, 0)
                        else:
                            print(f"DEBUG: [SERVICE_BUTTON] Nenhum serviço expirado, abrindo inventário normal")
                            self.show_inventory_matrix(["services"])
                    btn.config(command=services_handler)
                else:
                    def handler(tipo_carta=inv_key):
                        print(f"DEBUG: *** BOTÃO {tipo_carta.upper()} CLICADO ***")
                        # CAPTURAR ESTADO DOS BOTÕES IMEDIATAMENTE ANTES DE IR PARA INVENTÁRIO
                        self._capturar_estado_botoes_imediato()
                        self.show_inventory_matrix([tipo_carta])
                    btn.config(command=handler)

        # 2. Carrossel de cartas (agora abaixo dos botões)
        carousel_frame = tk.Frame(self, bg="black")
        carousel_frame.pack(pady=2)
        cards_container = tk.Frame(carousel_frame, bg="black")
        cards_container.pack()

        card_width, card_height = 85, 120  # Certifique-se que está definido antes

        self.card_labels = []
        for i, carta_path in enumerate(self.cards):
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_width, card_height)))
            
            # Durante Next Phase, verificar se esta posição pode ser selecionada
            can_select = True
            highlight_color = "black"  # Cor padrão do fundo
            border_width = 0
            border_color = "black"
            
            if getattr(self, '_next_phase_active', False) and os.path.basename(carta_path).startswith("back_card_"):
                # Durante Next Phase, verificar se tem User ID para esta posição
                can_select = self._can_access_carousel_position(i)
                if can_select:
                    highlight_color = "#8A2BE2"  # Roxo para cartas que podem ser selecionadas
                    border_width = 3
                    border_color = "#9370DB"  # Roxo mais claro para a borda
                    print(f"DEBUG: Carta {i} destacada em roxo - pode ser selecionada")
                else:
                    print(f"DEBUG: Carta {i} sem destaque - não pode ser selecionada")
            
            # Determinar cursor: sempre hand2 para cartas viradas para baixo
            if os.path.basename(carta_path).startswith("back_card_"):
                cursor = "hand2"  # Sempre clicável para cartas viradas para baixo
            else:
                cursor = "hand2" if can_select else "arrow"
            
            lbl = tk.Label(cards_container, image=img, bg=highlight_color, cursor=cursor,
                          borderwidth=border_width, relief="solid", highlightbackground=border_color, highlightcolor=border_color, highlightthickness=border_width)
            lbl.image = img  # type: ignore[attr-defined]
            lbl.grid(row=0, column=i, padx=2, pady=0)
            
            # Se for carta virada para baixo, abre inventário de Activities/Challenges
            # CORREÇÃO: Sempre permitir clique em cartas viradas para baixo, independentemente de can_select
            if os.path.basename(carta_path).startswith("back_card_"):
                lbl.bind("<Button-1>", lambda e, idx=i: self.abrir_inventario_para_carrossel(idx))
            else:
                # Para Activities/Challenges: SEMPRE criar binding para permitir cliques
                # A lógica de controlo será feita dentro de _select_carousel_card
                lbl.bind("<Button-1>", lambda e, idx=i, path=carta_path: self._select_carousel_card(idx, path))
            # lbl.selected = True  # Removido para linter
            # lbl.selected = False  # Removido para linter
            self.card_labels.append(lbl)
            
                # Frame para as barras de progresso
        self.progress_frame = tk.Frame(self, bg="black")
        self.progress_frame.pack(pady=(10, 0))

        self.progress_bars = {}
        self.progress_labels = {}

        stats = ["To send", "Rxd", "Lost"]
        for i, stat in enumerate(stats):
            row = tk.Frame(self.progress_frame, bg="black")
            row.pack(fill="x", pady=2)
            # Label do nome da stat à esquerda
            stat_lbl = tk.Label(row, text=stat, font=("Helvetica", 12, "bold"), bg="black", fg="white", width=8, anchor="w")
            stat_lbl.pack(side="left")
            # CORREÇÃO: Todas as barras usam o mesmo máximo inicial (será ajustado dinamicamente para message_size)
            # Isso garante precisão visual - barras com mesmo valor ficam alinhadas
            bar = ttk.Progressbar(row, orient="horizontal", length=240, mode="determinate", maximum=10)  # Valor inicial, será ajustado para message_size
            bar.pack(side="left", fill="x", expand=True, padx=(4, 4))
            self.progress_bars[stat] = bar
            # Label do valor à direita da barra
            value_lbl = tk.Label(row, text="0", font=("Helvetica", 12, "bold"), bg="black", fg="white", width=2, anchor="e")
            value_lbl.pack(side="left", padx=(4, 0))
            self.progress_labels[stat] = value_lbl

        #Outra alternativa para mostrar os valores abaixo das cartas
        """ # --- Tabela de valores por baixo das cartas ---
        stats_frame = tk.Frame(self, bg="black")
        stats_frame.pack(pady=(4, 0))

        self.stats_value_labels = []  # <-- Adiciona esta linha ANTES do ciclo

        stats_labels = [("To send", "To\nsend"), ("Rxd", "Rxd"), ("Lost", "Lost")]

        for row, (stat_key, stat_label) in enumerate(stats_labels):
            legend = tk.Label(
                stats_frame,
                text=stat_label,
                font=("Helvetica", 12, "bold"),
                bg="black",
                fg="white",
                width=8,
                height=2 if "\n" in stat_label else 1,
                anchor="w"  # <-- Alinha o texto à esquerda dentro do label
            )
            # Espaçamento extra APÓS "To send"
            if stat_key == "To send":
                pady_val = (0, 6)
            elif stat_key == "Rxd":
                pady_val = (0, 6)
            else:
                pady_val = (0, 0)
            legend.grid(row=row, column=0, padx=(0,0), pady=pady_val, sticky="w")  # <-- Alinha o label à esquerda na célula
            row_labels = []
            for col in range(4):
                value = self.card_stats[col][stat_key]
                # Ajusta o deslocamento horizontal de cada coluna:
                if col == 0:
                    col_padx = (0, 4)   # Mais espaço à direita da primeira coluna
                elif col == 3:
                    col_padx = (6, 2)   # Mais espaço à esquerda da última coluna
                else:
                    col_padx = (4, 4)   # Espaço igual entre colunas intermédias

                val_lbl = tk.Label(
                    stats_frame,
                    text=str(value),
                    font=("Helvetica", 12),
                    bg="black",
                    fg="white",
                    width=card_width//10,
                    anchor="w"
                )
                val_lbl.grid(row=row, column=col+1, padx=col_padx, pady=pady_val, sticky="w")
                row_labels.append(val_lbl)
            self.stats_value_labels.append(row_labels)

        # Ajuste o grid para expandir igualmente
        for col in range(1, 5):
            stats_frame.grid_columnconfigure(col, weight=1)
            cards_container.grid_columnconfigure(col-1, weight=1) """

        # NOTA: Botão End Turn agora é criado dinamicamente apenas quando necessário
        # Não criar botão End Turn aqui para evitar conflitos com o sistema de gestão de pacotes

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Saldo no canto inferior direito (sobre a BelowBar) - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, saldo))

        # Botão Next Phase OU Final Phase (cinza) na parte inferior central - criado no final para ficar visível
        # Verificar qual botão mostrar baseado no estado atual
        if getattr(self, '_next_phase_active', False) and not getattr(self, '_final_phase_active', False):
            # Next Phase já foi ativado mas Final Phase ainda não, mostrar botão Final Phase
            self._criar_botao_final_phase()
        elif getattr(self, '_final_phase_active', False) and getattr(self, '_show_end_turn_button', False):
            # Final Phase já foi ativado E o botão Final Phase já foi clicado, mostrar botão End Turn
            print("DEBUG: Final Phase ativo e botão Final Phase foi clicado - mostrando botão End Turn")
            
            # CORREÇÃO CRÍTICA: Usar o método _criar_botao_end_turn() que chama self.end_turn() corretamente
            # Este método já faz tudo: incrementa contadores, preserva estado, reseta flags
            self._criar_botao_end_turn()
            
            # CORREÇÃO CRÍTICA: Usar o método _criar_botao_end_turn() que chama self.end_turn() corretamente
            # NÃO redefinir end_turn_action aqui - usar a implementação correta
            self._criar_botao_end_turn()
        else:
            # Next Phase ainda não foi ativado, verificar se deve mostrar botão Next Phase
            # LÓGICA CORRETA:
            # - Se Challenge pendente (navegação Player) → NÃO mostrar Next Phase, mostrar Store
            # - Se Challenge aceite (decisão Accept/Reject) → mostrar Next Phase, NÃO mostrar Store  
            # - Se navegação normal → mostrar Next Phase
            
            challenge_foi_aceite = getattr(self, '_challenge_accepted', False)
            store_button_disabled = getattr(self, '_store_button_disabled', False)
            challenge_pendente_transferido = (hasattr(self, '_store_challenge_carta_path') and 
                                            hasattr(self, '_store_challenge_carta_tipo') and
                                            self._store_challenge_carta_tipo == "challenges")
            
            print(f"DEBUG: [INTERFACE] Verificação para mostrar Next Phase:")
            print(f"DEBUG: [INTERFACE]   _challenge_accepted: {challenge_foi_aceite}")
            print(f"DEBUG: [INTERFACE]   _store_button_disabled: {store_button_disabled}")
            print(f"DEBUG: [INTERFACE]   challenge_pendente_transferido: {challenge_pendente_transferido}")
            
            # LÓGICA CORRIGIDA: 
            # - Se Challenge pendente (Player button) → NÃO mostrar Next Phase
            # - Se Challenge aceite (Accept/Reject) → mostrar Next Phase
            # - Caso contrário → mostrar Next Phase
            if challenge_pendente_transferido:
                print("DEBUG: Challenge pendente via navegação (Player button) - Next Phase NÃO mostrado")
            elif challenge_foi_aceite or store_button_disabled:
                print("DEBUG: Challenge aceite via decisão (Accept/Reject) - Next Phase mostrado")
                # Mostrar Next Phase quando Challenge foi aceite
                self._criar_botao_next_phase()
            else:
                print("DEBUG: Navegação normal - Next Phase mostrado")
                # Mostrar Next Phase em navegação normal
                self._criar_botao_next_phase()

        # NOTA: As listas de cartas ativas (active_challenge, active_users, etc.) 
        # já estão inicializadas no __init__ do PlayerDashboard
        
        # IMPORTANTE: Atualizar destaques do carrossel no final da criação da interface
        # Isso garante que os destaques roxos apareçam corretamente quando Next Phase está ativo
        # CORREÇÃO: Usar delay para garantir que widgets estão completamente criados
        def atualizar_destaques_com_delay():
            if hasattr(self, 'card_labels') and self.card_labels:
                # Verificar se todos os widgets estão válidos antes de atualizar
                widgets_validos = True
                for i, lbl in enumerate(self.card_labels):
                    try:
                        if not lbl.winfo_exists():
                            widgets_validos = False
                            break
                    except tk.TclError:
                        widgets_validos = False
                        break
                
                if widgets_validos:
                    self._update_carousel_highlights()
                    print("DEBUG: Destaques do carrossel atualizados no final da criação da interface")
                else:
                    print("DEBUG: WARNING: Widgets ainda não estão prontos - pulando atualização de destaques")
            else:
                print("DEBUG: WARNING: card_labels não existe - pulando atualização de destaques")
        
        # Usar delay pequeno para garantir que widgets estão estabilizados
        self.after(150, atualizar_destaques_com_delay)
        
        # CORREÇÃO: Restaurar barras de progresso se há carta selecionada
        # Isso resolve o problema das barras ficarem zeradas ao voltar de páginas de inventário
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            carta_atual = self.cards[self.selected_carousel_index] 
            carta_index = self.selected_carousel_index
            
            print(f"DEBUG: Restaurando barras para carta REAL do carrossel: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar diferença se existe
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: WARNING: CORREÇÃO APLICADA:")
                    print(f"DEBUG:   Carta preservada (ERRADA): {carta_preservada}")
                    print(f"DEBUG:   Carta real (CORRETA): {carta_real}")
            
            # CORREÇÃO: Usar índice correto e verificar valores preservados
            if carta_index < len(self.card_stats):
                preserved_stats = self.card_stats[carta_index]
                print(f"DEBUG: Stats disponíveis para carta {carta_index}: {preserved_stats}")
                
                # CORREÇÃO CRÍTICA: Sempre aplicar valores preservados se existirem
                # Em gestão de pacotes, os valores preservados são sempre válidos
                gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
                if gestao_ativa or any(val > 0 for val in preserved_stats.values()):
                    print(f"DEBUG: Aplicando valores preservados para carta {carta_index} (gestão_ativa={gestao_ativa})")
                    self._apply_preserved_stats_to_progress_bars(preserved_stats, carta_atual)
                    
                    # FORÇA refresh visual adicional para garantir que valores aparecem
                    self.after(50, self._force_visual_refresh)
                else:
                    print(f"DEBUG: Valores preservados estão todos a zero - usando base de dados")
                    self._update_progress_bars_from_card(carta_atual)
            else:
                print(f"DEBUG: Índice {carta_index} fora do range de card_stats")
                self._update_progress_bars_from_card(carta_atual)
        else:
            print("DEBUG: Nenhuma carta selecionada no carrossel - barras ficam com valores padrão")
    
    def create_coin_saldo_overlay(self, screen_width, screen_height, saldo):
        """Cria o overlay do coin e saldo por cima de todos os outros elementos"""
        try:
            coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color, borderwidth=0)
            coin_lbl.image = coin_img  # type: ignore[attr-defined]
            coin_lbl.place(x=screen_width-100, y=screen_height-45)
            coin_lbl.lift()  # Garante que fica por cima
            
            saldo_lbl = tk.Label(self, text=f"{saldo}", font=("Helvetica", 16, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
            saldo_lbl.place(x=screen_width-70, y=screen_height-45)
            saldo_lbl.lift()  # Garante que fica por cima
        except Exception as e:
            print(f"DEBUG: Erro ao criar overlay coin/saldo: {e}")
    
    def update_progress_bars_for_card(self, card_idx):
        """Atualiza as barras de progresso com base nos valores do card_stats"""
        try:
            if not hasattr(self, 'card_stats') or card_idx >= len(self.card_stats):
                print(f"DEBUG: update_progress_bars_for_card - Índice inválido: {card_idx}")
                return
                
            stats = self.card_stats[card_idx]
            print(f"DEBUG: update_progress_bars_for_card - Atualizando carta {card_idx}: {stats}")
            
            # CORREÇÃO: Obter message_size da carta atual e aplicar como máximo para TODAS as barras
            if hasattr(self, 'cards') and card_idx < len(self.cards):
                carta_path = self.cards[card_idx]
                message_size = self._get_card_message_size_from_database(carta_path)
                print(f"DEBUG: update_progress_bars_for_card - Message size: {message_size}")
                
                # Aplicar message_size como máximo para todas as barras (precisão visual)
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        try:
                            # CORREÇÃO CRÍTICA: Verificar se o widget ainda existe antes de configurar
                            if self.progress_bars[stat].winfo_exists():
                                self.progress_bars[stat]["maximum"] = message_size
                                print(f"DEBUG: update_progress_bars_for_card - Máximo da barra '{stat}' definido para {message_size}")
                            else:
                                print(f"DEBUG: update_progress_bars_for_card - Widget progress bar '{stat}' foi destruído, pulando")
                        except tk.TclError as e:
                            print(f"DEBUG: update_progress_bars_for_card - Erro TclError na barra '{stat}': {e}")
                            print(f"DEBUG: update_progress_bars_for_card - Widget foi destruído, cancelando atualização")
                            return
            
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars and stat in self.progress_labels:
                    try:
                        # CORREÇÃO CRÍTICA: Verificar se os widgets ainda existem antes de atualizar
                        if (self.progress_bars[stat].winfo_exists() and 
                            self.progress_labels[stat].winfo_exists()):
                            value = stats[stat]
                            self.progress_bars[stat]["value"] = value
                            self.progress_labels[stat]["text"] = str(value)
                            
                            # Forçar atualização visual
                            self.progress_bars[stat].update_idletasks()
                            self.progress_labels[stat].update_idletasks()
                        else:
                            print(f"DEBUG: update_progress_bars_for_card - Widgets '{stat}' foram destruídos, pulando")
                    except tk.TclError as e:
                        print(f"DEBUG: update_progress_bars_for_card - Erro TclError ao atualizar '{stat}': {e}")
                        print(f"DEBUG: update_progress_bars_for_card - Widgets foram destruídos, cancelando resto da atualização")
                        return
            
            # Forçar atualização da interface principal
            self.update_idletasks()
            print(f"DEBUG: update_progress_bars_for_card - Atualização visual completa")
            
        except Exception as e:
            print(f"DEBUG: Erro em update_progress_bars_for_card: {e}")
            import traceback
            traceback.print_exc()
        

    def update_card_image(self):
        for i, lbl in enumerate(self.card_labels):
            idx = (self.card_idx + i) % len(self.cards)
            img = ImageTk.PhotoImage(Image.open(self.cards[idx]).resize((85,120)))
            lbl.config(image=img)
            lbl.image = img
            # CORREÇÃO: Usar _select_carousel_card em vez de make_card_callback
            # e passar o índice correto do carrossel
            carousel_index = idx
            carta_path = self.cards[idx]
            lbl.bind("<Button-1>", lambda e, ci=carousel_index, cp=carta_path: self._select_carousel_card(ci, cp))

    def prev_card(self):
        self.card_idx = (self.card_idx - 1) % len(self.cards)
        self.update_card_image()

    def next_card(self):
        self.card_idx = (self.card_idx + 1) % len(self.cards)
        self.update_card_image()

    def add_progress_bar(self, parent, label, value):
        fr = tk.Frame(parent, bg="black")
        fr.pack(pady=2, anchor="w", fill="x", expand=True)
        tk.Label(fr, text=label, font=("Helvetica", 14), bg="black", fg="white", width=8, anchor="w").pack(side=tk.LEFT)
        pb = ttk.Progressbar(fr, length=160, maximum=10, value=value)
        pb.pack(side=tk.LEFT, padx=8, fill="x", expand=True)
        value_lbl = tk.Label(fr, text=str(value), font=("Helvetica", 14), bg="black", fg="white", width=2)
        value_lbl.pack(side=tk.LEFT)
        self.progress_bars[label] = pb  # Guarda referência
        if not hasattr(self, "progress_labels"):
            self.progress_labels = {}
        self.progress_labels[label] = value_lbl  # Guarda referência à label do valor

    def try_mostrar_carta(self, path):
        try:
            print("CLICOU!", path)
            idx = self.cards.index(path)
            mostrar_carta_fullscreen_root(self.master, path, selected_card_idx=idx)
        except Exception as ex:
            print("ERRO AO ABRIR FULLSCREEN:", ex)

    def activate_card(self, card_type, card_path):
        # CORREÇÃO: Permitir ativação de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser ativadas antes de Next Phase e permanecem ativas entre turnos
        
        # IMPORTANTE: Não pode ativar cartas após Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de ativar carta {card_type} BLOQUEADA - Final Phase está ativo")
            return
        
        if card_type == "challenge":
            # Só pode haver 1 challenge ativo
            if self.active_challenge:
                self.discard_card(self.active_challenge)
            self.active_challenge = card_path
            self.show_card_active(card_path)
        elif card_type == "user" or card_type == "users":
            # Máximo de 4 users ativos (apenas Users têm limite)
            if card_path not in self.active_users:
                if len(self.active_users) < self.max_users:
                    self.active_users.append(card_path)
                    self.show_card_active(card_path)
                    print(f"DEBUG: User ativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                    # IMPORTANTE: Atualizar destaques do carrossel quando User é ativado
                    self._update_carousel_highlights()
                else:
                    # Opcional: feedback ao jogador que já tem 4 users
                    print("Já tens 4 users ativos!")
        elif card_type == "equipment" or card_type == "equipments":
            # SEM LIMITE para equipments após Next Phase
            if card_path not in self.active_equipments:
                self.active_equipments.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Equipment ativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type == "service" or card_type == "services":
            # SEM LIMITE para services após Next Phase
            if card_path not in self.active_services:
                self.active_services.append(card_path)
                self.show_card_active(card_path)
                print(f"DEBUG: Service ativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")
                
                # NOVO: Adicionar tracking para serviços TEMPORARY
                self._register_service_start_turn(card_path)
                
                # NOVO: Inicializar tracking para DATA VOLUME services
                self._register_data_volume_service(card_path)
    
    def is_card_active(self, card_path, card_type):
        """Verifica se uma carta está ativa"""
        if card_type == "challenge":
            return self.active_challenge == card_path
        elif card_type in ["user", "users"]:
            return card_path in self.active_users
        elif card_type in ["equipment", "equipments"]:
            return card_path in self.active_equipments
        elif card_type in ["service", "services"]:
            return card_path in self.active_services
        elif card_type == "actions":
            # NOVO: Actions só estão ativos se estão na posição 0 da fila cronológica
            chronological_order = self._get_chronological_actions_events_order()
            if chronological_order:
                first_card = chronological_order[0]
                is_active = (first_card['path'] == card_path and first_card['type'] == 'actions')
                print(f"DEBUG: [IS_ACTIVE_ACTION] {os.path.basename(card_path)} na posição 0? {is_active}")
                return is_active
            return False
        elif card_type == "events":
            # NOVO: Events só estão ativos se estão na posição 0 da fila cronológica
            chronological_order = self._get_chronological_actions_events_order()
            if chronological_order:
                first_card = chronological_order[0]
                is_active = (first_card['path'] == card_path and first_card['type'] == 'events')
                print(f"DEBUG: [IS_ACTIVE_EVENT] {os.path.basename(card_path)} na posição 0? {is_active}")
                return is_active
            return False
        return False
    
    def deactivate_card(self, card_path, card_type):
        """Desativa uma carta"""
        # CORREÇÃO: Permitir desativação de cartas em qualquer momento, exceto durante Final Phase
        # As cartas podem ser desativadas antes de Next Phase e o estado é preservado entre turnos
        
        # IMPORTANTE: Não pode desativar cartas após Final Phase ser ativado
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Tentativa de desativar carta {card_type} BLOQUEADA - Final Phase está ativo")
            return
        
        if card_type == "challenge":
            if self.active_challenge == card_path:
                self.active_challenge = None
                print(f"DEBUG: Challenge desativado: {os.path.basename(card_path)}")
        elif card_type in ["user", "users"]:
            if card_path in self.active_users:
                self.active_users.remove(card_path)
                print(f"DEBUG: User desativado: {os.path.basename(card_path)} ({len(self.active_users)}/{self.max_users})")
                # IMPORTANTE: Atualizar destaques do carrossel quando User é desativado
                self._update_carousel_highlights()
        elif card_type in ["equipment", "equipments"]:
            if card_path in self.active_equipments:
                self.active_equipments.remove(card_path)
                print(f"DEBUG: Equipment desativado: {os.path.basename(card_path)} (total: {len(self.active_equipments)})")
        elif card_type in ["service", "services"]:
            if card_path in self.active_services:
                self.active_services.remove(card_path)
                print(f"DEBUG: Service desativado: {os.path.basename(card_path)} (total: {len(self.active_services)})")
                
                # CORREÇÃO: Limpar tracking do Service quando desativado manualmente
                self._cleanup_expired_service_tracking(card_path)

    def discard_card(self, card_path):
        # Remove visualmente/desativa o challenge anterior
        pass

    def show_card_active(self, card_path):
        # Atualiza visualmente a carta como ativa
        pass
    
    def _limpar_cartas_actions_events_incorretas(self):
        """
        Remove cartas Actions/Events que foram incorretamente adicionadas ao inventário
        quando deveriam ter sido enviadas para outros jogadores.
        
        Cartas que devem ser removidas:
        - Actions com target diferente do jogador atual
        - Events com target_player diferente do jogador atual (exceto player_choice=True)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [_limpar_cartas_incorretas] Base de dados não disponível - não é possível limpar")
            return
        
        player_color = self.player_color.lower()
        cartas_para_remover = []
        
        # Verificar cartas Actions
        for carta_path in self.inventario.get("actions", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Action_(\d+)\.', filename)
                if match:
                    card_id = f"action_{match.group(1)}"
                    card_data = self.card_database.get_action(card_id)
                    if card_data:
                        target = getattr(card_data, 'target', None)
                        # Se target não é None e não é igual ao jogador atual, remover
                        if target is not None and target != player_color:
                            cartas_para_remover.append(('actions', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Action para remoção: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Action {filename}: {e}")
        
        # Verificar cartas Events
        for carta_path in self.inventario.get("events", []):
            try:
                filename = os.path.basename(carta_path)
                match = re.search(r'Event_(\d+)\.', filename)
                if match:
                    card_id = f"event_{match.group(1)}"
                    card_data = self.card_database.get_event(card_id)
                    if card_data:
                        target = getattr(card_data, 'target_player', None)
                        player_choice = getattr(card_data, 'player_choice', False)
                        # Se target não é None, não é igual ao jogador atual e player_choice é False, remover
                        if target is not None and target != player_color and not player_choice:
                            cartas_para_remover.append(('events', carta_path, target))
                            print(f"DEBUG: [_limpar_cartas_incorretas] Event para remoção: {filename} (target={target}, jogador={player_color})")
            except Exception as e:
                print(f"DEBUG: [_limpar_cartas_incorretas] Erro ao verificar Event {filename}: {e}")
        
        # Remover cartas identificadas
        cartas_removidas = 0
        for tipo, carta_path, target in cartas_para_remover:
            try:
                self.inventario[tipo].remove(carta_path)
                cartas_removidas += 1
                print(f"DEBUG: [_limpar_cartas_incorretas] SUCCESS: Removida: {os.path.basename(carta_path)} (tipo={tipo}, target={target})")
            except ValueError:
                print(f"DEBUG: [_limpar_cartas_incorretas] ERROR: Erro: carta não encontrada no inventário: {os.path.basename(carta_path)}")
        
        if cartas_removidas > 0:
            print(f"DEBUG: [_limpar_cartas_incorretas] Total de cartas removidas: {cartas_removidas}")
        else:
            print(f"DEBUG: [_limpar_cartas_incorretas] Nenhuma carta incorreta encontrada para remoção")

    def adicionar_carta_inventario(self, carta_path, carta_tipo):
        if carta_tipo in self.inventario:
            # CORREÇÃO CRÍTICA: Verificar se será primeira na fila ANTES de adicionar ao tracking
            will_be_first_in_queue = False
            if carta_tipo in ["actions", "events"]:
                if not hasattr(self, '_actions_events_order') or not self._actions_events_order:
                    will_be_first_in_queue = True  # Se não há fila, será a primeira
                    print(f"DEBUG: [TEMPORAL] Fila vazia - {carta_tipo} será primeira: {os.path.basename(carta_path)}")
                else:
                    will_be_first_in_queue = False  # Há cartas na fila, esta irá para o fim
                    print(f"DEBUG: [TEMPORAL] Fila com {len(self._actions_events_order)} cartas - {carta_tipo} vai para o fim: {os.path.basename(carta_path)}")
            
            self.inventario[carta_tipo].append(carta_path)
            
            # SISTEMA FIFO SIMPLES: Nova carta sempre vai para o fim da fila
            if carta_tipo in ["actions", "events"]:
                if not hasattr(self, '_actions_events_order'):
                    self._actions_events_order = []
                
                # CORREÇÃO: Permitir duplicatas - não remover cartas existentes
                # Sempre adicionar no fim, mesmo que a carta já exista na fila
                print(f"DEBUG: [FIFO_DUPLICATES] Permitindo duplicatas - carta será adicionada no fim mesmo que já exista: {os.path.basename(carta_path)}")
                
                # Determinar próximo timestamp (sempre o maior + 1 para garantir ordem FIFO)
                next_timestamp = len(self._actions_events_order)
                if self._actions_events_order:
                    # Garantir que o timestamp é sempre maior que todos os existentes
                    max_existing = max(entry.get('timestamp', 0) for entry in self._actions_events_order)
                    next_timestamp = max_existing + 1
                
                # Adicionar carta ao fim da fila cronológica (permitindo duplicatas)
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': carta_tipo,
                    'timestamp': next_timestamp
                })
                print(f"DEBUG: [SIMPLE_FIFO] Carta {carta_tipo} adicionada ao FIM da fila (timestamp {next_timestamp}): {os.path.basename(carta_path)}")
                print(f"DEBUG: [SIMPLE_FIFO] Fila atual: {[os.path.basename(entry['path']) for entry in self._actions_events_order]}")
            
            # Se for uma carta User, atualizar destaques do carrossel
            if carta_tipo == "users":
                # Aguardar um momento para garantir que a carta foi adicionada
                self.after(100, self._update_carousel_highlights)
            
            # Se for uma carta Event, registrar no tracking mas só ativar se for posição 0
            if carta_tipo == "events":
                current_turn = getattr(self, '_current_turn', 0)
                
                # Obter duration_turns da carta
                from cards_database import get_event_duration
                duration_turns = get_event_duration(carta_path)
                
                if duration_turns is not None:
                    # NOVA LÓGICA: Verificar se uma carta foi removida recentemente
                    card_should_be_inactive_initially = False
                    
                    # Se uma Action ou Event foi removido recentemente, próxima carta deve ficar inativa inicialmente
                    if self._action_recently_removed or self._event_recently_removed:
                        card_should_be_inactive_initially = True
                        print(f"DEBUG: [CARD_SEQUENCING] Event {os.path.basename(carta_path)} deve ficar INATIVO inicialmente - carta anterior foi removida")
                    
                    # CORREÇÃO: Usar a verificação feita antes de adicionar ao tracking
                    if will_be_first_in_queue and not card_should_be_inactive_initially:
                        # Event vai para posição 0 e não há sequenciamento - ativar imediatamente
                        self._event_start_turns[carta_path] = current_turn
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': current_turn,
                            'duration_turns': duration_turns,
                            'expires_turn': current_turn + duration_turns,
                            'is_active': True  # Marcador para indicar que está ativo
                        }
                        print(f"DEBUG: [ADD_EVENT] Event adicionado na posição 0 cronológica (ativo): {os.path.basename(carta_path)}")
                    else:
                        # Event vai para fila OU deve ficar inativo devido ao sequenciamento - não ativar ainda
                        self._event_start_turns[carta_path] = None  # Não ativo ainda
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': None,  # Será definido quando ativar no próximo turno
                            'duration_turns': duration_turns,
                            'expires_turn': None,  # Será calculado quando ativar
                            'is_active': False,  # Em fila ou inativo por sequenciamento
                            'pending_activation': card_should_be_inactive_initially  # Marca se está esperando ativação por sequenciamento
                        }
                        if card_should_be_inactive_initially:
                            print(f"DEBUG: [ADD_EVENT] Event adicionado na posição 0 mas INATIVO por sequenciamento: {os.path.basename(carta_path)}")
                        else:
                            print(f"DEBUG: [ADD_EVENT] Event adicionado na fila cronológica (inativo): {os.path.basename(carta_path)}")
                        
                self._ensure_active_event_tracking()

            # NOVA LÓGICA: Implementar sequenciamento para Actions também
            if carta_tipo == "actions":
                # Se uma Action ou Event foi removido recentemente, marcar próxima Action como inativa inicialmente
                if self._action_recently_removed or self._event_recently_removed:
                    if not hasattr(self, '_actions_pending_activation'):
                        self._actions_pending_activation = {}
                    
                    self._actions_pending_activation[carta_path] = True
                    print(f"DEBUG: [CARD_SEQUENCING] Action {os.path.basename(carta_path)} marcada como INATIVA inicialmente - carta anterior foi removida")

    def _is_first_card_in_actions_events_queue(self, carta_path):
        """Verifica se uma carta é a primeira na fila cronológica de Actions/Events"""
        if not hasattr(self, '_actions_events_order') or not self._actions_events_order:
            return True  # Se não há fila, será a primeira
        
        # CORREÇÃO: Verificar se a carta é realmente a primeira na ordem cronológica
        # Não apenas se é a única carta a ser adicionada
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            return True
        
        # A carta está na posição 0 da fila cronológica?
        first_card_in_queue = chronological_order[0]['path']
        is_first = (carta_path == first_card_in_queue)
        
        print(f"DEBUG: [IS_FIRST_CHECK] Carta: {os.path.basename(carta_path)}, É primeira na fila? {is_first}")
        if chronological_order:
            print(f"DEBUG: [IS_FIRST_CHECK] Primeira carta na fila: {os.path.basename(first_card_in_queue)}")
        
        return is_first

    def _get_chronological_actions_events_order(self):
        """Obtém a ordem cronológica das cartas Actions/Events respeitando ordem mista de chegada"""
        print(f"DEBUG: [CHRONOLOGICAL] _get_chronological_actions_events_order chamado")
        
        # CORREÇÃO SIMPLIFICADA: Se já existe _actions_events_order, apenas verificar consistência
        if hasattr(self, '_actions_events_order') and self._actions_events_order:
            print(f"DEBUG: [CHRONOLOGICAL] _actions_events_order JÁ EXISTE - verificando consistência ({len(self._actions_events_order)} cartas)")
            
            # Verificar se há cartas no inventário que não estão no tracking
            all_actions = self.inventario.get("actions", [])
            all_events = self.inventario.get("events", [])
            all_inventory_cards = all_actions + all_events
            
            # Cartas que estão no tracking cronológico
            tracked_cards = [entry['path'] for entry in self._actions_events_order]
            
            # Encontrar cartas no inventário que não estão no tracking
            missing_from_tracking = [carta for carta in all_inventory_cards if carta not in tracked_cards]
            
            if missing_from_tracking:
                print(f"DEBUG: [CHRONOLOGICAL] INCONSISTÊNCIA DETECTADA: {len(missing_from_tracking)} cartas no inventário não estão no tracking")
                
                # SOLUÇÃO SIMPLES: Adicionar cartas ausentes no FIM da fila (são cartas antigas hard-coded)
                for carta in missing_from_tracking:
                    carta_tipo = 'actions' if carta in all_actions else 'events'
                    print(f"DEBUG: [CHRONOLOGICAL] Carta ausente (hard-coded): {carta_tipo} - {os.path.basename(carta)}")
                    
                    # Adicionar ao FIM da ordem cronológica com próximo timestamp disponível
                    next_timestamp = max([entry.get('timestamp', 0) for entry in self._actions_events_order], default=-1) + 1
                    self._actions_events_order.append({
                        'path': carta,
                        'type': carta_tipo,
                        'timestamp': next_timestamp
                    })
                    print(f"DEBUG: [CHRONOLOGICAL] Carta hard-coded adicionada ao FIM: {carta_tipo} - {os.path.basename(carta)} (timestamp: {next_timestamp})")
            
            # Remover cartas órfãs (que não estão mais no inventário)
            orphaned_cards = [entry['path'] for entry in self._actions_events_order if entry['path'] not in all_inventory_cards]
            if orphaned_cards:
                print(f"DEBUG: [CHRONOLOGICAL] ÓRFÃOS DETECTADOS: {len(orphaned_cards)} cartas no tracking não estão no inventário")
                for carta in orphaned_cards:
                    print(f"DEBUG: [CHRONOLOGICAL] Carta órfã: {os.path.basename(carta)}")
                
                self._actions_events_order = [entry for entry in self._actions_events_order if entry['path'] in all_inventory_cards]
                print(f"DEBUG: [CHRONOLOGICAL] Cartas órfãs removidas do tracking")
            
        else:
            print(f"DEBUG: [CHRONOLOGICAL] Não existe _actions_events_order - criando a partir dos inventários atuais")
            # Se não há tracking temporal, criar assumindo ordem atual como cronológica
            self._actions_events_order = []
            
            # FALLBACK: Se não há tracking, assumir ordem por tipo (Actions depois Events)
            # Mas isto só acontece na primeira execução
            for carta_path in self.inventario.get("actions", []):
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': 'actions',
                    'timestamp': len(self._actions_events_order)
                })
                print(f"DEBUG: [CHRONOLOGICAL] Action adicionada: {os.path.basename(carta_path)} (timestamp: {len(self._actions_events_order)-1})")
            
            for carta_path in self.inventario.get("events", []):
                self._actions_events_order.append({
                    'path': carta_path,
                    'type': 'events',
                    'timestamp': len(self._actions_events_order)
                })
                print(f"DEBUG: [CHRONOLOGICAL] Event adicionado: {os.path.basename(carta_path)} (timestamp: {len(self._actions_events_order)-1})")
        
        # Ordenar por timestamp para garantir ordem cronológica correta
        self._actions_events_order.sort(key=lambda x: x.get('timestamp', 0))
        
        print(f"DEBUG: [CHRONOLOGICAL] Ordem cronológica MISTA final: {[entry['type'] + '-' + os.path.basename(entry['path']) for entry in self._actions_events_order]}")
        print(f"DEBUG: [CHRONOLOGICAL] Timestamps: {[entry.get('timestamp', 0) for entry in self._actions_events_order]}")
        print(f"DEBUG: [MIXED_FIFO] Ordem FIFO mista garantida - Actions e Events podem estar intercalados conforme ordem de chegada")
        
        return self._actions_events_order

    def get_active_cards_for_type(self, carta_tipo):
        """
        Retorna apenas cartas ativas (viradas para cima) para um tipo específico.
        Considera o sistema de sequenciamento para Actions/Events.
        """
        try:
            all_cards = self.inventario.get(carta_tipo, [])
            active_cards = []
            
            for carta_path in all_cards:
                is_active = False  # Por padrão, assumir que está inativa - carta deve provar que merece estar ativa
                
                # Verificar se a carta está ativa baseado no tipo
                if carta_tipo == "actions":
                    # Para Actions, verificar sistema de sequenciamento
                    # Action só está ativa se é a primeira na fila cronológica E não está pendente de ativação
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order:
                        first_item = chronological_order[0]
                        if first_item['type'] == 'actions' and first_item['path'] == carta_path:
                            # É a primeira Action na fila, verificar se não está pendente
                            is_pending = (hasattr(self, '_actions_pending_activation') and 
                                        carta_path in self._actions_pending_activation and 
                                        self._actions_pending_activation[carta_path])
                            is_active = not is_pending
                        else:
                            # Não é a primeira Action na fila, está inativa
                            is_active = False
                    else:
                        # Sem fila cronológica, não está ativa
                        is_active = False
                
                elif carta_tipo == "events":
                    # Para Events, verificar se está ativo no tracking
                    if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
                        tracking_data = self._event_duration_tracking[carta_path]
                        is_active = tracking_data.get('is_active', False)
                        # Verificar também se não está pendente de ativação
                        if tracking_data.get('pending_activation', False):
                            is_active = False
                    else:
                        is_active = False
                
                elif carta_tipo == "equipments":
                    # Para equipments, verificar se está no active_equipments
                    if hasattr(self, 'active_equipments'):
                        is_active = carta_path in self.active_equipments
                    else:
                        is_active = False
                
                elif carta_tipo == "services":
                    # Para services, verificar se está no active_services  
                    if hasattr(self, 'active_services'):
                        is_active = carta_path in self.active_services
                    else:
                        is_active = False
                
                elif carta_tipo in ["activities", "challenges"]:
                    # Activities e challenges que estão no carrossel são consideradas ativas
                    if hasattr(self, 'carrossel'):
                        is_active = carta_path in self.carrossel
                    else:
                        is_active = False
                
                elif carta_tipo == "users":
                    # Users cards são sempre ativas/visíveis 
                    is_active = True
                
                if is_active:
                    active_cards.append(carta_path)
            
            if carta_tipo in ["actions", "events"]:
                print(f"DEBUG: [get_active_cards_for_type] Cartas ativas de {carta_tipo}: {len(active_cards)} de {len(all_cards)} total")
                if len(active_cards) < len(all_cards):
                    inactive_cards = [c for c in all_cards if c not in active_cards]
                    print(f"DEBUG: [get_active_cards_for_type] Cartas INATIVAS de {carta_tipo}: {[os.path.basename(c) for c in inactive_cards]}")
            
            return active_cards
            
        except Exception as e:
            print(f"DEBUG: [get_active_cards_for_type] Erro ao obter cartas ativas para {carta_tipo}: {e}")
            return []

    def _activate_pending_cards(self):
        """
        Ativa cartas que estavam pendentes de ativação devido ao sequenciamento.
        Chamada no início de cada turno para ativar cartas que estavam esperando.
        """
        print(f"DEBUG: [CARD_SEQUENCING] === ATIVANDO CARTAS PENDENTES ===")
        
        current_turn = getattr(self, '_current_turn', 0)
        cards_activated = 0
        
        # Ativar Events pendentes
        if hasattr(self, '_event_duration_tracking'):
            for carta_path, tracking_data in list(self._event_duration_tracking.items()):
                if tracking_data.get('pending_activation', False):
                    print(f"DEBUG: [CARD_SEQUENCING] Ativando Event pendente: {os.path.basename(carta_path)}")
                    
                    # Verificar se o Event ainda está na posição 0 da fila
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order and chronological_order[0]['path'] == carta_path and chronological_order[0]['type'] == 'events':
                        # Event está na posição 0, pode ser ativado
                        duration_turns = tracking_data.get('duration_turns')
                        
                        # Para Events com duração fixa, definir start_turn e expires_turn
                        if duration_turns != "variable":
                            self._event_duration_tracking[carta_path].update({
                                'start_turn': current_turn,
                                'expires_turn': current_turn + duration_turns,
                                'is_active': True,
                                'pending_activation': False
                            })
                            print(f"DEBUG: [CARD_SEQUENCING] Event ativado: {os.path.basename(carta_path)} (duração: {duration_turns} turnos)")
                        else:
                            # Para Events com duração variável, apenas marcar como ativo mas start_turn permanece None
                            self._event_duration_tracking[carta_path].update({
                                'is_active': True,
                                'pending_activation': False
                            })
                            print(f"DEBUG: [CARD_SEQUENCING] Event variável ativado: {os.path.basename(carta_path)} (aguardando clique no ?)")
                        
                        cards_activated += 1
                    else:
                        print(f"DEBUG: [CARD_SEQUENCING] Event {os.path.basename(carta_path)} não está mais na posição 0, mantendo pendente")
        
        # Ativar Actions pendentes
        if hasattr(self, '_actions_pending_activation'):
            for carta_path in list(self._actions_pending_activation.keys()):
                if self._actions_pending_activation[carta_path]:
                    print(f"DEBUG: [CARD_SEQUENCING] Ativando Action pendente: {os.path.basename(carta_path)}")
                    
                    # Verificar se a Action ainda está na posição 0 da fila
                    chronological_order = self._get_chronological_actions_events_order()
                    if chronological_order and chronological_order[0]['path'] == carta_path and chronological_order[0]['type'] == 'actions':
                        # Action está na posição 0, ativar
                        self._actions_pending_activation[carta_path] = False
                        print(f"DEBUG: [CARD_SEQUENCING] Action ativada: {os.path.basename(carta_path)}")
                        cards_activated += 1
                    else:
                        print(f"DEBUG: [CARD_SEQUENCING] Action {os.path.basename(carta_path)} não está mais na posição 0, mantendo pendente")
        
        if cards_activated > 0:
            print(f"DEBUG: [CARD_SEQUENCING] === {cards_activated} CARTAS ATIVADAS ===")
            
            # Atualizar tracking de Events ativos
            self._ensure_active_event_tracking()
        else:
            print(f"DEBUG: [CARD_SEQUENCING] === NENHUMA CARTA PENDENTE PARA ATIVAR ===")

    def _mark_next_actions_as_pending(self):
        """
        Marca próximas Actions na fila como pendentes quando uma Action é removida.
        Isso faz com que a próxima Action fique inativa até o próximo turno.
        """
        print(f"DEBUG: [CARD_SEQUENCING] === MARCANDO PRÓXIMAS ACTIONS COMO PENDENTES ===")
        
        # Obter ordem cronológica atual
        chronological_order = self._get_chronological_actions_events_order()
        if not chronological_order:
            print(f"DEBUG: [CARD_SEQUENCING] Nenhuma fila cronológica - nada para marcar como pendente")
            return
        
        # Inicializar tracking de pendentes se não existir
        if not hasattr(self, '_actions_pending_activation'):
            self._actions_pending_activation = {}
        
        # Encontrar próximas Actions na fila e marcá-las como pendentes
        actions_marked = 0
        events_marked = 0
        
        for item in chronological_order:
            if item['type'] == 'actions':
                carta_path = item['path']
                # Verificar se a Action ainda está no inventário
                if carta_path in self.inventario.get('actions', []):
                    self._actions_pending_activation[carta_path] = True
                    print(f"DEBUG: [CARD_SEQUENCING] Action marcada como PENDENTE: {os.path.basename(carta_path)}")
                    actions_marked += 1
            
            elif item['type'] == 'events':
                carta_path = item['path']
                # Verificar se o Event ainda está no inventário
                if carta_path in self.inventario.get('events', []):
                    # Inicializar tracking de Events se não existir
                    if not hasattr(self, '_event_duration_tracking'):
                        self._event_duration_tracking = {}
                    
                    # Se Event não tem tracking, criar um básico
                    if carta_path not in self._event_duration_tracking:
                        # Obter dados da base de dados
                        event_id = self._extract_event_id_from_path(carta_path)
                        duration_turns = "variable"  # Padrão
                        
                        if event_id and hasattr(self, 'card_database') and self.card_database:
                            try:
                                event_data = self.card_database.get_event(event_id)
                                if event_data:
                                    duration_turns = event_data.duration_turns
                            except Exception as e:
                                print(f"DEBUG: [CARD_SEQUENCING] Erro ao obter dados do Event {event_id}: {e}")
                        
                        self._event_duration_tracking[carta_path] = {
                            'start_turn': None,
                            'duration_turns': duration_turns,
                            'expires_turn': None,
                            'is_active': False,
                            'pending_activation': True  # Marcar como pendente
                        }
                        print(f"DEBUG: [CARD_SEQUENCING] Event marcado como PENDENTE: {os.path.basename(carta_path)} (criando tracking)")
                        events_marked += 1
                    else:
                        # Event já tem tracking, apenas marcar como pendente
                        self._event_duration_tracking[carta_path]['pending_activation'] = True
                        self._event_duration_tracking[carta_path]['is_active'] = False
                        print(f"DEBUG: [CARD_SEQUENCING] Event marcado como PENDENTE: {os.path.basename(carta_path)} (atualizando tracking)")
                        events_marked += 1
        
        if actions_marked > 0 or events_marked > 0:
            print(f"DEBUG: [CARD_SEQUENCING] === {actions_marked} ACTIONS e {events_marked} EVENTS MARCADOS COMO PENDENTES ===")
        else:
            print(f"DEBUG: [CARD_SEQUENCING] === NENHUMA CARTA PARA MARCAR COMO PENDENTE ===")

    def _ensure_active_event_tracking(self):
        """
        Garante que apenas o Event na posição 0 está ativo e contando tempo.
        Ativa o próximo Event na fila quando necessário.
        CORREÇÃO: Cria tracking se não existir.
        """
        if not hasattr(self, '_event_duration_tracking'):
            self._event_duration_tracking = {}
            
        cartas_events = self.inventario.get("events", [])
        if not cartas_events:
            print("DEBUG: [ACTIVATE_EVENT] Nenhum Event no inventário")
            return
            
        current_turn = getattr(self, '_current_turn', 0)
        
        # CORREÇÃO: Determinar o Event do topo baseado na ordem cronológica, não na posição no array
        chronological_order = self._get_chronological_actions_events_order()
        event_do_topo = None
        
    def _ensure_active_event_tracking(self):
        """
        Garante que apenas o Event na posição 0 da fila cronológica está ativo.
        CRÍTICO: Apenas o primeiro item da fila (posição 0) pode estar ativo, e APENAS se for um Event.
        """
        if not hasattr(self, '_event_duration_tracking'):
            self._event_duration_tracking = {}
            
        cartas_events = self.inventario.get("events", [])
        if not cartas_events:
            print("DEBUG: [ACTIVATE_EVENT] Nenhum Event no inventário")
            return
            
        current_turn = getattr(self, '_current_turn', 0)
        
        # Obter ordem cronológica
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            print("DEBUG: [ACTIVATE_EVENT] ❌ Fila cronológica vazia")
            return
        
        print(f"DEBUG: [ACTIVATE_EVENT] Verificando se o primeiro item da fila é um Event...")
        print(f"DEBUG: [ACTIVATE_EVENT] Events no inventário: {[os.path.basename(p) for p in cartas_events]}")
        
        # CORREÇÃO CRÍTICA: Verificar APENAS o primeiro item da fila (posição 0)
        first_item = chronological_order[0]
        print(f"DEBUG: [ACTIVATE_EVENT] Primeiro item da fila (posição 0): {first_item['type']}-{os.path.basename(first_item['path'])}")
        
        # Se o primeiro item NÃO for um Event, nenhum Event deve estar ativo
        if first_item['type'] != 'events':
            print(f"DEBUG: [ACTIVATE_EVENT] ❌ Primeiro item não é Event - é {first_item['type']}")
            print("DEBUG: [ACTIVATE_EVENT] ❌ Apenas Events na posição 0 podem estar ativos")
            print("DEBUG: [ACTIVATE_EVENT] ❌ Desativando qualquer Event ativo...")
            
            # Desativar todos os Events
            for event_path in list(self._event_duration_tracking.keys()):
                if self._event_duration_tracking[event_path].get('is_active', False):
                    self._event_duration_tracking[event_path]['is_active'] = False
                    print(f"DEBUG: [ACTIVATE_EVENT] Event desativado: {os.path.basename(event_path)}")
            
            return
        
        # Se chegou aqui, o primeiro item É um Event
        event_do_topo = first_item['path']
        
        if event_do_topo not in cartas_events:
            print(f"DEBUG: [ACTIVATE_EVENT] ❌ Event do topo não está no inventário: {os.path.basename(event_do_topo)}")
            return
        
        print(f"DEBUG: [ACTIVATE_EVENT] ✅ Event na posição 0 deve estar ativo: {os.path.basename(event_do_topo)}")
        
        # Verificar todos os outros itens na fila e desativar qualquer Event que não seja da posição 0
        for i, item in enumerate(chronological_order[1:], 1):  # Começar do índice 1
            if item['type'] == 'events' and item['path'] in self._event_duration_tracking:
                if self._event_duration_tracking[item['path']].get('is_active', False):
                    self._event_duration_tracking[item['path']]['is_active'] = False
                    print(f"DEBUG: [ACTIVATE_EVENT] Event desativado na posição {i}: {os.path.basename(item['path'])}")
        
        print(f"DEBUG: [ACTIVATE_EVENT] === ATIVANDO EVENT DO TOPO ===")
        print(f"DEBUG: [ACTIVATE_EVENT] Event do topo: {os.path.basename(event_do_topo)}")
        print(f"DEBUG: [ACTIVATE_EVENT] Turno atual: {current_turn}")
        
        # CORREÇÃO CRÍTICA: Verificar PRIMEIRO se o Event JÁ EXPIROU antes de qualquer ação
        # Se o Event já existe no tracking, verificar se já deveria ter expirado
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            expires_turn = existing_tracking.get('expires_turn')
            
            # Se o Event já tem expires_turn definido e JÁ EXPIROU, removê-lo automaticamente
            if expires_turn is not None and current_turn >= expires_turn:
                print(f"DEBUG: [ACTIVATE_EVENT] 🚨 CRITICAL: Event JÁ EXPIROU - removendo automaticamente")
                print(f"DEBUG: [ACTIVATE_EVENT]   Event: {os.path.basename(event_do_topo)}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Turno atual: {current_turn}, Expira no turno: {expires_turn}")
                print(f"DEBUG: [ACTIVATE_EVENT]   Chamando _mostrar_overlay_event_expirado()")
                
                # Chamar o overlay de expiração
                self._mostrar_overlay_event_expirado(event_do_topo)
                return  # Sair da função sem ativar nada
        
        # CORREÇÃO FUNDAMENTAL: Se o Event tem tracking existente, PRESERVAR e não criar emergencial
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            print(f"DEBUG: [ACTIVATE_EVENT] ✅ Event do topo JÁ TEM tracking existente - PRESERVANDO:")
            print(f"DEBUG: [ACTIVATE_EVENT]   Event: {os.path.basename(event_do_topo)}")
            print(f"DEBUG: [ACTIVATE_EVENT]   start_turn: {existing_tracking.get('start_turn')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   duration_turns: {existing_tracking.get('duration_turns')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   expires_turn: {existing_tracking.get('expires_turn')}")
            print(f"DEBUG: [ACTIVATE_EVENT]   is_active: {existing_tracking.get('is_active')}")
            
            # CORREÇÃO: Se start_turn for None, definir agora (Event finalmente na posição 0 e ativo)
            # EXCETO para Events com duração 'variable' - esses só definem start_turn quando clicam no ?
            duration = existing_tracking.get('duration_turns')
            if existing_tracking.get('start_turn') is None and duration != "variable":
                print(f"DEBUG: [ACTIVATE_EVENT] 🔧 CORREÇÃO: start_turn era None para Event com duração FIXA, definindo para turno atual: {current_turn}")
                self._event_duration_tracking[event_do_topo]['start_turn'] = current_turn
                
                # Se também não tem expires_turn e tem duração fixa, calcular agora
                if (existing_tracking.get('expires_turn') is None and 
                    duration is not None and duration != "variable"):
                    expires_turn = current_turn + duration
                    self._event_duration_tracking[event_do_topo]['expires_turn'] = expires_turn
                    print(f"DEBUG: [ACTIVATE_EVENT] 🔧 CORREÇÃO: expires_turn calculado: {expires_turn} (start: {current_turn} + duration: {duration})")
            elif existing_tracking.get('start_turn') is None and duration == "variable":
                print(f"DEBUG: [ACTIVATE_EVENT] ⏳ Event com duração VARIABLE: start_turn permanece None até jogador clicar no ?")
                print(f"DEBUG: [ACTIVATE_EVENT] Event será ativado apenas quando o dado for lançado")
            
            # CORREÇÃO CRÍTICA: NÃO forçar ativação se Event está pendente de ativação
            # Verificar se Event está marcado como pendente no sistema de sequenciamento
            is_pending_activation = False
            if hasattr(self, '_event_duration_tracking') and event_do_topo in self._event_duration_tracking:
                is_pending_activation = self._event_duration_tracking[event_do_topo].get('pending_activation', False)
            
            # NÃO sobrescrever - apenas garantir que está ativo se necessário E não pendente
            if not existing_tracking.get('is_active', False) and not is_pending_activation:
                print(f"DEBUG: [ACTIVATE_EVENT] 🔄 Ativando Event com tracking preservado")
                self._event_duration_tracking[event_do_topo]['is_active'] = True
            elif is_pending_activation:
                print(f"DEBUG: [ACTIVATE_EVENT] ⏸️ Event está PENDENTE de ativação - não ativar ainda")
                print(f"DEBUG: [ACTIVATE_EVENT] Event será ativado no próximo turno pelo sistema de sequenciamento")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] ✅ Event já está ativo - nenhuma ação necessária")
            
            # Pular para verificação de ativação (não criar tracking emergencial)
        elif event_do_topo not in self._event_duration_tracking:
            print(f"DEBUG: [ACTIVATE_EVENT] ❌ Event do topo SEM tracking - criando com turno de ativação...")
            
            # CORREÇÃO CRÍTICA: Ao criar tracking emergencial, usar uma heurística para determinar
            # quando o Event foi realmente ativado, não apenas o turno atual
            
            # Se estivermos numa interface de navegação (turno 6), mas o Event deveria ter sido
            # ativado antes, tentar recuperar o turno original
            
            # Para Event_55.png, se está sendo acessado no turno 6 mas deveria ter expirado,
            # é porque foi ativado anteriormente - usar backup se disponível
            start_turn_to_use = current_turn
            
            # Verificar se há informações de backup que podem indicar quando foi ativado
            if hasattr(self, 'master') and hasattr(self.master, '_backup_turn_counters'):
                backup = self.master._backup_turn_counters
                event_backup = backup.get('_event_duration_tracking', {})
                
                if event_do_topo in event_backup:
                    original_start = event_backup[event_do_topo].get('start_turn')
                    if original_start is not None:
                        start_turn_to_use = original_start
                        print(f"DEBUG: [ACTIVATE_EVENT] ✅ Start turn recuperado do backup: {original_start}")
                    else:
                        print(f"DEBUG: [ACTIVATE_EVENT] ⚠️  Backup encontrado mas sem start_turn válido")
                else:
                    print(f"DEBUG: [ACTIVATE_EVENT] ⚠️  Event não encontrado no backup - usando turno atual: {current_turn}")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] ⚠️  Nenhum backup disponível - usando turno atual: {current_turn}")
            
            # Determinar duração baseada no nome do arquivo
            duration_turns = None
            if "Event_55.png" in event_do_topo:
                duration_turns = "variable"
                print(f"DEBUG: [ACTIVATE_EVENT] Event_55.png mapeado como duração VARIÁVEL")
            elif "Event_14.png" in event_do_topo:
                duration_turns = 1
                print(f"DEBUG: [ACTIVATE_EVENT] Event_14.png mapeado como duração FIXA: 1")
            else:
                # Tentar obter da base de dados
                try:
                    from cards_database import get_event_duration
                    duration_turns = get_event_duration(event_do_topo)
                    print(f"DEBUG: [ACTIVATE_EVENT] Duração obtida da base de dados: {duration_turns}")
                except Exception as e:
                    print(f"DEBUG: [ACTIVATE_EVENT] ERROR base de dados: {e}")
                    duration_turns = 3  # Fallback padrão
                    print(f"DEBUG: [ACTIVATE_EVENT] Usando duração fallback: {duration_turns}")
            
            # Criar tracking com start_turn correto
            if duration_turns == "variable":
                self._event_duration_tracking[event_do_topo] = {
                    'start_turn': start_turn_to_use,
                    'duration_turns': duration_turns,
                    'expires_turn': None,  # Será definido após o dado
                    'is_active': False  # Será ativado abaixo
                }
            else:
                self._event_duration_tracking[event_do_topo] = {
                    'start_turn': start_turn_to_use,
                    'duration_turns': duration_turns,
                    'expires_turn': start_turn_to_use + duration_turns,
                    'is_active': False  # Será ativado abaixo
                }
            print(f"DEBUG: [ACTIVATE_EVENT] ✅ Tracking criado com start_turn: {start_turn_to_use}")

        
        # NOVA LÓGICA SIMPLIFICADA: Se há tracking (preservado ou emergencial), apenas verificar ativação
        if event_do_topo in self._event_duration_tracking:
            existing_tracking = self._event_duration_tracking[event_do_topo]
            
            # Se não está ativo, ativar (sem alterar outros campos se já foram definidos)
            if not existing_tracking.get('is_active', False):
                print(f"DEBUG: [ACTIVATE_EVENT] 🔄 Ativando Event: {os.path.basename(event_do_topo)}")
                self._event_duration_tracking[event_do_topo]['is_active'] = True
                
                # Apenas sincronizar _event_start_turns se necessário
                start_turn = existing_tracking.get('start_turn')
                if start_turn is not None:
                    self._event_start_turns[event_do_topo] = start_turn
                    print(f"DEBUG: [ACTIVATE_EVENT] ✅ Event ativado com tracking preservado: start_turn={start_turn}")
                
                # Log do estado final
                print(f"DEBUG: [ACTIVATE_EVENT] Estado final do Event:")
                print(f"DEBUG: [ACTIVATE_EVENT]   start_turn: {existing_tracking.get('start_turn')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   duration_turns: {existing_tracking.get('duration_turns')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   expires_turn: {existing_tracking.get('expires_turn')}")
                print(f"DEBUG: [ACTIVATE_EVENT]   is_active: {existing_tracking.get('is_active')}")
            else:
                print(f"DEBUG: [ACTIVATE_EVENT] ✅ Event já está ativo - nenhuma ação necessária")
        else:
            print(f"DEBUG: [ACTIVATE_EVENT] ❌ ERRO: Event não tem tracking após verificação")
        
        # Garantir que Events em outras posições permanecem inativos
        for i, carta_path in enumerate(cartas_events[1:], 1):  # Começar do índice 1
            if carta_path in self._event_duration_tracking:
                if self._event_duration_tracking[carta_path].get('is_active', False) == True:
                    # Desativar Events que não estão na posição 0
                    self._event_duration_tracking[carta_path].update({
                        'start_turn': None,
                        'expires_turn': None,
                        'is_active': False
                    })
                    self._event_start_turns[carta_path] = None
                    print(f"DEBUG: [DEACTIVATE_EVENT] Event desativado na posição {i}: {os.path.basename(carta_path)}")

    def _verificar_events_expirados(self):
        """
        Verifica automaticamente Events expirados e remove-os do inventário,
        devolvendo-os à Store.
        CORREÇÃO: Também verifica Events de duração variável com expires_turn definido.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return
        
        current_turn = getattr(self, '_current_turn', 0)
        
        print(f"DEBUG: [VERIFICAR_EVENTS] === VERIFICAÇÃO DE EVENTS EXPIRADOS ===")
        print(f"DEBUG: [VERIFICAR_EVENTS] Turno atual: {current_turn}")
        print(f"DEBUG: [VERIFICAR_EVENTS] Total Events no tracking: {len(self._event_duration_tracking)}")
        
        # CORREÇÃO CRÍTICA: Verificar TODOS os Events no tracking, não só os ativos
        # porque Events de duração variável podem ter expires_turn definido mas is_active=False
        for carta_path, event_data in self._event_duration_tracking.items():
            is_active = event_data.get('is_active', False)
            start_turn = event_data.get('start_turn')
            duration_turns = event_data.get('duration_turns')
            expires_turn = event_data.get('expires_turn')
            
            print(f"DEBUG: [VERIFICAR_EVENTS] Event: {os.path.basename(carta_path)}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   is_active: {is_active}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   start_turn: {start_turn}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   duration_turns: {duration_turns}")
            print(f"DEBUG: [VERIFICAR_EVENTS]   expires_turn: {expires_turn}")
            
            # NOVA LÓGICA: Se expires_turn está definido (dado foi lançado), verificar expiração
            # independentemente do status is_active
            if expires_turn is not None and start_turn is not None:
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event com expires_turn definido - verificando expiração")
                
                if current_turn >= expires_turn:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ❌ Event EXPIROU: turno {current_turn} >= {expires_turn}")
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Chamando overlay de expiração...")
                    
                    # Mostrar overlay de expiração
                    self._mostrar_overlay_event_expirado(carta_path)
                    return  # Sair após mostrar o primeiro overlay (processar um de cada vez)
                else:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ✅ Event ainda válido até turno {expires_turn}")
            
            # LÓGICA LEGADA: Para Events ativos com duração fixa (não variável)
            elif is_active and start_turn is not None and duration_turns is not None:
                # CORREÇÃO CRÍTICA: Verificar se duration_turns é numérico antes de somar
                if duration_turns == "variable":
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Event com duração variável sem expires_turn - aguardando dado")
                    continue
                    
                # Garantir que duration_turns é um número
                try:
                    duration_turns_int = int(duration_turns)
                    calculated_expires_turn = start_turn + duration_turns_int
                except (ValueError, TypeError) as e:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ERRO: duration_turns inválido: {duration_turns} - {e}")
                    continue
                
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event ativo com duração fixa - calculando expiração")
                print(f"DEBUG: [VERIFICAR_EVENTS]   Calculated expires_turn: {calculated_expires_turn}")
                
                if current_turn >= calculated_expires_turn:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ❌ Event EXPIROU: turno {current_turn} >= {calculated_expires_turn}")
                    print(f"DEBUG: [VERIFICAR_EVENTS]   Chamando overlay de expiração...")
                    
                    # Mostrar overlay de expiração
                    self._mostrar_overlay_event_expirado(carta_path)
                    return  # Sair após mostrar o primeiro overlay (processar um de cada vez)
                else:
                    print(f"DEBUG: [VERIFICAR_EVENTS]   ✅ Event ainda válido até turno {calculated_expires_turn}")
            else:
                print(f"DEBUG: [VERIFICAR_EVENTS]   Event inativo ou sem dados suficientes - ignorando")
        
        print(f"DEBUG: [VERIFICAR_EVENTS] === FIM VERIFICAÇÃO - NENHUM EVENT EXPIRADO ===")
        
        # CORREÇÃO: Garantir que o tracking está correto APÓS verificar expirações
        # Isso evita reativar Events que deveriam ter expirado
        self._ensure_active_event_tracking()
        
    def _verificar_events_expirados_automaticamente(self):
        """
        Versão automática da verificação de Events expirados para o dashboard principal.
        Verifica Events expirados e mostra overlay automaticamente na interface principal.
        """
        if not hasattr(self, '_event_duration_tracking'):
            return False
        
        current_turn = getattr(self, '_current_turn', 0)
        
        print(f"DEBUG: [AUTO_EXPIRY] === VERIFICAÇÃO AUTOMÁTICA DE EVENTS EXPIRADOS ===")
        print(f"DEBUG: [AUTO_EXPIRY] Turno atual: {current_turn}")
        print(f"DEBUG: [AUTO_EXPIRY] Total Events no tracking: {len(self._event_duration_tracking)}")
        
        # Verificar Events expirados no inventário
        events_expirados = []
        for carta_path in self.inventario.get("events", []):
            if self._is_event_expired(carta_path):
                events_expirados.append({
                    'file': os.path.basename(carta_path),
                    'data': carta_path,
                    'path': carta_path
                })
                print(f"DEBUG: [AUTO_EXPIRY] Event EXPIRADO encontrado: {os.path.basename(carta_path)}")
        
        # Se há Events expirados, armazenar para mostrar no overlay
        if events_expirados:
            print(f"DEBUG: [AUTO_EXPIRY] Total de {len(events_expirados)} Events expirados encontrados")
            # Armazenar para mostrar no overlay
            self.events_expirados_para_overlay = events_expirados
            return True  # Retorna True se há Events expirados
        
        print(f"DEBUG: [AUTO_EXPIRY] === NENHUM EVENT EXPIRADO ENCONTRADO ===")
        return False  # Retorna False se não há Events expirados
    
    def _mostrar_overlay_events_expirados_apos_interface(self):
        """
        Mostra overlay com events expirados após a interface estar criada.
        É chamado via self.after() para garantir que aparece por cima da interface.
        """
        print("DEBUG: === MOSTRAR OVERLAY EVENTS EXPIRADOS APÓS INTERFACE ===")
        
        if hasattr(self, 'events_expirados_para_overlay') and self.events_expirados_para_overlay:
            print(f"DEBUG: [EVENTS] Mostrando overlay para {len(self.events_expirados_para_overlay)} events expirados")
            
            # Pegar o primeiro event expirado da lista
            event_expirado = self.events_expirados_para_overlay[0]
            
            # Remover da lista
            self.events_expirados_para_overlay.pop(0)
            
            # Chamar o método existente para mostrar o overlay
            self._mostrar_overlay_event_expirado(event_expirado['data'])
            
            # Se ainda há mais events expirados, agendar para mostrar o próximo
            if self.events_expirados_para_overlay:
                print(f"DEBUG: [EVENTS] Agendando próximo event expirado em 3 segundos...")
                self.after(3000, self._mostrar_overlay_events_expirados_apos_interface)
        else:
            print("DEBUG: [EVENTS] Nenhum event expirado para mostrar overlay.")

    def _verificar_services_expirados_automaticamente(self):
        """
        Verifica automaticamente se algum Service expirou.
        Verifica tanto Services TEMPORARY (arquivos .txt) quanto Services do inventário.
        É chamado durante a criação da interface principal e no início de cada turno.
        Retorna True se encontrou services expirados para mostrar overlay.
        """
        print("DEBUG: === VERIFICAR SERVICES EXPIRADOS AUTOMATICAMENTE ===")
        
        services_expirados = []
        
        # PARTE 1: Verificar Services TEMPORARY (arquivos .txt)
        player_color_capitalized = self.player_color.capitalize()
        base_dir = detect_player_inventory_base_dir()
        services_folder = os.path.join(base_dir, "Users", "Residential-level", player_color_capitalized, "Services")
        
        if os.path.exists(services_folder):
            service_files = [f for f in os.listdir(services_folder) if f.endswith('.txt')]
            print(f"DEBUG: [SERVICES] Verificando {len(service_files)} services TEMPORARY na pasta {services_folder}")
            
            for service_file in service_files:
                service_path = os.path.join(services_folder, service_file)
                
                try:
                    with open(service_path, 'r') as file:
                        service_data = json.load(file)
                    
                    # Só verificar services do tipo TEMPORARY
                    if service_data.get('type') != 'TEMPORARY':
                        continue
                        
                    print(f"DEBUG: [SERVICES] Verificando service TEMPORARY: {service_file}")
                    
                    # Verificar se ainda tem duracao > 0
                    duracao_restante = service_data.get('duration', 0)
                    
                    if duracao_restante <= 0:
                        print(f"DEBUG: [SERVICES] *** SERVICE TEMPORARY EXPIRADO: {service_file} ***")
                        services_expirados.append({
                            'file': service_file,
                            'data': service_data,
                            'path': service_path,
                            'tipo': 'TEMPORARY'
                        })
                    else:
                        print(f"DEBUG: [SERVICES] Service TEMPORARY ainda ativo: {service_file} (duração: {duracao_restante})")
                        
                except Exception as e:
                    print(f"DEBUG: [SERVICES] Erro ao ler service TEMPORARY {service_file}: {e}")
                    continue
        else:
            print(f"DEBUG: [SERVICES] Pasta {services_folder} não existe - sem Services TEMPORARY para verificar.")
        
        # PARTE 2: Verificar Services do inventário que expiraram
        print(f"DEBUG: [SERVICES] Verificando Services do inventário que expiraram...")
        
        if hasattr(self, 'inventario') and 'services' in self.inventario:
            services_inventario = self.inventario['services']
            print(f"DEBUG: [SERVICES] Verificando {len(services_inventario)} services no inventário")
            
            for service_carta in services_inventario:
                service_nome = os.path.basename(service_carta)
                
                # Usar a mesma lógica do botão Services para verificar expiração
                if self._is_service_expired(service_carta):
                    print(f"DEBUG: [SERVICES] *** SERVICE INVENTÁRIO EXPIRADO: {service_nome} ***")
                    services_expirados.append({
                        'file': service_nome,
                        'data': {'service_id': service_nome.replace('.png', '')},
                        'path': service_carta,
                        'tipo': 'INVENTARIO'
                    })
                else:
                    print(f"DEBUG: [SERVICES] Service inventário ainda ativo: {service_nome}")
        else:
            print("DEBUG: [SERVICES] Nenhum service no inventário para verificar.")
        
        # PARTE 3: Verificar Data Volume Services que expiraram por falta de pacotes
        print(f"DEBUG: [SERVICES] Verificando Data Volume Services com overlays pendentes...")
        
        if hasattr(self, '_pending_data_volume_expiry_overlays') and self._pending_data_volume_expiry_overlays:
            print(f"DEBUG: [SERVICES] Encontrados {len(self._pending_data_volume_expiry_overlays)} Data Volume services com overlays pendentes")
            
            for service_carta in self._pending_data_volume_expiry_overlays[:]:  # Cópia para evitar modificação durante iteração
                service_nome = os.path.basename(service_carta)
                print(f"DEBUG: [SERVICES] *** DATA VOLUME SERVICE EXPIRADO: {service_nome} ***")
                
                services_expirados.append({
                    'file': service_nome,
                    'data': {'service_id': service_nome.replace('.png', '')},
                    'path': service_carta,
                    'tipo': 'DATA_VOLUME'
                })
                
                # Remover da lista de overlays pendentes após processamento
                self._pending_data_volume_expiry_overlays.remove(service_carta)
        else:
            print("DEBUG: [SERVICES] Nenhum Data Volume service com overlay pendente.")
        
        if services_expirados:
            print(f"DEBUG: [SERVICES] === TOTAL DE SERVICES EXPIRADOS: {len(services_expirados)} ===")
            # Armazenar para mostrar no overlay
            self.services_expirados_para_overlay = services_expirados
            return True
        else:
            print("DEBUG: [SERVICES] Nenhum service expirado encontrado.")
            return False

    def _mostrar_overlay_services_expirados_apos_interface(self):
        """
        Mostra overlay com services expirados após a interface principal estar criada.
        É chamado via self.after() para garantir que aparece por cima da interface.
        """
        print("DEBUG: === MOSTRAR OVERLAY SERVICES EXPIRADOS APÓS INTERFACE ===")
        
        if hasattr(self, 'services_expirados_para_overlay') and self.services_expirados_para_overlay:
            print(f"DEBUG: [SERVICES] Mostrando overlay para {len(self.services_expirados_para_overlay)} services expirados")
            
            # Pegar o primeiro service expirado da lista
            service_expirado = self.services_expirados_para_overlay[0]
            
            # Remover da lista
            self.services_expirados_para_overlay.pop(0)
            
            # Construir o caminho da carta Service usando o service_id
            service_data = service_expirado['data']
            service_tipo = service_expirado.get('tipo', 'TEMPORARY')
            
            if service_tipo == 'TEMPORARY':
                # Service TEMPORARY - usar service_id dos dados do arquivo
                service_id = service_data.get('service_id', '')
                if service_id:
                    player_color_capitalized = self.player_color.capitalize()
                    cartas_base_dir = detect_cartas_base_dir()
                    carta_path = os.path.join(cartas_base_dir, "services", "Residential-level", player_color_capitalized, f"{service_id}.png")
                    print(f"DEBUG: [SERVICES] Mostrando overlay para service TEMPORARY: {carta_path}")
                    self._mostrar_overlay_service_expirado(carta_path)
                else:
                    print(f"DEBUG: [SERVICES] ERRO: service_id não encontrado em service TEMPORARY: {service_data}")
            
            elif service_tipo == 'INVENTARIO':
                # Service do inventário - usar o caminho direto
                carta_path = service_expirado['path']
                print(f"DEBUG: [SERVICES] Mostrando overlay para service INVENTÁRIO: {carta_path}")
                self._mostrar_overlay_service_expirado(carta_path)
            
            elif service_tipo == 'DATA_VOLUME':
                # Service Data Volume expirado - usar o caminho direto
                carta_path = service_expirado['path']
                print(f"DEBUG: [SERVICES] Mostrando overlay para service DATA VOLUME expirado: {carta_path}")
                self._mostrar_overlay_service_expirado_data_volume(carta_path)
            
            else:
                print(f"DEBUG: [SERVICES] ERRO: Tipo de service desconhecido: {service_tipo}")
            
            # Se ainda há mais services expirados, agendar para mostrar o próximo
            if self.services_expirados_para_overlay:
                print(f"DEBUG: [SERVICES] Agendando próximo service expirado em 3 segundos...")
                self.after(3000, self._mostrar_overlay_services_expirados_apos_interface)
        else:
            print("DEBUG: [SERVICES] Nenhum service expirado para mostrar overlay.")

    def _has_active_temporary_services(self):
        """
        Verifica se há Services TEMPORARY ativos (não expirados).
        Retorna True se houver pelo menos um Service TEMPORARY ativo.
        Usa o sistema de tracking em memória em vez de arquivos .txt.
        CORREÇÃO: Service só é considerado ativo se estiver no tracking de ativação.
        """
        try:
            print("DEBUG: [TEMPORARY_CHECK] Verificando Services TEMPORARY ativos usando tracking em memória")
            
            # Verificar Services no inventário que são TEMPORARY e não expirados
            services_inventory = self.inventario.get("services", [])
            print(f"DEBUG: [TEMPORARY_CHECK] Verificando {len(services_inventory)} services no inventário")
            
            for service_path in services_inventory:
                try:
                    # Verificar se é TEMPORARY usando a database
                    if hasattr(self, 'card_database') and self.card_database:
                        service_id = self._map_file_to_card_id(service_path, "services")
                        service_data = self.card_database.get_service(service_id)
                        
                        if service_data and service_data.service_type.value == 'temporary':
                            # CORREÇÃO: Service TEMPORARY só é ativo se estiver no tracking
                            # Verificar se está no tracking de ativação (foi realmente ativado)
                            is_in_tracking = (service_path in self._service_duration_tracking or 
                                            service_path in self._service_real_activation_turns)
                            
                            if is_in_tracking:
                                # Verificar se não expirou usando a função existente
                                if not self._is_service_expired(service_path):
                                    print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY ativo encontrado: {os.path.basename(service_path)}")
                                    return True
                                else:
                                    print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY expirado: {os.path.basename(service_path)}")
                            else:
                                print(f"DEBUG: [TEMPORARY_CHECK] Service TEMPORARY não ativado (sem tracking): {os.path.basename(service_path)}")
                        else:
                            print(f"DEBUG: [TEMPORARY_CHECK] Service não é TEMPORARY: {os.path.basename(service_path)}")
                            
                except Exception as e:
                    print(f"DEBUG: [TEMPORARY_CHECK] Erro ao verificar service {os.path.basename(service_path)}: {e}")
                    continue
                    
            print("DEBUG: [TEMPORARY_CHECK] Nenhum Service TEMPORARY ativo encontrado")
            return False
                
        except Exception as e:
            print(f"DEBUG: [TEMPORARY_CHECK] Erro ao verificar Services TEMPORARY: {e}")
            return False

    def _has_active_data_volume_services_with_packets(self):
        """
        Verifica se há Services DATA_VOLUME ativos com pacotes restantes.
        Retorna True se houver pelo menos um Service DATA_VOLUME ativo com pacotes > 0.
        """
        try:
            print("DEBUG: [DATA_VOLUME_CHECK] Verificando Data Volume services com pacotes")
            
            # Verificar services ativos que têm tracking de Data Volume
            if hasattr(self, '_service_data_volume_tracking'):
                for service_path, tracking_data in self._service_data_volume_tracking.items():
                    # Só considerar services que estão realmente ativos
                    if service_path in self.active_services:
                        packets_remaining = tracking_data.get('packets_remaining', 0)
                        
                        if packets_remaining > 0:
                            print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service ativo com pacotes: {os.path.basename(service_path)} ({packets_remaining} pacotes)")
                            return True
                        else:
                            print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service sem pacotes: {os.path.basename(service_path)}")
                    else:
                        print(f"DEBUG: [DATA_VOLUME_CHECK] Data Volume service não ativo: {os.path.basename(service_path)}")
            
            print("DEBUG: [DATA_VOLUME_CHECK] Nenhum Data Volume service ativo com pacotes")
            return False
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME_CHECK] Erro ao verificar Data Volume services: {e}")
            return False

    def _has_active_bandwidth_services(self):
        """
        Verifica se há Services BANDWIDTH ativos.
        Retorna True se houver pelo menos um Service BANDWIDTH ativo.
        Service só é considerado ativo se estiver no tracking de ativação.
        """
        try:
            print("DEBUG: [BANDWIDTH_CHECK] Verificando Services BANDWIDTH ativos usando tracking em memória")
            
            # Verificar Services no inventário que são BANDWIDTH e estão ativos
            services_inventory = self.inventario.get("services", [])
            print(f"DEBUG: [BANDWIDTH_CHECK] Verificando {len(services_inventory)} services no inventário")
            
            for service_path in services_inventory:
                try:
                    # Verificar se é BANDWIDTH usando a database
                    if hasattr(self, 'card_database') and self.card_database:
                        service_id = self._map_file_to_card_id(service_path, "services")
                        service_data = self.card_database.get_service(service_id)
                        
                        if service_data and service_data.service_type.value == 'bandwidth':
                            # Service BANDWIDTH só é ativo se estiver no tracking ou lista de Services ativos
                            is_in_active_list = service_path in self.active_services
                            is_in_tracking = (service_path in self._service_duration_tracking or 
                                            service_path in self._service_real_activation_turns)
                            
                            if is_in_active_list or is_in_tracking:
                                print(f"DEBUG: [BANDWIDTH_CHECK] Service BANDWIDTH ativo encontrado: {os.path.basename(service_path)}")
                                return True
                            else:
                                print(f"DEBUG: [BANDWIDTH_CHECK] Service BANDWIDTH não ativado: {os.path.basename(service_path)}")
                        else:
                            print(f"DEBUG: [BANDWIDTH_CHECK] Service não é BANDWIDTH: {os.path.basename(service_path)}")
                            
                except Exception as e:
                    print(f"DEBUG: [BANDWIDTH_CHECK] Erro ao verificar service {os.path.basename(service_path)}: {e}")
                    continue
                    
            print("DEBUG: [BANDWIDTH_CHECK] Nenhum Service BANDWIDTH ativo encontrado")
            return False
                
        except Exception as e:
            print(f"DEBUG: [BANDWIDTH_CHECK] Erro ao verificar Services BANDWIDTH: {e}")
            return False

    def _show_bandwidth_error_overlay(self, tipos, page):
        """Mostra overlay de erro BANDWIDTH sequencial (substitui o overlay de ativação) mantendo carta User de fundo"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Criando overlay sequencial de erro BANDWIDTH")
        
        # MANTER A CARTA USER DE FUNDO - remover apenas os widgets do overlay de ativação
        widgets_to_remove = []
        carta_user_label = None
        
        # Encontrar e preservar o Label da carta User
        for widget in self.winfo_children():
            if isinstance(widget, tk.Label) and hasattr(widget, 'image'):
                # Este é provavelmente o Label da carta User - preservar
                carta_user_label = widget
                print(f"DEBUG: [BANDWIDTH_ERROR] Carta User preservada: {widget}")
            else:
                # Remover os outros widgets (Frame do overlay de ativação, botões, etc.)
                widgets_to_remove.append(widget)
        
        # Remover apenas os widgets que não são a carta
        for widget in widgets_to_remove:
            widget.destroy()
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Carta User mantida de fundo, overlay de ativação removido")
        
        # Frame para a dialog de erro (centro da tela) - igual ao overlay de ativação
        error_frame = tk.Frame(self, bg="black")
        error_frame.pack(expand=True)
        
        # Título "Activation Denied" vermelho e maior (font 20)
        tk.Label(error_frame, text="Activation Denied", 
                font=("Helvetica", 20, "bold"), fg="red", bg="black").pack(pady=(40, 20))
        
        # Mensagem de erro (branco, centralizada)
        tk.Label(error_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                font=("Helvetica", 16), fg="white", bg="black", justify="center").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(error_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def voltar_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Voltando ao inventário de Users")
            
            # Recriar a TopBar antes de voltar ao inventário
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada após erro")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário de Users
            self.show_inventory_matrix(tipos, page)
        
        # Botão OK (verde, width=8, font 14) - igual aos outros overlays
        btn_ok = tk.Button(btns_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=voltar_inventario)
        btn_ok.pack(pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_inventario())
        self.bind('<Escape>', lambda e: voltar_inventario())
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Overlay sequencial criado - carta User permanece de fundo")
        
        # Force update para garantir que está visível
        self.update_idletasks()
        self.update()

    def _show_bandwidth_required_message_overlay(self):
        """Mostra overlay de erro BANDWIDTH por cima do overlay de ativação existente - versão Raspberry Pi"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Criando overlay modal RASPBERRY PI por cima do overlay de ativação")
        
        # ABORDAGEM RASPBERRY PI: Frame semi-transparente que deixa ver a carta User por baixo
        # Criar um Frame semi-transparente que ocupa toda a tela
        modal_frame = tk.Frame(self, bg="gray20")  # Cinzento escuro semi-transparente
        modal_frame.place(x=0, y=0, relwidth=1, relheight=1)
        
        # Armazenar referência para poder fechar depois
        self._bandwidth_error_modal = modal_frame
        
        # Container central para a mensagem de erro (com fundo opaco)
        content_frame = tk.Frame(modal_frame, bg="black", relief="raised", bd=5)
        content_frame.place(relx=0.5, rely=0.5, anchor="center", width=450, height=350)
        
        # Frame interno para o conteúdo
        inner_frame = tk.Frame(content_frame, bg="black")
        inner_frame.pack(expand=True, fill="both", padx=25, pady=25)
        
        # Título "Activation Denied" vermelho e maior (font 20)
        title_label = tk.Label(inner_frame, text="Activation Denied", 
                              font=("Helvetica", 20, "bold"), fg="red", bg="black")
        title_label.pack(pady=(20, 15))
        
        # Mensagem de erro (branco, centralizada)
        message_label = tk.Label(inner_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                                font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_label.pack(pady=(0, 20))
        
        # Frame para o botão
        btn_frame = tk.Frame(inner_frame, bg="black")
        btn_frame.pack(pady=15)
        
        def voltar_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Fechando modal e voltando ao inventário de Users")
            
            # Fechar o modal
            if hasattr(self, '_bandwidth_error_modal') and self._bandwidth_error_modal:
                self._bandwidth_error_modal.destroy()
                delattr(self, '_bandwidth_error_modal')
            
            # Recriar a TopBar antes de voltar ao inventário (como outras funções fazem)
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada após erro BANDWIDTH")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar diretamente para o inventário de Users (página 0)
            self.show_inventory_matrix(['users'], 0)
        
        # Botão OK (verde, width=10, font 14)
        btn_ok = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=10, command=voltar_inventario)
        btn_ok.pack(pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_inventario())
        self.bind('<Escape>', lambda e: voltar_inventario())
        
        # Focar no frame modal
        modal_frame.focus_set()
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Modal RASPBERRY PI criado - Frame semi-transparente permite ver carta User")
        
        # Force update para garantir que está visível
        modal_frame.update_idletasks()
        modal_frame.update()

    def _show_bandwidth_required_message(self, tipos, page):
        """Mostra mensagem de erro quando o jogador tenta ativar carta User sem ter BANDWIDTH ativo"""
        print(f"DEBUG: [BANDWIDTH_ERROR] Mostrando tela de erro BANDWIDTH - abordagem híbrida")
        
        # ABORDAGEM HÍBRIDA: Limpar TODOS os widgets como confirmação (garante visibilidade)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Frame para a dialog de erro (centro da tela) - pack(expand=True) para dimensionamento dinâmico
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título MELHORADO: "Activation Denied" vermelho e maior (font 20)
        tk.Label(confirm_frame, text="Activation Denied", 
                font=("Helvetica", 20, "bold"), fg="red", bg="black").pack(pady=(40, 20))
        
        # Mensagem de erro (branco, centralizada)
        tk.Label(confirm_frame, text="Cannot activate User cards!\nActivate a BANDWIDTH Service first.", 
                font=("Helvetica", 16), fg="white", bg="black", justify="center").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def voltar_ao_inventario():
            print(f"DEBUG: [BANDWIDTH_ERROR] Voltando ao inventário - recriando TopBar")
            
            # Recriar a TopBar antes de voltar ao inventário (como confirmação de ativação)
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [BANDWIDTH_ERROR] TopBar recriada após erro")
            except Exception as e:
                print(f"DEBUG: [BANDWIDTH_ERROR] Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
        
        # Botão OK (verde, width=8, font 14)
        btn_ok = tk.Button(btns_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=voltar_ao_inventario)
        btn_ok.pack(side="left", padx=20, pady=10)
        
        # Permitir fechar com Enter ou Escape
        self.bind('<Return>', lambda e: voltar_ao_inventario())
        self.bind('<Escape>', lambda e: voltar_ao_inventario())
        
        print(f"DEBUG: [BANDWIDTH_ERROR] Tela de erro criada com título 'Activation Denied' vermelho font 20")
        
        # Force update para garantir que está visível
        self.update_idletasks()
        self.update()

    def show_inventory_page(self, carta_tipo):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        screen_width = self.winfo_screenwidth()
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"),
                         fg="black", bg=self.bar_color)
        title.place(relx=0.5, y=65, anchor="n")

        # Mostra as cartas desse tipo
        cartas = self.inventario.get(carta_tipo, [])
        if cartas:
            carta_path = cartas[-1]  # Mostra a última carta tirada
            img = ImageTk.PhotoImage(Image.open(carta_path).resize((180, 260)))
            carta_lbl = tk.Label(self, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.place(relx=0.5, rely=0.4, anchor="center")

            def abrir_fullscreen(event=None):
                self.show_card_fullscreen(carta_path, carta_tipo)
            carta_lbl.bind("<Button-1>", abrir_fullscreen)
        else:
            tk.Label(self, text="Sem cartas!", font=("Helvetica", 16), bg="black", fg="white").place(relx=0.5, rely=0.5, anchor="center")

        # Botão seta para voltar (usando X_button.png como fallback para arrow_left.png)
        try:
            # Tentar carregar arrow_left.png primeiro
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((48, 48)))
        except FileNotFoundError:
            # Fallback para X_button.png se arrow_left.png não existir
            seta_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "X_button.png")).resize((48, 48)))
        seta_btn = tk.Button(
            self,
            image=seta_img,
            bg="black",
            borderwidth=0,
            command=lambda: self.show_dice_roll_screen(
                self.player_name,
                self.saldo,
                self.other_players,
                self.screen_width,
                self.screen_height
            )
        )
        seta_btn.image = seta_img  # type: ignore[attr-defined]
        seta_btn.place(x=10, rely=0.9*self.winfo_screenheight(), anchor="sw")

        # Se Next Phase estiver ativo, desabilitar vendas nesta página
        if getattr(self, '_next_phase_active', False):
            self._disable_inventory_sales()
    def _disable_inventory_sales(self):
        """Desativa botões ou funcionalidades de venda nas páginas de inventário."""
        # Aqui você pode implementar a lógica para desabilitar/remover botões de venda
        # Exemplo: desabilitar todos os botões de venda se existirem
        for widget in self.winfo_children():
            if isinstance(widget, tk.Button) and getattr(widget, 'is_sell_button', False):
                widget.config(state='disabled')

        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((self.screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada na página de inventário")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png na página de inventário: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

    def show_card_fullscreen(self, carta_path, carta_tipo):
        print("DEBUG: PlayerDashboard.show_card_fullscreen chamado")
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()

        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)

        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black")
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")

        # Botão X para fechar
        x_img_path = os.path.join(IMG_DIR, "X_button.png")
        x_img = ImageTk.PhotoImage(Image.open(x_img_path).resize((48, 48)))
        x_btn = tk.Label(self, image=x_img, bg="black", cursor="hand2")
        x_btn.image = x_img  # type: ignore[attr-defined]
        x_btn.place(relx=0.98, rely=0.02, anchor="ne")

        def fechar():
            # Limpa tudo menos a barra superior
            for widget in self.winfo_children():
                if widget == self.topbar_label:
                    continue
                widget.destroy()
            # Redesenha a interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

        x_btn.bind("<Button-1>", lambda e: fechar())

        # Verificar se é uma carta Event expirada durante Next Phase
        if (carta_tipo == "events" and 
            getattr(self, '_next_phase_active', False) and 
            carta_path in self._event_duration_tracking):
            
            current_turn = getattr(self, '_current_turn', 0)
            event_data = self._event_duration_tracking[carta_path]
            
            # Se a carta expirou (current_turn >= expires_turn)
            if current_turn >= event_data['expires_turn']:
                # Botão certo vermelho para devolver à Store (mesmo formato que botão de desativação)
                red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def devolver_event_para_store():
                    print(f"DEBUG: Devolvendo Event {carta_path} para a Store")
                    
                    # Remover da lista de Events no inventário
                    if carta_path in self.inventario.get("events", []):
                        self.inventario["events"].remove(carta_path)
                        
                        # Marcar que um Event foi removido para a próxima carta ficar virada para baixo
                        self._event_recently_removed = True
                        print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
                    
                    # Remover do tracking
                    if carta_path in self._event_duration_tracking:
                        del self._event_duration_tracking[carta_path]
                    if carta_path in self._event_start_turns:
                        del self._event_start_turns[carta_path]
                    
                    # Adicionar de volta à Store usando Store_v2
                    try:
                        from Store import adicionar_carta_store
                        adicionar_carta_store(carta_path, "events")
                        print(f"DEBUG: Event {carta_path} devolvido à Store com sucesso")
                    except ImportError:
                        print("DEBUG: Erro - Store_v2 não encontrado")
                    except Exception as e:
                        print(f"DEBUG: Erro ao devolver Event à Store: {e}")
                    
                    # Fechar fullscreen e voltar ao inventário
                    fechar()
                
                red_check_btn.config(command=devolver_event_para_store)

        # Verificar se é uma carta Service expirada
        print(f"DEBUG: [FULLSCREEN_SERVICE] Verificando expiração para carta tipo '{carta_tipo}' - {os.path.basename(carta_path)}")
        if carta_tipo == "services":
            print(f"DEBUG: [FULLSCREEN_SERVICE] É uma carta Service - verificando se está expirada...")
            is_expired = self._is_service_expired(carta_path)
            print(f"DEBUG: [FULLSCREEN_SERVICE] Resultado da verificação de expiração: {is_expired}")
            
            if is_expired:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service EXPIRADO - criando botão vermelho de expiração")
                # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                         bg="#F44336", fg="white", width=2, height=1, 
                                         borderwidth=0, highlightthickness=0, cursor="hand2", 
                                         activebackground="#D32F2F")
                red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                
                def mostrar_overlay_expiracao():
                    print(f"DEBUG: Mostrando overlay de expiração para Service {carta_path}")
                    self._mostrar_overlay_service_expirado(carta_path)
                
                red_check_btn.config(command=mostrar_overlay_expiracao)
                return  # Não criar outros botões se o Service expirou
            else:
                print(f"DEBUG: [FULLSCREEN_SERVICE] Service NÃO expirado - continuando com lógica normal")

    # ===============================
    # SISTEMA DE GESTÃO DE PACOTES
    # ===============================
    
    def _preservar_valores_atuais_barras(self):
        """
        CORREÇÃO CRÍTICA: Preserva os valores atuais das barras de progresso
        antes de iniciar o Final Phase. Este método preserva os valores
        específicos de cada carta individual, não apenas da carta selecionada.
        """
        print("DEBUG: ===== PRESERVANDO VALORES ATUAIS DAS BARRAS =====")
        
        if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
            print("DEBUG: WARNING: Barras de progresso não encontradas para preservação")
            return
        
        if not hasattr(self, 'card_stats'):
            print("DEBUG: WARNING: card_stats não existe, criando...")
            self.card_stats = [
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
                {"To send": 0, "Rxd": 0, "Lost": 0},
            ]
        
        # CORREÇÃO CRÍTICA: Preservar valores únicos para cada carta ativa
        print("DEBUG: INICIANDO preservação individual de cada carta...")
        
        try:
            # ETAPA 1: Capturar valores da carta atualmente selecionada/visível
            carta_selecionada_idx = getattr(self, 'selected_carousel_index', None)
            
            if carta_selecionada_idx is not None:
                # CORREÇÃO PROBLEMA 1: Verificar se barras estão válidas antes de capturar
                try:
                    to_send_selecionada = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_selecionada = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_selecionada = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # CORREÇÃO PROBLEMA 1: Se valores são zeros no primeiro turno, obter da base de dados
                    if to_send_selecionada == 0 and rxd_selecionada == 0 and lost_selecionada == 0:
                        carta_path = self.cards[carta_selecionada_idx]
                        message_size = self._get_card_message_size_from_database(carta_path)
                        to_send_selecionada = message_size
                        print(f"DEBUG: CORREÇÃO PROBLEMA 1 - Carta {carta_selecionada_idx} valores zero detectados")
                        print(f"DEBUG: Usando message_size da base de dados: {message_size}")
                    
                    # Preservar para a carta selecionada
                    if carta_selecionada_idx < len(self.card_stats):
                        self.card_stats[carta_selecionada_idx] = {
                            "To send": to_send_selecionada,
                            "Rxd": rxd_selecionada,
                            "Lost": lost_selecionada
                        }
                        print(f"DEBUG: SUCCESS: Carta selecionada {carta_selecionada_idx} preservada:")
                        print(f"DEBUG:   To send: {to_send_selecionada}, Rxd: {rxd_selecionada}, Lost: {lost_selecionada}")
                except Exception as e:
                    print(f"DEBUG: WARNING: Erro ao capturar valores da carta selecionada: {e}")
            
            # ETAPA 2: Para cartas não selecionadas, preservar valores existentes ou calcular padrões
            print("DEBUG: Verificando outras cartas do carrossel...")
            
            for i, carta_path in enumerate(self.cards):
                if i < len(self.card_stats):
                    carta_basename = os.path.basename(carta_path)
                    
                    # Pular cartas viradas para baixo
                    if carta_basename.startswith("back_card_"):
                        continue
                    
                    # Se esta carta não é a selecionada e ainda não tem valores preservados
                    if i != carta_selecionada_idx:
                        stats_atuais = self.card_stats[i]
                        
                        # CORREÇÃO PROBLEMA 1: Se esta carta ainda não tem valores válidos, calcular da base de dados
                        if (stats_atuais["To send"] == 0 and 
                            stats_atuais["Rxd"] == 0 and 
                            stats_atuais["Lost"] == 0):
                            
                            message_size = self._get_card_message_size_from_database(carta_path)
                            
                            # Valores padrão: carta não processada ainda
                            self.card_stats[i] = {
                                "To send": message_size,  # CORREÇÃO: Usar message_size correto
                                "Rxd": 0,
                                "Lost": 0
                            }
                            print(f"DEBUG: SUCCESS: Carta {i} inicializada com valores padrão da base de dados:")
                            print(f"DEBUG:   To send: {message_size}, Rxd: 0, Lost: 0")
                        else:
                            print(f"DEBUG: SUCCESS: Carta {i} já tem valores preservados:")
                            print(f"DEBUG:   To send: {stats_atuais['To send']}, Rxd: {stats_atuais['Rxd']}, Lost: {stats_atuais['Lost']}")
            
            print("DEBUG: ===== PRESERVAÇÃO INDIVIDUAL CONCLUÍDA =====")
            print(f"DEBUG: Estado final do card_stats:")
            for i, stats in enumerate(self.card_stats):
                carta_nome = os.path.basename(self.cards[i]) if i < len(self.cards) else "N/A"
                print(f"DEBUG:   Carta {i} ({carta_nome}): {stats}")
                
        except Exception as e:
            print(f"DEBUG: ERROR: Erro ao preservar valores das barras: {e}")
            import traceback
            traceback.print_exc()
    
    def _iniciar_gestao_pacotes(self):
        """Inicia o sistema de gestão de pacotes no Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Iniciando sistema de gestão de pacotes")
        
        # NOVO: Verificar se há Data Volume services com pacotes disponíveis
        tem_data_volume_packets = self._has_active_data_volume_services_with_packets()
        print(f"DEBUG: [GESTÃO_PACOTES] Data Volume services com pacotes: {tem_data_volume_packets}")
        
        # DEBUG: Verificar estado do tracking de Challenges antes de iniciar gestão
        self._debug_challenge_tracking_state()
        
        # Encontrar cartas ativas no carrossel
        cartas_ativas = self._obter_cartas_ativas_carrossel()
        print(f"DEBUG: [GESTÃO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        
        # CORREÇÃO: Se não há cartas ativas OU não há Data Volume services com pacotes, não iniciar gestão
        if not cartas_ativas or not tem_data_volume_packets:
            if not cartas_ativas:
                print("DEBUG: [GESTÃO_PACOTES] Nenhuma carta ativa encontrada no carrossel")
            if not tem_data_volume_packets:
                print("DEBUG: [GESTÃO_PACOTES] Nenhum Data Volume service com pacotes disponíveis")
            
            # CORREÇÃO: Garantir que gestão de pacotes não é ativada
            self._final_phase_gestao_ativa = False
            print("DEBUG: [GESTÃO_PACOTES] Flag _final_phase_gestao_ativa definida como False")
            # Se não há cartas ativas ou pacotes disponíveis, ativar botão End Turn imediatamente
            self._ativar_botao_end_turn()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] {len(cartas_ativas)} cartas ativas encontradas e pacotes Data Volume disponíveis")
        
        # IMPORTANTE: Só ativar gestão se realmente há cartas ativas E pacotes disponíveis
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GESTÃO_PACOTES] Flag _final_phase_gestao_ativa ativada (cartas e pacotes encontrados)")
        
        # Inicializar variáveis de controle
        self._cartas_gestao = cartas_ativas
        self._carta_atual_gestao = 0
        self._valores_pacotes = {}  # Armazenar valores enviados/perdidos por carta
        
        # Inicializar valores para cada carta
        for i, carta_path in enumerate(cartas_ativas):
            self._valores_pacotes[i] = {'enviados': 0, 'perdidos': 0}
        
        # Mostrar destaque na primeira carta e controles de gestão
        self._mostrar_gestao_carta_atual()
        
        # NOVO: Remover destaques da cor do jogador e bloquear interações
        self._bloquear_interacoes_carrossel()
    
    def _bloquear_interacoes_carrossel(self):
        """Remove destaques da cor do jogador e bloqueia cliques durante Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Bloqueando interações do carrossel")
        
        # CORREÇÃO 1: Garantir que o destaque roxo seja preservado
        # Verificar qual carta tem destaque roxo antes de remover outros destaques
        carta_roxo_posicao = getattr(self, '_carta_destacada_posicao', None)
        print(f"DEBUG: [GESTÃO_PACOTES] Preservando destaque roxo na posição: {carta_roxo_posicao}")
        
        # Remover TODOS os destaques da cor do jogador das cartas
        # EXCETO a carta que tem destaque roxo (carta de gestão atual)
        if hasattr(self, 'card_labels') and self.card_labels:
            for i, lbl in enumerate(self.card_labels):
                if lbl and lbl.winfo_exists():
                    # Verificar se esta carta é a que tem destaque roxo
                    carta_tem_destaque_roxo = (carta_roxo_posicao is not None and i == carta_roxo_posicao)
                    
                    if not carta_tem_destaque_roxo:
                        # Remover TODOS os tipos de destaque da cor do jogador
                        lbl.config(
                            highlightthickness=0,
                            highlightbackground="black",
                            highlightcolor="black",
                            bg="black",
                            borderwidth=0,
                            relief="flat"
                        )
                        print(f"DEBUG: [GESTÃO_PACOTES] Destaque removido da carta posição {i}")
                    else:
                        print(f"DEBUG: [GESTÃO_PACOTES] Preservando destaque roxo na carta posição {i}")
        
        # Também forçar atualização dos destaques através da função normal
        # que agora já considera o Final Phase
        self._update_carousel_selection_highlights()
        
        # Marcar que estamos em modo Final Phase (para bloquear cliques)
        self._final_phase_gestao_ativa = True
        print("DEBUG: [GESTÃO_PACOTES] Interações do carrossel bloqueadas")
    
    def _desbloquear_interacoes_carrossel(self):
        """Restaura o comportamento normal do carrossel após Final Phase"""
        print("DEBUG: [GESTÃO_PACOTES] Desbloqueando interações do carrossel")
        
        # Desmarcar flag de Final Phase
        self._final_phase_gestao_ativa = False
        
        # Remover destaque roxo se existir
        if hasattr(self, '_carta_destacada_posicao'):
            delattr(self, '_carta_destacada_posicao')
        
        # Restaurar destaques normais das cartas se necessário
        # (Será feito automaticamente quando o usuário navegar no carrossel)
        
        print("DEBUG: [GESTÃO_PACOTES] Interações do carrossel desbloqueadas")
    
    def _restaurar_controles_gestao_apos_fullscreen(self, carta_destacada_posicao):
        """Restaura os controles de gestão após voltar do fullscreen"""
        print(f"DEBUG: [FULLSCREEN] Restaurando controles de gestão após fullscreen")
        
        # Verificar se ainda estamos em gestão ativa
        if not getattr(self, '_final_phase_gestao_ativa', False):
            print(f"DEBUG: [FULLSCREEN] Gestão não está mais ativa - não restaurar controles")
            return
        
        # Verificar se temos dados válidos
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [FULLSCREEN] Dados de gestão inválidos - não restaurar controles")
            return
        
        # Restaurar destaque roxo na posição correta
        if carta_destacada_posicao is not None:
            print(f"DEBUG: [FULLSCREEN] Restaurando destaque roxo na posição {carta_destacada_posicao}")
            self._adicionar_destaque_roxo(carta_destacada_posicao)
        else:
            # Se não temos posição preservada, usar carta atual da gestão
            print(f"DEBUG: [FULLSCREEN] Usando carta atual da gestão para destaque")
            self._mostrar_gestao_carta_atual()
            return
        
        # NOVO: Restaurar valores das barras de progresso antes de mostrar controles
        self._atualizar_barras_gestao_carta_atual()
        
        # CORREÇÃO PROBLEMA 3: Usar estado preservado dos botões + em vez de verificar estado atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        rate_carta = self._obter_rate_carta(carta_atual)
        
        print(f"DEBUG: [FULLSCREEN] Verificando estado preservado dos botões +")
        
        # Verificar se temos estado preservado dos botões + e seta
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        botao_seta_estado = getattr(self, '_botao_seta_estado_preservado', False)
        print(f"DEBUG: [FULLSCREEN] Estado preservado botões +: {botoes_plus_estado}")
        print(f"DEBUG: [FULLSCREEN] Estado preservado botão seta: {botao_seta_estado}")
        
        # CORREÇÃO CRÍTICA: Usar valores específicos dos botões individuais
        btn_rxd_estava_visivel = botoes_plus_estado.get('rxd_visivel', False)
        btn_lost_estava_visivel = botoes_plus_estado.get('lost_visivel', False)
        
        # Se qualquer botão + estava visível antes do fullscreen, restaurá-los especificamente
        if btn_rxd_estava_visivel or btn_lost_estava_visivel:
            print(f"DEBUG: [FULLSCREEN] Botões + estavam visíveis - restaurar controles específicos")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Rxd: {btn_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   Restaurar btn Lost: {btn_lost_estava_visivel}")
            
            # NOVA FUNÇÃO: Restaurar apenas os botões específicos que estavam visíveis
            self._mostrar_controles_gestao_especificos(rate_carta, 
                                                     mostrar_rxd=btn_rxd_estava_visivel,
                                                     mostrar_lost=btn_lost_estava_visivel)
            print(f"DEBUG: [FULLSCREEN] Botões + específicos restaurados")
        else:
            print(f"DEBUG: [FULLSCREEN] Botões + não estavam visíveis - verificar se botão seta estava visível")
            # Se botão seta estava visível antes do fullscreen, restaurá-lo
            if botao_seta_estado:
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível - restaurar apenas botão seta")
                self._mostrar_botao_seta()
            else:
                print(f"DEBUG: [FULLSCREEN] Nem botões + nem botão seta estavam visíveis - não restaurar controles")
            
        # Limpar estado preservado após usar
        if hasattr(self, '_botoes_plus_estado_preservado'):
            delattr(self, '_botoes_plus_estado_preservado')
        if hasattr(self, '_botao_seta_estado_preservado'):
            delattr(self, '_botao_seta_estado_preservado')
        
        print(f"DEBUG: [FULLSCREEN] Restauração de controles de gestão concluída")
    
    def _obter_cartas_ativas_carrossel(self):
        """Obtém lista de cartas ativas (viradas para cima) no carrossel"""
        cartas_ativas = []
        
        # Verificar cada posição do carrossel usando self.cards
        for i in range(len(self.cards)):
            carta_path = self.cards[i]
            
            # Verificar se não é uma carta virada para baixo (back_card)
            if carta_path and "back_card" not in carta_path:
                carta_basename = os.path.basename(carta_path).lower()
                
                # CORREÇÃO: Para Activities e Challenges no carrossel, considerar ativas se estão viradas para cima
                # Para outros tipos de cartas, verificar as listas de cartas ativas
                carta_esta_ativa = False
                
                if "activity" in carta_basename or "challenge" in carta_basename:
                    # Activities e Challenges no carrossel são consideradas ativas se estão viradas para cima
                    carta_esta_ativa = True
                    print(f"DEBUG: [GESTÃO_PACOTES] Activity/Challenge virada para cima posição {i}: {os.path.basename(carta_path)}")
                else:
                    # Para outros tipos (Users, Equipments, Services), verificar listas de cartas ativas
                    if (carta_path in getattr(self, 'active_users', []) or
                        carta_path in getattr(self, 'active_equipments', []) or 
                        carta_path in getattr(self, 'active_services', []) or
                        carta_path == getattr(self, 'active_challenge', None)):
                        carta_esta_ativa = True
                        print(f"DEBUG: [GESTÃO_PACOTES] Carta ativa nas listas posição {i}: {os.path.basename(carta_path)}")
                
                # Só adicionar se estiver ativa E o jogador puder acessar a posição
                if carta_esta_ativa and self._can_access_carousel_position(i):
                    cartas_ativas.append(carta_path)
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Carta ATIVA posição {i}: {os.path.basename(carta_path)}")
                elif carta_esta_ativa:
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta ativa mas sem acesso à posição {i}: {os.path.basename(carta_path)}")
                else:
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta na posição {i} não está ativa: {os.path.basename(carta_path)}")
        
        print(f"DEBUG: [GESTÃO_PACOTES] Total de cartas ativas encontradas: {len(cartas_ativas)}")
        return cartas_ativas
    
    def _mostrar_gestao_carta_atual(self):
        """Mostra destaque roxo na carta atual e controles de gestão"""
        
        print(f"DEBUG: [GESTÃO_PACOTES] === INICIANDO _mostrar_gestao_carta_atual ===")
        
        # VERIFICAÇÃO ADICIONAL: Se não há cartas em gestão, finalizar imediatamente
        if not hasattr(self, '_cartas_gestao') or not self._cartas_gestao:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Lista de cartas gestão vazia ou inexistente")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Estado atual da gestão:")
        print(f"DEBUG: [GESTÃO_PACOTES]   _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
        print(f"DEBUG: [GESTÃO_PACOTES]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [GESTÃO_PACOTES]   _cartas_gestao: {[os.path.basename(c) if c else 'None' for c in self._cartas_gestao]}")
        
        # CORREÇÃO CRÍTICA: Verificar se índice atual está dentro dos limites
        if not hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print(f"DEBUG: [GESTÃO_PACOTES] WARNING: _carta_atual_gestao não existia, inicializado como 0")
            
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            # NOVA FUNCIONALIDADE: Todas as cartas foram processadas - enable End Turn
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Todas as cartas processadas - habilitando End Turn")
            print(f"DEBUG: [GESTÃO_PACOTES] Índice atual ({self._carta_atual_gestao}) >= tamanho da lista ({len(self._cartas_gestao)})")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando gestão para carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)}")
        
        # Encontrar posição da carta atual no carrossel
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        posicao_carta = None
        
        # VERIFICAÇÃO ADICIONAL: Se a carta atual é None ou vazia
        if not carta_atual:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Carta atual na gestão é None ou vazia")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA: Se a carta atual é um back_card, todas as cartas foram processadas
        carta_basename = os.path.basename(carta_atual).lower()
        if carta_basename.startswith("back_card_"):
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Carta atual é back_card: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Isto indica que todas as cartas ativas foram removidas")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA ADICIONAL: Se a carta não é Activity ou Challenge, finalizar
        if not ("activity" in carta_basename or "challenge" in carta_basename):
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Carta atual não é Activity nem Challenge: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        # VERIFICAÇÃO CRÍTICA ADICIONAL: Se carta não existe no carrossel atual, finalizar
        if hasattr(self, 'cards') and carta_atual not in self.cards:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Carta atual não existe no carrossel atual: {carta_basename}")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão de pacotes automaticamente")
            self._finalizar_gestao_pacotes()
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Procurando carta atual no carrossel: {os.path.basename(carta_atual)}")
        
        # NOVA FUNCIONALIDADE: Verificar flags de estado das cartas
        if hasattr(self, 'card_face_up_flags'):
            print(f"DEBUG: [GESTÃO_PACOTES] Estados das cartas (flags): {self.card_face_up_flags}")
        
        for i in range(len(self.cards)):
            if self.cards[i] == carta_atual:
                posicao_carta = i
                print(f"DEBUG: [GESTÃO_PACOTES] Carta encontrada na posição {i} do carrossel")
                
                # NOVA FUNCIONALIDADE: Verificar se a carta está virada para cima usando flags
                if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                    is_face_up = self.card_face_up_flags[i]
                    print(f"DEBUG: [GESTÃO_PACOTES] Carta na posição {i} virada para cima: {is_face_up}")
                    
                    if not is_face_up:
                        print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Carta na posição {i} está virada para baixo")
                        print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Isto indica que a carta foi completada e removida")
                        print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Removendo carta inválida da gestão e continuando")
                        
                        # Remover carta inválida da lista de gestão
                        self._cartas_gestao.remove(carta_atual)
                        
                        # Se não há mais cartas, finalizar
                        if not self._cartas_gestao:
                            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão - nenhuma carta válida restante")
                            self._finalizar_gestao_pacotes()
                        else:
                            # Ajustar índice se necessário e continuar com próxima carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                self._carta_atual_gestao = 0
                            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Continuando com próxima carta válida")
                            self._mostrar_gestao_carta_atual()
                        return
                break
        
        if posicao_carta is None:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Carta {os.path.basename(carta_atual)} não encontrada no carrossel")
            print(f"DEBUG: [GESTÃO_PACOTES] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Removendo carta inválida da gestão e continuando")
            
            # Remover carta inválida da lista de gestão
            self._cartas_gestao.remove(carta_atual)
            
            # Se não há mais cartas, finalizar
            if not self._cartas_gestao:
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão - nenhuma carta válida restante")
                self._finalizar_gestao_pacotes()
                return
            
            # Tentar próxima carta
            self._mostrar_gestao_carta_atual()
            return
        
        # CORREÇÃO CRÍTICA: Verificar se a carta atual é uma carta virada para baixo
        if posicao_carta is not None and carta_atual:
            carta_basename = os.path.basename(carta_atual).lower()
            if carta_basename.startswith("back_card_"):
                print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO CRÍTICO: Tentativa de aplicar gestão à carta virada para baixo: {carta_basename}")
                print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Isto indica que todas as cartas ativas foram processadas")
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Finalizando gestão de pacotes automaticamente")
                self._finalizar_gestao_pacotes()
                return
        
        # NOVA FUNCIONALIDADE: Garantir que End Turn permanece disabled enquanto há cartas para processar
        print(f"DEBUG: [GESTÃO_PACOTES] Ainda há cartas para processar - mantendo End Turn disabled")
        self._manter_end_turn_disabled()
        
        # Remover destaque anterior
        self._remover_destaque_roxo()
        
        if posicao_carta is not None:
            # CORREÇÃO 1: Adicionar destaque roxo ANTES de qualquer outra operação
            self._adicionar_destaque_roxo(posicao_carta)
            
            # CORREÇÃO CRÍTICA: Ajustar selected_carousel_index para corresponder à carta com destaque roxo
            # Isso garante que ao voltar do fullscreen, a seleção esteja correta
            print(f"DEBUG: [GESTÃO_PACOTES] Ajustando selected_carousel_index para posição {posicao_carta}")
            self.selected_carousel_index = posicao_carta
            self.selected_carousel_card = carta_atual
            
            # CORREÇÃO CRÍTICA: Forçar atualização dos destaques após ajustar índice
            print(f"DEBUG: [GESTÃO_PACOTES] Forçando atualização de destaques para carta {posicao_carta}")
            self._update_carousel_selection_highlights()
            
            # Obter dados da carta para determinar rate
            rate_carta = self._obter_rate_carta(carta_atual)
            
            # NOVO: Atualizar barras de progresso com valores salvos da carta atual
            self._atualizar_barras_gestao_carta_atual()
            
            # Mostrar controles de gestão
            self._mostrar_controles_gestao(rate_carta)
            
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Gestão configurada para carta {os.path.basename(carta_atual)} na posição {posicao_carta}")
            
            # CORREÇÃO: Botão seta só aparece quando há controles de gestão visíveis
            # (será mostrado dentro de _mostrar_controles_gestao se necessário)
    
    def _adicionar_destaque_roxo(self, posicao):
        """Adiciona destaque roxo à volta da carta especificada"""
        print(f"DEBUG: [GESTÃO_PACOTES] Adicionando destaque roxo à carta posição {posicao}")
        
        # Remover destaque anterior se existir
        self._remover_destaque_roxo()
        
        # Verificar se temos card_labels e se a posição é válida
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: [GESTÃO_PACOTES] card_labels não disponível para destaque")
            return
        
        if posicao >= len(self.card_labels):
            print(f"DEBUG: [GESTÃO_PACOTES] Posição {posicao} inválida (máx: {len(self.card_labels)-1})")
            return
        
        # Obter widget da carta
        carta_widget = self.card_labels[posicao]
        
        if carta_widget and carta_widget.winfo_exists():
            # CORREÇÃO CRÍTICA: Aplicar destaque roxo diretamente
            carta_widget.config(
                bg="#800080",  # Fundo roxo
                highlightbackground="#800080",  # Cor roxa da borda
                highlightcolor="#800080",
                highlightthickness=3  # Espessura da borda
            )
            
            # Guardar referência para remoção posterior
            self._carta_destacada = carta_widget
            # CORREÇÃO: Guardar também a posição para verificação de clique
            self._carta_destacada_posicao = posicao
            
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Destaque roxo aplicado à carta {posicao}")
            print(f"DEBUG: [GESTÃO_PACOTES] Widget configurado: bg='{carta_widget.cget('bg')}', highlightthickness={carta_widget.cget('highlightthickness')}")
        else:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Widget da carta {posicao} não disponível")
    
    def _remover_destaque_roxo(self):
        """Remove o destaque roxo atual"""
        print("DEBUG: [GESTÃO_PACOTES] === REMOVENDO DESTAQUE ROXO ===")
        
        if hasattr(self, '_carta_destacada') and self._carta_destacada:
            try:
                # Remover destaque roxo da carta
                self._carta_destacada.config(
                    bg="black",  # Voltar ao fundo preto
                    highlightbackground="black",  # Remover borda
                    highlightcolor="black",
                    highlightthickness=0  # Remover espessura da borda
                )
                print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Destaque roxo removido da carta específica")
                self._carta_destacada = None
            except Exception as e:
                print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Erro ao remover destaque roxo: {e}")
        
        # CORREÇÃO: Limpar também a posição destacada
        if hasattr(self, '_carta_destacada_posicao'):
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Limpando posição destacada: {self._carta_destacada_posicao}")
            self._carta_destacada_posicao = None
        
        # Limpar frame_destaque se ainda existir (fallback)
        if hasattr(self, '_frame_destaque') and self._frame_destaque:
            try:
                self._frame_destaque.destroy()
                self._frame_destaque = None
                print("DEBUG: [GESTÃO_PACOTES] SUCCESS: frame_destaque removido")
            except:
                pass
        
        # CORREÇÃO ADICIONAL: Remover destaque roxo de TODAS as cartas do carrossel
        # para garantir que não fica nenhum destaque residual
        if hasattr(self, 'card_labels') and self.card_labels:
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Limpando destaque roxo de todas as cartas do carrossel")
            for i, lbl in enumerate(self.card_labels):
                if lbl and hasattr(lbl, 'winfo_exists'):
                    try:
                        if lbl.winfo_exists():
                            # Verificar se tem destaque roxo e remover
                            current_bg = lbl.cget('bg')
                            current_thickness = lbl.cget('highlightthickness')
                            
                            if current_bg == "#800080" or current_thickness == 3:
                                lbl.config(
                                    bg="black",
                                    highlightbackground="black",
                                    highlightcolor="black", 
                                    highlightthickness=0
                                )
                                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Destaque roxo removido da carta {i}")
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] WARNING: Erro ao limpar carta {i}: {e}")
        
        print("DEBUG: [GESTÃO_PACOTES] === DESTAQUE ROXO COMPLETAMENTE REMOVIDO ===")
    
    def _obter_dados_carta(self, carta_path):
        """Obtém dados da carta (rate e drops_allowed) da base de dados"""
        try:
            if not hasattr(self, 'card_database') or not self.card_database:
                print(f"DEBUG: [GESTÃO_PACOTES] Database não disponível, usando fallback")
                return {
                    'rate': 20, 
                    'rate_options': list(range(21)), 
                    'drops_allowed': True,
                    'message_size': 20,
                    'message_received': 50
                }
            
            carta_basename = os.path.basename(carta_path).lower()
            print(f"DEBUG: [GESTÃO_PACOTES] Obtendo dados para carta: {carta_basename}")
            
            if "activity" in carta_basename:
                # Extrair número da activity
                import re
                match = re.search(r'activity_(\d+)', carta_basename)
                if match:
                    activity_num = int(match.group(1))
                    activity_id = f"activity_{activity_num}_{self.player_color.lower()}"
                    print(f"DEBUG: [GESTÃO_PACOTES] Procurando activity com ID: {activity_id}")
                    
                    activity_card = self.card_database.get_activity(activity_id)
                    if activity_card:
                        # Obter rate e rate_options
                        if hasattr(activity_card, 'rate'):
                            if isinstance(activity_card.rate, list):
                                rate_max = max(activity_card.rate)
                                rate_options = activity_card.rate
                            else:
                                rate_max = activity_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 20
                            rate_options = list(range(21))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(activity_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se botão Lost deve aparecer
                        penalty_per_packet = getattr(activity_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_received para completion
                        message_size = getattr(activity_card, 'message_size', rate_max)
                        message_received = getattr(activity_card, 'message_received', 0)
                        
                        # CORREÇÃO: Obter parâmetros de recompensa para Activities
                        reward_per_packet = getattr(activity_card, 'reward_per_packet', 0)
                        min_packets_bonus = getattr(activity_card, 'min_packets_bonus', 0)
                        lost_penalty_per_packet = getattr(activity_card, 'lost_penalty_per_packet', 0)
                        
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity reward_per_packet: {reward_per_packet}, min_packets_bonus: {min_packets_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Activity lost_penalty_per_packet: {lost_penalty_per_packet}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'reward_per_packet': reward_per_packet,
                            'min_packets_bonus': min_packets_bonus,
                            'lost_penalty_per_packet': lost_penalty_per_packet
                        }
            
            elif "challenge" in carta_basename:
                # Extrair número do challenge
                import re
                match = re.search(r'challenge_(\d+)', carta_basename)
                if match:
                    challenge_num = int(match.group(1))
                    challenge_id = f"challenge_{challenge_num}"
                    print(f"DEBUG: [GESTÃO_PACOTES] Procurando challenge com ID: {challenge_id}")
                    
                    challenge_card = self.card_database.get_challenge(challenge_id)
                    if challenge_card:
                        # Obter rate e rate_options
                        if hasattr(challenge_card, 'rate'):
                            if isinstance(challenge_card.rate, list):
                                rate_max = max(challenge_card.rate)
                                rate_options = challenge_card.rate
                            else:
                                rate_max = challenge_card.rate
                                rate_options = list(range(rate_max + 1))
                        else:
                            rate_max = 25
                            rate_options = list(range(26))
                        
                        # Obter drops_allowed
                        drops_allowed = getattr(challenge_card, 'drops_allowed', True)
                        
                        # Obter penalty_per_packet para verificar se botão Lost deve aparecer (Challenges geralmente não têm)
                        penalty_per_packet = getattr(challenge_card, 'penalty_per_packet', None)
                        
                        # Obter message_size e message_bonus para completion
                        message_size = getattr(challenge_card, 'message_size', rate_max)
                        
                        # CORREÇÃO: Obter parâmetros corretos da base de dados
                        n_turns = getattr(challenge_card, 'n_turns', 0)  # CORREÇÃO: Adicionar n_turns
                        time_limit = getattr(challenge_card, 'time_limit', 0)
                        time_limit_bonus = getattr(challenge_card, 'time_limit_bonus', 0)
                        message_received = getattr(challenge_card, 'message_bonus', 0)  # Field correto
                        reward_per_packet = getattr(challenge_card, 'reward_per_packet', 0)
                        message_received_bonus = getattr(challenge_card, 'message_received_bonus', 0)  # CORREÇÃO: Field correto para JACKPOT
                        
                        # CORREÇÃO: Obter challenge_quit_fee
                        challenge_quit_fee = getattr(challenge_card, 'challenge_quit_fee', 0)
                        
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge rate: {rate_max}, options: {rate_options}, drops_allowed: {drops_allowed}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge penalty_per_packet: {penalty_per_packet}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge message_size: {message_size}, message_received: {message_received}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge n_turns: {n_turns}")  # CORREÇÃO: Debug n_turns
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge time_limit: {time_limit}, time_limit_bonus: {time_limit_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge reward_per_packet: {reward_per_packet}, message_received_bonus: {message_received_bonus}")
                        print(f"DEBUG: [GESTÃO_PACOTES] Challenge challenge_quit_fee: {challenge_quit_fee}")
                        return {
                            'rate': rate_max,
                            'rate_options': rate_options,
                            'drops_allowed': drops_allowed,
                            'penalty_per_packet': penalty_per_packet,
                            'message_size': message_size,
                            'message_received': message_received,
                            'n_turns': n_turns,  # CORREÇÃO: Adicionar n_turns ao retorno
                            'time_limit': time_limit,
                            'time_limit_bonus': time_limit_bonus,
                            'reward_per_packet': reward_per_packet,
                            'message_received_bonus': message_received_bonus,
                            'challenge_quit_fee': challenge_quit_fee
                        }
            
            # Fallback baseado no tipo de carta
            if "activity" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Activity_', '').replace('.png', '')
                try:
                    rate_fallback = max(10, int(num) % 30 + 10)
                    print(f"DEBUG: [GESTÃO_PACOTES] Fallback Activity rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 50
                    }
                except:
                    print(f"DEBUG: [GESTÃO_PACOTES] Erro no fallback Activity, usando 20")
                    return {
                        'rate': 20, 
                        'rate_options': list(range(21)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 20,
                        'message_received': 50
                    }
                    
            elif "challenge" in carta_basename:
                nome_arquivo = os.path.basename(carta_path)
                num = nome_arquivo.replace('Challenge_', '').replace('.png', '')
                try:
                    rate_fallback = max(15, int(num) % 40 + 15)
                    print(f"DEBUG: [GESTÃO_PACOTES] Fallback Challenge rate: {rate_fallback}")
                    return {
                        'rate': rate_fallback,
                        'rate_options': list(range(rate_fallback + 1)),
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': rate_fallback,
                        'message_received': 100
                    }
                except:
                    print(f"DEBUG: [GESTÃO_PACOTES] Erro no fallback Challenge, usando 25")
                    return {
                        'rate': 25, 
                        'rate_options': list(range(26)), 
                        'drops_allowed': True,
                        'penalty_per_packet': None,
                        'message_size': 25,
                        'message_received': 100
                    }
            
            # Fallback final
            print(f"DEBUG: [GESTÃO_PACOTES] Fallback final: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }
            
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] Erro ao obter dados da carta: {e}")
            print(f"DEBUG: [GESTÃO_PACOTES] Fallback de emergência: usando rate 20")
            return {
                'rate': 20, 
                'rate_options': list(range(21)), 
                'drops_allowed': True,
                'penalty_per_packet': None,
                'message_size': 20,
                'message_received': 50
            }

    def _obter_rate_carta(self, carta_path):
        """Obtém o rate máximo da carta (Activities/Challenges)"""
        print(f"DEBUG: [GESTÃO_PACOTES] === OBTENDO RATE DA CARTA ===")
        print(f"DEBUG: [GESTÃO_PACOTES] Carta: {os.path.basename(carta_path)}")
        
        # Usar a nova função que obtém dados completos
        dados = self._obter_dados_carta(carta_path)
        return dados['rate']
    
    def _mostrar_controles_gestao(self, rate_max):
        """Mostra controles + para Rxd e Lost posicionados entre labels e barras"""
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando controles para rate máximo: {rate_max}")
        
        # Limpar controles anteriores
        self._remover_controles_gestao()
        
        # Obter valores atuais
        valores_atuais = self._valores_pacotes[self._carta_atual_gestao]
        
        # Obter dados da carta atual para verificar drops_allowed e penalty_per_packet
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        drops_allowed = dados_carta['drops_allowed']
        penalty_per_packet = dados_carta.get('penalty_per_packet', None)
        rate_options = dados_carta['rate_options']
        
        # CORREÇÃO: Determinar tipo da carta para aplicar lógica específica
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        print(f"DEBUG: [GESTÃO_PACOTES] Carta: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [GESTÃO_PACOTES] Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [GESTÃO_PACOTES] Drops allowed: {drops_allowed}")
        print(f"DEBUG: [GESTÃO_PACOTES] Penalty per packet: {penalty_per_packet}")
        print(f"DEBUG: [GESTÃO_PACOTES] Rate options: {rate_options}")
        
        # CORREÇÃO CRÍTICA: Regras específicas para Challenges vs Activities
        if is_challenge:
            # Para Challenges: Lost é permitido se há penalty_per_packet OU drops_allowed=True
            mostrar_botao_lost = drops_allowed or (penalty_per_packet is not None)
            print(f"DEBUG: [GESTÃO_PACOTES] Challenge - Mostrar botão Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   - drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
        else:
            # Para Activities: Lost é permitido se drops_allowed=True OU há penalty_per_packet específico
            mostrar_botao_lost = drops_allowed or (penalty_per_packet is not None)
            print(f"DEBUG: [GESTÃO_PACOTES] Activity - Mostrar botão Lost: {mostrar_botao_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   - drops_allowed ({drops_allowed}) OU penalty_per_packet existe ({penalty_per_packet is not None})")
        
        print(f"DEBUG: [GESTÃO_PACOTES] DECISÃO FINAL - Mostrar botão Lost: {mostrar_botao_lost}")
        
        # Encontrar as barras de progresso Rxd e Lost
        if not hasattr(self, 'progress_bars'):
            print("DEBUG: [GESTÃO_PACOTES] Barras de progresso não encontradas")
            return
        
        # CORREÇÃO CRÍTICA: Remover explicitamente o botão seta quando criamos botões +
        # Isso garante que quando há botões +, não há botão seta visível
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta antes de criar botões +")
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # CORREÇÃO: Sempre criar botões + independentemente dos valores atuais
        # Os botões + devem aparecer sempre para permitir modificações
        
        # Criar botão + para Rxd (sempre disponível)
        if "Rxd" in self.progress_bars:
            rxd_bar = self.progress_bars["Rxd"]
            
            # Posicionar botão + à esquerda da barra Rxd
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            
            # Posicionar o botão entre o label Rxd e a barra
            # Assumindo que a barra está em rely=0.77 e o label um pouco acima
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [GESTÃO_PACOTES] Botão + Rxd criado")
        else:
            self._btn_plus_rxd = None
            
        # Criar botão + para Lost baseado na nova regra
        if mostrar_botao_lost and "Lost" in self.progress_bars:
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            
            # Posicionar o botão entre o label Lost e sua barra
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            
            print("DEBUG: [GESTÃO_PACOTES] Botão + Lost criado")
        else:
            self._btn_plus_lost = None
            if not mostrar_botao_lost:
                print("DEBUG: [GESTÃO_PACOTES] Botão + Lost NÃO criado - condições não atendidas (drops_allowed=False e penalty_per_packet=None)")
            else:
                print("DEBUG: [GESTÃO_PACOTES] Botão + Lost deveria ter sido criado mas não foi encontrada barra Lost")
        
        # CORREÇÃO: Confirmar que botão seta foi removido quando botões + são criados
        print("DEBUG: [GESTÃO_PACOTES] Botões + criados - botão seta removido para evitar conflito")
    
    def _mostrar_controles_gestao_sem_seta(self, rate_max):
        """Versão especial para restauração após fullscreen - cria botões + sem mexer no botão seta"""
        print(f"DEBUG: [FULLSCREEN] Criando botões + sem afetar botão seta (rate máximo: {rate_max})")
        
        # IMPORTANTE: NÃO chamar _remover_controles_gestao para evitar criar botão seta
        
        # Remover apenas os botões + se existirem (sem afetar seta)
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORREÇÃO: Usar estado preservado para decidir quais botões + recriar
        botoes_plus_estado = getattr(self, '_botoes_plus_estado_preservado', {})
        print(f"DEBUG: [FULLSCREEN] Estado preservado dos botões +: {botoes_plus_estado}")
        
        # Obter dados da carta atual
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        dados_carta = self._obter_dados_carta(carta_atual)
        rate_options = dados_carta['rate_options']
        
        # Recriar APENAS os botões + que estavam visíveis antes do fullscreen
        if botoes_plus_estado.get('rxd_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando botão + Rxd (estava visível)")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
            print("DEBUG: [FULLSCREEN] Botão + Rxd recriado")
        else:
            print("DEBUG: [FULLSCREEN] Botão + Rxd NÃO recriado - não estava visível")
        
        # Recriar botão + Lost apenas se estava visível
        if botoes_plus_estado.get('lost_visivel', False):
            print("DEBUG: [FULLSCREEN] Recriando botão + Lost (estava visível)")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
            print("DEBUG: [FULLSCREEN] Botão + Lost recriado")
        else:
            print("DEBUG: [FULLSCREEN] Botão + Lost NÃO recriado - não estava visível")
        
        # IMPORTANTE: Garantir que o botão seta é removido se existe
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                self._btn_seta.destroy()
                self._btn_seta = None
                print("DEBUG: [FULLSCREEN] Botão seta removido após criar botões +")
            except Exception as e:
                print(f"DEBUG: [FULLSCREEN] Erro ao remover botão seta: {e}")
        
        print("DEBUG: [FULLSCREEN] Botões + recriados baseado no estado preservado")
    
    def _mostrar_controles_gestao_especificos(self, rate_max, mostrar_rxd=False, mostrar_lost=False):
        """Nova função para restaurar controles específicos baseado nas flags salvas"""
        print(f"DEBUG: [ESTADO] Criando controles específicos: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
        
        # Remover controles existentes
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
            
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Obter dados da carta atual
        if (hasattr(self, 'cards') and self.cards and 
            self._carta_atual_gestao < len(self.cards)):
            carta_atual = self.cards[self._carta_atual_gestao]
            dados_carta = self._obter_dados_carta(carta_atual)
            rate_options = dados_carta['rate_options']
        else:
            rate_options = [1, 2, 5, 10]  # valores padrão
        
        # Criar APENAS os botões solicitados
        if mostrar_rxd:
            print("DEBUG: [ESTADO] Criando botão + Rxd")
            self._btn_plus_rxd = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('enviados', rate_options)
            )
            self._btn_plus_rxd.place(relx=0.175, rely=0.8, anchor="center")
        
        if mostrar_lost:
            print("DEBUG: [ESTADO] Criando botão + Lost")
            self._btn_plus_lost = tk.Button(
                self,
                text="+",
                bg="#8B5CF6",  # Cor roxa
                fg="white", 
                font=("Helvetica", 10, "bold"),
                width=1,
                height=1,
                command=lambda: self._mostrar_overlay_entrada('perdidos', rate_options)
            )
            self._btn_plus_lost.place(relx=0.175, rely=0.865, anchor="center")
        
        print(f"DEBUG: [ESTADO] Controles específicos criados: Rxd={mostrar_rxd}, Lost={mostrar_lost}")
        
        # CORREÇÃO CRÍTICA: Se nenhum botão foi criado, verificar se deve finalizar gestão
        if not mostrar_rxd and not mostrar_lost:
            print("DEBUG: [ESTADO] ALERTA: Nenhum botão de gestão foi criado")
            
            # CORREÇÃO: Usar mesma lógica correta para verificar próxima carta
            carta_atual_index = getattr(self, '_carta_atual_gestao', 0)
            total_cartas = len(getattr(self, '_cartas_gestao', []))
            proxima_carta_index = carta_atual_index + 1
            
            print(f"DEBUG: [ESTADO] Análise de cartas:")
            print(f"DEBUG: [ESTADO]   Carta atual (índice): {carta_atual_index}")
            print(f"DEBUG: [ESTADO]   Total de cartas: {total_cartas}")
            print(f"DEBUG: [ESTADO]   Próxima carta (índice): {proxima_carta_index}")
            
            if proxima_carta_index < total_cartas:
                print("DEBUG: [ESTADO] Há próxima carta - criando botão seta para continuar")
                self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
            else:
                print("DEBUG: [ESTADO] SUCCESS: Última carta processada - FINALIZANDO GESTÃO AUTOMATICAMENTE")
                print("DEBUG: [ESTADO] SUCCESS: Sistema detectou conclusão automática da gestão de pacotes")
                # Agendar finalização para após a interface estar pronta
                self.after(100, self._finalizar_gestao_pacotes)
                return
    
    def _verificar_e_mostrar_botao_seta_se_necessario(self):
        """
        Verifica se todos os botões + foram removidos e se deve mostrar o botão seta
        CORREÇÃO: Agora verifica se os widgets existem E estão visíveis, não apenas se os atributos existem
        """
        print("DEBUG: [GESTÃO_PACOTES] === VERIFICAÇÃO AUTOMÁTICA DO BOTÃO SETA ===")
        
        # CORREÇÃO: Verificar se os botões existem E estão visíveis na interface
        def botao_esta_visivel(botao):
            try:
                return (botao is not None and 
                        hasattr(botao, 'winfo_exists') and 
                        botao.winfo_exists() and 
                        hasattr(botao, 'winfo_ismapped') and 
                        botao.winfo_ismapped())
            except (tk.TclError, AttributeError):
                return False
        
        btn_rxd_visivel = (hasattr(self, '_btn_plus_rxd') and 
                          botao_esta_visivel(self._btn_plus_rxd))
        btn_lost_visivel = (hasattr(self, '_btn_plus_lost') and 
                           botao_esta_visivel(self._btn_plus_lost))
        btn_seta_visivel = (hasattr(self, '_btn_seta') and 
                           botao_esta_visivel(self._btn_seta))
        
        print(f"DEBUG: [GESTÃO_PACOTES] Estado atual dos botões (visibilidade real):")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão + Rxd visível: {btn_rxd_visivel}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão + Lost visível: {btn_lost_visivel}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Botão seta visível: {btn_seta_visivel}")
        
        # REGRA CORRIGIDA: Só mostrar botão seta se NENHUM botão + está visível E não há botão seta visível
        if not btn_rxd_visivel and not btn_lost_visivel and not btn_seta_visivel:
            print("DEBUG: [GESTÃO_PACOTES] Não há botões + visíveis - verificando se há mais cartas")
            
            # PROTEÇÃO CRÍTICA: Verificar se gestão ainda está ativa antes de processar
            if not getattr(self, '_final_phase_gestao_ativa', False):
                print("DEBUG: [GESTÃO_PACOTES] WARNING: Gestão não está ativa - ignorando verificação")
                return
            
            # CORREÇÃO: Sempre mostrar botão seta após processar carta
            # O usuário deve clicar no botão seta para avançar ou finalizar
            carta_atual_index = getattr(self, '_carta_atual_gestao', 0)
            total_cartas = len(getattr(self, '_cartas_gestao', []))
            proxima_carta_index = carta_atual_index + 1
            
            print(f"DEBUG: [GESTÃO_PACOTES] Análise de cartas:")
            print(f"DEBUG: [GESTÃO_PACOTES]   Carta atual (índice): {carta_atual_index}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Total de cartas: {total_cartas}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Próxima carta (índice): {proxima_carta_index}")
            
            # SEMPRE mostrar botão seta - deixar o usuário decidir quando avançar/finalizar
            if proxima_carta_index < total_cartas:
                print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Há próxima carta - criando botão seta para continuar")
            else:
                print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Última carta - criando botão seta para finalizar")
            
            self._mostrar_botao_seta()
        elif btn_seta_visivel:
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Botão seta já visível - nada a fazer")
        elif btn_rxd_visivel or btn_lost_visivel:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: BLOQUEADO - ainda há botões + visíveis na interface")
            # CORREÇÃO CRÍTICA: Se há botões + visíveis mas há botão seta, remover o botão seta
            if btn_seta_visivel:
                print("DEBUG: [GESTÃO_PACOTES] WARNING: Removendo botão seta incorretamente visível")
                try:
                    self._btn_seta.destroy()
                    self._btn_seta = None
                except:
                    pass
        else:
            print(f"DEBUG: [GESTÃO_PACOTES] NEUTRAL: Estado indeterminado - mantendo como está")
        
        print("DEBUG: [GESTÃO_PACOTES] === FIM VERIFICAÇÃO AUTOMÁTICA DO BOTÃO SETA ===")
    
    
    
    def _mostrar_overlay_entrada(self, tipo, rate_options):
        """Mostra overlay com botões baseados nas opções de rate da carta"""
        print(f"DEBUG: [GESTÃO_PACOTES] Mostrando overlay para {tipo} com rate_options {rate_options}")
        
        # PROTEÇÃO: Fechar overlay anterior se existir
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            print("DEBUG: [OVERLAY] Fechando overlay anterior antes de criar novo...")
            try:
                self._overlay_entrada.destroy()
            except:
                pass
            self._overlay_entrada = None
        
        # Criar overlay semi-transparente
        self._overlay_entrada = tk.Toplevel(self)
        self._overlay_entrada.title("")
        self._overlay_entrada.configure(bg="black")
        self._overlay_entrada.overrideredirect(True)
        self._overlay_entrada.attributes("-alpha", 0.9)
        self._overlay_entrada.attributes("-topmost", True)  # Garantir que fica por cima
        self._overlay_entrada.transient(self)  # Garantir que é modal
        
        # Centralizar overlay
        overlay_width = 300
        overlay_height = 200
        x = (self.screen_width - overlay_width) // 2
        y = (self.screen_height - overlay_height) // 2
        self._overlay_entrada.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal do overlay
        main_frame = tk.Frame(self._overlay_entrada, bg="black", highlightbackground="#8B5CF6", highlightthickness=3)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Título
        titulo_tipo = "Rxd" if tipo == "enviados" else "Lost"
        titulo_label = tk.Label(
            main_frame,
            text=f"Inserir {titulo_tipo}:",
            fg="white",
            bg="black",
            font=("Helvetica", 14, "bold")
        )
        titulo_label.pack(pady=10)
        
        # Frame para botões
        botoes_frame = tk.Frame(main_frame, bg="black")
        botoes_frame.pack(pady=20)
        
        # Determinar quais botões mostrar baseado nas opções de rate da carta
        # Use os valores específicos da base de dados ou o range completo se for uma lista simples
        if isinstance(rate_options, list) and len(rate_options) > 0:
            # Se temos uma lista específica de valores, usar essa lista
            botoes_values = sorted(rate_options)
            # CORREÇÃO: Para Lost (perdidos), sempre garantir que 0 está incluído
            if tipo == "perdidos" and 0 not in botoes_values:
                botoes_values = [0] + botoes_values
        else:
            # Fallback: criar range de 0 até o valor máximo
            rate_max = max(rate_options) if isinstance(rate_options, list) else rate_options
            botoes_values = list(range(rate_max + 1))
        
        print(f"DEBUG: [GESTÃO_PACOTES] Valores dos botões: {botoes_values}")
        
        for valor in botoes_values:
            btn = tk.Button(
                botoes_frame,
                text=str(valor),
                bg="#8B5CF6",
                fg="white",
                font=("Helvetica", 12, "bold"),
                width=4,
                height=2,
                command=lambda v=valor: self._aplicar_valor_e_fechar_overlay(tipo, v)
            )
            btn.pack(side="left", padx=5)
        
        # Botão Cancelar
        btn_cancelar = tk.Button(
            main_frame,
            text="Cancelar",
            bg="#666666",
            fg="white",
            font=("Helvetica", 10),
            command=self._fechar_overlay_entrada
        )
        btn_cancelar.pack(pady=10)
    
    def _aplicar_valor_entrada(self, tipo, valor):
        """
        CORREÇÃO: Aplica o valor selecionado sincronizando com card_stats
        E AUTOMATICAMENTE atualiza To send quando Rxd ou Lost mudam
        NOVA FUNCIONALIDADE: Remove o botão + correspondente após aplicar valor
        CORREÇÃO PROBLEMA 2: Garantir que valores selecionados são aplicados corretamente
        CORREÇÃO CENÁRIO ZEROS: Registra interação do jogador independente dos valores escolhidos
        """
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor {valor} para {tipo}")
        
        # CORREÇÃO CENÁRIO ZEROS: Registar interação do jogador INDEPENDENTE do valor escolhido
        # Isto garante que mesmo clicando 0+0, a carta é considerada "processada pelo jogador"
        carta_atual_para_interacao = self._get_current_actual_card()
        if carta_atual_para_interacao:
            self._cartas_interagidas_jogador.add(carta_atual_para_interacao)
            print(f"DEBUG: [INTERACAO] Carta {os.path.basename(carta_atual_para_interacao)} registada como interagida pelo jogador")
            print(f"DEBUG: [INTERACAO] Total cartas interagidas: {len(self._cartas_interagidas_jogador)}")
        else:
            print(f"DEBUG: [INTERACAO] WARNING: Não foi possível registar interação - carta atual não encontrada")
        
        # CORREÇÃO FUNDAMENTAL: Usar carta selecionada diretamente do carrossel
        # Evita problemas de sincronização após restauração de fullscreen
        if not hasattr(self, 'selected_carousel_index') or self.selected_carousel_index is None:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Nenhuma carta selecionada no carrossel!")
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: hasattr(selected_carousel_index): {hasattr(self, 'selected_carousel_index')}")
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: selected_carousel_index value: {getattr(self, 'selected_carousel_index', 'NOT_SET')}")
            return
        
        posicao_carrossel = self.selected_carousel_index
        
        # CORREÇÃO CRÍTICA: Obter carta_atual diretamente da posição no carrossel, não da variável cached
        if not hasattr(self, 'cards') or posicao_carrossel >= len(self.cards):
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Posição inválida no carrossel!")
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: posicao_carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: len(cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
            return
        
        carta_atual = self.cards[posicao_carrossel]
        
        # DIAGNÓSTICO DETALHADO APÓS OBTER CARTA
        print(f"DEBUG: [GESTÃO_PACOTES] === DIAGNÓSTICO DETALHADO ===")
        print(f"DEBUG: [GESTÃO_PACOTES] posicao_carrossel: {posicao_carrossel}")
        print(f"DEBUG: [GESTÃO_PACOTES] carta_atual: {os.path.basename(carta_atual) if carta_atual else 'None'}")
        print(f"DEBUG: [GESTÃO_PACOTES] len(self.cards): {len(self.cards) if hasattr(self, 'cards') else 'NO_CARDS'}")
        print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Carta atual obtida do carrossel com sucesso!")
        
        if not carta_atual:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Carta atual é None!")
            return
        
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor na posição {posicao_carrossel} do carrossel")
        
        # CORREÇÃO: Obter message_size da base de dados
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # CORREÇÃO: Sincronizar com card_stats usando posição correta do carrossel
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            # Obter valores preservados atuais
            stats_atuais = self.card_stats[posicao_carrossel]
            to_send_anterior = stats_atuais.get('To send', message_size)
            rxd_anterior = stats_atuais.get('Rxd', 0)
            lost_anterior = stats_atuais.get('Lost', 0)
            
            print(f"DEBUG: [GESTÃO_PACOTES] Valores anteriores preservados:")
            print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_anterior}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Message size: {message_size}")
            
            # CORREÇÃO PROBLEMA 2: Aplicar o valor selecionado como INCREMENTO
            # O valor selecionado é ADICIONADO ao valor atual
            if tipo == 'enviados':
                # CORREÇÃO CRÍTICA: Distinguir entre REGISTRAR TENTATIVA e APLICAR VALOR
                # Quando valor=0, registramos a tentativa MAS NÃO alteramos o valor efetivo
                if valor > 0:
                    # Valor > 0: Incrementa realmente o Rxd
                    novo_rxd = rxd_anterior + valor
                    self.card_stats[posicao_carrossel]['Rxd'] = novo_rxd
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Rxd incrementado efetivamente: {rxd_anterior} + {valor} = {novo_rxd}")
                    
                    # NOVO: Consumir pacotes dos Data Volume services quando Rxd é incrementado
                    self._consume_data_volume_packets(valor)
                    
                else:
                    # Valor = 0: NÃO altera o valor efetivo, mas registra a tentativa
                    novo_rxd = rxd_anterior  # Mantém valor anterior
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Rxd MANTIDO (valor=0): {rxd_anterior} (sem alteração)")
                
                novo_lost = lost_anterior  # Lost mantém-se igual
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: card_stats[{posicao_carrossel}]['Rxd'] = {novo_rxd}")
                
                # IMPORTANTE: Sempre incrementar contador de processamento (independente do valor)
                # Isto garante que o botão + desaparece após ser usado, mesmo com valor 0
                # O contador registra a TENTATIVA do jogador, não o valor efetivo aplicado
                self._increment_processed_this_turn(carta_atual, 'rxd', 1)
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Tentativa de processamento registrada para Rxd (valor selecionado: {valor})")
                
                # NOVA FUNCIONALIDADE: Remover botão + de Rxd após aplicar valor
                if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
                    try:
                        self._btn_plus_rxd.destroy()
                        self._btn_plus_rxd = None
                        print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Botão + Rxd removido após incrementar +{valor}")
                        
                        # CORREÇÃO: Atualizar estado preservado para refletir que botão não está mais visível
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['rxd_visivel'] = False
                            print("DEBUG: [GESTÃO_PACOTES] Estado preservado atualizado: rxd_visivel = False")
                        
                        # CORREÇÃO ADICIONAL: Verificar imediatamente se deve mostrar botão seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] WARNING: Erro ao remover botão + Rxd: {e}")
                    
            elif tipo == 'perdidos':
                # CORREÇÃO CRÍTICA: Distinguir entre REGISTRAR TENTATIVA e APLICAR VALOR
                # Quando valor=0, registramos a tentativa MAS NÃO alteramos o valor efetivo
                novo_rxd = rxd_anterior  # Rxd mantém-se igual
                
                if valor > 0:
                    # Valor > 0: Incrementa realmente o Lost
                    novo_lost = lost_anterior + valor
                    self.card_stats[posicao_carrossel]['Lost'] = novo_lost
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Lost incrementado efetivamente: {lost_anterior} + {valor} = {novo_lost}")
                else:
                    # Valor = 0: NÃO altera o valor efetivo, mas registra a tentativa
                    novo_lost = lost_anterior  # Mantém valor anterior
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Lost MANTIDO (valor=0): {lost_anterior} (sem alteração)")
                
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: card_stats[{posicao_carrossel}]['Lost'] = {novo_lost}")
                
                # IMPORTANTE: Sempre incrementar contador de processamento (independente do valor)
                # Isto garante que o botão + desaparece após ser usado, mesmo com valor 0
                # O contador registra a TENTATIVA do jogador, não o valor efetivo aplicado
                self._increment_processed_this_turn(carta_atual, 'lost', 1)
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Tentativa de processamento registrada para Lost (valor selecionado: {valor})")
                
                # NOVA FUNCIONALIDADE: Remover botão + de Lost após aplicar valor
                if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
                    try:
                        self._btn_plus_lost.destroy()
                        self._btn_plus_lost = None
                        print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Botão + Lost removido após incrementar +{valor}")
                        
                        # CORREÇÃO: Atualizar estado preservado para refletir que botão não está mais visível
                        if hasattr(self, '_botoes_plus_estado_preservado'):
                            self._botoes_plus_estado_preservado['lost_visivel'] = False
                            print("DEBUG: [GESTÃO_PACOTES] Estado preservado atualizado: lost_visivel = False")
                        
                        # CORREÇÃO ADICIONAL: Verificar imediatamente se deve mostrar botão seta
                        self.after(100, self._verificar_e_mostrar_botao_seta_se_necessario)
                            
                    except Exception as e:
                        print(f"DEBUG: [GESTÃO_PACOTES] WARNING: Erro ao remover botão + Lost: {e}")
                    
            else:
                novo_rxd = rxd_anterior
                novo_lost = lost_anterior
            
            # CORREÇÃO CRÍTICA: Calcular To send com lógica especial para Activities
            # Para Activities com message_received não None e penalty_per_packet não None:
            # - Lost não decrementa To send (pacotes perdidos são contabilizados separadamente)
            # - Apenas Rxd decrementa To send
            
            # Obter dados da carta para verificar se é uma Activity especial
            carta_atual = self.cards[posicao_carrossel] if posicao_carrossel < len(self.cards) else None
            dados_carta = self._obter_dados_carta(carta_atual) if carta_atual else None
            
            is_activity_especial = False
            if dados_carta and 'message_received' in dados_carta and 'penalty_per_packet' in dados_carta:
                message_received = dados_carta.get('message_received')
                penalty_per_packet = dados_carta.get('penalty_per_packet')
                if message_received is not None and penalty_per_packet is not None:
                    is_activity_especial = True
                    print(f"DEBUG: [GESTÃO_PACOTES] Activity especial detectada: message_received={message_received}, penalty_per_packet={penalty_per_packet}")
            
            if is_activity_especial:
                # Para Activities especiais: apenas Rxd decrementa To send
                novo_to_send = max(message_size - novo_rxd, 0)
                print(f"DEBUG: [GESTÃO_PACOTES] LÓGICA ESPECIAL PARA ACTIVITY:")
                print(f"DEBUG: [GESTÃO_PACOTES]   To send = message_size - Rxd (Lost não decrementa)")
                print(f"DEBUG: [GESTÃO_PACOTES]   To send = {message_size} - {novo_rxd} = {novo_to_send}")
            else:
                # Para Challenges e Activities normais: tanto Rxd quanto Lost decrementam To send
                novo_to_send = max(message_size - (novo_rxd + novo_lost), 0)
                print(f"DEBUG: [GESTÃO_PACOTES] LÓGICA NORMAL:")
                print(f"DEBUG: [GESTÃO_PACOTES]   To send = message_size - (Rxd + Lost)")
                print(f"DEBUG: [GESTÃO_PACOTES]   To send = {message_size} - ({novo_rxd} + {novo_lost}) = {novo_to_send}")
            
            # Atualizar To send nos card_stats
            self.card_stats[posicao_carrossel]['To send'] = novo_to_send
            
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: APLICAÇÃO DE VALOR COMPLETA:")
            print(f"DEBUG: [GESTÃO_PACOTES]   Valor selecionado: {valor}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Aplicado a: {tipo}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO Rxd total: {novo_rxd}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO Lost total: {novo_lost}")
            print(f"DEBUG: [GESTÃO_PACOTES]   NOVO To send: {novo_to_send}")
            if is_activity_especial:
                print(f"DEBUG: [GESTÃO_PACOTES]   CORREÇÃO ESPECIAL: Para Activity com message_received/penalty_per_packet, apenas Rxd reduz To send")
            else:
                print(f"DEBUG: [GESTÃO_PACOTES]   CORREÇÃO NORMAL: Tanto Lost quanto Rxd reduzem To send")
            
            # CORREÇÃO: Atualizar TODAS as barras visualmente
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Atualizar To send
                if "To send" in self.progress_bars and "To send" in self.progress_labels:
                    self.progress_bars["To send"].config(value=novo_to_send, maximum=message_size)
                    self.progress_labels["To send"].config(text=str(novo_to_send))
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Barra To send atualizada visualmente: {novo_to_send}/{message_size}")
                
                # Atualizar Rxd
                if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                    self.progress_bars["Rxd"].config(value=novo_rxd, maximum=message_size)
                    self.progress_labels["Rxd"].config(text=str(novo_rxd))
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Barra Rxd atualizada visualmente: {novo_rxd}")
                
                # Atualizar Lost
                if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                    self.progress_bars["Lost"].config(value=novo_lost, maximum=message_size)
                    self.progress_labels["Lost"].config(text=str(novo_lost))
                    print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Barra Lost atualizada visualmente: {novo_lost}")
        
        # CORREÇÃO: Sincronizar com card_stats após aplicar valores
        try:
            self._sync_card_stats_with_progress_bars()
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: card_stats sincronizado com barras após aplicar valor")
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] WARNING: Erro ao sincronizar card_stats: {e}")
        
        # NOVA CORREÇÃO: Verificar se deve mostrar botão seta após remover botões +
        self._verificar_e_mostrar_botao_seta_se_necessario()
        
        # Manter compatibilidade com sistema antigo (se existir)
        if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
        
        # Fechar overlay
        self._fechar_overlay_entrada()
    
    def _fechar_overlay_entrada(self):
        """Fecha o overlay de entrada"""
        try:
            if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
                print("DEBUG: [OVERLAY] Fechando overlay de entrada...")
                self._overlay_entrada.destroy()
                self._overlay_entrada = None
                print("DEBUG: [OVERLAY] SUCCESS: Overlay de entrada fechado com sucesso")
            else:
                print("DEBUG: [OVERLAY] WARNING: Nenhum overlay de entrada encontrado para fechar")
        except Exception as e:
            print(f"DEBUG: [OVERLAY] ERRO ao fechar overlay de entrada: {e}")
            # Força limpeza da referência mesmo com erro
            self._overlay_entrada = None
    
    def _aplicar_valor_e_fechar_overlay(self, tipo, valor):
        """Aplica o valor selecionado e fecha o overlay"""
        print(f"DEBUG: [GESTÃO_PACOTES] Aplicando valor {valor} para {tipo} e fechando overlay")
        
        try:
            # Aplicar o valor
            self._aplicar_valor_entrada(tipo, valor)
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Valor {valor} aplicado para {tipo}")
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ERRO ao aplicar valor: {e}")
        
        try:
            # Fechar o overlay
            self._fechar_overlay_entrada()
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Overlay fechado após aplicar valor")
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ERRO ao fechar overlay: {e}")
            # Força limpeza da referência mesmo com erro
            if hasattr(self, '_overlay_entrada'):
                self._overlay_entrada = None
    
    def _is_challenge_card(self, carta_path):
        """
        Verifica se uma carta é do tipo Challenge baseada no caminho.
        
        Args:
            carta_path: Caminho para a carta (ex: "/path/Challenge_1.png")
            
        Returns:
            True se for uma carta Challenge, False caso contrário
        """
        if not carta_path:
            return False
            
        filename = os.path.basename(carta_path)
        return filename.startswith('Challenge_') and filename.endswith('.png')
    
    def _incrementar_valor(self, tipo, message_size):
        """
        Incrementa valor respeitando o message_size máximo da carta.
        CORREÇÃO: Usar message_size como limite, não rate_max.
        rate_max é para pacotes por turno, message_size é o limite total da mensagem.
        NOVO: Incrementa também o contador de processamento por turno.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor_atual = int(entry.get())
            
            # Obter carta atual
            carta_path = self._cartas_gestao[self._carta_atual_gestao]
            
            # Obter rate_max para verificar limite por turno
            rate_max = self._obter_rate_carta(carta_path)
            
            # Verificar contadores de processamento por turno
            tipo_contador = 'rxd' if tipo == 'enviados' else 'lost'
            processed_this_turn = self._get_processed_this_turn(carta_path, tipo_contador)
            
            print(f"DEBUG: [INCREMENTAR] {tipo}: atual={valor_atual}, processed_this_turn={processed_this_turn}")
            print(f"DEBUG: [INCREMENTAR] Limites: message_size={message_size}, rate_max={rate_max}")
            
            # NOVA VERIFICAÇÃO: Ambos os limites devem ser respeitados
            pode_incrementar = (valor_atual < message_size) and (processed_this_turn < rate_max)
            
            if pode_incrementar:
                novo_valor = valor_atual + 1
                entry.delete(0, tk.END)
                entry.insert(0, str(novo_valor))
                
                # Atualizar valores armazenados
                self._valores_pacotes[self._carta_atual_gestao][tipo] = novo_valor
                
                # NOVO: Incrementar contador de processamento por turno
                self._increment_processed_this_turn(carta_path, tipo_contador, 1)
                
                # Atualizar barra "To send"
                self._atualizar_barra_to_send()
                
                print(f"DEBUG: [INCREMENTAR] SUCCESS: {tipo} incrementado para {novo_valor}")
                print(f"DEBUG: [INCREMENTAR] Novo processed_this_turn: {self._get_processed_this_turn(carta_path, tipo_contador)}")
            else:
                if valor_atual >= message_size:
                    print(f"DEBUG: [INCREMENTAR] ERROR: Limite de message_size atingido ({message_size})")
                if processed_this_turn >= rate_max:
                    print(f"DEBUG: [INCREMENTAR] ERROR: Limite de rate_max por turno atingido ({rate_max})")
                
        except ValueError:
            print("DEBUG: [INCREMENTAR] Valor inválido no campo")
    
    def _validar_entrada(self, tipo, message_size):
        """
        Valida entrada manual respeitando message_size máximo.
        CORREÇÃO: Usar message_size como limite, não rate_max.
        """
        entry = self._entry_rxd if tipo == 'enviados' else self._entry_lost
        
        try:
            valor = int(entry.get())
            if valor < 0:
                valor = 0
                entry.delete(0, tk.END)
                entry.insert(0, "0")
            
            # CORREÇÃO: Verificar limite individual por message_size
            if valor > message_size:
                valor = message_size
                entry.delete(0, tk.END)
                entry.insert(0, str(valor))
            
            # Atualizar valores armazenados
            self._valores_pacotes[self._carta_atual_gestao][tipo] = valor
            
            # Atualizar barra "To send"
            self._atualizar_barra_to_send()
            
            print(f"DEBUG: [GESTÃO_PACOTES] {tipo} validado para {valor} (limite: {message_size})")
            
        except ValueError:
            # Se valor inválido, resetar para 0
            entry.delete(0, tk.END)
            entry.insert(0, "0")
            self._valores_pacotes[self._carta_atual_gestao][tipo] = 0
    
    def _atualizar_barra_to_send(self):
        """Atualiza a barra 'To send' com base nos valores inseridos"""
        valores = self._valores_pacotes[self._carta_atual_gestao]
        
        # CORREÇÃO: "To send" = message_size(DB) - enviados - perdidos
        # Obter message_size da base de dados para a carta atual (coerente com pré-Final Phase)
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        message_size = self._get_card_message_size_from_database(carta_atual)
        
        # Calcular quanto ainda resta para enviar
        total_processado = valores['enviados'] + valores['perdidos']
        to_send_restante = max(message_size - total_processado, 0)
        
        print(f"DEBUG: [GESTÃO_PACOTES] Cálculo 'To send':")
        print(f"DEBUG: [GESTÃO_PACOTES]   Message size (DB): {message_size}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Enviados (Rxd): {valores['enviados']}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Perdidos (Lost): {valores['perdidos']}")
        print(f"DEBUG: [GESTÃO_PACOTES]   Total processado: {total_processado}")
        print(f"DEBUG: [GESTÃO_PACOTES]   To send restante: {to_send_restante}")
        
        # Atualizar a barra de progresso "To send" usando o widget diretamente
        if hasattr(self, 'progress_bars') and "To send" in self.progress_bars:
            # Usar configuração do widget Progressbar do tkinter (máximo coerente com DB)
            self.progress_bars["To send"].config(value=to_send_restante, maximum=message_size)
            print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'To send' atualizada para {to_send_restante}/{message_size}")
            
        # Atualizar label do valor usando o widget diretamente
        if hasattr(self, 'progress_labels') and "To send" in self.progress_labels:
            self.progress_labels["To send"].config(text=str(to_send_restante))
            print(f"DEBUG: [GESTÃO_PACOTES] Progress label 'To send' atualizada para {to_send_restante}")
        
        # NOVO: Atualizar também as barras Rxd e Lost para refletir os valores atuais
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=valores['enviados'])
                self.progress_labels["Rxd"].config(text=str(valores['enviados']))
                print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'Rxd' atualizada para {valores['enviados']}")
                
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=valores['perdidos'])
                self.progress_labels["Lost"].config(text=str(valores['perdidos']))
                print(f"DEBUG: [GESTÃO_PACOTES] Progress bar 'Lost' atualizada para {valores['perdidos']}")
        
        # REMOVIDO: Não verificar completion automaticamente - só no botão seta da última carta
        # self._verificar_completion_activity()
    
    def _verificar_completion_activity(self):
        """
        Verifica se uma Activity/Challenge foi completada:
        - To send = 0 (todos os pacotes da mensagem foram enviados)
        - drops_allowed = False
        
        NOTA: Uma Activity/Challenge é completada quando todos os pacotes da mensagem
        (message_size) foram enviados ao longo de múltiplos turnos, não apenas
        quando o rate de um turno foi atingido.
        """
        if not hasattr(self, '_valores_pacotes') or self._carta_atual_gestao not in self._valores_pacotes:
            return
        
        carta_atual = self._cartas_gestao[self._carta_atual_gestao]
        
        # Obter dados da carta da database
        dados_carta = self._obter_dados_carta(carta_atual)
        if not dados_carta:
            print(f"DEBUG: [COMPLETION] Não foi possível obter dados da carta {os.path.basename(carta_atual)}")
            return
        
        # CORREÇÃO: Para Challenges, verificar completion mesmo com drops_allowed=True
        # As regras de completion são diferentes para Activities vs Challenges
        carta_basename = os.path.basename(carta_atual).lower()
        is_challenge = "challenge" in carta_basename
        is_activity = "activity" in carta_basename
        
        drops_allowed = dados_carta.get('drops_allowed', True)
        
        # NOVA LÓGICA: Challenges sempre verificam completion, Activities só se drops_allowed=False
        if is_activity and drops_allowed:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=True, não verifica completion")
            return
        elif is_challenge:
            print(f"DEBUG: [COMPLETION] Challenge {os.path.basename(carta_atual)} - sempre verifica completion")
        else:
            print(f"DEBUG: [COMPLETION] Activity {os.path.basename(carta_atual)} tem drops_allowed=False - verifica completion")
        
        # Obter dados da carta para verificar completion
        message_size = dados_carta.get('message_size', 0)
        
        # Verificar se a carta tem dados de progresso acumulados
        if not hasattr(self, 'card_stats'):
            print(f"DEBUG: [COMPLETION] Dados de progresso não encontrados")
            return
            
        # CORREÇÃO: Encontrar o índice real da carta no carrossel
        carta_idx = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                carta_idx = i
                break
        
        if carta_idx is None or carta_idx >= len(self.card_stats):
            print(f"DEBUG: [COMPLETION] Carta não encontrada no carrossel ou índice inválido")
            return
            
        stats = self.card_stats[carta_idx]
        to_send_atual = stats['To send']
        rxd_acumulado = stats['Rxd']
        
        print(f"DEBUG: [COMPLETION] Verificando completion para {os.path.basename(carta_atual)}:")
        print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge' if is_challenge else 'Activity'}")
        print(f"DEBUG: [COMPLETION]   Message size: {message_size}")
        print(f"DEBUG: [COMPLETION]   To send atual: {to_send_atual}")
        print(f"DEBUG: [COMPLETION]   Rxd acumulado: {rxd_acumulado}")
        print(f"DEBUG: [COMPLETION]   Drops allowed: {drops_allowed}")
        
        # CORREÇÃO: Condições de completion mais flexíveis
        # Para Challenges: To send = 0 OU Rxd >= message_size
        # Para Activities: To send = 0 E Rxd >= message_size
        completion_achieved = False
        
        if is_challenge:
            # Challenges: mais flexível - ou todos enviados ou todos recebidos
            completion_achieved = (to_send_atual == 0) or (rxd_acumulado >= message_size)
            completion_reason = "todos enviados" if to_send_atual == 0 else f"todos recebidos ({rxd_acumulado}/{message_size})"
        else:
            # Activities: mais restritivo - todos enviados E todos recebidos
            completion_achieved = (to_send_atual == 0) and (rxd_acumulado >= message_size)
            completion_reason = f"todos enviados e recebidos ({rxd_acumulado}/{message_size})"
        
        if completion_achieved:
            print(f"DEBUG: [COMPLETION] *** {'Challenge' if is_challenge else 'Activity'} COMPLETADA! ***")
            print(f"DEBUG: [COMPLETION] Carta: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [COMPLETION] Motivo: {completion_reason}")
            
            # VALIDAÇÃO EXTRA: Confirmar que To send é realmente 0 antes de mostrar overlay
            if to_send_atual > 0:
                print(f"DEBUG: [COMPLETION] ❌ ERRO CRÍTICO: Completion calculado incorretamente!")
                print(f"DEBUG: [COMPLETION] completion_achieved = {completion_achieved}")
                print(f"DEBUG: [COMPLETION] Mas to_send_atual = {to_send_atual} (deveria ser 0)")
                print(f"DEBUG: [COMPLETION] CANCELANDO overlay - valores inconsistentes")
                return
            
            print(f"DEBUG: [COMPLETION] ✅ Validação confirmada: To send = 0, mostrando overlay")
            
            # Mostrar overlay de congratulações
            self._mostrar_overlay_completion(carta_atual, dados_carta)
        else:
            print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_atual)} ainda não completada:")
            print(f"DEBUG: [COMPLETION]   To send: {to_send_atual} (deve ser 0)")
            print(f"DEBUG: [COMPLETION]   Rxd: {rxd_acumulado} (deve ser >= {message_size})")
            print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge (flexível)' if is_challenge else 'Activity (restritivo)'}")
    
    def _mostrar_overlay_completion(self, carta_path, dados_carta, is_sequential=False, carta_index=None, tempo_limite_obrigatorio=False):
        """
        Mostra overlay de congratulações quando Activity/Challenge é completada
        
        Args:
            carta_path: Caminho da carta completada
            dados_carta: Dados da carta da base de dados
            is_sequential: Se True, este overlay faz parte de uma sequência (múltiplas cartas completadas)
            tempo_limite_obrigatorio: Se True, completion foi por tempo limite obrigatório (finaliza gestão)
            carta_index: Índice específico da carta no carrossel (para cálculo correto de reward)
        """
        print(f"DEBUG: [COMPLETION] ===== VALIDAÇÃO CRÍTICA ANTES DE MOSTRAR OVERLAY =====")
        print(f"DEBUG: [COMPLETION] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [COMPLETION] Tempo limite obrigatório: {tempo_limite_obrigatorio}")
        print(f"DEBUG: [COMPLETION] Índice da carta: {carta_index}")
        
        # CORREÇÃO CRÍTICA: VALIDAÇÃO EXTRA ANTES DE MOSTRAR OVERLAY
        # Verificar se a carta realmente pode ser completada antes de mostrar overlay
        if not tempo_limite_obrigatorio:
            # Se não é completion por tempo limite, verificar condições normais
            carta_basename = os.path.basename(carta_path).lower()
            is_challenge = "challenge" in carta_basename
            is_activity = "activity" in carta_basename
            
            # Obter valores atuais das barras
            if carta_index is not None and hasattr(self, 'card_stats') and carta_index < len(self.card_stats):
                stats = self.card_stats[carta_index]
                to_send_atual = stats.get('To send', 0)
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                # Fallback: tentar obter dos progress_labels
                try:
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                except:
                    to_send_atual = 0
                    rxd_atual = 0
                    lost_atual = 0
            
            message_size = dados_carta.get('message_size', 0)
            
            print(f"DEBUG: [COMPLETION] VALIDAÇÃO DOS VALORES ATUAIS:")
            print(f"DEBUG: [COMPLETION]   To send: {to_send_atual}")
            print(f"DEBUG: [COMPLETION]   Rxd: {rxd_atual}")
            print(f"DEBUG: [COMPLETION]   Lost: {lost_atual}")
            print(f"DEBUG: [COMPLETION]   Message size: {message_size}")
            print(f"DEBUG: [COMPLETION]   Tipo: {'Challenge' if is_challenge else 'Activity'}")
            
            # REGRA CRÍTICA: Para Challenges e Activities, To send DEVE ser 0 para completion normal
            if to_send_atual > 0:
                print(f"DEBUG: [COMPLETION] ❌ ERRO CRÍTICO: Completion inválido!")
                print(f"DEBUG: [COMPLETION] To send deve ser 0, mas é {to_send_atual}")
                print(f"DEBUG: [COMPLETION] CANCELANDO overlay de completion - condições não atendidas")
                print(f"DEBUG: [COMPLETION] ===== OVERLAY CANCELADO =====")
                return  # NÃO mostrar overlay se condições não estão atendidas
            
            print(f"DEBUG: [COMPLETION] ✅ VALIDAÇÃO PASSOU: To send = 0, pode mostrar completion")
        else:
            print(f"DEBUG: [COMPLETION] ✅ COMPLETION POR TEMPO LIMITE: Validação bypassed")
        
        print(f"DEBUG: [COMPLETION] Mostrando overlay de congratulações")
        print(f"DEBUG: [COMPLETION] Sequencial: {is_sequential}")
        
        # Inicializar variável de decisão da gestão
        gestao_deve_continuar = None
        
        # CORREÇÃO: Marcar que overlay de completion está ativo
        self._completion_overlay_active = True
        print("DEBUG: [COMPLETION] Flag _completion_overlay_active = True")
        
        # NOVA FLAG: Marcar se completion foi por tempo limite obrigatório
        self._completion_tempo_limite_obrigatorio = tempo_limite_obrigatorio
        if tempo_limite_obrigatorio:
            print("DEBUG: [COMPLETION] COMPLETION POR TEMPO LIMITE OBRIGATÓRIO - Gestão será finalizada após overlay")
        
        # CORREÇÃO: Limpar controles de gestão antes de mostrar overlay
        # Isso evita que o botão roxo apareça por baixo do overlay
        if hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa:
            print(f"DEBUG: [COMPLETION] Removendo controles de gestão antes do overlay")
            self._remover_controles_gestao_silencioso()
        
        # Determinar tipo da carta (Activity ou Challenge)
        carta_basename = os.path.basename(carta_path).lower()
        if "activity" in carta_basename:
            card_type = "Activity"
        elif "challenge" in carta_basename:
            card_type = "Challenge"
        else:
            card_type = "Activity"  # fallback
        
        print(f"DEBUG: [COMPLETION] Tipo de carta detectado: {card_type}")
        
        # Calcular reward baseado no tipo de carta e regras específicas usando índice correto
        reward_value = self._calcular_reward_completion(carta_path, dados_carta, card_type, carta_index)
        print(f"DEBUG: [COMPLETION] Reward calculado: {reward_value} picoins")
        
        # NOVO FORMATO: Overlay fullscreen igual ao de ativação
        # Limpar TODOS os widgets para criar overlay fullscreen
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (igual ao overlay de ativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à ativação)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à ativação)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [COMPLETION] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de congratulações (centro da tela) - fundo preto com letras coloridas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de ativação
        completion_frame = tk.Frame(self, bg="black")
        completion_frame.pack(expand=True)
        
        # NOVO: Se é sequencial, mostrar informação sobre progresso (APENAS para Challenges)
        if (is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays') and
            card_type == "Challenge"):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            
            progress_lbl = tk.Label(
                completion_frame,
                text=f"Carta {current_index + 1} de {total_overlays} completadas",
                font=("Helvetica", 14),
                fg="#888888",
                bg="black"
            )
            progress_lbl.pack(pady=(5, 0))
            
            # Nome da carta atual
            carta_name = os.path.basename(carta_path).replace('.png', '')
            carta_name_lbl = tk.Label(
                completion_frame,
                text=carta_name,
                font=("Helvetica", 16, "bold"),
                fg="#8000FF",
                bg="black"
            )
            carta_name_lbl.pack(pady=(0, 10))
        
        # Título "Congratulations!" em roxo (centralizado)
        title_lbl = tk.Label(
            completion_frame,
            text="   Congratulations!   ",
            font=("Helvetica", 20, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(10, 10), anchor="center")
        
        # Frame para "You've won" + valor + picoin
        won_frame = tk.Frame(completion_frame, bg="black")
        won_frame.pack(pady=(0, 30), anchor="center")
        
        # Texto "You've won"
        won_text_lbl = tk.Label(won_frame, text="You've won", 
                               font=("Helvetica", 14, "bold"), 
                               fg="white", bg="black")
        won_text_lbl.pack(side="left", padx=(0, 10))
        
        # Valor da reward
        valor_lbl = tk.Label(won_frame, text=str(reward_value), 
                            font=("Helvetica", 14, "bold"), 
                            fg="#FFD700", bg="black")
        valor_lbl.pack(side="left", padx=(0, 5))
        
        # Ícone do picoin
        try:
            coin_img_path = os.path.join(os.path.dirname(__file__), "img", "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path).resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                coin_lbl = tk.Label(won_frame, image=coin_img, bg="black")
                coin_lbl.image = coin_img  # type: ignore[attr-defined]
                coin_lbl.pack(side="left")
            else:
                # Fallback para emoji
                coin_lbl = tk.Label(won_frame, text="🪙", 
                                   font=("Helvetica", 14), 
                                   fg="#FFD700", bg="black")
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar ícone picoin: {e}")
            # Fallback para emoji
            coin_lbl = tk.Label(won_frame, text="🪙", 
                               font=("Helvetica", 14), 
                               fg="#FFD700", bg="black")
            coin_lbl.pack(side="left")
        
        # CORREÇÃO: Botão para fechar o overlay (sempre presente)
        def fechar_e_continuar():
            print(f"DEBUG: [COMPLETION] Fechando overlay e continuando...")
            
            # CRÍTICO: Verificar se já foi processado para evitar duplicação
            if hasattr(self, '_completion_processed') and self._completion_processed:
                print(f"DEBUG: [COMPLETION] AVISO: Completion já processado, ignorando")
                return
                
            # Marcar como processado
            self._completion_processed = True
            
            # CORREÇÃO CRÍTICA: Preservar decisão da gestão que foi calculada acima
            nonlocal gestao_deve_continuar
            
            # Atualizar saldo do jogador
            self.saldo += reward_value
            print(f"DEBUG: [COMPLETION] Saldo atualizado: +{reward_value}, novo saldo: {self.saldo}")
            
            # NOVO: Limpar tracking de Challenge se for Challenge completado
            if card_type == "Challenge":
                self._cleanup_completed_challenge_tracking(carta_path)
                print(f"DEBUG: [COMPLETION] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # AGORA remover carta do carrossel e devolver para store
            self._devolver_carta_para_store(carta_path, card_type)
            
            # Resetar flag para próximo overlay
            self._completion_processed = False
            
            # NOVO: Se é sequencial, mostrar próximo overlay
            if is_sequential and hasattr(self, '_next_completion_overlays') and hasattr(self, '_current_completion_index'):
                next_index = self._current_completion_index + 1
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                self._mostrar_overlays_completion_sequencial(self._next_completion_overlays, next_index)
            else:
                print(f"DEBUG: [COMPLETION] Todos os overlays de completion foram mostrados")
                
                # AGORA verificar se ainda há cartas válidas para processar
                cartas_reais_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for i, carta in enumerate(self.cards):
                        carta_basename = os.path.basename(carta).lower()
                        if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                            # NOVA FUNCIONALIDADE: Verificar flag da carta
                            is_face_up = True  # Default para compatibilidade
                            if hasattr(self, 'card_face_up_flags') and i < len(self.card_face_up_flags):
                                is_face_up = self.card_face_up_flags[i]
                            
                            if is_face_up:
                                cartas_reais_no_carrossel += 1
                
                # Verificar se ainda há cartas na lista de gestão VÁLIDAS (já foi atualizada acima)
                cartas_gestao_restantes = 0
                cartas_validas_gestao = []
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    # NOVA FUNCIONALIDADE: Primeiro limpar cartas inválidas (viradas para baixo) da gestão
                    cartas_para_remover = []
                    for carta in self._cartas_gestao:
                        if carta and hasattr(self, 'cards') and carta in self.cards:
                            carta_index = self.cards.index(carta)
                            if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                if not self.card_face_up_flags[carta_index]:
                                    cartas_para_remover.append(carta)
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} virada para baixo - será removida da gestão")
                    
                    # Remover cartas inválidas
                    for carta in cartas_para_remover:
                        carta_index_gestao = self._cartas_gestao.index(carta)
                        self._cartas_gestao.remove(carta)
                        # Ajustar índice se necessário
                        if carta_index_gestao <= self._carta_atual_gestao and self._carta_atual_gestao > 0:
                            self._carta_atual_gestao -= 1
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} removida da gestão")
                    
                    # CORREÇÃO: Verificar apenas se há cartas VÁLIDAS restantes na lista de gestão
                    # NÃO verificar se podem processar - isso será feito dentro da gestão
                    for i, carta in enumerate(self._cartas_gestao):
                        if carta:
                            carta_basename = os.path.basename(carta).lower()
                            # Carta deve ser Activity ou Challenge E existir no carrossel E estar virada para cima
                            if (not carta_basename.startswith("back_card_") and 
                                ("activity" in carta_basename or "challenge" in carta_basename) and
                                hasattr(self, 'cards') and carta in self.cards):
                                
                                # NOVA FUNCIONALIDADE: Verificar flag da carta
                                carta_index = self.cards.index(carta)
                                is_face_up = True  # Default para compatibilidade
                                if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                    is_face_up = self.card_face_up_flags[carta_index]
                                
                                if is_face_up:
                                    print(f"DEBUG: [COMPLETION] Carta válida encontrada: {os.path.basename(carta)} - gestão deve continuar")
                                    cartas_gestao_restantes += 1
                                    cartas_validas_gestao.append(carta)
                                else:
                                    print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta)} está virada para baixo - será ignorada")
                    
                    # ADICIONAL: Se há cartas na lista mas _carta_atual_gestao está fora de range, ajustar
                    if cartas_gestao_restantes > 0 and hasattr(self, '_carta_atual_gestao'):
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            print(f"DEBUG: [COMPLETION] WARNING: _carta_atual_gestao ({self._carta_atual_gestao}) fora de range - ajustando para 0")
                            self._carta_atual_gestao = 0
                
                # VERIFICAÇÃO CRÍTICA: Se gestão está ativa mas não há cartas para processar, finalizar imediatamente
                gestao_esta_ativa = (hasattr(self, '_final_phase_gestao_ativa') and self._final_phase_gestao_ativa)
                
                # CORREÇÃO CRÍTICA: Verificar se há cartas SEGUINTES para processar
                # Mesmo com tempo limite obrigatório, verificar se há cartas nas posições seguintes
                tempo_limite_obrigatorio = getattr(self, '_completion_tempo_limite_obrigatorio', False)
                
                # NOVA LÓGICA CORRETA: Verificar se há cartas APÓS a posição atual que precisam ser processadas
                cartas_seguintes_existem = False
                if hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao') and self._cartas_gestao:
                    posicao_atual = self._carta_atual_gestao
                    # Verificar todas as posições APÓS a atual
                    for i in range(posicao_atual + 1, len(self._cartas_gestao)):
                        carta_seguinte = self._cartas_gestao[i]
                        # Verificar se carta seguinte está face up (ativa) no carrossel
                        try:
                            carrossel_idx = self.cards.index(carta_seguinte)
                            if carrossel_idx < len(self.card_face_up_flags) and self.card_face_up_flags[carrossel_idx]:
                                cartas_seguintes_existem = True
                                print(f"DEBUG: [COMPLETION] Carta seguinte encontrada na posição {i}: {os.path.basename(carta_seguinte)}")
                                break
                        except (ValueError, IndexError):
                            continue
                
                # CORREÇÃO CRÍTICA: SEMPRE inicializar cartas_nao_processadas
                cartas_nao_processadas = 0
                cartas_processadas_debug = []
                
                if tempo_limite_obrigatorio and not cartas_seguintes_existem:
                    print("DEBUG: [COMPLETION] TEMPO LIMITE OBRIGATÓRIO e NÃO há cartas seguintes - FINALIZANDO gestão")
                    gestao_deve_continuar = False
                elif tempo_limite_obrigatorio and cartas_seguintes_existem:
                    print("DEBUG: [COMPLETION] TEMPO LIMITE OBRIGATÓRIO mas HÁ cartas seguintes - CONTINUANDO gestão")
                    gestao_deve_continuar = True
                    # AINDA ASSIM calcular cartas não processadas para debugging (com lógica corrigida)
                    for carta in cartas_validas_gestao:
                        try:
                            carta_idx = self.cards.index(carta)
                            carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            # MESMA CORREÇÃO: Só considerar processada se jogador interagiu NESTE CICLO
                            foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                            foi_processada = foi_processada_interacao
                            
                            if not foi_processada:
                                cartas_nao_processadas += 1
                            else:
                                cartas_processadas_debug.append(f"{os.path.basename(carta)}(interação_registrada)")
                        except (ValueError, IndexError):
                            continue
                else:
                    # CORREÇÃO CRÍTICA: A gestão deve continuar APENAS se há cartas AINDA NÃO PROCESSADAS
                    # Não é suficiente verificar se há cartas na lista - deve verificar se há cartas que ainda precisem de processamento
                    
                    # CORREÇÃO CRÍTICA: Durante gestão de pacotes, apenas cartas que AINDA NÃO foram processadas
                    # pelo jogador NESTE CICLO DE GESTÃO devem continuar. 
                    # IMPORTANTE: Valores de turnos anteriores NÃO significam que foram processadas neste ciclo!
                    
                    # Verificar quantas cartas na lista de gestão ainda não foram processadas NESTE CICLO
                    for carta in cartas_validas_gestao:
                        # Obter posição no carrossel
                        try:
                            carta_idx = self.cards.index(carta)
                            carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            # CORREÇÃO CRÍTICA: Durante gestão de pacotes, só considerar "processada" se:
                            # 1. Jogador interagiu com a carta NESTE CICLO DE GESTÃO (registro de interação)
                            # 2. OU carta foi explicitamente processada pelo sistema NESTE CICLO
                            
                            # IMPORTANTE: Valores > 0 de turnos anteriores NÃO contam como "processada neste ciclo"!
                            foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                            
                            # DEBUG: Mostrar análise detalhada de cada carta
                            print(f"DEBUG: [COMPLETION] Analisando carta: {os.path.basename(carta)}")
                            print(f"DEBUG: [COMPLETION]   Stats atuais: Rxd={carta_stats.get('Rxd', 0)}, Lost={carta_stats.get('Lost', 0)}")
                            print(f"DEBUG: [COMPLETION]   Interação registrada: {foi_processada_interacao}")
                            print(f"DEBUG: [COMPLETION]   Cartas interagidas: {[os.path.basename(c) for c in getattr(self, '_cartas_interagidas_jogador', set())]}")
                            
                            # DECISÃO FINAL: Carta é considerada processada APENAS se jogador interagiu NESTE CICLO
                            foi_processada = foi_processada_interacao
                            
                            if not foi_processada:
                                cartas_nao_processadas += 1
                                print(f"DEBUG: [COMPLETION]   RESULTADO: NÃO processada neste ciclo - DEVE continuar gestão")
                            else:
                                cartas_processadas_debug.append(f"{os.path.basename(carta)}(interação_registrada)")
                                print(f"DEBUG: [COMPLETION]   RESULTADO: Processada neste ciclo - pode pular")
                        except (ValueError, IndexError):
                            # Carta não encontrada no carrossel
                            print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta)} não encontrada no carrossel")
                            continue
                    
                    print(f"DEBUG: [COMPLETION] === ANÁLISE DE PROCESSAMENTO DAS CARTAS ===")
                    print(f"DEBUG: [COMPLETION] Cartas válidas na gestão: {len(cartas_validas_gestao)}")
                    print(f"DEBUG: [COMPLETION] Cartas processadas: {len(cartas_processadas_debug)} - {cartas_processadas_debug}")
                    print(f"DEBUG: [COMPLETION] Cartas não processadas: {cartas_nao_processadas}")
                    
                    # LÓGICA CORRIGIDA: Gestão deve continuar APENAS se há cartas não processadas
                    gestao_deve_continuar = gestao_esta_ativa and cartas_nao_processadas > 0
                
                print(f"DEBUG: [COMPLETION] ===== DECISÃO DE CONTINUAÇÃO DA GESTÃO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] cartas_reais_no_carrossel: {cartas_reais_no_carrossel}")
                print(f"DEBUG: [COMPLETION] cartas_gestao_restantes: {cartas_gestao_restantes}")
                print(f"DEBUG: [COMPLETION] cartas_nao_processadas: {cartas_nao_processadas}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                print(f"DEBUG: [COMPLETION] cartas_validas_gestao: {[os.path.basename(c) for c in cartas_validas_gestao]}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                print(f"DEBUG: [COMPLETION] RAZÃO: {'Há cartas não processadas' if cartas_nao_processadas > 0 else 'Todas as cartas já foram processadas'}")
                
                # CORREÇÃO CRÍTICA: PRIMEIRO remover carta da LISTA DE GESTÃO, não do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA DA LISTA DE GESTÃO ===")
                if (hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao') and
                    self._cartas_gestao and carta_path in self._cartas_gestao):
                    
                    # Encontrar e remover carta da lista de gestão
                    try:
                        carta_gestao_idx = self._cartas_gestao.index(carta_path)
                        print(f"DEBUG: [COMPLETION] Carta {os.path.basename(carta_path)} está na posição {carta_gestao_idx} da lista de gestão")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao antes da remoção: {self._carta_atual_gestao}")
                        
                        # Remover carta da lista
                        self._cartas_gestao.remove(carta_path)
                        
                        # CORREÇÃO CRÍTICA: Ajustar _carta_atual_gestao baseado na posição da carta removida
                        if carta_gestao_idx < self._carta_atual_gestao:
                            # Carta removida estava antes da carta atual, decrementar índice
                            self._carta_atual_gestao -= 1
                            print(f"DEBUG: [COMPLETION] Carta removida antes da atual - índice decrementado para: {self._carta_atual_gestao}")
                        elif carta_gestao_idx == self._carta_atual_gestao:
                            # A carta atual foi removida
                            print(f"DEBUG: [COMPLETION] Carta atual foi removida - mantendo índice {self._carta_atual_gestao}")
                            # NOVA LÓGICA: Se removemos a carta atual, o índice fica apontando para a próxima carta
                            # Se o índice ficou >= tamanho da lista, significa que removemos a última carta
                            if self._carta_atual_gestao >= len(self._cartas_gestao):
                                if len(self._cartas_gestao) > 0:
                                    # Há cartas restantes, voltar ao início
                                    self._carta_atual_gestao = 0
                                    print(f"DEBUG: [COMPLETION] Última carta removida - voltando ao início: {self._carta_atual_gestao}")
                                else:
                                    # Não há cartas restantes
                                    print(f"DEBUG: [COMPLETION] Nenhuma carta restante na gestão")
                        # Se carta_gestao_idx > self._carta_atual_gestao, não precisa ajustar
                        
                        print(f"DEBUG: [COMPLETION] Lista gestão após remoção: {len(self._cartas_gestao)} cartas")
                        print(f"DEBUG: [COMPLETION] _carta_atual_gestao após remoção: {self._carta_atual_gestao}")
                        print(f"DEBUG: [COMPLETION] Cartas restantes: {[os.path.basename(c) for c in self._cartas_gestao]}")
                        
                    except ValueError:
                        print(f"DEBUG: [COMPLETION] AVISO: Carta não estava na lista de gestão")
                
                # SEGUNDO: AGORA remover carta do carrossel
                print(f"DEBUG: [COMPLETION] === REMOVENDO CARTA COMPLETADA DO CARROSSEL ===")
                self._remover_carta_do_carrossel(carta_path)
                
                # TERCEIRO: Determinar se gestão deve continuar baseado na lista de gestão ATUALIZADA
                # CORREÇÃO CRÍTICA: A carta já foi removida da lista _cartas_gestao acima
                print(f"DEBUG: [COMPLETION] === VERIFICAÇÃO FINAL DE CONTINUAÇÃO ===")
                print(f"DEBUG: [COMPLETION] _cartas_gestao atual: {[os.path.basename(c) for c in getattr(self, '_cartas_gestao', [])]}")
                print(f"DEBUG: [COMPLETION] Tamanho da lista: {len(getattr(self, '_cartas_gestao', []))}")
                
                # CORREÇÃO CRÍTICA: NÃO resetar gestao_deve_continuar aqui!
                # A primeira lógica já tomou a decisão correta baseada em tempo_limite_obrigatorio e cartas seguintes
                # gestao_deve_continuar = False  # REMOVIDO - não sobrescrever primeira decisão
                # CORREÇÃO CRÍTICA: Apenas verificar cartas válidas para informação, NÃO alterar gestao_deve_continuar
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
                    # Verificar se ainda há cartas válidas na lista de gestão (apenas para logs informativos)
                    cartas_validas_na_gestao = 0
                    for carta in self._cartas_gestao:
                        if carta and hasattr(self, 'cards') and carta in self.cards:
                            carta_basename = os.path.basename(carta).lower()
                            # Carta deve ser Activity ou Challenge E existir no carrossel E estar virada para cima
                            if (not carta_basename.startswith("back_card_") and 
                                ("activity" in carta_basename or "challenge" in carta_basename)):
                                
                                # Verificar flag da carta
                                carta_index = self.cards.index(carta)
                                is_face_up = True  # Default para compatibilidade
                                if hasattr(self, 'card_face_up_flags') and carta_index < len(self.card_face_up_flags):
                                    is_face_up = self.card_face_up_flags[carta_index]
                                
                                if is_face_up:
                                    cartas_validas_na_gestao += 1
                                    print(f"DEBUG: [COMPLETION] Carta válida encontrada: {os.path.basename(carta)}")
                    
                    print(f"DEBUG: [COMPLETION] Cartas válidas restantes na gestão: {cartas_validas_na_gestao}")
                    print(f"DEBUG: [COMPLETION] IMPORTANTE: Respeitando decisão da primeira lógica: gestao_deve_continuar = {gestao_deve_continuar}")
                    
                    # NOVA VERIFICAÇÃO: Mesmo que hajam cartas válidas, verificar se já foram processadas
                    if cartas_validas_na_gestao > 0 and gestao_deve_continuar:
                        # Garantir que _carta_atual_gestao está dentro dos limites
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            self._carta_atual_gestao = 0
                        
                        # CORREÇÃO ADICIONAL: Verificar se as cartas restantes ainda precisam processamento NESTE CICLO
                        cartas_restantes_nao_processadas = 0
                        for carta in self._cartas_gestao:
                            try:
                                carta_idx = self.cards.index(carta)
                                carta_stats = self.card_stats[carta_idx] if carta_idx < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                                
                                # APLICAR A MESMA LÓGICA CORRIGIDA: APENAS interação do jogador NESTE CICLO
                                foi_processada_interacao = carta in getattr(self, '_cartas_interagidas_jogador', set())
                                foi_processada = foi_processada_interacao
                                
                                print(f"DEBUG: [COMPLETION] Verificação final carta: {os.path.basename(carta)}")
                                print(f"DEBUG: [COMPLETION]   Interação neste ciclo: {foi_processada_interacao}")
                                
                                if not foi_processada:
                                    cartas_restantes_nao_processadas += 1
                                    print(f"DEBUG: [COMPLETION]   RESULTADO: Precisa processamento - contando como não processada")
                                else:
                                    print(f"DEBUG: [COMPLETION]   RESULTADO: Já processada neste ciclo - pode pular")
                            except (ValueError, IndexError):
                                print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta)} não encontrada no carrossel para verificação final")
                                continue
                        
                        print(f"DEBUG: [COMPLETION] VERIFICAÇÃO FINAL:")
                        print(f"DEBUG: [COMPLETION]   Cartas válidas restantes: {cartas_validas_na_gestao}")
                        print(f"DEBUG: [COMPLETION]   Cartas restantes NÃO processadas: {cartas_restantes_nao_processadas}")
                        
                        if cartas_restantes_nao_processadas == 0:
                            print(f"DEBUG: [COMPLETION] CORREÇÃO: Todas as cartas restantes já foram processadas - FINALIZANDO gestão")
                            gestao_deve_continuar = False
                        else:
                            proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                            print(f"DEBUG: [COMPLETION] SUCCESS: Próxima carta será: {os.path.basename(proxima_carta)} (posição gestão: {self._carta_atual_gestao})")
                    elif cartas_validas_na_gestao == 0:
                        print(f"DEBUG: [COMPLETION] INFO: Não há cartas VÁLIDAS restantes na lista - finalizando independentemente da primeira decisão")
                        gestao_deve_continuar = False
                    else:
                        print(f"DEBUG: [COMPLETION] INFO: Há cartas válidas mas primeira lógica decidiu finalizar gestão")
                        # NÃO sobrescrever gestao_deve_continuar aqui - primeira lógica já decidiu
                else:
                    print(f"DEBUG: [COMPLETION] INFO: Lista de gestão vazia - finalizando gestão")
                    # Só finalizar se primeira lógica não decidiu continuar por tempo_limite_obrigatorio
                    if not (tempo_limite_obrigatorio and gestao_deve_continuar):
                        gestao_deve_continuar = False
                
                # TERCEIRO: Ajustar índice se está fora de range
                if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                    if self._carta_atual_gestao >= len(self._cartas_gestao):
                        self._carta_atual_gestao = len(self._cartas_gestao) - 1
                        print(f"DEBUG: [COMPLETION] Ajustado _carta_atual_gestao para {self._carta_atual_gestao}")
                
                # Fechar overlay atual (destruir todos os widgets)
                for widget in self.winfo_children():
                    widget.destroy()
                
                # CORREÇÃO: Remover flag de overlay ativo quando widgets são destruídos
                self._completion_overlay_active = False
                print("DEBUG: [COMPLETION] Flag _completion_overlay_active = False (overlay fechado)")
                
                # Limpar flag de tempo limite obrigatório
                if hasattr(self, '_completion_tempo_limite_obrigatorio'):
                    delattr(self, '_completion_tempo_limite_obrigatorio')
                
                print(f"DEBUG: [COMPLETION] ===== DECISÃO DE CONTINUAÇÃO DA GESTÃO =====")
                print(f"DEBUG: [COMPLETION] gestao_esta_ativa: {gestao_esta_ativa}")
                print(f"DEBUG: [COMPLETION] gestao_deve_continuar: {gestao_deve_continuar}")
                print(f"DEBUG: [COMPLETION] len(_cartas_gestao): {len(getattr(self, '_cartas_gestao', []))}")
                print(f"DEBUG: [COMPLETION] _carta_atual_gestao: {getattr(self, '_carta_atual_gestao', 'N/A')}")
                
                # QUARTO: Tomar decisão final sobre continuação da gestão
                if gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] SUCCESS: Continuando gestão de pacotes")
                    
                    # CORREÇÃO CRÍTICA: Determinar corretamente a próxima carta válida na lista de gestão
                    if hasattr(self, '_cartas_gestao') and self._cartas_gestao and hasattr(self, '_carta_atual_gestao'):
                        # NOVA LÓGICA: Quando uma carta é removida no meio da lista, o índice atual já aponta para a próxima carta
                        # Se a carta removida estava na posição atual, não incrementamos - a próxima já está na mesma posição
                        # Se a carta removida estava antes da atual, já decrementámos o índice
                        
                        # Verificar se o índice atual ainda está válido
                        if self._carta_atual_gestao >= len(self._cartas_gestao):
                            # Se o índice ficou inválido, significa que removemos a última carta
                            # Voltar ao início da lista para continuar com a primeira carta restante
                            self._carta_atual_gestao = 0
                            print(f"DEBUG: [COMPLETION] Índice ajustado para início da lista: {self._carta_atual_gestao}")
                        
                        proxima_carta = self._cartas_gestao[self._carta_atual_gestao]
                        print(f"DEBUG: [COMPLETION] SUCCESS: Próxima carta determinada: {os.path.basename(proxima_carta)} (posição gestão: {self._carta_atual_gestao})")
                        
                        # CORREÇÃO CRÍTICA: Encontrar posição da próxima carta no carrossel ATUALIZADO 
                        # Após remoção, as cartas mudam de posição - procurar pelo basename da carta
                        proxima_posicao = None
                        proxima_carta_basename = os.path.basename(proxima_carta)
                        
                        if hasattr(self, 'cards'):
                            print(f"DEBUG: [COMPLETION] Procurando carta {proxima_carta_basename} no carrossel atualizado:")
                            for i, carta in enumerate(self.cards):
                                carta_basename = os.path.basename(carta)
                                print(f"DEBUG: [COMPLETION]   Posição {i}: {carta_basename}")
                                
                                # CORREÇÃO: Comparar basename e verificar se carta está face up
                                if (carta_basename == proxima_carta_basename and 
                                    i < len(self.card_face_up_flags) and 
                                    self.card_face_up_flags[i]):
                                    proxima_posicao = i
                                    print(f"DEBUG: [COMPLETION] SUCCESS: {proxima_carta_basename} encontrada na posição {i} e está face up")
                                    break
                        
                        if proxima_posicao is not None:
                            print(f"DEBUG: [COMPLETION] SUCCESS: Atualizando seleção para próxima carta válida:")
                            print(f"DEBUG: [COMPLETION]   Carta: {proxima_carta_basename}")
                            print(f"DEBUG: [COMPLETION]   Posição carrossel: {proxima_posicao}")
                            print(f"DEBUG: [COMPLETION]   Posição gestão: {self._carta_atual_gestao}")
                            
                            # ATUALIZAR seleção do carrossel para a próxima carta CORRETA
                            self.selected_carousel_card = self.cards[proxima_posicao]  # Usar carta do carrossel atual
                            self.selected_carousel_index = proxima_posicao
                            
                        else:
                            print(f"DEBUG: [COMPLETION] WARNING: Carta {proxima_carta_basename} não encontrada face up no carrossel")
                            print(f"DEBUG: [COMPLETION] Carrossel atual: {[os.path.basename(c) for c in self.cards]}")
                            print(f"DEBUG: [COMPLETION] Estados face up: {self.card_face_up_flags}")
                            print(f"DEBUG: [COMPLETION] IMPORTANTE: Mesmo assim, continuar gestão - carta pode estar noutro slot")
                            # NÃO definir gestao_deve_continuar = False - deixar a gestão continuar
                    
                    if gestao_deve_continuar:
                        print(f"DEBUG: [COMPLETION] Reconstruindo dashboard e continuando gestão...")
                        
                        # BACKUP CRÍTICO: Preservar tracking antes da reconstrução da interface
                        print(f"DEBUG: [COMPLETION] BACKUP DOS CONTADORES antes da reconstrução...")
                        self._backup_turn_counters_before_reconstruction()
                        
                        # RECONSTRUIR DASHBOARD antes de continuar gestão
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                        # Depois de reconstruir, continuar gestão na carta correta
                        self.after(100, lambda: self._mostrar_gestao_carta_atual())
                        return
                
                if not gestao_deve_continuar:
                    print(f"DEBUG: [COMPLETION] SUCCESS: Gestão de pacotes finalizada - não há mais cartas para processar")
                    print(f"DEBUG: [COMPLETION] Voltando ao dashboard normal com End Turn habilitado")
                    
                    # CORREÇÃO CRÍTICA: Finalizar gestão mas MANTER Final Phase ativo para End Turn
                    self._final_phase_gestao_ativa = False
                    # NÃO limpar _final_phase_active - o jogador ainda está em Final Phase!
                    
                    # CORREÇÃO: Ativar End Turn quando gestão termina por completion
                    self._show_end_turn_button = True
                    
                    if hasattr(self, '_cartas_gestao'):
                        self._cartas_gestao = []
                    if hasattr(self, '_carta_atual_gestao'):
                        self._carta_atual_gestao = 0
                    
                    # CORREÇÃO CRÍTICA: Voltar ao dashboard MANTENDO Final Phase ativo
                    print(f"DEBUG: [COMPLETION] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    # CORREÇÃO CRÍTICA: Ativar o botão End Turn APÓS reconstruir a interface
                    self.after(100, self._ativar_botao_end_turn)
                    
                    # CORREÇÃO NOVA: Forçar atualização dos destaques para garantir que carta restante fique destacada
                    self.after(200, lambda: self._update_carousel_selection_highlights())
                    
            # CORREÇÃO CRÍTICA: Preservar a decisão da gestão para retorno
            print(f"DEBUG: [COMPLETION] Preservando decisão final: gestao_deve_continuar = {gestao_deve_continuar}")
        
        # Texto do botão baseado no tipo de carta
        if card_type == "Activity":
            btn_text = "OK"
        elif is_sequential and hasattr(self, '_current_completion_index') and hasattr(self, '_next_completion_overlays'):
            current_index = self._current_completion_index
            total_overlays = len(self._next_completion_overlays)
            if current_index < total_overlays - 1:
                btn_text = "Próxima →"
            else:
                btn_text = "Finalizar"
        else:
            btn_text = "OK"
        
        # Botão OK roxo (inferior central)
        print(f"DEBUG: [COMPLETION] Criando botão OK...")
        ok_btn = tk.Button(
            completion_frame,
            text=btn_text,
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="#8000FF",  # Roxo
            bd=2,
            relief="raised",
            width=12,
            height=1,
            command=fechar_e_continuar
        )
        ok_btn.pack(pady=(20, 20), anchor="center")  # Centralizar o botão
        print(f"DEBUG: [COMPLETION] Botão OK criado e posicionado")
        
        print(f"DEBUG: [COMPLETION] Overlay de congratulações criado com botão '{btn_text}'")
        
        # Armazenar dados da recompensa e tipo de carta para quando fechar o overlay
        self._completion_reward = reward_value
        self._completed_card_path = carta_path
        self._completed_card_type = card_type
        
        # Forçar update da janela principal para garantir que tudo é renderizado
        self.update_idletasks()
        self.deiconify()  # Garantir que está visível
        self.lift()       # Trazer para a frente
        self.focus_force()  # Forçar foco
        
        print(f"DEBUG: [COMPLETION] Overlay criado, tipo: {card_type}, recompensa: {reward_value} picoins")
        print(f"DEBUG: [COMPLETION] Widgets criados no overlay: {len(completion_frame.winfo_children())} widgets")
        print(f"DEBUG: [COMPLETION] Botão OK widget: {ok_btn}")
        print(f"DEBUG: [COMPLETION] Botão OK visível: {ok_btn.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal geometry: {self.geometry()}")
        print(f"DEBUG: [COMPLETION] Janela principal viewable: {self.winfo_viewable()}")
        print(f"DEBUG: [COMPLETION] Janela principal ismapped: {self.winfo_ismapped()}")
    
    def _calcular_reward_completion(self, carta_path, dados_carta, card_type, carta_index=None):
        """
        Calcula o reward de completion baseado nas regras específicas do arquivo Reward_Activity e Reward_Challenge
        """
        print(f"DEBUG: [REWARD_CALC] Calculando reward para {card_type}: {os.path.basename(carta_path)}")
        
        # CORREÇÃO: Usar índice específico da carta se fornecido, senão usar selected_card_idx
        card_idx = carta_index if carta_index is not None else getattr(self, 'selected_card_idx', 0)
        
        # Obter valores atuais das barras de progresso usando o índice correto
        rxd_atual = self._obter_valor_barra_atual_by_index("Rxd", card_idx)
        lost_atual = self._obter_valor_barra_atual_by_index("Lost", card_idx)
        
        print(f"DEBUG: [REWARD_CALC] Valores atuais (carta índice {card_idx}) - Rxd: {rxd_atual}, Lost: {lost_atual}")
        print(f"DEBUG: [REWARD_CALC] Dados da carta: {dados_carta}")
        
        if card_type == "Activity":
            return self._calcular_reward_activity(carta_path, dados_carta, rxd_atual, lost_atual)
        elif card_type == "Challenge":
            return self._calcular_reward_challenge(carta_path, dados_carta, rxd_atual, lost_atual)
        else:
            # Fallback para valor message_received
            return dados_carta.get('message_received', 0)
    
    def _calcular_reward_activity(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Activity baseado nas regras do arquivo Reward_Activity
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necessários da carta
        reward_per_packet = dados_carta.get('reward_per_packet', 0)
        packet_bonus = dados_carta.get('packet_bonus', 0)
        bonus_condition = dados_carta.get('bonus_condition', 0)
        message_received = dados_carta.get('message_received', 0)
        message_size = dados_carta.get('message_size', 0)
        penalty_per_packet = dados_carta.get('penalty_per_packet', 0)
        penalty_condition = dados_carta.get('penalty_condition', 0)
        
        print(f"DEBUG: [REWARD_CALC] Activity data:")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  packet_bonus: {packet_bonus}")
        print(f"  bonus_condition: {bonus_condition}")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  penalty_per_packet: {penalty_per_packet}")
        print(f"  penalty_condition: {penalty_condition}")
        
        # Identificar qual Activity é baseado no nome do arquivo
        if "activity_1" in carta_basename:
            # Activity_1 (Home Surveillance): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_1: {n_rxd} × {reward_per_packet} = {reward}")
            
        elif "activity_2" in carta_basename or "activity_3" in carta_basename:
            # Activity_2-3 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [n_Rxd x packet_bonus (se n_Rxd >= bonus_condition)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (n_rxd * packet_bonus) if n_rxd >= bonus_condition else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_2-3: {n_rxd}×{reward_per_packet} + bonus({n_rxd}×{packet_bonus} se {n_rxd}>={bonus_condition}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_4" in carta_basename:
            # Activity_4 (Home Surveillance): Reward = [n_Rxd x reward_per_packet] + [message_received (se bonus_condition == n_Lost)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if bonus_condition == n_lost else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_4: {n_rxd}×{reward_per_packet} + message_received({message_received} se {bonus_condition}=={n_lost}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_5" in carta_basename:
            # Activity_5 (Home Safety): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_5: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_6" in carta_basename or "activity_7" in carta_basename:
            # Activity_6-7 (Home Safety): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost <= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost <= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # Não pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_6-7: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}×{penalty_per_packet} se {n_lost}<={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_8" in carta_basename:
            # Activity_8 (Short Message): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_8: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        elif "activity_9" in carta_basename:
            # Activity_9 (Short Message): Reward = message_received (se n_Rxd == message_size) - [n_Lost x penalty_per_packet (se n_Lost >= penalty_condition)]
            base_reward = message_received if n_rxd == message_size else 0
            penalty = (n_lost * penalty_per_packet) if n_lost >= penalty_condition else 0
            reward = max(0, base_reward - penalty)  # Não pode ser negativo
            print(f"DEBUG: [REWARD_CALC] Activity_9: message_received({message_received} se {n_rxd}=={message_size}) - penalty({n_lost}×{penalty_per_packet} se {n_lost}>={penalty_condition}) = {base_reward} - {penalty} = {reward}")
            
        elif "activity_10" in carta_basename:
            # Activity_10 (Gaming): Reward = n_Rxd x reward_per_packet
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Activity_10: {n_rxd} × {reward_per_packet} = {reward}")
            
        elif "activity_11" in carta_basename:
            # Activity_11 (Gaming): Reward = [n_Rxd x reward_per_packet] + [message_received (se n_Rxd == message_size)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = message_received if n_rxd == message_size else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Activity_11: {n_rxd}×{reward_per_packet} + message_received({message_received} se {n_rxd}=={message_size}) = {base_reward} + {bonus_reward} = {reward}")
            
        elif "activity_12" in carta_basename:
            # Activity_12 (File Transfer): Reward = message_received (se n_Rxd == message_size)
            reward = message_received if n_rxd == message_size else 0
            print(f"DEBUG: [REWARD_CALC] Activity_12: message_received({message_received} se {n_rxd}=={message_size}) = {reward}")
            
        else:
            # Fallback para Activities não reconhecidas
            reward = message_received
            print(f"DEBUG: [REWARD_CALC] Activity não reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que não é negativo
    
    def _calcular_reward_challenge(self, carta_path, dados_carta, n_rxd, n_lost):
        """
        Calcula reward para Challenge baseado nas regras do arquivo Reward_Challenge
        """
        carta_basename = os.path.basename(carta_path).lower()
        
        # Extrair dados necessários da carta
        message_received = dados_carta.get('message_received', 0) or 0
        message_size = dados_carta.get('message_size', 0) or 0
        reward_per_packet = dados_carta.get('reward_per_packet', 0) or 0
        time_limit_bonus = dados_carta.get('time_limit_bonus', 0) or 0
        message_received_bonus = dados_carta.get('message_received_bonus', 0) or 0
        
        # CORREÇÃO: Usar valor passado por parâmetro em vez de obter da barra atual
        # (que pode estar apontando para carta errada)
        to_send_atual = message_size - n_rxd  # Calcular To send baseado nos valores corretos
        
        print(f"DEBUG: [REWARD_CALC] Challenge data:")
        print(f"  message_received: {message_received}")
        print(f"  message_size: {message_size}")
        print(f"  reward_per_packet: {reward_per_packet}")
        print(f"  time_limit_bonus: {time_limit_bonus}")
        print(f"  message_received_bonus: {message_received_bonus}")
        print(f"  to_send_calculado: {to_send_atual}")
        
        # Verificar condições de completion (To send = 0 e Rxd = message_size)
        completion_achieved = (to_send_atual == 0 and n_rxd == message_size)
        print(f"DEBUG: [REWARD_CALC] Completion achieved: {completion_achieved} (to_send={to_send_atual}, rxd={n_rxd}, message_size={message_size})")
        
        # Identificar qual Challenge é baseado no nome do arquivo
        if any(f"challenge_{i}." in carta_basename for i in range(1, 5)):
            # Challenge_1-4 (Message Mission): Reward = message_received (se completion achieved)
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge_1-4: message_received({message_received} se completion) = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(5, 8)):
            # Challenge_5-7 (Message Sprint): Reward = time_limit_bonus + message_received (se completion achieved E dentro do time_limit)
            time_limit = dados_carta.get('time_limit', 0) or 0
            
            # Verificar se carta foi iniciada e calcular turnos decorridos
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            within_time_limit = turns_elapsed <= time_limit if time_limit > 0 else True
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7 timing:")
            print(f"  time_limit: {time_limit} turnos")
            print(f"  turns_elapsed: {turns_elapsed} turnos")
            print(f"  within_time_limit: {within_time_limit}")
            
            # Time bonus só é dado se completion achieved E dentro do limite de tempo
            time_bonus = (time_limit_bonus or 0) if (completion_achieved and within_time_limit) else 0
            # Message received só é dado se completion achieved (independente do tempo)
            message_bonus = (message_received or 0) if completion_achieved else 0
            reward = time_bonus + message_bonus
            
            print(f"DEBUG: [REWARD_CALC] Challenge_5-7: time_limit_bonus({time_limit_bonus} se completion E time_limit) + message_received({message_received} se completion) = {time_bonus} + {message_bonus} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(8, 11)):
            # Challenge_8-10 (Jackpot): Reward = [n_Rxd x reward_per_packet] + [message_received_bonus (se completion achieved)]
            base_reward = n_rxd * reward_per_packet
            bonus_reward = (message_received_bonus or 0) if completion_achieved else 0
            reward = base_reward + bonus_reward
            print(f"DEBUG: [REWARD_CALC] Challenge_8-10: {n_rxd}×{reward_per_packet} + message_received_bonus({message_received_bonus} se completion) = {base_reward} + {bonus_reward} = {reward}")
            
        elif any(f"challenge_{i}." in carta_basename for i in range(11, 15)):
            # Challenge_11-14 (Packet Race): Reward = n_Rxd x reward_per_packet (SEM verificação de completion)
            reward = n_rxd * reward_per_packet
            print(f"DEBUG: [REWARD_CALC] Challenge_11-14: {n_rxd} × {reward_per_packet} = {reward}")
            
        else:
            # Fallback para Challenges não reconhecidas
            reward = (message_received or 0) if completion_achieved else 0
            print(f"DEBUG: [REWARD_CALC] Challenge não reconhecida, usando message_received: {reward}")
        
        return max(0, reward)  # Garantir que não é negativo
    
    def _get_turns_elapsed_for_challenge(self, carta_path):
        """
        Calcula quantos turnos uma Challenge esteve ativa usando a fórmula:
        turnos_ativo = turno_atual - turno_carta_ativou + 1
        
        CORREÇÃO CRÍTICA: Implementa busca por basename como fallback para resolver
        incompatibilidade entre caminhos completos no tracking e basenames no carrossel.
        
        Args:
            carta_path (str): Caminho da carta Challenge
            
        Returns:
            int: Número de turnos que a carta esteve ativa
        """
        if not carta_path:
            print(f"DEBUG: [TURNS_ELAPSED] Carta path vazio ou None")
            return 0
        
        carta_filename = os.path.basename(carta_path)
        print(f"DEBUG: [TURNS_ELAPSED] Calculando turnos para: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED] Caminho fornecido: {carta_path}")
        print(f"DEBUG: [TURNS_ELAPSED] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [TURNS_ELAPSED] Tracking disponível: {self._challenge_start_turns}")
        
        # CORREÇÃO CRÍTICA: Primeiro tentar caminho exato
        if carta_path in self._challenge_start_turns:
            turno_inicio = self._challenge_start_turns[carta_path]
            turnos_ativa = self._current_turn_number - turno_inicio + 1
            print(f"DEBUG: [TURNS_ELAPSED] ✅ Registo encontrado por caminho exato:")
            print(f"DEBUG: [TURNS_ELAPSED]   Turno de ativação: {turno_inicio}")
            print(f"DEBUG: [TURNS_ELAPSED]   Turno atual: {self._current_turn_number}")
            print(f"DEBUG: [TURNS_ELAPSED]   Fórmula: {self._current_turn_number} - {turno_inicio} + 1 = {turnos_ativa}")
            print(f"DEBUG: [TURNS_ELAPSED]   Challenge ativa há {turnos_ativa} turnos")
            print(f"DEBUG: [TURNS_ELAPSED]   AMBIENTE: {get_universal_paths()['environment']}")
            return turnos_ativa
        
        # CORREÇÃO CRÍTICA: Se não encontrou por caminho exato, procurar por basename
        print(f"DEBUG: [TURNS_ELAPSED] ⚠️ Caminho exato não encontrado, procurando por basename: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED] ANÁLISE DETALHADA do tracking disponível:")
        
        for i, (tracked_path, turno_inicio) in enumerate(self._challenge_start_turns.items(), 1):
            tracked_basename = os.path.basename(tracked_path)
            match_basename = tracked_basename == carta_filename
            print(f"DEBUG: [TURNS_ELAPSED]   Entrada {i}:")
            print(f"DEBUG: [TURNS_ELAPSED]     Caminho: {tracked_path}")
            print(f"DEBUG: [TURNS_ELAPSED]     Basename: {tracked_basename}")
            print(f"DEBUG: [TURNS_ELAPSED]     Match com {carta_filename}? {match_basename}")
            print(f"DEBUG: [TURNS_ELAPSED]     Turno início: {turno_inicio}")
            
            if match_basename:
                turnos_ativa = self._current_turn_number - turno_inicio + 1
                print(f"DEBUG: [TURNS_ELAPSED] ✅ MATCH ENCONTRADO por basename!")
                print(f"DEBUG: [TURNS_ELAPSED]   Tracking path: {tracked_path}")
                print(f"DEBUG: [TURNS_ELAPSED]   Basename match: {tracked_basename} == {carta_filename}")
                print(f"DEBUG: [TURNS_ELAPSED]   Turno de ativação: {turno_inicio}")
                print(f"DEBUG: [TURNS_ELAPSED]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [TURNS_ELAPSED]   Fórmula: {self._current_turn_number} - {turno_inicio} + 1 = {turnos_ativa}")
                print(f"DEBUG: [TURNS_ELAPSED]   Challenge ativa há {turnos_ativa} turnos")
                print(f"DEBUG: [TURNS_ELAPSED]   AMBIENTE: {get_universal_paths()['environment']}")
                return turnos_ativa
        
        # Se nem por basename encontrou, então realmente não foi registada
        print(f"DEBUG: [TURNS_ELAPSED] ❌ ERRO CRÍTICO: Challenge {carta_filename} não tem registo de ativação!")
        print(f"DEBUG: [TURNS_ELAPSED] Nem por caminho exato nem por basename foi encontrada no tracking")
        print(f"DEBUG: [TURNS_ELAPSED] CAUSA POSSÍVEL: Challenge não foi registada quando adicionada ao carrossel")
        print(f"DEBUG: [TURNS_ELAPSED] DIAGNÓSTICO:")
        print(f"DEBUG: [TURNS_ELAPSED]   - Caminho procurado: {carta_path}")
        print(f"DEBUG: [TURNS_ELAPSED]   - Basename procurado: {carta_filename}")
        print(f"DEBUG: [TURNS_ELAPSED]   - Total tracking entries: {len(self._challenge_start_turns)}")
        print(f"DEBUG: [TURNS_ELAPSED]   - Método de busca: caminho exato + basename fallback")
        
        # CORREÇÃO AUTOMÁTICA: Tentar recuperar Challenge sem tracking
        print(f"DEBUG: [TURNS_ELAPSED] 🔧 TENTANDO RECUPERAÇÃO AUTOMÁTICA...")
        if self._tentar_recuperar_challenge_perdida(carta_path):
            # Se conseguiu recuperar, tentar novamente
            print(f"DEBUG: [TURNS_ELAPSED] ✅ Challenge recuperado! Tentando novamente...")
            if carta_path in self._challenge_start_turns:
                turno_inicio = self._challenge_start_turns[carta_path]
                turnos_ativa = self._current_turn_number - turno_inicio + 1
                print(f"DEBUG: [TURNS_ELAPSED] ✅ RECUPERAÇÃO SUCESSO: Challenge ativa há {turnos_ativa} turnos")
                return turnos_ativa
        
        print(f"DEBUG: [TURNS_ELAPSED] ❌ RECUPERAÇÃO FALHADA: Retornando 0 turnos")
        print(f"DEBUG: [TURNS_ELAPSED] CORREÇÃO SUGERIDA: Verificar _register_challenge_start_turn() ou _substituir_activity_por_challenge()")
        return 0
    
    def _tentar_recuperar_challenge_perdida(self, carta_path):
        """
        Tenta recuperar uma Challenge que perdeu o registo de tracking.
        
        CORREÇÃO CRÍTICA: Challenge recém aceite deve ser registado NO TURNO ATUAL.
        A recuperação anterior estava incorretamente estimando turnos passados.
        
        Args:
            carta_path (str): Caminho da Challenge perdida
            
        Returns:
            bool: True se conseguiu recuperar, False caso contrário
        """
        try:
            print(f"DEBUG: [RECOVERY] === INICIANDO RECUPERAÇÃO DE CHALLENGE PERDIDA ===")
            print(f"DEBUG: [RECOVERY] Challenge: {os.path.basename(carta_path)}")
            print(f"DEBUG: [RECOVERY] Caminho: {carta_path}")
            
            # PRIMEIRO: Verificar se Challenge está nos backups consolidados
            # Se está, não é Challenge perdida - é problema de sincronização temporária
            fontes_backup = []
            
            # Backup imediato (mais recente)
            if hasattr(self, '_estado_botoes_imediato') and self._estado_botoes_imediato:
                backup_imediato = getattr(self._estado_botoes_imediato, 'challenge_tracking_consolidado', {})
                if backup_imediato:
                    fontes_backup.append((backup_imediato, 'imediato'))
            
            # Backups do master (root)
            if hasattr(self.master, '_backup_challenge_tracking'):
                fontes_backup.append((self.master._backup_challenge_tracking, 'master_backup'))
            if hasattr(self.master, '_super_challenge_backup'):
                fontes_backup.append((self.master._super_challenge_backup, 'super_backup'))
            
            # Backup do registry 
            if hasattr(self, '_challenge_backup_registry'):
                fontes_backup.append((self._challenge_backup_registry, 'registry_backup'))
            
            print(f"DEBUG: [RECOVERY] Verificando {len(fontes_backup)} fontes de backup...")
            
            # Procurar Challenge nos backups
            for backup_source, nome_fonte in fontes_backup:
                if carta_path in backup_source:
                    turno_correto = backup_source[carta_path]
                    print(f"DEBUG: [RECOVERY] ✅ ENCONTRADO em {nome_fonte}: turno {turno_correto}")
                    self._challenge_start_turns[carta_path] = turno_correto
                    print(f"DEBUG: [RECOVERY] ✅ RECUPERAÇÃO DE BACKUP: Challenge registado no turno {turno_correto}")
                    print(f"DEBUG: [RECOVERY] === FIM RECUPERAÇÃO (BACKUP) ===")
                    return True
            
            print(f"DEBUG: [RECOVERY] Challenge não encontrado em backups - assumindo Challenge RECÉM ACEITE")
            
            # Se não encontrado em backups, é Challenge recém aceite no turno atual
            turno_atual = self._current_turn_number
            print(f"DEBUG: [RECOVERY] Turno atual: {turno_atual}")
            print(f"DEBUG: [RECOVERY] CORREÇÃO: Challenge recém aceite deve iniciar NO TURNO ATUAL")
            
            # Registar no turno atual
            self._challenge_start_turns[carta_path] = turno_atual
            print(f"DEBUG: [RECOVERY] ✅ Challenge registado como RECÉM ACEITE no turno {turno_atual}")
            print(f"DEBUG: [RECOVERY] Challenge ficará ativo por toda a sua duração normal")
            print(f"DEBUG: [RECOVERY] === FIM RECUPERAÇÃO (NOVA CHALLENGE) ===")
            return True
            
        except Exception as e:
            print(f"DEBUG: [RECOVERY] ❌ ERRO durante recuperação: {e}")
            print(f"DEBUG: [RECOVERY] === FIM RECUPERAÇÃO (ERRO) ===")
            return False
    
    def _debug_challenge_tracking_state(self):
        """
        Método de debug para analisar o estado atual do tracking de Challenges
        e identificar inconsistências entre carrossel e tracking
        """
        print(f"DEBUG: [TRACKING_DEBUG] ========== ESTADO DO CHALLENGE TRACKING ==========")
        print(f"DEBUG: [TRACKING_DEBUG] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [TRACKING_DEBUG] Challenges no tracking: {len(self._challenge_start_turns)}")
        
        # Analisar tracking atual
        for i, (tracked_path, turno_inicio) in enumerate(self._challenge_start_turns.items(), 1):
            turnos_ativa = self._current_turn_number - turno_inicio + 1
            print(f"DEBUG: [TRACKING_DEBUG] Entrada {i}:")
            print(f"DEBUG: [TRACKING_DEBUG]   Caminho: {tracked_path}")
            print(f"DEBUG: [TRACKING_DEBUG]   Basename: {os.path.basename(tracked_path)}")
            print(f"DEBUG: [TRACKING_DEBUG]   Turno início: {turno_inicio}")
            print(f"DEBUG: [TRACKING_DEBUG]   Turnos ativa: {turnos_ativa}")
        
        # Analisar cartas no carrossel
        print(f"DEBUG: [TRACKING_DEBUG] ========== CHALLENGES NO CARROSSEL ==========")
        if hasattr(self, 'cards'):
            for i, carta_path in enumerate(self.cards):
                if carta_path and self._is_challenge_card(carta_path):
                    carta_basename = os.path.basename(carta_path)
                    has_tracking = carta_path in self._challenge_start_turns
                    has_tracking_basename = any(os.path.basename(p) == carta_basename for p in self._challenge_start_turns.keys())
                    
                    print(f"DEBUG: [TRACKING_DEBUG] Posição {i}:")
                    print(f"DEBUG: [TRACKING_DEBUG]   Caminho: {carta_path}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Basename: {carta_basename}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Tem tracking exato: {has_tracking}")
                    print(f"DEBUG: [TRACKING_DEBUG]   Tem tracking basename: {has_tracking_basename}")
                    
                    if not has_tracking and not has_tracking_basename:
                        print(f"DEBUG: [TRACKING_DEBUG]   ⚠️ PROBLEMA: Challenge sem tracking!")
        
        print(f"DEBUG: [TRACKING_DEBUG] ========== FIM ANÁLISE TRACKING ==========")
    
    def _register_challenge_start_turn(self, carta_path, turno_especifico=None):
        """
        Regista o turno em que uma carta Challenge foi aceite
        CORREÇÃO CRÍTICA: Aceitar turno específico para casos onde o timing é crítico
        CORREÇÃO ESPECÍFICA: Normalizar caminhos para garantir compatibilidade com busca posterior
        CORREÇÃO EMERGENCIAL: Garantir que tracking nunca se perde durante reconstruções
        CORREÇÃO FUNDAMENTAL: Detectar se estamos numa substituição e sempre usar turno correto
        
        Args:
            carta_path: Caminho da carta Challenge
            turno_especifico: Turno específico para registar (opcional - se None, usa turno atual)
        """
        print(f"DEBUG: [CHALLENGE_REGISTER] === REGISTANDO CHALLENGE START TURN ===")
        print(f"DEBUG: [CHALLENGE_REGISTER] Challenge: {os.path.basename(carta_path)}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Caminho original: {carta_path}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno específico solicitado: {turno_especifico}")
        
        # PROTEÇÃO CRÍTICA: Inicializar _challenge_start_turns se não existir
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}
            print(f"DEBUG: [CHALLENGE_REGISTER] WARNING: _challenge_start_turns não existia! Inicializado vazio.")
        
        # CORREÇÃO CRÍTICA: Usar turno específico se fornecido, senão usar turno atual
        if turno_especifico is not None:
            turno_registo = turno_especifico
            print(f"DEBUG: [CHALLENGE_REGISTER] USANDO TURNO ESPECÍFICO: {turno_registo}")
        else:
            turno_registo = self._current_turn_number
            print(f"DEBUG: [CHALLENGE_REGISTER] USANDO TURNO ATUAL: {turno_registo}")
        
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno atual do sistema: {self._current_turn_number}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Turno de registo (aceite neste turno): {turno_registo}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Tracking atual: {self._challenge_start_turns}")
        
        # CORREÇÃO ESPECÍFICA: Normalizar caminho para usar sempre o basename
        # Isto garante compatibilidade independentemente do caminho completo usado
        challenge_basename = os.path.basename(carta_path)
        
        # CORREÇÃO FUNDAMENTAL: Detectar se esta função está a ser chamada durante aceitação/substituição
        # Se turno_especifico foi fornecido, significa que estamos numa operação controlada (aceitar/substituir)
        is_controlled_registration = turno_especifico is not None
        print(f"DEBUG: [CHALLENGE_REGISTER] Operação controlada (aceitar/substituir): {is_controlled_registration}")
        
        # CORREÇÃO CRÍTICA: Verificar se já existe registo por basename (busca robusta)
        existing_path = None
        existing_turn = None
        
        # Primeiro verificar caminho exato
        if carta_path in self._challenge_start_turns:
            existing_path = carta_path
            existing_turn = self._challenge_start_turns[carta_path]
        
        # Se não encontrou por caminho exato, procurar por basename
        if not existing_path:
            for tracked_path, turno in self._challenge_start_turns.items():
                if os.path.basename(tracked_path) == challenge_basename:
                    existing_path = tracked_path
                    existing_turn = turno
                    break
        
        # CORREÇÃO FUNDAMENTAL: Se já existe registo, distinguir entre operações controladas e recuperação automática
        if existing_path:
            print(f"DEBUG: [CHALLENGE_REGISTER] Challenge {challenge_basename} JÁ tem registo:")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Caminho tracking: {existing_path}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Turno existente: {existing_turn}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Tentativa de re-registo com turno: {turno_registo}")
            print(f"DEBUG: [CHALLENGE_REGISTER]   Operação controlada: {is_controlled_registration}")
            
            # CORREÇÃO CRÍTICA: Se é operação controlada (aceitar/substituir Challenge), SEMPRE atualizar
            if is_controlled_registration:
                print(f"DEBUG: [CHALLENGE_REGISTER] *** OPERAÇÃO CONTROLADA DETECTADA ***")
                print(f"DEBUG: [CHALLENGE_REGISTER] Challenge está sendo aceite/substituído AGORA - ATUALIZANDO turno!")
                print(f"DEBUG: [CHALLENGE_REGISTER] SOBRESCREVENDO turno {existing_turn} -> {turno_registo}")
                
                # Atualizar com o turno correto da aceitação/substituição
                if existing_path != carta_path:
                    # Migrar chave se necessário
                    del self._challenge_start_turns[existing_path]
                    print(f"DEBUG: [CHALLENGE_REGISTER] Chave migrada: {existing_path} -> {carta_path}")
                
                self._challenge_start_turns[carta_path] = turno_registo
                print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Challenge registado com turno ATUAL {turno_registo}")
                return
            else:
                # Operação não controlada (recuperação automática) - preservar turno existente
                print(f"DEBUG: [CHALLENGE_REGISTER] Operação NÃO controlada (recuperação automática)")
                print(f"DEBUG: [CHALLENGE_REGISTER] PRESERVANDO turno original {existing_turn} - NÃO sobrescrevendo!")
                
                # CORREÇÃO ESPECÍFICA: Se os caminhos são diferentes mas o basename igual, 
                # manter o registo com o caminho do carrossel (mais preciso) MAS preservar turno original
                if existing_path != carta_path:
                    print(f"DEBUG: [CHALLENGE_REGISTER] MIGRAÇÃO: Atualizando chave de tracking:")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   De: {existing_path}")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   Para: {carta_path}")
                    print(f"DEBUG: [CHALLENGE_REGISTER]   Preservando turno original: {existing_turn}")
                    del self._challenge_start_turns[existing_path]
                    self._challenge_start_turns[carta_path] = existing_turn
                    print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Chave migrada mantendo turno original {existing_turn}")
                else:
                    print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Registo já existe e está correto - nenhuma ação necessária")
                return
        
        # NOTA: O código de verificação de substituição foi removido porque agora sempre preservamos
        # o turno original. Substituições devem ser tratadas explicitamente por outras funções.
        
        # Registar novo Challenge com o turno correto de aceitação
        self._challenge_start_turns[carta_path] = turno_registo
        print(f"DEBUG: [CHALLENGE_REGISTER] SUCCESS: Challenge {challenge_basename} registado no turno {turno_registo}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Caminho de tracking: {carta_path}")
        print(f"DEBUG: [CHALLENGE_REGISTER] Tracking atualizado: {self._challenge_start_turns}")
        print(f"DEBUG: [CHALLENGE_REGISTER] === FIM REGISTO ===")
        
        # BACKUP CRÍTICO: Salvar tracking no root E master como backup de segurança
        try:
            # Backup no root (primary)
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root:
                    root._backup_challenge_tracking = self._challenge_start_turns.copy()
                    print(f"DEBUG: [CHALLENGE_REGISTER] BACKUP: Tracking salvo no ROOT (primary)")
            
            # Backup no master (secondary)
            if hasattr(self, 'master') and self.master is not None:
                if not hasattr(self.master, '_challenge_start_turns_backup'):
                    self.master._challenge_start_turns_backup = {}
                self.master._challenge_start_turns_backup[carta_path] = turno_registo
                print(f"DEBUG: [CHALLENGE_REGISTER] BACKUP: Tracking salvo no master (secondary)")
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_REGISTER] WARNING: Não foi possível salvar backup: {e}")

    
    def _verificar_challenges_tempo_limite(self):
        """
        Verifica se alguma carta Challenge atingiu o limite de n_turns (apenas para logs informativos)
        CORREÇÃO: NÃO remove cartas automaticamente - elas devem ser completadas manualmente pelo jogador
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] === VERIFICANDO CHALLENGES COM TEMPO LIMITE (INFO ONLY) ===")
        
        print(f"DEBUG: [CHALLENGE_TIMEOUT] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge registrados: {self._challenge_start_turns}")
        
        challenges_expirados = []
        
        # Verificar todas as cartas no carrossel
        for i, carta_path in enumerate(self.cards):
            if not carta_path or carta_path == os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png"):
                continue
                
            # Verificar se é uma carta Challenge
            carta_basename = os.path.basename(carta_path).lower()
            if not carta_basename.startswith('challenge_'):
                continue
                
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Verificando Challenge: {os.path.basename(carta_path)}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Dados não encontrados para {os.path.basename(carta_path)}")
                continue
                
            n_turns = dados_carta.get('n_turns', 0)
            if n_turns <= 0:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge sem limite de turnos válido: n_turns={n_turns}")
                continue
                
            # Verificar quantos turnos passaram desde que foi ativada
            turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
            
            print(f"DEBUG: [CHALLENGE_TIMEOUT] Challenge {os.path.basename(carta_path)}:")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   n_turns limite: {n_turns}")
            print(f"DEBUG: [CHALLENGE_TIMEOUT]   turnos decorridos: {turns_elapsed}")
            
            # Se atingiu o limite, registrar para informação (mas NÃO processar automaticamente)
            if turns_elapsed >= n_turns:
                print(f"DEBUG: [CHALLENGE_TIMEOUT] INFO: LIMITE ATINGIDO! Challenge pode ser completado via botão seta")
                challenges_expirados.append(os.path.basename(carta_path))
            else:
                turnos_restantes = n_turns - turns_elapsed
                print(f"DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Ainda tem {turnos_restantes} turno(s) restante(s)")
        
        # Relatório informativo apenas (sem processamento automático)
        if challenges_expirados:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] === {len(challenges_expirados)} CHALLENGE(S) PODEM SER COMPLETADOS ===")
            for nome in challenges_expirados:
                print(f"DEBUG: [CHALLENGE_TIMEOUT]   - {nome}: Pronto para completion via botão seta")
        else:
            print("DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Nenhuma carta Challenge atingiu limite de turnos")
        
        # Retornar decisão final sobre continuidade da gestão
        # Se gestao_deve_continuar não foi definido na lógica principal, usar valor padrão
        if gestao_deve_continuar is None:
            print("DEBUG: [COMPLETION] AVISO: gestao_deve_continuar não foi definido - usando valor padrão False")
            gestao_deve_continuar = False
        
        print(f"DEBUG: [COMPLETION] === DECISÃO FINAL ===")
        print(f"DEBUG: [COMPLETION] gestao_deve_continuar = {gestao_deve_continuar}")
        return gestao_deve_continuar

    

    

    
    def _mostrar_overlay_completion_tempo_limite(self, carta_path, dados_carta, carta_info, reward):
        """
        Mostra overlay específico para completion por tempo limite
        CORREÇÃO CRÍTICA: Proteções máximas contra destruição da aplicação
        """
        print("DEBUG: [CHALLENGE_TIMEOUT] Mostrando overlay de completion por tempo limite")
        
        # PROTEÇÃO CRÍTICA FASE 1: Verificações básicas de estado
        try:
            # Verificação 1: Estado do widget principal
            if not hasattr(self, 'winfo_exists') or not self.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Aplicação destruída (winfo_exists) - overlay não pode ser criado")
                return
                
            # Verificação 2: Tentar acessar propriedades básicas
            _ = self.winfo_width()
            _ = self.winfo_height()
            
            # Verificação 3: Verificar se ainda temos acesso aos atributos necessários
            if not hasattr(self, 'screen_width') or not hasattr(self, 'screen_height'):
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Atributos de tela não disponíveis - overlay não pode ser criado")
                return
                
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 1 - aplicação destruída: {e}")
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: Erro inesperado fase 1: {e}")
            return
        
        # PROTEÇÃO CRÍTICA FASE 2: Tentar criar overlay com fallback completo
        overlay = None
        try:
            # Verificação adicional antes de criar overlay
            if not self.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Aplicação destruída antes de criar overlay")
                return
                
            # Criar overlay de fundo
            overlay = tk.Toplevel(self)
            overlay.title("")
            overlay.configure(bg="black")
            overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
            overlay.overrideredirect(True)
            overlay.attributes("-fullscreen", True)
            overlay.lift()
            overlay.focus_set()
            
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 2 - aplicação destruída durante criação overlay: {e}")
            if overlay:
                try:
                    overlay.destroy()
                except:
                    pass
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] ERROR: Erro inesperado ao criar overlay: {e}")
            if overlay:
                try:
                    overlay.destroy()
                except:
                    pass
            return
        
        # PROTEÇÃO CRÍTICA FASE 3: Criar conteúdo do overlay com proteções adicionais
        try:
            # Verificação contínua de estado durante criação de widgets
            if not self.winfo_exists() or not overlay.winfo_exists():
                print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Widget destruído durante criação de conteúdo")
                return
            
            # Título do overlay
            title_label = tk.Label(
                overlay, 
                text="CHALLENGE - TEMPO LIMITE ATINGIDO!", 
                font=("Helvetica", 28, "bold"),
                bg="black", 
                fg="red"
            )
            title_label.place(relx=0.5, rely=0.15, anchor="center")
            
            # Informações da carta
            carta_nome = os.path.basename(carta_path)
            info_text = f"Carta: {carta_nome}\n"
            info_text += f"Limite de turnos: {carta_info['n_turns']}\n"
            info_text += f"Turnos decorridos: {carta_info['turns_elapsed']}\n\n"
            info_text += f"Valores finais:\n"
            
            carta_index = carta_info['carta_index']
            if carta_index < len(self.card_stats):
                stats = self.card_stats[carta_index]
                info_text += f"Packets Received: {stats['Rxd']}\n"
                info_text += f"Packets Lost: {stats['Lost']}\n"
            
            info_text += f"\nReward obtido: {reward} picoins"
            
            info_label = tk.Label(
                overlay,
                text=info_text,
                font=("Helvetica", 18),
                bg="black",
                fg="white",
                justify="center"
            )
            info_label.place(relx=0.5, rely=0.5, anchor="center")
            
            # Botão OK com comando seguro
            def safe_close_overlay():
                try:
                    # CORREÇÃO: Limpar tracking de Challenge completado
                    if "challenge" in os.path.basename(carta_path).lower():
                        self._cleanup_completed_challenge_tracking(carta_path)
                        print(f"DEBUG: [COMPLETION_TIMEOUT] Challenge tracking limpo para: {os.path.basename(carta_path)}")
                    
                    if overlay.winfo_exists():
                        overlay.destroy()
                except:
                    pass
            
            ok_button = tk.Button(
                overlay,
                text="OK",
                font=("Helvetica", 16, "bold"),
                bg=self.bar_color if hasattr(self, 'bar_color') else "#AAAAAA",
                fg="black",
                width=10,
                command=safe_close_overlay
            )
            ok_button.place(relx=0.5, rely=0.8, anchor="center")
            
            print("DEBUG: [CHALLENGE_TIMEOUT] SUCCESS: Overlay de completion por tempo limite criado com sucesso")
            
        except tk.TclError as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] WARNING: TclError fase 3 - aplicação destruída durante criação de conteúdo: {e}")
            try:
                overlay.destroy()
            except:
                pass
            print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Não foi possível criar overlay - Challenge permanece ativo")
            return
        except Exception as e:
            print(f"DEBUG: [CHALLENGE_TIMEOUT] ERROR: Erro inesperado ao criar conteúdo do overlay: {e}")
            try:
                overlay.destroy()
            except:
                pass
            print("DEBUG: [CHALLENGE_TIMEOUT] WARNING: Não foi possível criar overlay - Challenge permanece ativo")
            return

    def _increment_turn_counter(self):
        """
        Incrementa TODOS os contadores de turnos (chamado no end_turn)
        CORREÇÃO CRÍTICA: Sincronizar todos os sistemas de contagem
        """
        # Detectar ambiente para debug específico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        print(f"DEBUG: [TIME_TRACKING] === INCREMENTANDO CONTADORES DE TURNO ===")
        print(f"DEBUG: [TIME_TRACKING] AMBIENTE: {ambiente}")
        print(f"DEBUG: [TIME_TRACKING] Contadores ANTES do incremento:")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_number (Challenges): {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn (Events): {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_id (Processing): {self._current_turn_id}")
        
        # CORREÇÃO CRÍTICA: Incrementar TODOS os contadores de forma sincronizada
        self._current_turn_number += 1
        self._current_turn += 1
        self._current_turn_id += 1
        
        print(f"DEBUG: [TIME_TRACKING] Contadores APÓS incremento (SINCRONIZADOS):")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [TIME_TRACKING]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [TIME_TRACKING] SUCCESS: TODOS OS SISTEMAS AGORA NO TURNO {self._current_turn_number}")
        print(f"DEBUG: [TIME_TRACKING] === FIM INCREMENTO DE CONTADORES ===")
        
        # CRÍTICO: Verificar Challenges que atingiram o tempo limite após incremento
        try:
            self._verificar_challenges_tempo_limite()
            print(f"DEBUG: [TIME_TRACKING] SUCCESS: Verificação de tempo limite executada")
        except Exception as e:
            print(f"DEBUG: [TIME_TRACKING] ERROR: Erro na verificação de tempo limite: {e}")
    
    def _cleanup_completed_challenge_tracking(self, carta_path):
        """
        Remove tracking de uma carta Challenge que foi completada
        """
        if carta_path in self._challenge_start_turns:
            del self._challenge_start_turns[carta_path]
            print(f"DEBUG: [TIME_TRACKING] Tracking removido para Challenge completado: {os.path.basename(carta_path)}")
    
    def _cleanup_orphaned_challenge_tracking(self):
        """
        Remove tracking de Challenges órfãos que não estão mais no carrossel.
        Chamado no início de cada turno para limpar tracking de Challenges antigos.
        CORREÇÃO CRÍTICA: Também limpa todos os backups para evitar restauração.
        """
        print("DEBUG: [ORPHAN_CLEANUP] === LIMPEZA DE TRACKING ÓRFÃO ===")
        
        if not hasattr(self, '_challenge_start_turns') or not self._challenge_start_turns:
            print("DEBUG: [ORPHAN_CLEANUP] Nenhum tracking de Challenges para limpar")
            return
        
        # Obter Challenges atualmente no carrossel
        challenges_no_carrossel = set()
        if hasattr(self, 'cards') and self.cards:
            for carta in self.cards:
                if carta and 'challenge' in carta.lower():
                    challenges_no_carrossel.add(carta)
                    print(f"DEBUG: [ORPHAN_CLEANUP] Challenge encontrado no carrossel: {os.path.basename(carta)}")
        
        # Identificar tracking órfão
        tracking_orfao = []
        for carta_path in list(self._challenge_start_turns.keys()):
            if carta_path not in challenges_no_carrossel:
                tracking_orfao.append(carta_path)
                print(f"DEBUG: [ORPHAN_CLEANUP] Challenge órfão identificado: {os.path.basename(carta_path)}")
        
        # Remover tracking órfão
        challenges_removidos = 0
        for carta_path in tracking_orfao:
            if carta_path in self._challenge_start_turns:
                del self._challenge_start_turns[carta_path]
                challenges_removidos += 1
                print(f"DEBUG: [ORPHAN_CLEANUP] ✅ Tracking órfão removido: {os.path.basename(carta_path)}")
        
        # CORREÇÃO CRÍTICA: Limpar tracking órfão de TODOS os backups também
        backup_locations = []
        
        # 1. Backup no master
        if hasattr(self, 'master') and hasattr(self.master, '_backup_challenge_tracking'):
            master_backup = self.master._backup_challenge_tracking
            backup_locations.append((master_backup, 'master._backup_challenge_tracking'))
        
        # 2. Backup no root - tentar múltiplas formas de acesso
        root_found = False
        root = None
        if hasattr(self, 'master'):
            # Tentar acessar via self.master.master (normal para Toplevel)
            if hasattr(self.master, 'master'):
                root = self.master.master
                root_found = True
            # Se não funcionar, tentar acessar diretamente via self.master (para root direto)
            elif hasattr(self.master, '_backup_challenge_tracking'):
                root = self.master
                root_found = True
            
            if root_found and hasattr(root, '_backup_challenge_tracking'):
                root_backup = root._backup_challenge_tracking
                backup_locations.append((root_backup, 'root._backup_challenge_tracking'))
        
        # 3. Super backup no master
        if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
            super_backup = self.master._super_challenge_backup
            backup_locations.append((super_backup, 'master._super_challenge_backup'))
        
        # 4. Super backup no root
        if root_found and root and hasattr(root, '_super_challenge_backup'):
            root_super_backup = root._super_challenge_backup
            backup_locations.append((root_super_backup, 'root._super_challenge_backup'))
        
        # Limpar tracking órfão de todos os backups
        backups_limpos = 0
        for backup_dict, backup_name in backup_locations:
            backup_removidos = 0
            for carta_path in tracking_orfao:
                if carta_path in backup_dict:
                    del backup_dict[carta_path]
                    backup_removidos += 1
                    print(f"DEBUG: [ORPHAN_CLEANUP] ✅ Backup órfão removido de {backup_name}: {os.path.basename(carta_path)}")
            
            if backup_removidos > 0:
                backups_limpos += 1
                print(f"DEBUG: [ORPHAN_CLEANUP] Backup limpo: {backup_name} ({backup_removidos} entradas removidas)")
        
        print(f"DEBUG: [ORPHAN_CLEANUP] === RESULTADO ===")
        print(f"DEBUG: [ORPHAN_CLEANUP] Challenges no carrossel: {len(challenges_no_carrossel)}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Tracking órfão removido: {challenges_removidos}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Backups limpos: {backups_limpos}")
        print(f"DEBUG: [ORPHAN_CLEANUP] Tracking final: {len(self._challenge_start_turns)} entradas")
        
        if challenges_removidos > 0:
            print(f"DEBUG: [ORPHAN_CLEANUP] ✅ SUCCESS: {challenges_removidos} Challenge(s) órfão(s) removido(s) do tracking")
            # Mostrar tracking final limpo
            if self._challenge_start_turns:
                print("DEBUG: [ORPHAN_CLEANUP] Tracking restante:")
                for carta_path, turno in self._challenge_start_turns.items():
                    print(f"DEBUG: [ORPHAN_CLEANUP]   - {os.path.basename(carta_path)}: turno {turno}")
            else:
                print("DEBUG: [ORPHAN_CLEANUP] Tracking completamente limpo")
        else:
            print("DEBUG: [ORPHAN_CLEANUP] Nenhum tracking órfão encontrado")
        
        print("DEBUG: [ORPHAN_CLEANUP] === FIM LIMPEZA ===")
    
    def _reset_card_values_on_activation(self, carta_path, posicao_carrossel):
        """
        Reset dos valores das barras de progresso quando uma carta é ativada no carrossel.
        Sempre começa com: To send = message_size, Rxd = 0, Lost = 0
        """
        try:
            print(f"DEBUG: [RESET_VALUES] Resetando valores para carta: {os.path.basename(carta_path)} na posição {posicao_carrossel}")
            
            # Obter message_size da carta
            message_size = self._get_card_message_size(carta_path)
            if message_size is None:
                print(f"DEBUG: [RESET_VALUES] ERROR: Não foi possível obter message_size para {os.path.basename(carta_path)}")
                return
            
            # Reset dos valores: To send = message_size, Rxd = 0, Lost = 0
            valores_reset = {
                'To send': message_size,
                'Rxd': 0,
                'Lost': 0
            }
            
            # Atualizar card_stats se existir
            if not hasattr(self, 'card_stats'):
                self.card_stats = {}
            
            self.card_stats[posicao_carrossel] = valores_reset.copy()
            
            print(f"DEBUG: [RESET_VALUES] SUCCESS: Valores resetados para posição {posicao_carrossel}")
            print(f"DEBUG: [RESET_VALUES]   To send: {message_size} (= message_size)")
            print(f"DEBUG: [RESET_VALUES]   Rxd: 0")
            print(f"DEBUG: [RESET_VALUES]   Lost: 0")
            print(f"DEBUG: [RESET_VALUES]   card_stats[{posicao_carrossel}] = {valores_reset}")
            
        except Exception as e:
            print(f"DEBUG: [RESET_VALUES] ERRO ao resetar valores: {e}")
            import traceback
            traceback.print_exc()
    
    def _backup_turn_counters_before_reconstruction(self):
        """
        Faz backup dos contadores de turno antes da reconstrução da interface.
        CRITICAL: Garante que os contadores não voltam ao início quando há substituição.
        """
        print(f"DEBUG: [BACKUP_COUNTERS] === BACKUP CRÍTICO DOS CONTADORES ===")
        print(f"DEBUG: [BACKUP_COUNTERS] Situação: Interface será reconstruída (substituição Challenge/Activity)")
        print(f"DEBUG: [BACKUP_COUNTERS] PROBLEMA: Reconstrução pode resetar contadores para turno 1")
        print(f"DEBUG: [BACKUP_COUNTERS] SOLUÇÃO: Backup dos valores atuais para restaurar após reconstrução")
        
        # CORREÇÃO CRÍTICA: Verificar se há Challenges recém-registados que podem estar apenas nos backups temporários
        print(f"DEBUG: [BACKUP_COUNTERS] === VERIFICAÇÃO DE CHALLENGES TEMPORÁRIOS ===")
        challenge_tracking_consolidado = getattr(self, '_challenge_start_turns', {}).copy()
        
        # Consolidar Challenges de todos os backups temporários para não perder nenhum
        backup_sources = []
        
        # 1. Backup imediato do master
        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup_imediato'):
            backup_sources.append(('master_imediato', self.master._challenge_start_turns_backup_imediato))
        
        # 2. Backup do master
        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup'):
            backup_sources.append(('master_backup', self.master._challenge_start_turns_backup))
        
        # 3. Backup do root
        if hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_challenge_tracking'):
                backup_sources.append(('root_backup', root._backup_challenge_tracking))
        
        # 4. Backup da Store (específico para Challenges aceites)
        if hasattr(self, 'master') and hasattr(self.master, '_backup_challenge_start_turns'):
            backup_sources.append(('store_backup', self.master._backup_challenge_start_turns))
        
        print(f"DEBUG: [BACKUP_COUNTERS] Fontes de backup encontradas: {len(backup_sources)}")
        
        # Consolidar todos os Challenges de todas as fontes
        for source_name, backup_data in backup_sources:
            if backup_data:
                print(f"DEBUG: [BACKUP_COUNTERS] Processando fonte '{source_name}': {len(backup_data)} itens")
                for challenge_path, turno in backup_data.items():
                    challenge_name = os.path.basename(challenge_path)
                    if challenge_path not in challenge_tracking_consolidado:
                        challenge_tracking_consolidado[challenge_path] = turno
                        print(f"DEBUG: [BACKUP_COUNTERS] ✅ {challenge_name} consolidado de '{source_name}': turno {turno}")
                    else:
                        print(f"DEBUG: [BACKUP_COUNTERS] {challenge_name} já existe no consolidado: turno {challenge_tracking_consolidado[challenge_path]}")
        
        print(f"DEBUG: [BACKUP_COUNTERS] Challenge tracking consolidado: {len(challenge_tracking_consolidado)} itens total")
        for path, turno in challenge_tracking_consolidado.items():
            print(f"DEBUG: [BACKUP_COUNTERS]   - {os.path.basename(path)}: turno {turno}")
        
        # Capturar valores atuais de todos os contadores USANDO tracking consolidado
        current_counters = {
            '_current_turn_number': getattr(self, '_current_turn_number', 1),
            '_current_turn': getattr(self, '_current_turn', 1), 
            '_current_turn_id': getattr(self, '_current_turn_id', 1),
            '_challenge_start_turns': challenge_tracking_consolidado,  # CORREÇÃO: Usar consolidado
            '_event_start_turns': getattr(self, '_event_start_turns', {}).copy(),
            '_service_start_turns': getattr(self, '_service_start_turns', {}).copy(),
            '_event_duration_tracking': getattr(self, '_event_duration_tracking', {}).copy(),
            '_service_duration_tracking': getattr(self, '_service_duration_tracking', {}).copy(),
            '_service_real_activation_turns': getattr(self, '_service_real_activation_turns', {}).copy(),  # NOVO: preservar turnos reais
            '_service_data_volume_tracking': getattr(self, '_service_data_volume_tracking', {}).copy(),  # NOVO: tracking Data Volume
            '_pending_data_volume_expiry_overlays': getattr(self, '_pending_data_volume_expiry_overlays', []).copy()  # NOVO: overlays pendentes
        }
        
        print(f"DEBUG: [BACKUP_COUNTERS] Valores atuais sendo salvos:")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn_number: {current_counters['_current_turn_number']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn: {current_counters['_current_turn']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   _current_turn_id: {current_counters['_current_turn_id']}")
        print(f"DEBUG: [BACKUP_COUNTERS]   Challenge tracking: {len(current_counters['_challenge_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Event tracking: {len(current_counters['_event_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Service tracking: {len(current_counters['_service_start_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Service real activation: {len(current_counters['_service_real_activation_turns'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Data Volume tracking: {len(current_counters['_service_data_volume_tracking'])} itens")
        print(f"DEBUG: [BACKUP_COUNTERS]   Data Volume pending overlays: {len(current_counters['_pending_data_volume_expiry_overlays'])} itens")
        
        # Salvar no root para sobreviver à reconstrução
        if hasattr(self, 'master') and self.master:
            self.master._backup_turn_counters = current_counters
            print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup salvo no master (janela pai)")
        elif hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root:
                root._backup_turn_counters = current_counters  
                print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup salvo no toplevel root")
        
        # Backup adicional como atributo da classe (fallback)
        self._backup_counters_reconstruction = current_counters
        print(f"DEBUG: [BACKUP_COUNTERS] SUCCESS: Backup adicional salvo na instância (fallback)")
        print(f"DEBUG: [BACKUP_COUNTERS] === BACKUP COMPLETO ===")
    
    def _restore_turn_counters_after_reconstruction(self):
        """
        Restaura os contadores de turno após a reconstrução da interface.
        CORREÇÃO CRÍTICA: Verificar Challenges no carrossel após restauração
        """
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURAÇÃO DOS CONTADORES ===")
        
        # Tentar restaurar do root primeiro
        backup_counters = None
        
        if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_turn_counters'):
            backup_counters = self.master._backup_turn_counters
            print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no master")
        elif hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_turn_counters'):
                backup_counters = root._backup_turn_counters
                print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no toplevel root")
        elif hasattr(self, '_backup_counters_reconstruction'):
            backup_counters = self._backup_counters_reconstruction
            print(f"DEBUG: [RESTORE_COUNTERS] Backup encontrado no fallback da instância")
        
        if not backup_counters:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Nenhum backup encontrado - verificando Challenges do carrossel")
            self._ensure_challenge_tracking_integrity()
            return
        
        # Restaurar todos os contadores
        self._current_turn_number = backup_counters.get('_current_turn_number', 1)
        self._current_turn = backup_counters.get('_current_turn', 1)
        self._current_turn_id = backup_counters.get('_current_turn_id', 1)
        self._challenge_start_turns = backup_counters.get('_challenge_start_turns', {}).copy()
        self._event_start_turns = backup_counters.get('_event_start_turns', {}).copy()
        self._service_start_turns = backup_counters.get('_service_start_turns', {}).copy()
        self._event_duration_tracking = backup_counters.get('_event_duration_tracking', {}).copy()
        self._service_duration_tracking = backup_counters.get('_service_duration_tracking', {}).copy()
        self._service_real_activation_turns = backup_counters.get('_service_real_activation_turns', {}).copy()  # NOVO: restaurar turnos reais
        
        # SUPER RESTORATION SYSTEM: Consolidar de múltiplas fontes de backup
        root = None
        try:
            root = self.master if hasattr(self, 'master') else self.winfo_toplevel()
        except:
            pass
        
        if root:
            # Restaurar Services tracking com consolidação múltipla
            if hasattr(root, '_backup_service_tracking_super'):
                consolidated_services = root._backup_service_tracking_super
                self._service_real_activation_turns.update(consolidated_services)
                print(f"DEBUG: [RESTORE_COUNTERS] Services super backup restaurado: {len(consolidated_services)} entries")
            
            # Consolidar de todas as fontes disponíveis
            if hasattr(root, '_backup_service_tracking'):
                self._service_real_activation_turns.update(root._backup_service_tracking)
            if hasattr(root, '_service_tracking_backup_imediato'):
                self._service_real_activation_turns.update(root._service_tracking_backup_imediato)
            if hasattr(root, '_backup_service_tracking_end_turn'):
                self._service_real_activation_turns.update(root._backup_service_tracking_end_turn)
            
            # Restaurar Events tracking com consolidação múltipla
            if hasattr(root, '_backup_event_tracking_super'):
                consolidated_events = root._backup_event_tracking_super
                self._event_duration_tracking.update(consolidated_events)
                print(f"DEBUG: [RESTORE_COUNTERS] Events super backup restaurado: {len(consolidated_events)} entries")
            
            if hasattr(root, '_backup_event_start_turns_super'):
                consolidated_event_starts = root._backup_event_start_turns_super
                self._event_start_turns.update(consolidated_event_starts)
                print(f"DEBUG: [RESTORE_COUNTERS] Events start turns super backup restaurado: {len(consolidated_event_starts)} entries")
            
            # Consolidar de todas as fontes disponíveis para Events
            if hasattr(root, '_backup_event_tracking'):
                self._event_duration_tracking.update(root._backup_event_tracking)
            if hasattr(root, '_event_tracking_backup_imediato'):
                self._event_duration_tracking.update(root._event_tracking_backup_imediato)
            if hasattr(root, '_backup_event_tracking_end_turn'):
                self._event_duration_tracking.update(root._backup_event_tracking_end_turn)
            
            if hasattr(root, '_backup_event_start_turns'):
                self._event_start_turns.update(root._backup_event_start_turns)
            if hasattr(root, '_backup_event_start_turns_end_turn'):
                self._event_start_turns.update(root._backup_event_start_turns_end_turn)
        
        # NOVO: Restaurar Data Volume tracking de múltiplas fontes
        if hasattr(root, '_backup_turn_counters'):
            backup_data_volume = backup_counters.get('_service_data_volume_tracking', {})
            if backup_data_volume:
                if not hasattr(self, '_service_data_volume_tracking'):
                    self._service_data_volume_tracking = {}
                self._service_data_volume_tracking.update(backup_data_volume)
                print(f"DEBUG: [RESTORE_COUNTERS] Data Volume tracking backup principal restaurado: {len(backup_data_volume)} itens")
            
            backup_pending_overlays = backup_counters.get('_pending_data_volume_expiry_overlays', [])
            if backup_pending_overlays:
                if not hasattr(self, '_pending_data_volume_expiry_overlays'):
                    self._pending_data_volume_expiry_overlays = []
                self._pending_data_volume_expiry_overlays.extend(backup_pending_overlays)
                print(f"DEBUG: [RESTORE_COUNTERS] Data Volume overlays backup principal restaurado: {len(backup_pending_overlays)} itens")
            
            # Consolidar Data Volume de todas as fontes disponíveis
            if hasattr(root, '_backup_data_volume_tracking'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking)
            if hasattr(root, '_data_volume_tracking_backup_imediato'):
                self._service_data_volume_tracking.update(root._data_volume_tracking_backup_imediato)
            if hasattr(root, '_backup_data_volume_tracking_end_turn'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking_end_turn)
            if hasattr(root, '_backup_data_volume_tracking_super'):
                self._service_data_volume_tracking.update(root._backup_data_volume_tracking_super)
            
            if hasattr(root, '_backup_data_volume_overlays'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays)
            if hasattr(root, '_backup_data_volume_overlays_end_turn'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays_end_turn)
            if hasattr(root, '_backup_data_volume_overlays_super'):
                self._pending_data_volume_expiry_overlays.extend(root._backup_data_volume_overlays_super)
        
        # CORREÇÃO CRÍTICA: Verificar se o backup principal tem o _challenge_start_turns atualizado
        print(f"DEBUG: [RESTORE_COUNTERS] Challenge tracking restaurado do backup principal: {len(self._challenge_start_turns)} itens")
        for path, turn in self._challenge_start_turns.items():
            print(f"DEBUG: [RESTORE_COUNTERS]   - {os.path.basename(path)}: turno {turn}")
        
        print(f"DEBUG: [RESTORE_COUNTERS] SUCCESS: Contadores restaurados:")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [RESTORE_COUNTERS]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [RESTORE_COUNTERS]   Challenge tracking: {len(self._challenge_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Event tracking: {len(self._event_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Service tracking: {len(self._service_start_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Service real activation: {len(self._service_real_activation_turns)} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Data Volume tracking: {len(getattr(self, '_service_data_volume_tracking', {}))} itens")
        print(f"DEBUG: [RESTORE_COUNTERS]   Data Volume pending overlays: {len(getattr(self, '_pending_data_volume_expiry_overlays', []))} itens")
        
        # Debug detalhado dos Services restaurados
        if self._service_real_activation_turns:
            print(f"DEBUG: [RESTORE_COUNTERS] Services com turnos reais preservados:")
            for path, turn in self._service_real_activation_turns.items():
                print(f"DEBUG: [RESTORE_COUNTERS]   - {os.path.basename(path)}: turno real {turn}")
        
        # CORREÇÃO CRÍTICA: NÃO chamar _ensure_challenge_tracking_integrity() após restore
        # pois irá sobrescrever os turnos originais restaurados com o turno atual!
        print(f"DEBUG: [RESTORE_COUNTERS] TRACKING PRESERVADO: Challenges restaurados mantêm turnos originais")
        
        # CORREÇÃO CRÍTICA CHALLENGE_13: Sistema de restauração múltiplas camadas
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURAÇÃO MÚLTIPLAS CAMADAS ===")
        backup_encontrado = False
        
        try:
            # CAMADA 1: Emergency backup (prioridade máxima)
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_challenge_tracking_emergency_backup'):
                emergency_backup = self.master._challenge_tracking_emergency_backup
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 1: Emergency backup encontrado: {emergency_backup}")
                
                for carta_path, turno in emergency_backup.items():
                    self._challenge_start_turns[carta_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] 🚨 CAMADA 1: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                    backup_encontrado = True
                
                delattr(self.master, '_challenge_tracking_emergency_backup')
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 1: Emergency backup limpo")
            
            # CAMADA 2: Super backup no master  
            if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
                super_backup = self.master._super_challenge_backup
                if super_backup:
                    print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 2: Super backup master encontrado: {super_backup}")
                    
                    for carta_path, turno in super_backup.items():
                        if carta_path not in self._challenge_start_turns:  # Não sobrescrever se já restaurado
                            self._challenge_start_turns[carta_path] = turno
                            print(f"DEBUG: [RESTORE_COUNTERS] � CAMADA 2: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                            backup_encontrado = True
            
            # CAMADA 3: Super backup no root
            try:
                if hasattr(self.master.master, '_super_challenge_backup'):
                    root_backup = self.master.master._super_challenge_backup
                    if root_backup:
                        print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 3: Super backup root encontrado: {root_backup}")
                        
                        for carta_path, turno in root_backup.items():
                            if carta_path not in self._challenge_start_turns:
                                self._challenge_start_turns[carta_path] = turno
                                print(f"DEBUG: [RESTORE_COUNTERS] 🌐 CAMADA 3: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                                backup_encontrado = True
            except:
                print("DEBUG: [RESTORE_COUNTERS] CAMADA 3: Root não acessível")
            
            # CAMADA 4: Backup registry na instância
            if hasattr(self, '_challenge_backup_registry') and self._challenge_backup_registry:
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 4: Backup registry encontrado: {self._challenge_backup_registry}")
                
                for carta_path, turno in self._challenge_backup_registry.items():
                    if carta_path not in self._challenge_start_turns:
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] 📋 CAMADA 4: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                        backup_encontrado = True
            
            # CAMADA 5: Backup global (último recurso)
            import builtins
            if hasattr(builtins, '_global_challenge_backup') and builtins._global_challenge_backup:
                print(f"DEBUG: [RESTORE_COUNTERS] CAMADA 5: Backup global encontrado: {builtins._global_challenge_backup}")
                
                for carta_path, turno in builtins._global_challenge_backup.items():
                    if carta_path not in self._challenge_start_turns:
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] 🌍 CAMADA 5: Challenge {os.path.basename(carta_path)} restaurado: turno {turno}")
                        backup_encontrado = True
                
                # Limpar backup global após uso
                builtins._global_challenge_backup = {}
                print("DEBUG: [RESTORE_COUNTERS] CAMADA 5: Backup global limpo")
        
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao processar backups múltiplas camadas: {e}")
        
        # CORREÇÃO CRÍTICA: Inicializar variável para backup imediato
        backup_imediato_encontrado = False
        
        try:
            # Verificar backup imediato no master
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_challenge_start_turns_backup_imediato'):
                backup_imediato = self.master._challenge_start_turns_backup_imediato
                print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato encontrado no master: {backup_imediato}")
                
                # Integrar backup imediato no tracking restaurado
                for carta_path, turno in backup_imediato.items():
                    self._challenge_start_turns[carta_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] ✅ Challenge {os.path.basename(carta_path)} restaurado do backup imediato: turno {turno}")
                    backup_imediato_encontrado = True
                
                # Limpar backup imediato
                delattr(self.master, '_challenge_start_turns_backup_imediato')
                print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato do master limpo")
            
            # CORREÇÃO CRÍTICA CHALLENGE_8: Verificar backup da Store também
            if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_challenge_start_turns'):
                backup_store = self.master._backup_challenge_start_turns
                print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store encontrado no master: {backup_store}")
                
                # CORREÇÃO CRÍTICA: Integrar backup da Store usando caminho completo
                for challenge_path, turno in backup_store.items():
                    self._challenge_start_turns[challenge_path] = turno
                    print(f"DEBUG: [RESTORE_COUNTERS] ✅ Challenge {os.path.basename(challenge_path)} (caminho: {challenge_path}) restaurado do backup da Store: turno {turno}")
                    backup_imediato_encontrado = True
                
                # Limpar backup da Store
                delattr(self.master, '_backup_challenge_start_turns')
                print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store limpo")
            
            # Verificar também no root
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root and hasattr(root, '_challenge_start_turns_backup_imediato'):
                    backup_imediato = root._challenge_start_turns_backup_imediato
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato encontrado no root: {backup_imediato}")
                    
                    # Integrar backup imediato no tracking restaurado  
                    for carta_path, turno in backup_imediato.items():
                        self._challenge_start_turns[carta_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] ✅ Challenge {os.path.basename(carta_path)} restaurado do backup imediato: turno {turno}")
                        backup_imediato_encontrado = True
                    
                    # Limpar backup imediato
                    delattr(root, '_challenge_start_turns_backup_imediato')
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup imediato do root limpo")
                
                # Verificar também backup da Store no root
                if root and hasattr(root, '_backup_challenge_start_turns'):
                    backup_store = root._backup_challenge_start_turns
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store encontrado no root: {backup_store}")
                    
                    # CORREÇÃO CRÍTICA: Integrar backup da Store usando caminho completo
                    for challenge_path, turno in backup_store.items():
                        self._challenge_start_turns[challenge_path] = turno
                        print(f"DEBUG: [RESTORE_COUNTERS] ✅ Challenge {os.path.basename(challenge_path)} (caminho: {challenge_path}) restaurado do backup da Store: turno {turno}")
                        backup_imediato_encontrado = True
                    
                    # Limpar backup da Store do root
                    delattr(root, '_backup_challenge_start_turns')
                    print(f"DEBUG: [RESTORE_COUNTERS] Backup da Store do root limpo")
        
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao processar backup imediato: {e}")
        
        if backup_imediato_encontrado:
            print(f"DEBUG: [RESTORE_COUNTERS] ✅ BACKUP IMEDIATO INTEGRADO COM SUCESSO!")
            print(f"DEBUG: [RESTORE_COUNTERS] Tracking final com backup imediato: {self._challenge_start_turns}")
        else:
            print(f"DEBUG: [RESTORE_COUNTERS] Nenhum backup imediato encontrado")
        
        # CORREÇÃO CRÍTICA ADICIONAL: Sincronizar _backup_challenge_tracking no root
        # Isto garante que futuras inicializações encontrem o tracking correto
        try:
            if hasattr(self, 'winfo_toplevel'):
                root = self.winfo_toplevel()
                if root and self._challenge_start_turns:
                    root._backup_challenge_tracking = self._challenge_start_turns.copy()
                    print(f"DEBUG: [RESTORE_COUNTERS] SYNC: _backup_challenge_tracking atualizado no root: {self._challenge_start_turns}")
        except Exception as e:
            print(f"DEBUG: [RESTORE_COUNTERS] WARNING: Erro ao sincronizar _backup_challenge_tracking: {e}")
        
        print(f"DEBUG: [RESTORE_COUNTERS] === RESTAURAÇÃO COMPLETA ===")
        
        # Limpar backup após restaurar
        if hasattr(self, 'master') and self.master and hasattr(self.master, '_backup_turn_counters'):
            delattr(self.master, '_backup_turn_counters')
        if hasattr(self, 'winfo_toplevel'):
            root = self.winfo_toplevel()
            if root and hasattr(root, '_backup_turn_counters'):
                delattr(root, '_backup_turn_counters')
        if hasattr(self, '_backup_counters_reconstruction'):
            delattr(self, '_backup_counters_reconstruction')
    
    def _ensure_challenge_tracking_integrity(self):
        """
        Assegura que todos os Challenges no carrossel têm tracking adequado.
        Esta é uma medida de segurança para prevenir perda de tracking.
        """
        print(f"DEBUG: [CHALLENGE_INTEGRITY] === VERIFICANDO INTEGRIDADE DO TRACKING ===")
        
        if not hasattr(self, 'cards') or not self.cards:
            print(f"DEBUG: [CHALLENGE_INTEGRITY] Sem cartas no carrossel - nada a verificar")
            return
        
        if not hasattr(self, '_challenge_start_turns'):
            self._challenge_start_turns = {}
            print(f"DEBUG: [CHALLENGE_INTEGRITY] _challenge_start_turns inicializado")
        
        challenges_found = 0
        challenges_without_tracking = 0
        
        for i, carta_path in enumerate(self.cards):
            if not carta_path or "back_card_" in carta_path:
                continue
                
            carta_basename = os.path.basename(carta_path).lower()
            if not carta_basename.startswith('challenge_'):
                continue
                
            challenges_found += 1
            print(f"DEBUG: [CHALLENGE_INTEGRITY] Challenge encontrado na posição {i}: {os.path.basename(carta_path)}")
            
            # Verificar se tem tracking (por caminho exato ou basename)
            has_tracking = False
            if carta_path in self._challenge_start_turns:
                has_tracking = True
                print(f"DEBUG: [CHALLENGE_INTEGRITY]   ✅ Tracking por caminho exato: turno {self._challenge_start_turns[carta_path]}")
            else:
                # Procurar por basename
                for tracked_path, turno in self._challenge_start_turns.items():
                    if os.path.basename(tracked_path) == os.path.basename(carta_path):
                        has_tracking = True
                        print(f"DEBUG: [CHALLENGE_INTEGRITY]   ✅ Tracking por basename: turno {turno} (migrar chave)")
                        # Migrar chave para o caminho correto
                        del self._challenge_start_turns[tracked_path]
                        self._challenge_start_turns[carta_path] = turno
                        break
            
            if not has_tracking:
                challenges_without_tracking += 1
                print(f"DEBUG: [CHALLENGE_INTEGRITY]   ❌ SEM TRACKING para {os.path.basename(carta_path)}")
                
                # CORREÇÃO CRÍTICA: Se _current_turn_number é 1 (valor padrão), NÃO registar automaticamente
                # Isto evita sobrescrever tracking correto com valores incorretos durante reconstruções
                if self._current_turn_number == 1:
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   PROTEÇÃO: Turno atual é 1 (possivelmente incorreto)")
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   NÃO registando automaticamente - aguardar registo manual correto")
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenge permanecerá sem tracking até correção")
                else:
                    print(f"DEBUG: [CHALLENGE_INTEGRITY]   Registando com turno atual: {self._current_turn_number}")
                    # Usar a função com lógica de preservação
                    self._register_challenge_start_turn(carta_path, turno_especifico=self._current_turn_number)
        
        print(f"DEBUG: [CHALLENGE_INTEGRITY] RESULTADO:")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenges encontrados: {challenges_found}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Challenges sem tracking: {challenges_without_tracking}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY]   Tracking final: {self._challenge_start_turns}")
        print(f"DEBUG: [CHALLENGE_INTEGRITY] === INTEGRIDADE VERIFICADA ===")
    
    # ===============================
    # SISTEMA DE TRACKING DE SERVIÇOS TEMPORARY
    # ===============================
    
    def _register_service_start_turn(self, carta_path):
        """
        Regista o turno em que uma carta Service TEMPORARY foi ativada
        CORREÇÃO: Preservar o turno REAL de ativação, não sobrescrever durante reconstruções
        """
        # Verificar se é um serviço TEMPORARY usando a base de dados
        try:
            service_data = self._get_service_data_from_path(carta_path)
            if service_data and service_data.service_type.value == 'temporary' and service_data.service_turns:
                
                # CORREÇÃO CRÍTICA: Se já existe tracking do turno real, PRESERVAR
                if carta_path in self._service_real_activation_turns:
                    turno_real_ativacao = self._service_real_activation_turns[carta_path]
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} JÁ TINHA tracking do turno real: {turno_real_ativacao}")
                    print(f"DEBUG: [SERVICE_TRACKING] PRESERVANDO turno real em vez de usar turno atual ({self._current_turn_number})")
                else:
                    # Primeira vez a ser ativado - registar turno atual como turno real
                    turno_real_ativacao = self._current_turn_number
                    self._service_real_activation_turns[carta_path] = turno_real_ativacao
                    print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} PRIMEIRA ATIVAÇÃO no turno {turno_real_ativacao}")
                
                # Usar o turno real (preservado) em vez do turno atual
                self._service_start_turns[carta_path] = turno_real_ativacao
                self._service_duration_tracking[carta_path] = {
                    'duration_turns': service_data.service_turns,
                    'start_turn': turno_real_ativacao  # CORREÇÃO: usar turno real
                }
                
                turnos_decorridos = self._current_turn_number - turno_real_ativacao
                print(f"DEBUG: [SERVICE_TRACKING] Service TEMPORARY {os.path.basename(carta_path)}:")
                print(f"DEBUG: [SERVICE_TRACKING]   Turno real de ativação: {turno_real_ativacao}")
                print(f"DEBUG: [SERVICE_TRACKING]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [SERVICE_TRACKING]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [SERVICE_TRACKING]   Duração total: {service_data.service_turns} turnos")
                
                # Verificar se já expirou
                if turnos_decorridos >= service_data.service_turns:
                    print(f"DEBUG: [SERVICE_TRACKING] WARNING: Service {os.path.basename(carta_path)} JÁ EXPIROU!")
                else:
                    print(f"DEBUG: [SERVICE_TRACKING] Service ainda ativo por mais {service_data.service_turns - turnos_decorridos} turnos")
                
            else:
                print(f"DEBUG: [SERVICE_TRACKING] Service {os.path.basename(carta_path)} não é TEMPORARY - tracking ignorado")
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] ERRO ao registar service: {e}")
    
    def _get_service_data_from_path(self, carta_path):
        """
        Obtém dados de um serviço usando a base de dados a partir do caminho
        """
        try:
            # Extrair ID do serviço do caminho (ex: Service_5.png -> service_temporary_5_red)
            filename = os.path.basename(carta_path)
            if not filename.startswith('Service_'):
                return None
                
            # Extrair número do serviço
            import re
            match = re.match(r'Service_(\d+)', filename)
            if not match:
                return None
                
            service_number = int(match.group(1))
            
            # Obter todos os serviços e mapear pelo número
            all_services = self.card_database.get_all_services()
            if service_number <= len(all_services):
                return all_services[service_number - 1]
                
        except Exception as e:
            print(f"DEBUG: [SERVICE_TRACKING] Erro ao obter dados do serviço: {e}")
            
        return None
    
    def _register_data_volume_service(self, carta_path):
        """
        Regista uma carta Service DATA_VOLUME para tracking de pacotes
        """
        try:
            service_data = self._get_service_data_from_path(carta_path)
            if service_data and service_data.service_type.value == 'data_volume' and service_data.service_packets:
                
                # Se já existe tracking (por causa de reconstrução da interface), preservar
                if carta_path in self._service_data_volume_tracking:
                    print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} JÁ TINHA tracking, preservando...")
                    tracking_data = self._service_data_volume_tracking[carta_path]
                    print(f"DEBUG: [DATA_VOLUME] Pacotes restantes preservados: {tracking_data['packets_remaining']}")
                else:
                    # Primeira vez a ser ativado - inicializar com o número total de pacotes
                    self._service_data_volume_tracking[carta_path] = {
                        'packets_remaining': service_data.service_packets,
                        'original_packets': service_data.service_packets
                    }
                    print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} inicializado com {service_data.service_packets} pacotes")
                
            else:
                print(f"DEBUG: [DATA_VOLUME] Service {os.path.basename(carta_path)} não é DATA_VOLUME - tracking ignorado")
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao registar data volume service: {e}")
    
    def _consume_data_volume_packets(self, packets_consumed=1):
        """
        Consome pacotes do pool total de todas as cartas Service DATA_VOLUME ativas
        Distribui a redução pelas cartas ativas usando estratégia FIFO (primeiro a expirar primeiro)
        """
        try:
            print(f"DEBUG: [DATA_VOLUME] === CONSUMINDO {packets_consumed} PACOTES DO POOL TOTAL ===")
            
            # 1. Calcular pool total de pacotes disponíveis
            active_cards = []
            total_packets = 0
            
            for carta_path in list(self._service_data_volume_tracking.keys()):
                if carta_path in self.active_services:  # Só cartas ativas
                    tracking_data = self._service_data_volume_tracking[carta_path]
                    packets_remaining = tracking_data['packets_remaining']
                    
                    if packets_remaining > 0:  # Só cartas com pacotes
                        active_cards.append((carta_path, packets_remaining))
                        total_packets += packets_remaining
                        print(f"DEBUG: [DATA_VOLUME] Service ativo: {os.path.basename(carta_path)} - {packets_remaining} pacotes")
            
            print(f"DEBUG: [DATA_VOLUME] POOL TOTAL: {total_packets} pacotes de {len(active_cards)} cartas")
            
            # 2. Verificar se há pacotes suficientes
            if total_packets < packets_consumed:
                print(f"DEBUG: [DATA_VOLUME] ⚠️ POOL INSUFICIENTE: {total_packets} disponíveis, {packets_consumed} requisitados")
                packets_consumed = total_packets  # Consumir só o que está disponível
            
            if packets_consumed <= 0:
                print("DEBUG: [DATA_VOLUME] Nenhum pacote para consumir")
                return
                
            # 3. Distribuir redução usando estratégia FIFO (cartas com menos pacotes primeiro)
            # Ordenar cartas por pacotes restantes (ascendente) - as com menos pacotes "expiram" primeiro
            active_cards.sort(key=lambda x: x[1])  # Ordenar por packets_remaining
            
            remaining_to_consume = packets_consumed
            expired_services = []
            
            print(f"DEBUG: [DATA_VOLUME] Distribuindo {packets_consumed} pacotes usando estratégia FIFO:")
            
            for carta_path, current_packets in active_cards:
                if remaining_to_consume <= 0:
                    break
                    
                # Calcular quanto consumir desta carta
                to_consume_from_this = min(remaining_to_consume, current_packets)
                new_packets = current_packets - to_consume_from_this
                
                # Atualizar tracking
                self._service_data_volume_tracking[carta_path]['packets_remaining'] = new_packets
                
                print(f"DEBUG: [DATA_VOLUME] {os.path.basename(carta_path)}: {current_packets} → {new_packets} (-{to_consume_from_this})")
                
                # Verificar se expirou
                if new_packets <= 0:
                    print(f"DEBUG: [DATA_VOLUME] EXPIROU: {os.path.basename(carta_path)} ficou sem pacotes!")
                    expired_services.append(carta_path)
                
                remaining_to_consume -= to_consume_from_this
            
            print(f"DEBUG: [DATA_VOLUME] Pool atualizado: {total_packets - packets_consumed + remaining_to_consume} pacotes restantes")
                
            # 4. Processar services expirados
            if expired_services:
                print(f"DEBUG: [DATA_VOLUME] {len(expired_services)} services expiraram por falta de pacotes")
                for expired_service in expired_services:
                    print(f"DEBUG: [DATA_VOLUME] Processando service expirado: {os.path.basename(expired_service)}")
                    
                    # Remover da lista de services ativos
                    if expired_service in self.active_services:
                        self.active_services.remove(expired_service)
                        print(f"DEBUG: [DATA_VOLUME] Service removido dos ativos: {os.path.basename(expired_service)}")
                    
                    # NOVO: Agendar overlay para aparecer IMEDIATAMENTE na interface principal
                    self._schedule_data_volume_expiry_overlay(expired_service)
                
                # NOVO: Verificar se ainda há Data Volume services com pacotes disponíveis
                tem_pacotes_disponiveis = self._has_active_data_volume_services_with_packets()
                print(f"DEBUG: [DATA_VOLUME] Após expiração - ainda há pacotes disponíveis: {tem_pacotes_disponiveis}")
                
                # Se não há mais pacotes disponíveis E gestão está ativa, desativar gestão
                gestao_ativa = getattr(self, '_final_phase_gestao_ativa', False)
                if not tem_pacotes_disponiveis and gestao_ativa:
                    print("DEBUG: [DATA_VOLUME] *** SEM PACOTES DISPONÍVEIS - DESATIVANDO GESTÃO AUTOMATICAMENTE ***")
                    self._finalizar_gestao_pacotes()
                    
                    # Mostrar overlay imediatamente se estamos na interface principal
                    if hasattr(self, '_pending_data_volume_expiry_overlays') and self._pending_data_volume_expiry_overlays:
                        print("DEBUG: [DATA_VOLUME] *** MOSTRANDO OVERLAY DE DATA VOLUME EXPIRADO IMEDIATAMENTE ***")
                        
                        # NOVO: Transferir overlays pendentes para services_expirados_para_overlay para mostra imediata
                        if not hasattr(self, 'services_expirados_para_overlay'):
                            self.services_expirados_para_overlay = []
                        
                        # Transferir cada overlay pendente para a lista de exibição
                        for expired_service_path in self._pending_data_volume_expiry_overlays[:]:
                            service_expirado = {
                                'file': os.path.basename(expired_service_path),
                                'data': {'service_id': os.path.basename(expired_service_path).replace('.png', '')},
                                'path': expired_service_path,
                                'tipo': 'DATA_VOLUME'
                            }
                            self.services_expirados_para_overlay.append(service_expirado)
                            print(f"DEBUG: [DATA_VOLUME] Overlay transferido para exibição imediata: {os.path.basename(expired_service_path)}")
                        
                        # Limpar lista de pendentes já que foram transferidos
                        self._pending_data_volume_expiry_overlays.clear()
                        
                        # Usar after() para garantir que aparece após a interface estar estável
                        self.after(500, self._mostrar_overlay_services_expirados_apos_interface)
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao consumir pacotes: {e}")
    
    def _schedule_data_volume_expiry_overlay(self, carta_path):
        """
        Agenda um overlay de Service Data Volume expirado para aparecer no próximo turno
        """
        try:
            # Adicionar à lista de overlays pendentes (similar ao sistema de Services TEMPORARY)
            if not hasattr(self, '_pending_data_volume_expiry_overlays'):
                self._pending_data_volume_expiry_overlays = []
            
            if carta_path not in self._pending_data_volume_expiry_overlays:
                self._pending_data_volume_expiry_overlays.append(carta_path)
                print(f"DEBUG: [DATA_VOLUME] Overlay de expiração agendado para: {os.path.basename(carta_path)}")
            else:
                print(f"DEBUG: [DATA_VOLUME] Overlay já agendado para: {os.path.basename(carta_path)}")
                
        except Exception as e:
            print(f"DEBUG: [DATA_VOLUME] ERRO ao agendar overlay de expiração: {e}")
    
    
    def _verificar_services_expirados(self):
        """
        Verifica se algum serviço TEMPORARY expirou baseado no número de turnos
        Chamado automaticamente no end_turn()
        """
        print("DEBUG: [SERVICE_EXPIRY] === VERIFICANDO SERVIÇOS EXPIRADOS ===")
        
        services_expirados = []
        
        # Verificar todos os serviços ativos
        for carta_path in self.active_services[:]:  # Cópia para evitar modificação durante iteração
            if carta_path in self._service_duration_tracking:
                tracking_data = self._service_duration_tracking[carta_path]
                duration_turns = tracking_data['duration_turns']
                start_turn = tracking_data['start_turn']
                
                # Calcular turnos decorridos
                turnos_decorridos = self._current_turn_number - start_turn
                
                print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)}:")
                print(f"DEBUG: [SERVICE_EXPIRY]   Início: turno {start_turn}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Duração: {duration_turns} turnos")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [SERVICE_EXPIRY]   Turno atual: {self._current_turn_number}")
                
                # Verificar se expirou (turnos decorridos >= duração)
                if turnos_decorridos >= duration_turns:
                    print(f"DEBUG: [SERVICE_EXPIRY] TIME: Service {os.path.basename(carta_path)} EXPIROU!")
                    services_expirados.append(carta_path)
        
        if services_expirados:
            print(f"DEBUG: [SERVICE_EXPIRY] {len(services_expirados)} serviços expiraram neste turno")
            # A expiração será tratada quando o usuário clicar na carta
        else:
            print("DEBUG: [SERVICE_EXPIRY] Nenhum serviço expirou neste turno")
    
    def _encontrar_todos_services_expirados(self):
        """
        Encontra TODOS os serviços expirados no inventário do jogador
        Retorna uma lista com os caminhos das cartas expiradas ou lista vazia
        """
        print("DEBUG: [SERVICE_BUTTON] === PROCURANDO TODOS OS SERVIÇOS EXPIRADOS ===")
        
        services_expirados = []
        services_inventory = self.inventario.get("services", [])
        
        for carta_path in services_inventory:
            if self._is_service_expired(carta_path):
                print(f"DEBUG: [SERVICE_BUTTON] Service expirado encontrado: {os.path.basename(carta_path)}")
                services_expirados.append(carta_path)
        
        print(f"DEBUG: [SERVICE_BUTTON] Total de serviços expirados encontrados: {len(services_expirados)}")
        return services_expirados
    
    def _encontrar_primeiro_service_expirado(self):
        """
        Encontra o primeiro serviço expirado no inventário do jogador
        Retorna o caminho da carta ou None se não houver serviços expirados
        MANTIDO PARA COMPATIBILIDADE - mas agora usa o método _encontrar_todos_services_expirados
        """
        print("DEBUG: [SERVICE_BUTTON] === PROCURANDO PRIMEIRO SERVIÇO EXPIRADO (COMPATIBILIDADE) ===")
        
        todos_expirados = self._encontrar_todos_services_expirados()
        
        if todos_expirados:
            primeiro = todos_expirados[0]
            print(f"DEBUG: [SERVICE_BUTTON] Primeiro service expirado: {os.path.basename(primeiro)}")
            return primeiro
        
        print("DEBUG: [SERVICE_BUTTON] Nenhum serviço expirado encontrado no inventário")
        return None
    
    def _encontrar_todos_events_expirados(self):
        """
        Encontra TODOS os events expirados no inventário do jogador
        Retorna uma lista com os caminhos das cartas expiradas ou lista vazia
        """
        print("DEBUG: [EVENT_BUTTON] === PROCURANDO TODOS OS EVENTS EXPIRADOS ===")
        
        events_expirados = []
        events_inventory = self.inventario.get("events", [])
        
        for carta_path in events_inventory:
            if self._is_event_expired(carta_path):
                print(f"DEBUG: [EVENT_BUTTON] Event expirado encontrado: {os.path.basename(carta_path)}")
                events_expirados.append(carta_path)
        
        print(f"DEBUG: [EVENT_BUTTON] Total de events expirados encontrados: {len(events_expirados)}")
        return events_expirados
    
    def _is_service_expired(self, carta_path):
        """
        Verifica se um serviço específico expirou
        CORREÇÃO: Usar turno real de ativação em vez de tracking que pode ter sido recriado
        """
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Verificando se Service expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Turno atual: {self._current_turn_number}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Services com tracking: {list(self._service_duration_tracking.keys())}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Services com turno real: {list(self._service_real_activation_turns.keys())}")
        
        # CORREÇÃO CRÍTICA: Priorizar o turno real de ativação se disponível
        if carta_path in self._service_real_activation_turns:
            turno_real_ativacao = self._service_real_activation_turns[carta_path]
            print(f"DEBUG: [SERVICE_EXPIRY_CHECK] USANDO TURNO REAL de ativação: {turno_real_ativacao}")
            
            # Obter duração do Service da base de dados
            try:
                service_data = self._get_service_data_from_path(carta_path)
                if service_data and service_data.service_type.value == 'temporary' and service_data.service_turns:
                    duration_turns = service_data.service_turns
                    
                    turnos_decorridos = self._current_turn_number - turno_real_ativacao
                    expirou = turnos_decorridos >= duration_turns
                    
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)}:")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno real ativação: {turno_real_ativacao}")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
                    
                    return expirou
                    
                else:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service não é TEMPORARY - considerado não expirado")
                    return False
                    
            except Exception as e:
                print(f"DEBUG: [SERVICE_EXPIRY_CHECK] ERRO ao obter dados do Service: {e}")
                return False
        
        # FALLBACK: Usar tracking antigo se turno real não disponível
        if carta_path not in self._service_duration_tracking:
            print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)} NÃO está no tracking - considerado não expirado")
            # CORREÇÃO: Verificar se o Service está ativo mas sem tracking - recriar tracking se necessário
            if self.is_card_active(carta_path, "services"):
                print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service está ATIVO mas sem tracking - tentando recriar...")
                self._register_service_start_turn(carta_path)
                # Após recriar, verificar novamente se agora está no tracking
                if carta_path in self._service_duration_tracking:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Tracking recriado com sucesso - continuando verificação...")
                else:
                    print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Falhou ao recriar tracking - Service considerado não expirado")
                    return False
            else:
                return False
            
        tracking_data = self._service_duration_tracking[carta_path]
        duration_turns = tracking_data['duration_turns']
        start_turn = tracking_data['start_turn']
        
        turnos_decorridos = self._current_turn_number - start_turn
        expirou = turnos_decorridos >= duration_turns
        
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] FALLBACK - Service {os.path.basename(carta_path)}:")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno início (tracking): {start_turn}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK] Service {os.path.basename(carta_path)}:")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turno início: {start_turn}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
        print(f"DEBUG: [SERVICE_EXPIRY_CHECK]   EXPIROU: {expirou}")
        
        return expirou
    
    def _is_event_expired(self, carta_path):
        """
        Verifica se um event específico expirou
        CORREÇÃO: Usar expires_turn quando disponível (Events com duração variável)
        """
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Verificando se Event expirou: {os.path.basename(carta_path)}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Turno atual: {self._current_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Events com tracking: {list(self._event_duration_tracking.keys())}")
        
        if carta_path not in self._event_duration_tracking:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)} NÃO está no tracking - considerado não expirado")
            return False
            
        tracking_data = self._event_duration_tracking[carta_path]
        duration_turns = tracking_data.get('duration_turns')
        start_turn = tracking_data.get('start_turn')
        expires_turn = tracking_data.get('expires_turn')
        is_active = tracking_data.get('is_active', False)
        
        print(f"DEBUG: [EVENT_EXPIRY_CHECK] Event {os.path.basename(carta_path)}:")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turno início: {start_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Expires turn: {expires_turn}")
        print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Ativo: {is_active}")
        
        # NOVA LÓGICA: Se expires_turn está definido (dado foi lançado), usar isso
        if expires_turn is not None and start_turn is not None:
            expirou = self._current_turn >= expires_turn
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   USANDO expires_turn: {expires_turn}")
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   EXPIROU: {expirou} (turno {self._current_turn} >= {expires_turn})")
            return expirou
        
        # LÓGICA LEGADA: Para Events com duração fixa
        elif is_active and duration_turns is not None and start_turn is not None:
            # Verificar se duration_turns é numérico antes de calcular
            if duration_turns == "variable":
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Event com duração variável sem expires_turn - não expirado ainda")
                return False
                
            try:
                duration_turns_int = int(duration_turns)
                turnos_decorridos = self._current_turn - start_turn
                expirou = turnos_decorridos >= duration_turns_int
                
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   USANDO duração fixa: {duration_turns_int}")
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Turnos decorridos: {turnos_decorridos}")
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   EXPIROU: {expirou}")
                return expirou
            except (ValueError, TypeError) as e:
                print(f"DEBUG: [EVENT_EXPIRY_CHECK]   ERRO: duration_turns inválido: {duration_turns} - {e}")
                return False
        else:
            print(f"DEBUG: [EVENT_EXPIRY_CHECK]   Event inativo ou dados insuficientes - não expirado")
            return False
    
    def _cleanup_expired_service_tracking(self, carta_path):
        """
        Remove tracking de um serviço que expirou
        CORREÇÃO: Limpar também o turno real de ativação
        """
        if carta_path in self._service_start_turns:
            del self._service_start_turns[carta_path]
        if carta_path in self._service_duration_tracking:
            del self._service_duration_tracking[carta_path]
        if carta_path in self._service_real_activation_turns:
            del self._service_real_activation_turns[carta_path]
            print(f"DEBUG: [SERVICE_TRACKING] Turno real de ativação removido para Service expirado: {os.path.basename(carta_path)}")
        print(f"DEBUG: [SERVICE_TRACKING] Tracking removido para Service expirado: {os.path.basename(carta_path)}")
    
    def _mostrar_overlays_services_expirados_sequencial(self, services_expirados, index=0):
        """
        Mostra overlays sequenciais para todos os serviços expirados
        
        Args:
            services_expirados (list): Lista de caminhos dos serviços expirados
            index (int): Índice atual na lista de serviços expirados
        """
        print(f"DEBUG: [SERVICE_SEQUENTIAL] === OVERLAY SEQUENCIAL {index+1}/{len(services_expirados)} ===")
        
        if index >= len(services_expirados):
            print("DEBUG: [SERVICE_SEQUENTIAL] Todos os overlays de serviços expirados foram mostrados")
            # Após mostrar todos os overlays, abrir inventário normal de Services
            self.show_inventory_matrix(["services"])
            return
        
        carta_path = services_expirados[index]
        print(f"DEBUG: [SERVICE_SEQUENTIAL] Mostrando overlay para Service {index+1}: {os.path.basename(carta_path)}")
        
        # Mostrar overlay individual para este serviço
        self._mostrar_overlay_service_expirado_sequencial(carta_path, services_expirados, index)
    
    def _mostrar_overlay_service_expirado_sequencial(self, carta_path, services_expirados, index):
        """
        Mostra overlay de serviço expirado individual como parte de uma sequência
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Mostrando overlay de expiração para {os.path.basename(carta_path)} ({index+1}/{len(services_expirados)})")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conteúdo do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # Título "Expired Service" em vermelho com contador
        titulo_contador = f"Expired Service ({index+1}/{len(services_expirados)})" if len(services_expirados) > 1 else "Expired Service"
        title_label = tk.Label(
            content_frame, 
            text=f"   {titulo_contador}    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto "Temporary Service has expired"
        service_name = os.path.basename(carta_path).replace('.png', '')
        message_text = "Temporary Service has expired for \n Residential User"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Botão OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_service_expirado_sequencial(overlay, carta_path, services_expirados, index)
        )
        ok_button.pack(pady=20)
    
    def _mostrar_overlay_service_expirado(self, carta_path):
        """
        Mostra overlay de serviço expirado com a carta em fullscreen de fundo
        MANTIDO PARA COMPATIBILIDADE - mas agora chama o sistema sequencial
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Método legado chamado - redirecionando para sistema sequencial")
        
        # Usar o novo sistema sequencial mesmo para um único serviço
        self._mostrar_overlays_services_expirados_sequencial([carta_path], 0)
    
    def _mostrar_overlay_service_expirado_data_volume(self, carta_path):
        """
        Mostra overlay específico para serviço Data Volume expirado por falta de pacotes
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Mostrando overlay específico para DATA VOLUME expirado: {os.path.basename(carta_path)}")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conteúdo do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # Título "Data Volume Expired" em vermelho
        title_label = tk.Label(
            content_frame, 
            text="   Data Volume Expired    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Texto específico para Data Volume - "No packets available for transmission"
        message_text = "No packets available for transmission\nfor Residential User"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Botão OK
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_data_volume_expirado(overlay, carta_path)
        )
        ok_button.pack(pady=10)
        
        print(f"DEBUG: [DATA_VOLUME] Overlay de Data Volume expirado mostrado para: {os.path.basename(carta_path)}")
    
    def _processar_data_volume_expirado(self, overlay, carta_path):
        """
        Processa a expiração do serviço Data Volume e fecha o overlay
        """
        print(f"DEBUG: [DATA_VOLUME] Processando expiração de Data Volume: {os.path.basename(carta_path)}")
        
        # Processar a expiração deste serviço
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar o overlay
        overlay.destroy()
        
        print(f"DEBUG: [DATA_VOLUME] Overlay de Data Volume expirado processado e fechado")
    
    def _processar_service_expirado_sequencial(self, overlay, carta_path, services_expirados, index):
        """
        Processa a expiração do serviço sequencialmente e mostra o próximo overlay se houver
        """
        print(f"DEBUG: [SERVICE_SEQUENTIAL] Processando expiração sequencial de {os.path.basename(carta_path)} ({index+1}/{len(services_expirados)})")
        
        # Processar a expiração deste serviço
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar o overlay atual
        overlay.destroy()
        
        # Mostrar o próximo overlay se houver mais serviços expirados
        proximo_index = index + 1
        if proximo_index < len(services_expirados):
            print(f"DEBUG: [SERVICE_SEQUENTIAL] Passando para próximo serviço: {proximo_index+1}/{len(services_expirados)}")
            # Usar after() para dar tempo ao overlay fechar antes de mostrar o próximo
            self.after(100, lambda: self._mostrar_overlays_services_expirados_sequencial(services_expirados, proximo_index))
        else:
            print("DEBUG: [SERVICE_SEQUENTIAL] Todos os serviços expirados foram processados - ficando na interface principal")
            # MUDANÇA: Em vez de abrir inventário de Services, simplesmente fica na interface principal
            # Overlay foi fechado, interface principal continua visível
    
    def _processar_service_expirado_individual(self, carta_path):
        """
        Processa a expiração de um serviço individual
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Processando expiração individual de {os.path.basename(carta_path)}")
        
        # Remover da lista de serviços ativos
        if carta_path in self.active_services:
            self.active_services.remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service removido da lista ativa")
        
        # CORREÇÃO CRÍTICA: Remover carta do inventário do jogador
        if carta_path in self.inventario.get("services", []):
            self.inventario["services"].remove(carta_path)
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} removido do inventário do jogador")
        else:
            print(f"DEBUG: [SERVICE_EXPIRY] AVISO: Service {os.path.basename(carta_path)} não encontrado no inventário do jogador")
        
        # CORREÇÃO CRÍTICA: Devolver carta para a Store
        try:
            self._devolver_carta_para_store(carta_path, "services")
            print(f"DEBUG: [SERVICE_EXPIRY] Service {os.path.basename(carta_path)} devolvido para a Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao devolver carta para Store: {e}")
        
        # Limpar tracking do serviço expirado
        self._cleanup_expired_service_tracking(carta_path)
    
    def _processar_service_expirado(self, overlay, carta_path):
        """
        Processa a expiração do serviço: remove das cartas ativas, do inventário do jogador e devolve para a Store
        MANTIDO PARA COMPATIBILIDADE
        """
        print(f"DEBUG: [SERVICE_EXPIRY] Método legado de processamento chamado")
        
        # Processar individualmente
        self._processar_service_expirado_individual(carta_path)
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar ao dashboard
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        self._cleanup_expired_service_tracking(carta_path)
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de inventário de Services do jogador (interface completa)
        print(f"DEBUG: [SERVICE_EXPIRY] Abrindo matriz de inventário de Services do jogador")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de inventário de Services (interface completa e formatada)
            self.show_inventory_matrix(["services"], page=0)
            print(f"DEBUG: [SERVICE_EXPIRY] Matriz de inventário de Services aberta com sucesso")
            print(f"DEBUG: [SERVICE_EXPIRY] Processo de expiração completo - carta removida do jogador e devolvida à Store")
        except Exception as e:
            print(f"DEBUG: [SERVICE_EXPIRY] Erro ao abrir matriz de inventário de Services: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [SERVICE_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [SERVICE_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [SERVICE_EXPIRY] Serviço {os.path.basename(carta_path)} retornou para o inventário da Store")
    
    def _mostrar_overlays_events_expirados_sequencial(self, events_expirados, index=0):
        """
        Mostra overlays sequenciais para todos os events expirados
        
        Args:
            events_expirados (list): Lista de caminhos dos events expirados
            index (int): Índice atual na lista de events expirados
        """
        print(f"DEBUG: [EVENT_SEQUENTIAL] === OVERLAY SEQUENCIAL {index+1}/{len(events_expirados)} ===")
        
        if index >= len(events_expirados):
            print("DEBUG: [EVENT_SEQUENTIAL] Todos os overlays de events expirados foram mostrados")
            # Após mostrar todos os overlays, abrir inventário normal de Actions/Events
            self.show_inventory_matrix(["actions", "events"])
            return
        
        carta_path = events_expirados[index]
        print(f"DEBUG: [EVENT_SEQUENTIAL] Mostrando overlay para Event {index+1}: {os.path.basename(carta_path)}")
        
        # Mostrar overlay individual para este event
        self._mostrar_overlay_event_expirado_sequencial(carta_path, events_expirados, index)
    
    def _mostrar_overlay_event_expirado_sequencial(self, carta_path, events_expirados, index):
        """
        Mostra overlay de event expirado individual como parte de uma sequência
        """
        print(f"DEBUG: [EVENT_EXPIRY] Mostrando overlay de expiração para {os.path.basename(carta_path)} ({index+1}/{len(events_expirados)})")
        
        # Criar overlay de fundo
        overlay = tk.Toplevel(self)
        overlay.title("")
        overlay.configure(bg="black")
        overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
        overlay.overrideredirect(True)
        overlay.attributes("-fullscreen", True)
        overlay.lift()
        overlay.focus_set()
        
        # Carregar a imagem da carta como fundo (igual ao overlay de desativação)
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = overlay.winfo_screenwidth(), overlay.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(overlay, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
        
        # Frame para o conteúdo do overlay (centro da tela)
        content_frame = tk.Frame(overlay, bg="black")
        content_frame.pack(expand=True)
        
        # Título "Expired Event" em vermelho com contador
        titulo_contador = f"Expired Event ({index+1}/{len(events_expirados)})" if len(events_expirados) > 1 else "Expired Event"
        title_label = tk.Label(
            content_frame, 
            text=f"   {titulo_contador}    ", 
            font=("Helvetica", 24, "bold"),
            bg="black", 
            fg="red"
        )
        title_label.pack(pady=(80, 20))
        
        # Obter texto específico do tipo de Event
        event_type_text = self._get_event_type_text(carta_path)
        message_text = f"{event_type_text} \nhas expired"
        
        message_label = tk.Label(
            content_frame, 
            text=message_text,
            font=("Helvetica", 15),
            bg="black", 
            fg="white",
            justify="center"
        )
        message_label.pack(pady=(0, 30))
        
        # Botão OK verde
        ok_button = tk.Button(
            content_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#00AA00",  # Cor verde
            fg="white",
            width=10,
            height=2,
            command=lambda: self._processar_event_expirado_sequencial(overlay, carta_path, events_expirados, index)
        )
        ok_button.pack(pady=20)
    
    def _processar_event_expirado_sequencial(self, overlay, carta_path, events_expirados, index):
        """
        Processa a expiração do event sequencialmente e mostra o próximo overlay se houver
        """
        print(f"DEBUG: [EVENT_SEQUENTIAL] Processando expiração sequencial de {os.path.basename(carta_path)} ({index+1}/{len(events_expirados)})")
        
        # Processar a expiração deste event
        self._processar_event_expirado_individual(carta_path)
        
        # Fechar o overlay atual
        overlay.destroy()
        
        # Mostrar o próximo overlay se houver mais events expirados
        proximo_index = index + 1
        if proximo_index < len(events_expirados):
            print(f"DEBUG: [EVENT_SEQUENTIAL] Passando para próximo event: {proximo_index+1}/{len(events_expirados)}")
            # Usar after() para dar tempo ao overlay fechar antes de mostrar o próximo
            self.after(100, lambda: self._mostrar_overlays_events_expirados_sequencial(events_expirados, proximo_index))
        else:
            print("DEBUG: [EVENT_SEQUENTIAL] Todos os events expirados foram processados")
            # CORREÇÃO: Após processar todos, APENAS fechar overlay e permanecer no dashboard
            # NÃO abrir inventário automaticamente
            print("DEBUG: [EVENT_SEQUENTIAL] Overlay fechado - permanecendo no dashboard principal")
    
    def _processar_event_expirado_individual(self, carta_path):
        """
        Processa a expiração de um event individual
        """
        print(f"DEBUG: [EVENT_EXPIRY] Processando expiração individual de {os.path.basename(carta_path)}")
        
        # Remover da lista de eventos ativos (se houver)
        if hasattr(self, 'active_events') and carta_path in self.active_events:
            self.active_events.remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event removido da lista ativa")
        
        # CORREÇÃO CRÍTICA: Remover carta do inventário do jogador
        if carta_path in self.inventario.get("events", []):
            self.inventario["events"].remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do inventário do jogador")
            
            # Marcar que um Event foi removido para a próxima carta ficar virada para baixo
            self._event_recently_removed = True
            print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
        else:
            print(f"DEBUG: [EVENT_EXPIRY] AVISO: Event {os.path.basename(carta_path)} não encontrado no inventário do jogador")
        
        # CORREÇÃO CRÍTICA: Devolver carta para a Store
        try:
            self._devolver_carta_para_store(carta_path, "events")
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} devolvido para a Store")
        except Exception as e:
            print(f"DEBUG: [EVENT_EXPIRY] Erro ao devolver carta para Store: {e}")
        
        # Limpar tracking do event expirado
        self._cleanup_expired_event_tracking(carta_path)
        
        # NOVA FUNCIONALIDADE: Ativar próxima carta após Event expirar
        # A próxima carta Action/Event na fila cronológica fica virada para cima (ativa)
        self._ativar_proxima_carta_apos_event_expirado()
    
    def _ativar_proxima_carta_apos_event_expirado(self):
        """
        Ativa a carta (Action ou Event) que está na posição 0 da fila cronológica após um Event expirar
        """
        print("DEBUG: [NEXT_ACTIVATION] === ATIVANDO CARTA NA POSIÇÃO 0 APÓS EVENT EXPIRADO ===")
        
        # Obter ordem cronológica atual
        chronological_order = self._get_chronological_actions_events_order()
        
        if not chronological_order:
            print("DEBUG: [NEXT_ACTIVATION] Nenhuma carta na fila cronológica")
            return
        
        # CORREÇÃO: Sempre ativar a carta na posição 0 (topo da fila)
        proxima_carta = chronological_order[0]  # Primeira carta da fila cronológica
        carta_path = proxima_carta['path']
        carta_tipo = proxima_carta['type']
        
        print(f"DEBUG: [NEXT_ACTIVATION] Ativando carta na posição 0: {os.path.basename(carta_path)} (tipo: {carta_tipo})")
        
        # Verificar se já está ativa (não deveria estar após um Event expirar)
        is_already_active = False
        if carta_tipo == 'actions':
            is_already_active = self.is_card_active(carta_path, 'actions')
        elif carta_tipo == 'events':
            is_already_active = self.is_card_active(carta_path, 'events')
        
        if is_already_active:
            print(f"DEBUG: [NEXT_ACTIVATION] AVISO: Carta {os.path.basename(carta_path)} já está ativa - não precisa ativar")
            return
        
        # Ativar a carta que está no topo da fila
        if carta_tipo == 'actions':
            # Para Actions, adicionar à lista de actions ativos (se ainda não estiver)
            if carta_path not in self.inventario.get("actions_active", []):
                if "actions_active" not in self.inventario:
                    self.inventario["actions_active"] = []
                self.inventario["actions_active"].append(carta_path)
                print(f"DEBUG: [NEXT_ACTIVATION] Action {os.path.basename(carta_path)} ativado (posição 0)")
        
        elif carta_tipo == 'events':
            # Para Events, adicionar tracking de duração se ainda não estiver
            if carta_path not in self._event_start_turns:
                self._register_event_start_turn(carta_path)
                print(f"DEBUG: [NEXT_ACTIVATION] Event {os.path.basename(carta_path)} ativado (posição 0)")
            else:
                # Se já tem tracking mas não está ativo, ativar agora
                current_turn = getattr(self, '_current_turn_number', 1)
                self._event_start_turns[carta_path] = current_turn
                
                # Atualizar tracking para ativo
                if carta_path in self._event_duration_tracking:
                    tracking_info = self._event_duration_tracking[carta_path]
                    tracking_info['start_turn'] = current_turn
                    tracking_info['is_active'] = True
                    
                    # Recalcular expiração
                    duration_turns = tracking_info.get('duration_turns', 1)
                    tracking_info['expires_turn'] = current_turn + duration_turns
                    
                    print(f"DEBUG: [NEXT_ACTIVATION] Event {os.path.basename(carta_path)} reativado (posição 0)")
                    print(f"DEBUG: [NEXT_ACTIVATION]   Turno início: {current_turn}")
                    print(f"DEBUG: [NEXT_ACTIVATION]   Expira no turno: {current_turn + duration_turns}")
        
        print("DEBUG: [NEXT_ACTIVATION] === FIM ATIVAÇÃO CARTA POSIÇÃO 0 ===")
    
    def _register_event_start_turn(self, carta_path):
        """
        Registra o turno de início de um Event quando ativado automaticamente
        """
        current_turn = getattr(self, '_current_turn_number', 1)
        
        # Obter duração do Event da base de dados
        try:
            event_data = self._get_event_data_from_path(carta_path)
            if event_data and event_data.duration_turns:
                duration_turns = event_data.duration_turns
            else:
                duration_turns = 1  # Fallback
        except Exception as e:
            print(f"DEBUG: [REGISTER_EVENT] Erro ao obter duração do Event: {e}")
            duration_turns = 1
        
        # Registrar no tracking
        self._event_start_turns[carta_path] = current_turn
        self._event_duration_tracking[carta_path] = {
            'start_turn': current_turn,
            'duration_turns': duration_turns,
            'expires_turn': current_turn + duration_turns,
            'is_active': True
        }
        
        print(f"DEBUG: [REGISTER_EVENT] Event {os.path.basename(carta_path)} registrado:")
        print(f"DEBUG: [REGISTER_EVENT]   Turno início: {current_turn}")
        print(f"DEBUG: [REGISTER_EVENT]   Duração: {duration_turns} turnos")
        print(f"DEBUG: [REGISTER_EVENT]   Expira no turno: {current_turn + duration_turns}")
    
    def _cleanup_expired_event_tracking(self, carta_path):
        """
        Remove tracking de um event que expirou
        """
        if carta_path in self._event_start_turns:
            del self._event_start_turns[carta_path]
        if carta_path in self._event_duration_tracking:
            del self._event_duration_tracking[carta_path]
        print(f"DEBUG: [EVENT_TRACKING] Tracking removido para Event expirado: {os.path.basename(carta_path)}")
    
    def _mostrar_overlay_event_expirado(self, carta_path):
        """
        Mostra overlay de event expirado - agora usa o sistema sequencial
        MANTIDO PARA COMPATIBILIDADE - mas agora chama o sistema sequencial
        """
        print(f"DEBUG: [EVENT_EXPIRY] Método legado chamado - redirecionando para sistema sequencial")
        
        # Usar o novo sistema sequencial mesmo para um único event
        self._mostrar_overlays_events_expirados_sequencial([carta_path], 0)
    
    def _get_event_type_text(self, carta_path):
        """
        Obtém o texto do tipo de Event baseado no caminho da carta usando a base de dados
        
        Args:
            carta_path: Caminho para a carta Event (ex: "/path/Event_55.png")
            
        Returns:
            Texto do tipo do Event (ex: "Transmission Delay", "Link Failure", etc.)
        """
        try:
            # Extrair ID do Event do caminho
            filename = os.path.basename(carta_path)
            match = re.match(r'Event_(\d+)', filename)
            
            if not match:
                print(f"DEBUG: [EVENT_TYPE] Formato de arquivo inválido: {filename}")
                return "Unknown"
            
            event_id = f"event_{match.group(1)}"
            print(f"DEBUG: [EVENT_TYPE] Buscando Event na base de dados: {event_id}")
            
            # Obter Event da base de dados
            if hasattr(self, 'card_database') and self.card_database:
                event_card = self.card_database.get_event(event_id)
                
                if event_card:
                    print(f"DEBUG: [EVENT_TYPE] Event encontrado: {event_card.title}")
                    return event_card.title
                else:
                    print(f"DEBUG: [EVENT_TYPE] Event não encontrado na base de dados: {event_id}")
            else:
                print(f"DEBUG: [EVENT_TYPE] Base de dados não disponível")
            
            # Fallback baseado no ID do Event
            event_number = int(match.group(1))
            
            # Mapear números para tipos baseado na base de dados
            event_type_mapping = {
                # TRANSMISSION_DELAY Events (1-50)
                range(1, 51): "Transmission Delay",
                # LINK_FAILURE Events (51-100)  
                range(51, 101): "Link Failure",
                # TRAFFIC_BURST Events (101-120)
                range(101, 121): "Traffic Burst",
                # QUEUE_CONGESTION Events (121-130)
                range(121, 131): "Queue Congestion",
                # QUEUE_FULL Events (131-140)
                range(131, 141): "Queue Full",
                # PACKET_DROP Events (141-150)
                range(141, 151): "Packet Drop",
                # EMPTY_QUEUE Events (151-175)
                range(151, 176): "Empty Queue"
            }
            
            # Encontrar tipo baseado no número
            for event_range, event_type in event_type_mapping.items():
                if event_number in event_range:
                    print(f"DEBUG: [EVENT_TYPE] Tipo mapeado: {event_type}")
                    return event_type
            
            print(f"DEBUG: [EVENT_TYPE] Tipo não mapeado para número: {event_number}")
            return "Unknown Event"
            
        except Exception as e:
            print(f"DEBUG: [EVENT_TYPE] Erro ao obter tipo do Event: {e}")
            return "Unknown Event"
    
    def _processar_event_expirado(self, overlay, carta_path):
        """
        Processa a expiração do event: remove do inventário do jogador
        """
        print(f"DEBUG: [EVENT_EXPIRY] Processando expiração de {os.path.basename(carta_path)}")
        
        # CORREÇÃO CRÍTICA: Remover carta do inventário do jogador
        if carta_path in self.inventario.get("events", []):
            self.inventario["events"].remove(carta_path)
            print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do inventário do jogador")
            
            # Marcar que um Event foi removido para a próxima carta ficar virada para baixo
            self._event_recently_removed = True
            print(f"DEBUG: [REMOVE_EVENT] Flag _event_recently_removed definida para True")
        else:
            print(f"DEBUG: [EVENT_EXPIRY] AVISO: Event {os.path.basename(carta_path)} não encontrado no inventário do jogador")
        
        # Limpar tracking
        if hasattr(self, '_event_start_turns') and carta_path in self._event_start_turns:
            del self._event_start_turns[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de turno removido para {os.path.basename(carta_path)}")
        
        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
            del self._event_duration_tracking[carta_path]
            print(f"DEBUG: [EVENT_EXPIRY] Tracking de duração removido para {os.path.basename(carta_path)}")
        
        # Fechar overlay
        overlay.destroy()
        
        # Voltar para a matriz de inventário de Actions/Events (interface completa)
        print(f"DEBUG: [EVENT_EXPIRY] Voltando para matriz de inventário de Actions/Events")
        try:
            # Salvar estado atual antes de navegar
            self._save_dashboard_state()
            
            # Abrir matriz de inventário de Actions/Events (interface completa e formatada)
            self.show_inventory_matrix(["actions", "events"], page=0)
            print(f"DEBUG: [EVENT_EXPIRY] Matriz de inventário de Actions/Events aberta com sucesso")
            print(f"DEBUG: [EVENT_EXPIRY] Processo de expiração completo - carta removida do jogador")
        except Exception as e:
            print(f"DEBUG: [EVENT_EXPIRY] Erro ao abrir matriz de inventário de Actions/Events: {e}")
            # Fallback: voltar para interface principal
            try:
                self.playerdashboard_interface(
                    getattr(self, 'player_name', 'Player'), 
                    self.saldo, 
                    self.other_players
                )
                print(f"DEBUG: [EVENT_EXPIRY] Fallback: voltou para interface principal")
            except Exception as fallback_error:
                print(f"DEBUG: [EVENT_EXPIRY] Erro no fallback: {fallback_error}")
                print(f"DEBUG: [EVENT_EXPIRY] Event {os.path.basename(carta_path)} removido do inventário")
    
    
    def _obter_valor_barra_atual(self, tipo_barra):
        """
        Obtém o valor atual de uma barra de progresso específica
        """
        return self._obter_valor_barra_atual_by_index(tipo_barra, getattr(self, 'selected_card_idx', 0))
    
    def _obter_valor_barra_atual_by_index(self, tipo_barra, card_idx):
        """
        Obtém o valor atual de uma barra de progresso específica para um índice de carta específico
        """
        try:
            # Verificar se existe dados de estatísticas e índice válido
            if hasattr(self, 'card_stats') and card_idx < len(self.card_stats):
                valor = self.card_stats[card_idx].get(tipo_barra, 0)
                print(f"DEBUG: [REWARD_CALC] Valor da barra {tipo_barra} (carta {card_idx}): {valor}")
                return valor
            
            print(f"DEBUG: [REWARD_CALC] Não foi possível obter valor da barra {tipo_barra} para carta {card_idx}, retornando 0")
            return 0
        except Exception as e:
            print(f"DEBUG: [REWARD_CALC] Erro ao obter valor da barra {tipo_barra} para carta {card_idx}: {e}")
            return 0
    
    def _fechar_overlay_completion(self):
        """
        Fecha overlay de completion - MÉTODO LEGADO
        O processamento principal agora é feito em fechar_e_continuar()
        """
        if hasattr(self, '_overlay_completion') and self._overlay_completion:
            print(f"DEBUG: [COMPLETION] Fechando overlay (método legado)")
            
            # Apenas fechar overlay - processamento já foi feito
            self._overlay_completion.destroy()
            self._overlay_completion = None
            
            # CORREÇÃO: Remover flag de overlay ativo
            self._completion_overlay_active = False
            print(f"DEBUG: [COMPLETION] Flag _completion_overlay_active = False")
            
            print(f"DEBUG: [COMPLETION] Overlay fechado")
    
    def _devolver_carta_para_store(self, carta_path, card_type):
        """
        Devolve carta completada para a Store conforme o tipo:
        - Challenge: volta para o baralho da Store
        - Activity: volta para o inventário Activity da Store
        - Services: volta para o inventário Services da Store
        """
        try:
            print(f"DEBUG: [DEVOLVER_STORE] Devolvendo {card_type}: {os.path.basename(carta_path)}")
            
            # CORREÇÃO CRÍTICA: Primeiro remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # CORREÇÃO: Normalizar tipo para maiúsculo para comparação
            card_type_normalized = card_type.capitalize() if isinstance(card_type, str) else str(card_type).capitalize()
            
            if card_type_normalized == "Challenge":
                # Challenge volta para o baralho da Store
                self._devolver_challenge_para_baralho(carta_path)
            elif card_type_normalized == "Activity":
                # Activity volta para o inventário Activity da Store
                self._devolver_activity_para_inventario(carta_path)
            elif card_type_normalized == "Services":
                # Services volta para o inventário Services da Store
                self._devolver_service_para_inventario_store(carta_path)
            else:
                print(f"DEBUG: [DEVOLVER_STORE] AVISO: Tipo de carta desconhecido: {card_type} (normalizado: {card_type_normalized})")
                # CORREÇÃO ADICIONAL: Tentar detectar tipo pelo nome do arquivo
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Activity pelo nome do arquivo - devolvendo como Activity")
                    self._devolver_activity_para_inventario(carta_path)
                elif "challenge" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Challenge pelo nome do arquivo - devolvendo como Challenge")
                    self._devolver_challenge_para_baralho(carta_path)
                elif "service" in carta_basename:
                    print(f"DEBUG: [DEVOLVER_STORE] Detectado Service pelo nome do arquivo - devolvendo como Service")
                    self._devolver_service_para_inventario_store(carta_path)
                else:
                    print(f"DEBUG: [DEVOLVER_STORE] ERRO: Não foi possível determinar tipo da carta")
                
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_STORE] ERRO ao devolver carta à Store: {e}")
            import traceback
            traceback.print_exc()
    
    def _devolver_challenge_para_baralho(self, carta_path):
        """
        Devolve Challenge completado para o baralho da Store
        """
        try:
            # CORREÇÃO: Limpar tracking do Challenge antes de devolver
            self._cleanup_completed_challenge_tracking(carta_path)
            print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # Determinar cor da carta (geralmente neutral para Challenges)
            cor_carta = self._get_color_from_path(carta_path) or "neutral"
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "challenges", cor_carta)
                    print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "challenges" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["challenges"] = []
                
                # Adicionar no início do baralho (topo)
                baralhos[cor_carta]["challenges"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_CHALLENGE] Challenge devolvido ao baralho global challenges/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO: Não foi possível importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_CHALLENGE] ERRO ao devolver Challenge: {e}")
    
    def _devolver_activity_para_inventario(self, carta_path):
        """
        Devolve Activity completada para o inventário Activity da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "activities", cor_carta)
                    print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao inventário da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "activities" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["activities"] = []
                
                # Adicionar no início do baralho (topo)
                baralhos[cor_carta]["activities"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_ACTIVITY] Activity devolvida ao baralho global activities/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO: Não foi possível importar baralhos da Store: {e}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_ACTIVITY] ERRO ao devolver Activity: {e}")
    
    def _devolver_service_para_inventario_store(self, carta_path):
        """
        Devolve Service expirado para o inventário Services da Store
        """
        try:
            # Determinar cor da carta
            cor_carta = self._get_color_from_path(carta_path) or self.player_color.lower()
            
            # Tentar devolver via Store_v2 se houver referência
            if hasattr(self, 'store_window') and self.store_window:
                if hasattr(self.store_window, 'adicionar_carta_ao_baralho'):
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "services", cor_carta)
                    print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao inventário da Store via store_window")
                    return
            
            # Fallback: adicionar diretamente aos baralhos globais da Store
            try:
                from Store import baralhos
                if cor_carta not in baralhos:
                    baralhos[cor_carta] = {}
                if "services" not in baralhos[cor_carta]:
                    baralhos[cor_carta]["services"] = []
                
                # Adicionar no início do baralho (topo) para ficar disponível imediatamente
                baralhos[cor_carta]["services"].insert(0, carta_path)
                print(f"DEBUG: [DEVOLVER_SERVICE] Service devolvido ao baralho global services/{cor_carta}")
                
            except ImportError as e:
                print(f"DEBUG: [DEVOLVER_SERVICE] ERRO: Não foi possível importar baralhos da Store: {e}")
                # Fallback adicional: tentar diretamente através de Store_v2
                try:
                    from Store import StoreWindow
                    # Criar instância temporária da Store para adicionar carta
                    # Nota: Isto é um fallback extremo, normalmente a store_window deve estar disponível
                    print(f"DEBUG: [DEVOLVER_SERVICE] Tentando fallback via StoreWindow direto")
                except Exception as e2:
                    print(f"DEBUG: [DEVOLVER_SERVICE] ERRO no fallback StoreWindow: {e2}")
            
        except Exception as e:
            print(f"DEBUG: [DEVOLVER_SERVICE] ERRO ao devolver Service: {e}")
    
    def _remover_carta_do_carrossel(self, carta_path):
        """
        Remove carta completada do carrossel e volta ao estado vazio
        """
        try:
            # CORREÇÃO: Limpar tracking do Challenge se for Challenge
            if "challenge" in os.path.basename(carta_path).lower():
                self._cleanup_completed_challenge_tracking(carta_path)
                print(f"DEBUG: [REMOVER_CARROSSEL] Challenge tracking limpo para: {os.path.basename(carta_path)}")
            
            # Encontrar posição da carta no carrossel
            carta_removida_idx = None
            for i, card_path in enumerate(self.cards):
                if card_path == carta_path:
                    carta_removida_idx = i
                    break
            
            if carta_removida_idx is not None:
                print(f"DEBUG: [COMPLETION] Removendo carta da posição {carta_removida_idx} do carrossel")
                
                # Voltar para carta de costas padrão
                default_card = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                self.cards[carta_removida_idx] = default_card
                
                # NOVA FUNCIONALIDADE: Atualizar flag da carta para False (virada para baixo)
                if hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags[carta_removida_idx] = False
                    print(f"DEBUG: [COMPLETION] Flag da posição {carta_removida_idx} atualizada para False (virada para baixo)")
                    print(f"DEBUG: [COMPLETION] Estados das cartas: {self.card_face_up_flags}")
                
                # Resetar estatísticas da carta
                self.card_stats[carta_removida_idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # NOTA: NÃO removemos da lista de gestão aqui - isso é feito antes na função de completion
                # Apenas removemos visualmente do carrossel
                
                # Atualizar carrossel visual
                self.atualizar_carrossel()
                
                # Se a carta removida era a carta atual, atualizar barras de progresso
                if carta_removida_idx == self.selected_card_idx:
                    self.update_progress_bars_for_card(carta_removida_idx)
                
                print(f"DEBUG: [COMPLETION] Carta removida com sucesso da posição {carta_removida_idx}")
            else:
                print(f"DEBUG: [COMPLETION] AVISO: Carta {os.path.basename(carta_path)} não encontrada no carrossel")
        
        except Exception as e:
            print(f"DEBUG: [COMPLETION] ERRO ao remover carta do carrossel: {e}")
            import traceback
            traceback.print_exc()
    
    def _atualizar_display_saldo(self):
        """
        Atualiza o display do saldo na interface (se existir)
        """
        # Procurar por widgets de saldo na interface principal
        for widget in self.winfo_children():
            if isinstance(widget, tk.Label):
                # Tentar encontrar label do saldo pelo texto numérico
                try:
                    texto = widget.cget("text")
                    if texto.isdigit():
                        widget.config(text=str(self.saldo))
                        print(f"DEBUG: [COMPLETION] Display do saldo atualizado para {self.saldo}")
                        break
                except:
                    continue
    
    def _carta_pode_processar_pacotes(self, carta_path):
        """
        Verifica se uma carta ainda tem capacidade de processamento restante.
        Uma carta NÃO pode processar mais se:
        1. Para Activities: Rxd >= message_size E To send <= 0
        2. Para Activities: Já processou rate_max pacotes neste turno
        3. Para Challenges: Similar mas com regras específicas
        
        Returns:
            bool: True se a carta pode processar mais pacotes, False caso contrário
        """
        try:
            carta_basename = os.path.basename(carta_path).lower()
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_path)
            if not dados_carta:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem dados - NÃO pode processar")
                return False
            
            rate_max = dados_carta.get('rate', 1)
            message_size = dados_carta.get('message_size', 20)
            
            # Encontrar posição da carta no carrossel para obter valores atuais
            posicao_carrossel = None
            if hasattr(self, 'cards') and carta_path in self.cards:
                posicao_carrossel = self.cards.index(carta_path)
            
            if posicao_carrossel is None:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: não encontrada no carrossel - NÃO pode processar")
                return False
            
            # Obter valores atuais das barras
            if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                stats = self.card_stats[posicao_carrossel]
                to_send_atual = stats.get('To send', 0)
                rxd_atual = stats.get('Rxd', 0)
                lost_atual = stats.get('Lost', 0)
            else:
                print(f"DEBUG: [PODE_PROCESSAR] Carta {os.path.basename(carta_path)}: sem stats - NÃO pode processar")
                return False
            
            # Verificar quantos pacotes foram processados NESTE turno
            rxd_processado_turno = self._get_processed_this_turn(carta_path, 'rxd')
            lost_processado_turno = self._get_processed_this_turn(carta_path, 'lost')
            total_processado_turno = rxd_processado_turno + lost_processado_turno
            
            print(f"DEBUG: [PODE_PROCESSAR] === VERIFICAÇÃO CARTA {os.path.basename(carta_path)} ===")
            print(f"DEBUG: [PODE_PROCESSAR] Valores atuais: To send={to_send_atual}, Rxd={rxd_atual}, Lost={lost_atual}")
            print(f"DEBUG: [PODE_PROCESSAR] Rate máximo por turno: {rate_max}")
            print(f"DEBUG: [PODE_PROCESSAR] Message size (limite total): {message_size}")
            print(f"DEBUG: [PODE_PROCESSAR] Processado neste turno: Rxd={rxd_processado_turno}, Lost={lost_processado_turno}, Total={total_processado_turno}")
            
            # REGRA 1: Verificar limite por turno (rate_max)
            if total_processado_turno >= rate_max:
                print(f"DEBUG: [PODE_PROCESSAR] ERROR: Limite por turno atingido ({total_processado_turno}/{rate_max})")
                return False
            
            # REGRA 2: Para Activities - verificar completion
            if "activity" in carta_basename:
                # Activity completa quando: To send = 0 E Rxd >= message_size
                if to_send_atual <= 0 and rxd_atual >= message_size:
                    print(f"DEBUG: [PODE_PROCESSAR] ERROR: Activity completada (To send={to_send_atual}, Rxd={rxd_atual}/{message_size})")
                    return False
                
                # Verificar se ainda pode incrementar Rxd ou Lost
                pode_incrementar_rxd = (rxd_atual < message_size and rxd_processado_turno < rate_max)
                
                # Para Lost: verificar se drops são permitidos
                drops_allowed = dados_carta.get('drops_allowed', False)
                penalty_per_packet = dados_carta.get('penalty_per_packet')
                lost_permitido = drops_allowed or penalty_per_packet is not None
                pode_incrementar_lost = (lost_permitido and lost_atual < message_size and lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Activity pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            # REGRA 3: Para Challenges - similar mas com regras específicas
            elif "challenge" in carta_basename:
                # Challenge pode processar enquanto não atingir rate_max neste turno
                pode_incrementar_rxd = (rxd_processado_turno < rate_max)
                pode_incrementar_lost = (lost_processado_turno < rate_max)
                
                pode_processar = pode_incrementar_rxd or pode_incrementar_lost
                print(f"DEBUG: [PODE_PROCESSAR] Challenge pode processar: Rxd={pode_incrementar_rxd}, Lost={pode_incrementar_lost} => {pode_processar}")
                return pode_processar
            
            print(f"DEBUG: [PODE_PROCESSAR] ERROR: Tipo de carta não reconhecido: {carta_basename}")
            return False
            
        except Exception as e:
            print(f"DEBUG: [PODE_PROCESSAR] ERROR: ERRO ao verificar carta {os.path.basename(carta_path)}: {e}")
            return False
    
    def _atualizar_barras_gestao_carta_atual(self):
        """
        CORREÇÃO CRÍTICA: Atualiza barras usando sempre a carta REAL do carrossel
        e não a carta preservada que pode estar incorreta
        """
        print(f"DEBUG: [GESTÃO_PACOTES] === ATUALIZAÇÃO BARRAS CARTA SELECIONADA ===")
        
        # CORREÇÃO FUNDAMENTAL: SEMPRE usar a carta que está REALMENTE no carrossel
        # em vez de confiar na carta preservada que pode estar desatualizada
        carta_atual = None
        posicao_carrossel = None
        
        if (hasattr(self, 'selected_carousel_index') and self.selected_carousel_index is not None and
            hasattr(self, 'cards') and self.cards and 
            self.selected_carousel_index < len(self.cards)):
            
            # USAR SEMPRE A CARTA REAL DO CARROSSEL
            posicao_carrossel = self.selected_carousel_index
            carta_atual = self.cards[posicao_carrossel]
            
            print(f"DEBUG: [GESTÃO_PACOTES]   SUCCESS: USANDO CARTA REAL DO CARROSSEL:")
            print(f"DEBUG: [GESTÃO_PACOTES]   Posição no carrossel: {posicao_carrossel}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Carta REAL: {os.path.basename(carta_atual)}")
            
            # Debug: Mostrar se há diferença entre carta real e preservada
            if hasattr(self, 'selected_carousel_card') and self.selected_carousel_card:
                carta_preservada = os.path.basename(self.selected_carousel_card)
                carta_real = os.path.basename(carta_atual)
                if carta_preservada != carta_real:
                    print(f"DEBUG: [GESTÃO_PACOTES]   WARNING: DIFERENÇA DETECTADA:")
                    print(f"DEBUG: [GESTÃO_PACOTES]   Carta preservada: {carta_preservada}")
                    print(f"DEBUG: [GESTÃO_PACOTES]   Carta real: {carta_real}")
                    print(f"DEBUG: [GESTÃO_PACOTES]   SUCCESS: USANDO A CARTA REAL!")
            
        else:
            # Fallback: usar sistema antigo se não há carrossel válido
            if hasattr(self, '_cartas_gestao') and hasattr(self, '_carta_atual_gestao'):
                carta_atual = self._cartas_gestao[self._carta_atual_gestao]
                carta_basename = os.path.basename(carta_atual)
                
                print(f"DEBUG: [GESTÃO_PACOTES] === FALLBACK - CARTA ATUAL (SISTEMA ANTIGO) ===")
                print(f"DEBUG: [GESTÃO_PACOTES]   Carta: {carta_basename}")
                print(f"DEBUG: [GESTÃO_PACOTES]   Índice gestão: {self._carta_atual_gestao}")
                
                # Encontrar a posição real no carrossel (self.cards)
                posicao_carrossel = None
                if hasattr(self, 'cards'):
                    for i, card_path in enumerate(self.cards):
                        if card_path == carta_atual:
                            posicao_carrossel = i
                            break
                
                if posicao_carrossel is None:
                    print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Carta não encontrada no carrossel!")
                    return
                
                print(f"DEBUG: [GESTÃO_PACOTES]   Posição real no carrossel: {posicao_carrossel}")
            else:
                print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO: Não há informação de cartas!")
                return
        
        # CORREÇÃO: Verificar se há valores preservados para esta carta primeiro
        preserved_stats = None
        if hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
            preserved_stats = self.card_stats[posicao_carrossel]
            print(f"DEBUG: [GESTÃO_PACOTES] Stats preservadas encontradas: {preserved_stats}")
        
        # CORREÇÃO: Se há stats preservadas, usar essas; senão buscar da base de dados
        if preserved_stats:
            # Usar valores preservados do turno atual
            to_send_atual = preserved_stats.get('To send', 0)
            rxd_atual = preserved_stats.get('Rxd', 0) 
            lost_atual = preserved_stats.get('Lost', 0)
            
            # Obter message_size da base de dados para máximo das barras
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: USANDO VALORES PRESERVADOS:")
            print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_atual}")
            print(f"DEBUG: [GESTÃO_PACOTES]   Message size (máximo): {message_size}")
            
        else:
            # Fallback: usar base de dados se não há valores preservados
            print(f"DEBUG: [GESTÃO_PACOTES] WARNING: Sem valores preservados - usando base de dados")
            message_size = self._get_card_message_size_from_database(carta_atual)
            
            # Verificar se há valores nos _valores_pacotes (antigo sistema)
            if hasattr(self, '_valores_pacotes') and self._carta_atual_gestao in self._valores_pacotes:
                valores = self._valores_pacotes[self._carta_atual_gestao]
                total_processado = valores['enviados'] + valores['perdidos']
                to_send_atual = max(message_size - total_processado, 0)
                rxd_atual = valores['enviados']
                lost_atual = valores['perdidos']
            else:
                # Reset completo se não há dados
                to_send_atual = message_size
                rxd_atual = 0
                lost_atual = 0
        
        # Atualizar todas as barras com os valores corretos
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            # Atualizar To send
            if "To send" in self.progress_bars and "To send" in self.progress_labels:
                self.progress_bars["To send"].config(value=to_send_atual, maximum=message_size)
                self.progress_labels["To send"].config(text=str(to_send_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: To send atualizada: {to_send_atual}/{message_size}")
            
            # Atualizar Rxd
            if "Rxd" in self.progress_bars and "Rxd" in self.progress_labels:
                self.progress_bars["Rxd"].config(value=rxd_atual, maximum=message_size)
                self.progress_labels["Rxd"].config(text=str(rxd_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Rxd atualizada: {rxd_atual}")
            
            # Atualizar Lost
            if "Lost" in self.progress_bars and "Lost" in self.progress_labels:
                self.progress_bars["Lost"].config(value=lost_atual, maximum=message_size)
                self.progress_labels["Lost"].config(text=str(lost_atual))
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Lost atualizada: {lost_atual}")
                
            # IMPORTANTE: Sincronizar os valores preservados com o que está nas barras
            if preserved_stats is None and hasattr(self, 'card_stats') and posicao_carrossel < len(self.card_stats):
                self.card_stats[posicao_carrossel] = {
                    'To send': to_send_atual,
                    'Rxd': rxd_atual,
                    'Lost': lost_atual
                }
                print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: Stats sincronizadas na posição {posicao_carrossel}")
        else:
            print("DEBUG: [GESTÃO_PACOTES] ERROR: Barras de progresso não encontradas para atualização")
    
    def _mostrar_botao_seta(self):
        """Mostra botão seta (→) na mesma altura do End Turn com cor roxa"""
        print("DEBUG: [GESTÃO_PACOTES] === INICIANDO CRIAÇÃO DO BOTÃO SETA ===")
        
        if hasattr(self, '_btn_seta') and self._btn_seta:
            try:
                print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta existente...")
                self._btn_seta.destroy()
            except (tk.TclError, AttributeError):
                print("DEBUG: [GESTÃO_PACOTES] Erro ao remover botão seta existente")
                pass
        
        try:
            self._btn_seta = tk.Button(
                self,
                text="→",
                font=("Helvetica", 16, "bold"),
                bg="#8B5CF6",  # Cor roxa
                fg="white",
                command=self._proxima_carta_gestao,
                width=3,
                height=1
            )
            
            # Posicionar na mesma altura (rely) que o End Turn (aproximadamente)
            # End Turn está em rely=0.945, então usamos uma posição ligeiramente diferente
            self._btn_seta.place(relx=0.05, rely=0.945, anchor="w")
            
            # Forçar o botão a aparecer por cima de todos os outros elementos
            self._btn_seta.lift()
            
            # Atualizar a interface para garantir que o botão aparece
            self.update_idletasks()
            
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Botão seta criado com sucesso!")
            print(f"DEBUG: [GESTÃO_PACOTES] Posição: relx=0.05, rely=0.945")
            print(f"DEBUG: [GESTÃO_PACOTES] Widget existe: {hasattr(self, '_btn_seta') and self._btn_seta}")
            
        except Exception as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: ERRO ao criar botão seta: {e}")
            self._btn_seta = None
    
    def _proxima_carta_gestao(self):
        """
        NOVA FUNCIONALIDADE: 
        1. Verificar PRIMEIRO se é Challenge na Final Phase (independente da posição)
        2. Se for Challenge na Final Phase, mostrar overlay completion
        3. Caso contrário, continuar gestão normal
        """
        print(f"DEBUG: [SETA_COMPLETION] ===== BOTÃO SETA CLICADO =====")
        print(f"DEBUG: [SETA_COMPLETION] Carta atual (índice): {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION] Total de cartas gestão: {len(self._cartas_gestao)}")
        
        # CORREÇÃO CRÍTICA: Bloquear temporariamente cliques no carrossel por 500ms
        # para evitar fullscreen acidental após clique no botão seta
        self._bloqueio_temporario_carrossel = True
        self.after(500, lambda: setattr(self, '_bloqueio_temporario_carrossel', False))
        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Bloqueio temporário do carrossel ativado por 500ms")
        
        # CORREÇÃO CRÍTICA: Validar índices antes de acessar as listas
        print(f"DEBUG: [SETA_COMPLETION] Validação inicial:")
        print(f"DEBUG: [SETA_COMPLETION]   _carta_atual_gestao: {self._carta_atual_gestao}")
        print(f"DEBUG: [SETA_COMPLETION]   len(_cartas_gestao): {len(self._cartas_gestao)}")
        print(f"DEBUG: [SETA_COMPLETION]   _cartas_gestao: {[os.path.basename(c) for c in self._cartas_gestao]}")
        
        # CORREÇÃO FUNDAMENTAL: Verificar se o índice é válido antes de acessar
        if self._carta_atual_gestao >= len(self._cartas_gestao):
            print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: Índice gestão ({self._carta_atual_gestao}) >= tamanho lista ({len(self._cartas_gestao)})")
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: CORREÇÃO: Usando carta selecionada do carrossel como referência")
            selected_carta = getattr(self, 'selected_carousel_card', None)
            if selected_carta:
                carta_atual = selected_carta
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Carta corrigida para: {os.path.basename(carta_atual)}")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO CRÍTICO: Sem carta selecionada no carrossel")
                return
        else:
            # CORREÇÃO CRÍTICA: Garantir que estamos a processar a carta CORRETA
            # A carta atual da gestão deve corresponder à carta selecionada no carrossel
            carta_atual = self._cartas_gestao[self._carta_atual_gestao]
            selected_carta = getattr(self, 'selected_carousel_card', None)
        
        print(f"DEBUG: [SETA_COMPLETION] Carta gestão atual: {os.path.basename(carta_atual)}")
        print(f"DEBUG: [SETA_COMPLETION] Carta selecionada carrossel: {os.path.basename(selected_carta) if selected_carta else 'None'}")
        
        # CORREÇÃO FUNDAMENTAL: Se há discrepância E a gestão tem cartas válidas, usar a carta selecionada do carrossel
        # que é a que está destacada em roxo e visível ao utilizador
        if (selected_carta and 
            len(self._cartas_gestao) > 0 and 
            self._carta_atual_gestao < len(self._cartas_gestao) and 
            selected_carta != carta_atual):
            print(f"DEBUG: [SETA_COMPLETION] WARNING: DISCREPÂNCIA DETECTADA!")
            print(f"DEBUG: [SETA_COMPLETION] Gestão: {os.path.basename(carta_atual)}")
            print(f"DEBUG: [SETA_COMPLETION] Carrossel: {os.path.basename(selected_carta)}")
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: CORRIGINDO - Usando carta do carrossel como referência")
            carta_atual = selected_carta
            
            # Atualizar a posição da gestão para corresponder à carta correta
            try:
                nova_posicao_gestao = self._cartas_gestao.index(carta_atual)
                self._carta_atual_gestao = nova_posicao_gestao
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Posição gestão corrigida para: {nova_posicao_gestao}")
            except ValueError:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: AVISO: Carta selecionada não está na lista de gestão")
                print(f"DEBUG: [SETA_COMPLETION] Lista gestão: {[os.path.basename(c) for c in self._cartas_gestao]}")
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Continuando com carta selecionada do carrossel")
        elif selected_carta and len(self._cartas_gestao) == 0:
            print(f"DEBUG: [SETA_COMPLETION] WARNING: Lista gestão vazia - usando carta selecionada do carrossel")
            carta_atual = selected_carta
        
        carta_basename = os.path.basename(carta_atual).lower()
        
        print(f"DEBUG: [SETA_COMPLETION] Carta final a processar: {carta_basename}")
        
        # CORREÇÃO: Verificar PRIMEIRO se é Challenge que atingiu tempo limite
        is_challenge_card = "challenge" in carta_basename
        
        if is_challenge_card:
            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Challenge detectado - verificando tempo limite")
            
            # Obter dados da carta
            dados_carta = self._obter_dados_carta(carta_atual)
            
            if dados_carta and 'n_turns' in dados_carta:
                n_turns = dados_carta['n_turns']
                
                # NOVA VERIFICAÇÃO: Usar a mesma lógica do end_turn() para verificar tempo limite
                if n_turns > 0:
                    print(f"DEBUG: [SETA_COMPLETION] Verificação de tempo limite:")
                    print(f"DEBUG: [SETA_COMPLETION]   Challenge: {os.path.basename(carta_atual)}")
                    print(f"DEBUG: [SETA_COMPLETION]   n_turns limite: {n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   Turno atual: {self._current_turn_number}")
                    
                    # CORREÇÃO CRÍTICA: Usar exatamente a mesma lógica que o end_turn() para verificar tempo limite
                    # Isso garante consistência entre a gestão e o final do turno
                    
                    # Calcular turnos decorridos usando a função oficial
                    turns_elapsed = self._get_turns_elapsed_for_challenge(carta_atual)
                    
                    print(f"DEBUG: [SETA_COMPLETION] ANÁLISE DETALHADA DO TEMPO LIMITE:")
                    print(f"DEBUG: [SETA_COMPLETION]   Challenge: {os.path.basename(carta_atual)}")
                    print(f"DEBUG: [SETA_COMPLETION]   n_turns limite: {n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   Turnos decorridos: {turns_elapsed}")
                    print(f"DEBUG: [SETA_COMPLETION]   Comparação: {turns_elapsed} >= {n_turns}?")
                    
                    # LÓGICA UNIFICADA: Usar exatamente a mesma condição do end_turn()
                    tempo_limite_atingido = (turns_elapsed >= n_turns) and (n_turns > 0)
                    
                    print(f"DEBUG: [SETA_COMPLETION]   RESULTADO: tempo_limite_atingido = {tempo_limite_atingido}")
                    print(f"DEBUG: [SETA_COMPLETION]   VALIDAÇÃO: turns_elapsed({turns_elapsed}) >= n_turns({n_turns}) = {turns_elapsed >= n_turns}")
                    print(f"DEBUG: [SETA_COMPLETION]   VALIDAÇÃO: n_turns({n_turns}) > 0 = {n_turns > 0}")
                    print(f"DEBUG: [SETA_COMPLETION]   RESULTADO FINAL: {tempo_limite_atingido}")
                    
                    if tempo_limite_atingido:
                        print(f"DEBUG: [SETA_COMPLETION] *** TEMPO LIMITE ATINGIDO! ***")
                        print(f"DEBUG: [SETA_COMPLETION] *** Challenge esteve ativo por {turns_elapsed} turnos (limite: {n_turns}) ***")
                        print(f"DEBUG: [SETA_COMPLETION] *** COMPLETION OBRIGATÓRIO NECESSÁRIO ***")
                    else:
                        print(f"DEBUG: [SETA_COMPLETION] Challenge ainda ativo: {turns_elapsed}/{n_turns} turnos")
                    
                    # CORREÇÃO CRÍTICA: Challenges que atingiram tempo limite DEVEM ser completados
                    # quando o jogador clicar no botão seta, independente do estado dos pacotes
                    if tempo_limite_atingido:
                        print(f"DEBUG: [SETA_COMPLETION] *** TEMPO LIMITE ATINGIDO! ***")
                        print(f"DEBUG: [SETA_COMPLETION] Challenge deve ser completado obrigatoriamente com valores atuais")
                        
                        # Obter valores atuais das barras para o completion
                        carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                        
                        if carta_index_carrossel is None:
                            for i, carta_carrossel in enumerate(self.cards):
                                if carta_carrossel == carta_atual:
                                    carta_index_carrossel = i
                                    break
                        
                        if carta_index_carrossel is not None:
                            stats = self.card_stats[carta_index_carrossel] if carta_index_carrossel < len(self.card_stats) else {"To send": 0, "Rxd": 0, "Lost": 0}
                            
                            print(f"DEBUG: [SETA_COMPLETION] COMPLETION OBRIGATÓRIO - Valores finais:")
                            print(f"DEBUG: [SETA_COMPLETION]   To send: {stats['To send']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Rxd: {stats['Rxd']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Lost: {stats['Lost']}")
                            print(f"DEBUG: [SETA_COMPLETION]   Motivo: Tempo limite atingido ({turns_elapsed}/{n_turns} turnos)")
                            
                            # Preservar valores antes de mostrar completion
                            self._preservar_valores_atuais_barras()
                            
                            # Mostrar overlay de completion por tempo limite
                            self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel, tempo_limite_obrigatorio=True)
                            return
                        else:
                            print(f"DEBUG: [SETA_COMPLETION] ERROR: Não foi possível encontrar carta no carrossel")
                            return
                
                # Se não atingiu tempo limite, verificar completion normal por pacotes
                message_size = dados_carta.get('message_size', 0)
                
                # Obter valores atuais das barras (posição atual do carrossel)
                current_to_send = 0
                current_rxd = 0
                
                try:
                    if hasattr(self, 'progress_labels'):
                        # CORREÇÃO: Usar formato correto para obter texto dos labels
                        if "To send" in self.progress_labels:
                            if hasattr(self.progress_labels["To send"], 'cget'):
                                # É um objeto Label
                                current_to_send = int(self.progress_labels["To send"].cget("text") or "0")
                            else:
                                # É um dicionário com chave 'text'
                                current_to_send = int(self.progress_labels["To send"].get("text", "0"))
                        
                        if "Rxd" in self.progress_labels:
                            if hasattr(self.progress_labels["Rxd"], 'cget'):
                                # É um objeto Label
                                current_rxd = int(self.progress_labels["Rxd"].cget("text") or "0")
                            else:
                                # É um dicionário com chave 'text'
                                current_rxd = int(self.progress_labels["Rxd"].get("text", "0"))
                except Exception as e:
                    print(f"DEBUG: [SETA_COMPLETION] ERROR: Erro ao obter valores das barras: {e}")
                    current_to_send = 0
                    current_rxd = 0
                
                # CONDIÇÕES DE COMPLETION PARA CHALLENGES:
                # REGRA: Challenge pode ser completado quando To send = 0 OU quando expira por tempo limite
                # (o tempo limite já foi verificado acima)
                
                # Para completion por pacotes: apenas To send = 0 é necessário
                pacotes_todos_enviados = (current_to_send == 0)
                
                # Challenge pode ser completado quando todos os pacotes foram enviados (To send = 0)
                challenge_pode_ser_completado = pacotes_todos_enviados
                
                print(f"DEBUG: [SETA_COMPLETION] Challenge dados completos:")
                print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                print(f"DEBUG: [SETA_COMPLETION]   Turno atual: {self._current_turn_number}")
                print(f"DEBUG: [SETA_COMPLETION]   Condição (todos enviados): {pacotes_todos_enviados}")
                print(f"DEBUG: [SETA_COMPLETION]   challenge_pode_ser_completado: {challenge_pode_ser_completado}")
                
                # DEBUG ESPECÍFICO: Se Challenge deveria estar expirado, fazer análise detalhada
                if tempo_limite_atingido:
                    print(f"DEBUG: [SETA_COMPLETION] ⚠️ CHALLENGE EXPIRADO DETECTADO!")
                    print(f"DEBUG: [SETA_COMPLETION] Fazendo análise completa do tracking...")
                    self._debug_challenge_tracking_state()
                
                if challenge_pode_ser_completado:
                    completion_tipo = "To send = 0"
                    print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Challenge pode ser completado - {completion_tipo}")
                    
                    # VALIDAÇÃO DUPLA: Confirmar que to_send é realmente 0
                    if current_to_send != 0:
                        print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO CRÍTICO: Validation failed!")
                        print(f"DEBUG: [SETA_COMPLETION] challenge_pode_ser_completado = {challenge_pode_ser_completado}")  
                        print(f"DEBUG: [SETA_COMPLETION] Mas current_to_send = {current_to_send} (deveria ser 0)")
                        print(f"DEBUG: [SETA_COMPLETION] CANCELANDO completion - condições inconsistentes")
                        # Continuar gestão normal em case de inconsistência
                        challenge_pode_ser_completado = False
                    
                    if challenge_pode_ser_completado:
                        # Preservar valores antes de mostrar completion
                        self._preservar_valores_atuais_barras()
                        
                        # CORREÇÃO: Usar o índice correto da carta no carrossel, não o índice na gestão
                        # O índice no carrossel é selected_carousel_index, não _carta_atual_gestao
                        carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                        
                        # CORREÇÃO ADICIONAL: Se não há selected_carousel_index, procurar a carta no carrossel
                        if carta_index_carrossel is None:
                            for i, carta_carrossel in enumerate(self.cards):
                                if carta_carrossel == carta_atual:
                                    carta_index_carrossel = i
                                    print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posição: {i}")
                                    break
                        
                        if carta_index_carrossel is None:
                            print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: Não foi possível encontrar carta no carrossel")
                            return
                        
                        print(f"DEBUG: [SETA_COMPLETION] Usando índice do carrossel: {carta_index_carrossel} (gestão: {self._carta_atual_gestao})")
                        
                        # Mostrar overlay de completion diretamente
                        self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                        
                        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Overlay de completion mostrado para Challenge")
                        return
                
                # Se chegou até aqui, Challenge não pode ser completado
                else:
                    print(f"DEBUG: [SETA_COMPLETION] Challenge não pode ser completado ainda - continuar gestão normal")
                    print(f"DEBUG: [SETA_COMPLETION]   Razão: To send deve ser 0, atual: {current_to_send}")
                    print(f"DEBUG: [SETA_COMPLETION]   Nota: Challenge só pode ser completado com To send = 0 ou tempo limite atingido")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: Dados da carta não encontrados")
        else:
            print(f"DEBUG: [SETA_COMPLETION] ERROR: Não é Challenge - verificando se é Activity...")
            
            # CORREÇÃO CRÍTICA: Adicionar verificação de completion para Activities
            is_activity_card = "activity" in carta_basename
            
            if is_activity_card:
                print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Activity detectado - verificando completion")
                
                # Obter dados da carta
                dados_carta = self._obter_dados_carta(carta_atual)
                
                if dados_carta:
                    message_size = dados_carta.get('message_size', 0)
                    drops_allowed = dados_carta.get('drops_allowed', True)
                    
                    # Obter valores atuais das barras (posição atual do carrossel)
                    current_to_send = 0
                    current_rxd = 0
                    
                    try:
                        if hasattr(self, 'progress_labels'):
                            # CORREÇÃO: Usar formato correto para obter texto dos labels
                            if "To send" in self.progress_labels:
                                if hasattr(self.progress_labels["To send"], 'cget'):
                                    # É um objeto Label
                                    current_to_send = int(self.progress_labels["To send"].cget("text") or "0")
                                else:
                                    # É um dicionário com chave 'text'
                                    current_to_send = int(self.progress_labels["To send"].get("text", "0"))
                            
                            if "Rxd" in self.progress_labels:
                                if hasattr(self.progress_labels["Rxd"], 'cget'):
                                    # É um objeto Label
                                    current_rxd = int(self.progress_labels["Rxd"].cget("text") or "0")
                                else:
                                    # É um dicionário com chave 'text'
                                    current_rxd = int(self.progress_labels["Rxd"].get("text", "0"))
                    except Exception as e:
                        print(f"DEBUG: [SETA_COMPLETION] ERROR: Erro ao obter valores das barras: {e}")
                        current_to_send = 0
                        current_rxd = 0
                    
                    print(f"DEBUG: [SETA_COMPLETION] Activity dados completos:")
                    print(f"DEBUG: [SETA_COMPLETION]   message_size: {message_size}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_to_send: {current_to_send}")
                    print(f"DEBUG: [SETA_COMPLETION]   current_rxd: {current_rxd}")
                    print(f"DEBUG: [SETA_COMPLETION]   drops_allowed: {drops_allowed}")
                    
                    # CONDIÇÕES DE COMPLETION PARA ACTIVITIES:
                    # REGRA SIMPLIFICADA: Activity só pode ser completada quando To send = 0
                    # Não importa o valor de Rxd ou drops_allowed
                    
                    pacotes_todos_enviados = (current_to_send == 0)
                    
                    # Activity é completada APENAS quando todos os pacotes foram enviados (To send = 0)
                    activity_completada = pacotes_todos_enviados
                    
                    print(f"DEBUG: [SETA_COMPLETION]   Condição (todos enviados): {pacotes_todos_enviados}")
                    print(f"DEBUG: [SETA_COMPLETION]   activity_completada: {activity_completada}")
                    
                    if activity_completada:
                        print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Activity pode ser completada - mostrar overlay")
                        
                        # VALIDAÇÃO DUPLA: Confirmar que to_send é realmente 0
                        if current_to_send != 0:
                            print(f"DEBUG: [SETA_COMPLETION] ❌ ERRO CRÍTICO: Activity validation failed!")
                            print(f"DEBUG: [SETA_COMPLETION] activity_completada = {activity_completada}")
                            print(f"DEBUG: [SETA_COMPLETION] Mas current_to_send = {current_to_send} (deveria ser 0)")
                            print(f"DEBUG: [SETA_COMPLETION] CANCELANDO completion - condições inconsistentes")
                            # Continuar gestão normal em case de inconsistência
                            activity_completada = False
                        
                        if activity_completada:
                            # Preservar valores antes de mostrar completion
                            self._preservar_valores_atuais_barras()
                            
                            # CORREÇÃO: Usar o índice correto da carta no carrossel, não o índice na gestão
                            carta_index_carrossel = getattr(self, 'selected_carousel_index', None)
                            
                            # CORREÇÃO ADICIONAL: Se não há selected_carousel_index, procurar a carta no carrossel
                            if carta_index_carrossel is None:
                                for i, carta_carrossel in enumerate(self.cards):
                                    if carta_carrossel == carta_atual:
                                        carta_index_carrossel = i
                                        print(f"DEBUG: [SETA_COMPLETION] Carta encontrada no carrossel posição: {i}")
                                        break
                            
                            if carta_index_carrossel is None:
                                print(f"DEBUG: [SETA_COMPLETION] ERROR: ERRO: Não foi possível encontrar carta no carrossel")
                                return
                            
                            print(f"DEBUG: [SETA_COMPLETION] Usando índice do carrossel: {carta_index_carrossel} (gestão: {self._carta_atual_gestao})")
                            
                            # Mostrar overlay de completion diretamente
                            self._mostrar_overlay_completion(carta_atual, dados_carta, is_sequential=False, carta_index=carta_index_carrossel)
                            
                            print(f"DEBUG: [SETA_COMPLETION] SUCCESS: Overlay de completion mostrado para Activity")
                            return
                    
                    # Se chegou até aqui, Activity não pode ser completada
                    else:
                        print(f"DEBUG: [SETA_COMPLETION] ERROR: Activity não pode ser completada ainda - continuar gestão normal")
                        print(f"DEBUG: [SETA_COMPLETION]   Razão: To send deve ser 0, atual: {current_to_send}")
                else:
                    print(f"DEBUG: [SETA_COMPLETION] ERROR: Dados da Activity não encontrados")
            else:
                print(f"DEBUG: [SETA_COMPLETION] ERROR: Não é nem Challenge nem Activity - continuar gestão normal")
        
        print(f"DEBUG: [SETA_COMPLETION] ERROR: Condições para completion não atendidas - continuar gestão normal")
        
        # FLUXO ORIGINAL: PRESERVAR VALORES DA CARTA ATUAL ANTES DE AVANÇAR
        
        # Encontrar posição real no carrossel
        posicao_carrossel_atual = None
        for i, card_path in enumerate(self.cards):
            if card_path == carta_atual:
                posicao_carrossel_atual = i
                break
        
        if posicao_carrossel_atual is not None:
            # Capturar valores atuais das barras visíveis
            try:
                if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                    to_send_atual = int(self.progress_labels.get("To send", tk.Label()).cget("text") or "0")
                    rxd_atual = int(self.progress_labels.get("Rxd", tk.Label()).cget("text") or "0")
                    lost_atual = int(self.progress_labels.get("Lost", tk.Label()).cget("text") or "0")
                    
                    # IMPORTANTE: Preservar na posição correta do carrossel
                    if hasattr(self, 'card_stats') and posicao_carrossel_atual < len(self.card_stats):
                        self.card_stats[posicao_carrossel_atual] = {
                            "To send": to_send_atual,
                            "Rxd": rxd_atual, 
                            "Lost": lost_atual
                        }
                        print(f"DEBUG: [GESTÃO_PACOTES] SUCCESS: VALORES PRESERVADOS antes de avançar:")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Posição carrossel: {posicao_carrossel_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   To send: {to_send_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Rxd: {rxd_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   Lost: {lost_atual}")
                        print(f"DEBUG: [GESTÃO_PACOTES]   card_stats[{posicao_carrossel_atual}] = {self.card_stats[posicao_carrossel_atual]}")
                    
            except Exception as e:
                print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Erro ao preservar valores: {e}")
        
        # CORREÇÃO 2: Salvar também no sistema antigo (compatibilidade)
        if hasattr(self, '_entry_rxd') and hasattr(self, '_entry_lost'):
            try:
                enviados = int(self._entry_rxd.get()) if hasattr(self._entry_rxd, 'get') else rxd_atual
                perdidos = int(self._entry_lost.get()) if hasattr(self._entry_lost, 'get') else lost_atual
                
                if not hasattr(self, '_valores_pacotes'):
                    self._valores_pacotes = {}
                    
                self._valores_pacotes[self._carta_atual_gestao] = {
                    'enviados': enviados,
                    'perdidos': perdidos
                }
                print(f"DEBUG: [GESTÃO_PACOTES] Valores salvos no sistema antigo - Enviados: {enviados}, Perdidos: {perdidos}")
            except (ValueError, AttributeError):
                print("DEBUG: [GESTÃO_PACOTES] Sistema antigo não disponível")
        
        # Remover controles atuais
        self._remover_controles_gestao()
        
        # CORREÇÃO 3: Avançar para próxima carta
        self._carta_atual_gestao += 1
        print(f"DEBUG: [GESTÃO_PACOTES] Nova carta atual (índice): {self._carta_atual_gestao}")
        
        # VERIFICAÇÃO CRÍTICA: Antes de continuar, verificar se ainda há cartas válidas
        cartas_validas_restantes = 0
        if hasattr(self, '_cartas_gestao') and self._cartas_gestao:
            for i, carta in enumerate(self._cartas_gestao):
                if (i >= self._carta_atual_gestao and carta and hasattr(self, 'cards') and 
                    carta in self.cards):
                    carta_basename = os.path.basename(carta).lower()
                    if not carta_basename.startswith("back_card_") and ("activity" in carta_basename or "challenge" in carta_basename):
                        cartas_validas_restantes += 1
        
        print(f"DEBUG: [GESTÃO_PACOTES] Cartas válidas restantes para processar: {cartas_validas_restantes}")
        print(f"DEBUG: [GESTÃO_PACOTES] Índice atual: {self._carta_atual_gestao}, Total cartas: {len(getattr(self, '_cartas_gestao', []))}")
        
        # Se não há mais cartas válidas, finalizar gestão automaticamente
        if cartas_validas_restantes == 0 or self._carta_atual_gestao >= len(getattr(self, '_cartas_gestao', [])):
            print("DEBUG: [GESTÃO_PACOTES] ERROR: Não há mais cartas válidas para processar")
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: FINALIZANDO GESTÃO DE PACOTES AUTOMATICAMENTE")
            
            # CORREÇÃO CRÍTICA: Finalizar gestão mas MANTER Final Phase ativo para End Turn
            # A gestão termina mas o jogador ainda está em Final Phase
            self._final_phase_gestao_ativa = False
            # NÃO limpar _final_phase_active - o jogador ainda está em Final Phase!
            # self._final_phase_active = False  # ERROR: REMOVIDO - Final Phase deve continuar ativo
            
            # CORREÇÃO: Ativar End Turn quando gestão termina automaticamente
            self._show_end_turn_button = True
            
            if hasattr(self, '_cartas_gestao'):
                self._cartas_gestao = []
            if hasattr(self, '_carta_atual_gestao'):
                self._carta_atual_gestao = 0
            
            # Remover controles silenciosamente
            self._remover_controles_gestao_silencioso()
            
            # CORREÇÃO CRÍTICA: Reconstruir dashboard MANTENDO Final Phase ativo
            print("DEBUG: [GESTÃO_PACOTES] Voltando ao dashboard com Final Phase ativo e End Turn enabled...")
            print(f"DEBUG: [GESTÃO_PACOTES] Estado final: _final_phase_active={self._final_phase_active}, _show_end_turn_button={self._show_end_turn_button}")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # CORREÇÃO CRÍTICA: Ativar o botão End Turn APÓS reconstruir a interface
            self.after(100, self._ativar_botao_end_turn)
            
            # CORREÇÃO NOVA: Forçar atualização dos destaques para garantir que carta restante fique destacada
            self.after(200, lambda: self._update_carousel_selection_highlights())
            return
        
        # CORREÇÃO 4: Mostrar gestão da próxima carta ou finalizar
        self._mostrar_gestao_carta_atual()
        
        print(f"DEBUG: [GESTÃO_PACOTES] ===== AVANÇO CONCLUÍDO =====")
    
    def _remover_controles_gestao_silencioso(self):
        """Remove controles de gestão SEM criar automaticamente o botão seta"""
        print("DEBUG: [GESTÃO_PACOTES] Removendo controles de gestão silenciosamente...")
        
        # Remover frame de controles (versão antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover botões + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # Remover botão seta se existir
        if hasattr(self, '_btn_seta') and self._btn_seta:
            self._btn_seta.destroy()
            self._btn_seta = None
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GESTÃO_PACOTES] Controles removidos silenciosamente")

    def _remover_controles_gestao(self):
        """Remove controles de gestão atuais"""
        print("DEBUG: [GESTÃO_PACOTES] Removendo controles de gestão...")
        
        # Verificar se há botões + para remover
        tinha_botoes_plus = False
        if ((hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd) or 
            (hasattr(self, '_btn_plus_lost') and self._btn_plus_lost)):
            tinha_botoes_plus = True
        
        # Remover frame de controles (versão antiga)
        if hasattr(self, '_frame_controles') and self._frame_controles:
            self._frame_controles.destroy()
            self._frame_controles = None
        
        # Remover botões + individuais
        if hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd:
            self._btn_plus_rxd.destroy()
            self._btn_plus_rxd = None
            
        if hasattr(self, '_btn_plus_lost') and self._btn_plus_lost:
            self._btn_plus_lost.destroy()
            self._btn_plus_lost = None
        
        # CORREÇÃO: Mostrar botão seta APÓS remover os botões +
        if tinha_botoes_plus:
            print("DEBUG: [GESTÃO_PACOTES] Botões + foram removidos - agora mostrar botão seta")
            self._mostrar_botao_seta()
        
        # NÃO remover botão seta aqui, pois ele deve aparecer quando os botões + desaparecem
        # O botão seta será removido apenas quando a gestão de pacotes terminar completamente
        
        # Fechar overlay se estiver aberto
        if hasattr(self, '_overlay_entrada') and self._overlay_entrada:
            self._overlay_entrada.destroy()
            self._overlay_entrada = None
        
        print("DEBUG: [GESTÃO_PACOTES] Controles removidos")
    
    def _finalizar_gestao_pacotes(self):
        """Finaliza gestão de pacotes e ativa botão End Turn"""
        print("DEBUG: [GESTÃO_PACOTES] === FINALIZANDO GESTÃO DE PACOTES ===")
        
        # PROTEÇÃO CRÍTICA: Evitar múltiplas chamadas quando gestão já foi finalizada
        if not getattr(self, '_final_phase_gestao_ativa', False):
            print("DEBUG: [GESTÃO_PACOTES] WARNING: Gestão já foi finalizada - ignorando chamada duplicada")
            return
        
        # CORREÇÃO CRÍTICA: Desativar gestão de pacotes PRIMEIRO
        self._final_phase_gestao_ativa = False
        print("DEBUG: [GESTÃO_PACOTES] SUCCESS: _final_phase_gestao_ativa = False")
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles (incluindo botão seta)
        self._remover_controles_gestao()
        
        # CORREÇÃO: Remover botão seta quando gestão termina completamente
        if hasattr(self, '_btn_seta') and self._btn_seta:
            print("DEBUG: [GESTÃO_PACOTES] Removendo botão seta - gestão de pacotes finalizada")
            try:
                self._btn_seta.destroy()
                self._btn_seta = None
            except tk.TclError:
                self._btn_seta = None
        
        # CORREÇÃO CRÍTICA: Verificar completion ANTES de limpar variáveis de gestão
        self._aplicar_valores_finais()
        
        # CORREÇÃO: Limpar todas as variáveis de gestão
        if hasattr(self, '_cartas_gestao'):
            self._cartas_gestao = []
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: _cartas_gestao limpa")
        
        if hasattr(self, '_carta_atual_gestao'):
            self._carta_atual_gestao = 0
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: _carta_atual_gestao resetado")
        
        if hasattr(self, '_carta_destacada'):
            self._carta_destacada = None
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: _carta_destacada limpa")
        
        if hasattr(self, '_carta_destacada_posicao'):
            self._carta_destacada_posicao = None
            print("DEBUG: [GESTÃO_PACOTES] SUCCESS: _carta_destacada_posicao limpa")
        
        # CORREÇÃO CRÍTICA: Limpar seleção do carrossel para evitar destaques residuais
        self.selected_carousel_card = None
        self.selected_carousel_index = None
        print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Seleção do carrossel limpa")
        
        # CORREÇÃO CRÍTICA: Forçar limpeza completa de todos os destaques
        print("DEBUG: [GESTÃO_PACOTES] SUCCESS: Forçando limpeza completa de destaques")
        if hasattr(self, 'card_labels') and self.card_labels:
            for lbl in self.card_labels:
                try:
                    lbl.config(highlightthickness=0)
                except tk.TclError:
                    pass
        
        # Atualização em múltiplas etapas para garantir limpeza
        self.after(25, lambda: self._update_carousel_selection_highlights())
        self.after(50, lambda: self._update_carousel_selection_highlights())
        
        # CORREÇÃO: Ativar botão End Turn APENAS se não há overlays de completion pendentes
        self.after(75, self._ativar_botao_end_turn_se_apropriado)
        
        print("DEBUG: [GESTÃO_PACOTES] === GESTÃO FINALIZADA COM SUCESSO ===")
    
    def _aplicar_valores_finais(self):
        """
        CORREÇÃO: Verifica completion de TODAS as cartas ativas no carrossel
        Não depende de _cartas_gestao que pode estar vazia
        """
        print("DEBUG: [GESTÃO_PACOTES] === VERIFICAÇÃO FINAL DE COMPLETION DE TODAS AS CARTAS ===")
        
        cartas_completadas = []
        
        # CORREÇÃO CRÍTICA: Verificar todas as cartas ativas no carrossel, não apenas _cartas_gestao
        for carta_idx, carta_path in enumerate(self.cards):
            if carta_idx >= len(self.card_stats) or not carta_path:
                continue
            
            # Verificar se é uma carta ativa (não é back_card)
            carta_name = os.path.basename(carta_path)
            if "back_card" in carta_name.lower():
                continue
            
            # Verificar se tem barras de progresso válidas
            stats = self.card_stats[carta_idx]
            
            print(f"DEBUG: [COMPLETION_FINAL] Verificando carta {carta_idx}: {carta_name}")
            print(f"DEBUG: [COMPLETION_FINAL] Estado final da carta {carta_idx}:")
            print(f"DEBUG: [COMPLETION_FINAL]   To send: {stats['To send']}")
            print(f"DEBUG: [COMPLETION_FINAL]   Rxd total: {stats['Rxd']}")
            print(f"DEBUG: [COMPLETION_FINAL]   Lost total: {stats['Lost']}")
            
            # NOVA FUNCIONALIDADE: Verificar completion para cada carta
            dados_carta = self._obter_dados_carta(carta_path)
            if dados_carta:
                message_size = dados_carta.get('message_size', 0)
                drops_allowed = dados_carta.get('drops_allowed', True)
                
                # Determinar tipo da carta
                carta_basename = carta_name.lower()
                is_challenge = "challenge" in carta_basename
                is_activity = "activity" in carta_basename
                
                print(f"DEBUG: [COMPLETION_FINAL] Carta: {carta_name}")
                print(f"DEBUG: [COMPLETION_FINAL]   Tipo: {'Challenge' if is_challenge else 'Activity' if is_activity else 'Outro'}")
                print(f"DEBUG: [COMPLETION_FINAL]   Message size: {message_size}")
                print(f"DEBUG: [COMPLETION_FINAL]   Drops allowed: {drops_allowed}")
                
                # Aplicar regras de completion
                completion_achieved = False
                completion_reason = ""
                
                # Para Activities: só verificar se drops_allowed=False
                # Para Challenges: sempre verificar
                should_check_completion = is_challenge or (is_activity and not drops_allowed)
                
                if should_check_completion:
                    to_send = stats['To send']
                    rxd = stats['Rxd']
                    
                    print(f"DEBUG: [COMPLETION_FINAL] Verificando completion para {carta_name}:")
                    print(f"DEBUG: [COMPLETION_FINAL]   To send: {to_send}, Rxd: {rxd}, Message size: {message_size}")
                    
                    if is_challenge:
                        # Challenges: mais flexível - considera completado se To send = 0 OU Rxd >= message_size
                        completion_achieved = (to_send == 0) or (rxd >= message_size)
                        if to_send == 0:
                            completion_reason = "todos os pacotes foram enviados"
                        elif rxd >= message_size:
                            completion_reason = f"todos os pacotes foram recebidos ({rxd}/{message_size})"
                    else:
                        # Activities: mais restritivo - precisa To send = 0 E Rxd >= message_size
                        completion_achieved = (to_send == 0) and (rxd >= message_size)
                        if completion_achieved:
                            completion_reason = f"todos os pacotes foram enviados e recebidos ({rxd}/{message_size})"
                    
                    # Verificar se carta foi completada
                    if completion_achieved:
                        print(f"DEBUG: [COMPLETION_FINAL] *** {'Challenge' if is_challenge else 'Activity'} {carta_name} COMPLETADA! ***")
                        print(f"DEBUG: [COMPLETION_FINAL] Motivo: {completion_reason}")
                        cartas_completadas.append({
                            'path': carta_path,
                            'name': carta_name,
                            'type': 'Challenge' if is_challenge else 'Activity',
                            'reason': completion_reason,
                            'dados': dados_carta,
                            'index': carta_idx  # CORREÇÃO: Adicionar índice da carta
                        })
                    else:
                        print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} não completada:")
                        print(f"DEBUG: [COMPLETION_FINAL]   To send: {to_send}, Rxd: {rxd}, Message size: {message_size}")
                else:
                    print(f"DEBUG: [COMPLETION_FINAL] Carta {carta_name} não verifica completion (Activity com drops_allowed=True)")
        
        # NOVA FUNCIONALIDADE: Mostrar overlays para TODAS as cartas completadas
        if cartas_completadas:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: {len(cartas_completadas)} CARTAS COMPLETADAS ===")
            for carta_info in cartas_completadas:
                print(f"DEBUG: [COMPLETION_FINAL] - {carta_info['type']}: {carta_info['name']} ({carta_info['reason']})")
            
            # Mostrar overlays sequencialmente (com delay entre elas)
            self._mostrar_overlays_completion_sequencial(cartas_completadas)
        else:
            print(f"DEBUG: [COMPLETION_FINAL] === RESULTADO: NENHUMA CARTA COMPLETADA ===")
    
    def _mostrar_overlays_completion_sequencial(self, cartas_completadas, index=0):
        """
        Mostra overlays de completion para múltiplas cartas de forma sequencial
        """
        if index >= len(cartas_completadas):
            print("DEBUG: [COMPLETION_FINAL] SUCCESS: Todos os overlays de completion foram mostrados")
            return
        
        carta_info = cartas_completadas[index]
        print(f"DEBUG: [COMPLETION_FINAL] Mostrando overlay {index+1}/{len(cartas_completadas)} para {carta_info['name']}")
        
        # Armazenar informações para o próximo overlay
        self._next_completion_overlays = cartas_completadas
        self._current_completion_index = index
        
        # Mostrar overlay atual (será fechado automaticamente ou pelo usuário)
        self._mostrar_overlay_completion(carta_info['path'], carta_info['dados'], is_sequential=True, carta_index=carta_info.get('index'))
    
    def _mostrar_overlay_quit_challenge(self, carta_path):
        """
        Mostra overlay de confirmação para quit challenge
        """
        print(f"DEBUG: [QUIT_CHALLENGE] Criando overlay de confirmação para: {os.path.basename(carta_path)}")
        
        # Obter dados da carta para challenge_quit_fee
        dados_carta = self._obter_dados_carta(carta_path)
        challenge_quit_fee = dados_carta.get('challenge_quit_fee', 0)
        
        print(f"DEBUG: [QUIT_CHALLENGE] Challenge quit fee: {challenge_quit_fee}")
        
        # Criar overlay
        if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
            self._overlay_quit_challenge.destroy()
        
        self._overlay_quit_challenge = tk.Toplevel(self)
        self._overlay_quit_challenge.title("")
        self._overlay_quit_challenge.configure(bg="black")
        self._overlay_quit_challenge.overrideredirect(True)
        self._overlay_quit_challenge.attributes("-topmost", True)
        
        # Centralizar na tela com altura reduzida
        overlay_width, overlay_height = 400, 220  # Reduzido de 300 para 220
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_quit_challenge.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com padding reduzido
        main_frame = tk.Frame(self._overlay_quit_challenge, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=5)  # Reduzido pady de 10 para 5
        
        # Título "Are you sure you want to quit?" em roxo (centralizado) com padding reduzido
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to quit?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",
            bg="black"
        )
        title_lbl.pack(pady=(15, 15))  # Reduzido de (20, 20) para (15, 15)
        
        # Frame para "You'll lost" + valor + moeda com padding reduzido
        lost_frame = tk.Frame(main_frame, bg="black")
        lost_frame.pack(pady=(5, 15))  # Reduzido de (10, 20) para (5, 15)
        
        # Texto "You'll lost " em branco
        lost_text_lbl = tk.Label(
            lost_frame,
            text="You'll lost ",
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        lost_text_lbl.pack(side="left")
        
        # Valor da taxa em branco
        fee_value_lbl = tk.Label(
            lost_frame,
            text=str(challenge_quit_fee),
            font=("Helvetica", 14, "bold"),
            fg="white",
            bg="black"
        )
        fee_value_lbl.pack(side="left", padx=(0, 5))
        
        # Símbolo da piccoin
        try:
            coin_img_path = os.path.join(IMG_DIR, "picoin.png")
            if os.path.exists(coin_img_path):
                coin_pil = Image.open(coin_img_path)
                coin_pil = coin_pil.resize((20, 20), Image.Resampling.LANCZOS)
                coin_img = ImageTk.PhotoImage(coin_pil)
                
                coin_lbl = tk.Label(
                    lost_frame,
                    image=coin_img,
                    bg="black"
                )
                coin_lbl.image = coin_img  # manter referência
                coin_lbl.pack(side="left")
            else:
                # Fallback se imagem não existir
                coin_lbl = tk.Label(
                    lost_frame,
                    text="🪙",
                    font=("Helvetica", 14),
                    fg="gold",
                    bg="black"
                )
                coin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: [QUIT_CHALLENGE] Erro ao carregar imagem da moeda: {e}")
            # Fallback emoji
            coin_lbl = tk.Label(
                lost_frame,
                text="🪙",
                font=("Helvetica", 14),
                fg="gold",
                bg="black"
            )
            coin_lbl.pack(side="left")
        
        # Frame para botões com padding reduzido
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(15, 5))  # Reduzido de (20, 10) para (15, 5)
        
        # Função para fechar overlay sem quit
        def fechar_sem_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador cancelou quit challenge")
            if hasattr(self, '_overlay_quit_challenge') and self._overlay_quit_challenge:
                self._overlay_quit_challenge.destroy()
                self._overlay_quit_challenge = None
        
        # Função para confirmar quit
        def confirmar_quit():
            print(f"DEBUG: [QUIT_CHALLENGE] Jogador confirmou quit challenge")
            
            # Verificar se jogador tem saldo suficiente
            if self.saldo < challenge_quit_fee:
                print(f"DEBUG: [QUIT_CHALLENGE] ERROR: Saldo insuficiente: {self.saldo} < {challenge_quit_fee}")
                # Talvez mostrar mensagem de erro aqui
                fechar_sem_quit()
                return
            
            # Decrementar saldo
            self.saldo -= challenge_quit_fee
            print(f"DEBUG: [QUIT_CHALLENGE] Saldo decrementado: -{challenge_quit_fee}, novo saldo: {self.saldo}")
            self._atualizar_display_saldo()
            
            # CORREÇÃO: Remover carta do inventário do jogador ANTES de devolver ao baralho
            if 'challenges' in self.inventario and carta_path in self.inventario['challenges']:
                self.inventario['challenges'].remove(carta_path)
                print(f"DEBUG: [QUIT_CHALLENGE] SUCCESS: Carta {os.path.basename(carta_path)} removida do inventário challenges do jogador")
            else:
                print(f"DEBUG: [QUIT_CHALLENGE] WARNING: Carta {os.path.basename(carta_path)} não encontrada no inventário challenges do jogador")
            
            # Remover carta do carrossel
            self._remover_carta_do_carrossel(carta_path)
            
            # Devolver carta para baralho da Store (challenges)
            self._devolver_challenge_para_baralho(carta_path)
            
            # Fechar overlay
            fechar_sem_quit()
            
            # Voltar para interface principal
            print(f"DEBUG: [QUIT_CHALLENGE] Voltando para interface principal após quit")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Botão "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_quit
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Botão "Yes" verde (lado direito)
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",
            fg="white",
            width=8,
            height=1,
            command=confirmar_quit
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [QUIT_CHALLENGE] Overlay de quit challenge criado")
    
    def _mostrar_overlay_confirmacao_troca(self, carta_path, tipos, page=0):
        """
        Mostra overlay de confirmação para troca de carta com warning sobre perda de progresso
        """
        print(f"DEBUG: [SWITCH_CONFIRM] Criando overlay de confirmação de troca para: {os.path.basename(carta_path)}")
        
        # Criar overlay
        if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
            self._overlay_switch_confirm.destroy()
        
        self._overlay_switch_confirm = tk.Toplevel(self)
        self._overlay_switch_confirm.title("")
        self._overlay_switch_confirm.configure(bg="black")
        self._overlay_switch_confirm.overrideredirect(True)
        self._overlay_switch_confirm.attributes("-topmost", True)
        
        # Centralizar na tela 
        overlay_width, overlay_height = 400, 200
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - overlay_width) // 2
        y = (screen_height - overlay_height) // 2
        self._overlay_switch_confirm.geometry(f"{overlay_width}x{overlay_height}+{x}+{y}")
        
        # Frame principal com borda
        main_frame = tk.Frame(self._overlay_switch_confirm, bg="black", bd=2, relief="solid")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Título "Are you sure you want to switch?" em roxo (centralizado)
        title_lbl = tk.Label(
            main_frame,
            text="Are you sure you want to switch?",
            font=("Helvetica", 16, "bold"),
            fg="#8000FF",  # Roxo
            bg="black"
        )
        title_lbl.pack(pady=(20, 10))
        
        # Subtítulo "All progress will be lost" em branco
        subtitle_lbl = tk.Label(
            main_frame,
            text="All progress will be lost",
            font=("Helvetica", 12),
            fg="white",
            bg="black"
        )
        subtitle_lbl.pack(pady=(0, 20))
        
        # Frame para botões
        buttons_frame = tk.Frame(main_frame, bg="black")
        buttons_frame.pack(pady=(10, 0))
        
        # Função para fechar overlay sem confirmar troca
        def fechar_sem_trocar():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador cancelou a troca")
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
        
        # Função para confirmar troca (executar troca e voltar ao dashboard)
        def confirmar_troca():
            print(f"DEBUG: [SWITCH_CONFIRM] Jogador confirmou a troca")
            
            # Fechar overlay
            if hasattr(self, '_overlay_switch_confirm') and self._overlay_switch_confirm:
                self._overlay_switch_confirm.destroy()
                self._overlay_switch_confirm = None
            
            # CORREÇÃO CRÍTICA: Executar a troca diretamente
            print(f"DEBUG: [SWITCH_CONFIRM] Executando troca da carta: {os.path.basename(carta_path)}")
            
            # Chama diretamente aceitar_carta_carrossel que faz a troca completa
            self.aceitar_carta_carrossel(carta_path, tipos, page)
        
        # Botão "No" vermelho (lado esquerdo)
        no_btn = tk.Button(
            buttons_frame,
            text="No",
            font=("Helvetica", 12, "bold"),
            bg="#DC143C",  # Vermelho
            fg="white",
            width=8,
            height=1,
            command=fechar_sem_trocar
        )
        no_btn.pack(side="left", padx=(0, 20))
        
        # Botão "Yes" verde (lado direito)  
        yes_btn = tk.Button(
            buttons_frame,
            text="Yes",
            font=("Helvetica", 12, "bold"),
            bg="#228B22",  # Verde
            fg="white",
            width=8,
            height=1,
            command=confirmar_troca
        )
        yes_btn.pack(side="right", padx=(20, 0))
        
        print(f"DEBUG: [SWITCH_CONFIRM] Overlay de confirmação de troca criado")
    
    def _ativar_botao_end_turn_se_apropriado(self):
        """
        Ativa o botão End Turn apenas se não há overlays de completion pendentes.
        """
        print("DEBUG: [END_TURN] === VERIFICANDO SE É APROPRIADO ATIVAR END TURN ===")
        
        # Verificar se há overlays de completion ativos
        overlay_completion_ativo = False
        
        # Verificar se há atributos que indicam overlay ativo
        if hasattr(self, '_completion_overlay_active') and self._completion_overlay_active:
            overlay_completion_ativo = True
            print("DEBUG: [END_TURN] Overlay de completion detectado via flag _completion_overlay_active")
        
        # Verificar se há widgets de overlay na interface
        for widget in self.winfo_children():
            widget_name = str(widget).lower()
            if 'overlay' in widget_name or 'completion' in widget_name:
                overlay_completion_ativo = True
                print(f"DEBUG: [END_TURN] Overlay de completion detectado via widget: {widget}")
                break
        
        if overlay_completion_ativo:
            print("DEBUG: [END_TURN] WARNING: Overlay de completion ativo - adiando ativação do End Turn")
            # Tentar novamente em 500ms
            self.after(500, self._ativar_botao_end_turn_se_apropriado)
            return
        
        print("DEBUG: [END_TURN] SUCCESS: Nenhum overlay de completion ativo - procedendo com ativação")
        self._ativar_botao_end_turn()

    def _ativar_botao_end_turn(self):
        """Ativa o botão End Turn e muda sua aparência"""
        print("DEBUG: [END_TURN] === TENTANDO ATIVAR BOTÃO END TURN ===")
        try:
            # CORREÇÃO: Procurar por botão End Turn em toda a interface se necessário
            end_turn_button = None
            
            # 1. Verificar se temos referência válida
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                if hasattr(self.end_turn_btn, 'winfo_exists') and self.end_turn_btn.winfo_exists():
                    end_turn_button = self.end_turn_btn
                    print("DEBUG: [END_TURN] SUCCESS: Botão encontrado via referência self.end_turn_btn")
                else:
                    print("DEBUG: [END_TURN] ERROR: Referência self.end_turn_btn inválida")
                    self.end_turn_btn = None
            
            # 2. Se não encontrou, procurar em toda a interface
            if not end_turn_button:
                print("DEBUG: [END_TURN] Procurando botão End Turn em toda a interface...")
                end_turn_button = self._procurar_botao_end_turn_na_interface()
                if end_turn_button:
                    self.end_turn_btn = end_turn_button
                    print("DEBUG: [END_TURN] SUCCESS: Botão End Turn encontrado na interface")
            
            # 3. Se encontrou o botão, ativar
            if end_turn_button:
                end_turn_button.config(
                    state="normal",
                    bg="#808080",
                    fg="black"
                )
                print("DEBUG: [END_TURN] SUCCESS: Botão End Turn ATIVADO com sucesso")
            else:
                print("DEBUG: [END_TURN] ERROR: Botão End Turn não encontrado")
                # CORREÇÃO: Tentar recriar o botão se não existir
                self._tentar_recriar_end_turn_button()
                
        except tk.TclError as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro TclError ao ativar End Turn: {e}")
            # Limpar referência inválida e tentar recriar
            self.end_turn_btn = None
            self._tentar_recriar_end_turn_button()
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro inesperado ao ativar End Turn: {e}")
    
    def _procurar_botao_end_turn_na_interface(self):
        """Procura o botão End Turn em toda a interface atual"""
        try:
            # Procurar em todos os widgets filhos
            for widget in self.winfo_children():
                if hasattr(widget, 'winfo_children'):
                    for sub_widget in widget.winfo_children():
                        # Verificar se é um botão com texto "End Turn"
                        if (hasattr(sub_widget, 'cget') and 
                            hasattr(sub_widget, 'config') and
                            hasattr(sub_widget, 'state')):
                            try:
                                text = sub_widget.cget('text')
                                if text and 'End Turn' in str(text):
                                    print(f"DEBUG: [END_TURN] SUCCESS: Botão End Turn encontrado: {text}")
                                    return sub_widget
                            except:
                                continue
            
            print("DEBUG: [END_TURN] ERROR: Botão End Turn não encontrado na interface")
            return None
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao procurar botão: {e}")
            return None
    
    def _tentar_recriar_end_turn_button(self):
        """Tenta recriar o botão End Turn se não existir"""
        try:
            print("DEBUG: [END_TURN] Tentando recriar botão End Turn...")
            # Verificar se há um container válido para o botão
            if hasattr(self, 'winfo_children') and self.winfo_children():
                # CORREÇÃO: Usar método seguro para criar End Turn
                print("DEBUG: [END_TURN] SUCCESS: Container válido encontrado - tentando recriar...")
                self.after(100, lambda: self._criar_botao_end_turn_seguro())
            else:
                print("DEBUG: [END_TURN] ERROR: Não há container válido para recriar End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao tentar recriar End Turn: {e}")
    
    def _criar_botao_end_turn_seguro(self):
        """Cria botão End Turn de forma segura"""
        try:
            if not hasattr(self, 'end_turn_btn') or not self.end_turn_btn:
                # Verificar se já existe na interface atual
                existing_button = self._procurar_botao_end_turn_na_interface()
                if existing_button:
                    self.end_turn_btn = existing_button
                    print("DEBUG: [END_TURN] SUCCESS: Botão End Turn existente encontrado e vinculado")
                    
                    # Ativar imediatamente
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] SUCCESS: Botão End Turn ativado")
                    return
                
                # Se não existe, tentar criar novo
                print("DEBUG: [END_TURN] Tentando criar novo botão End Turn...")
                self._criar_botao_end_turn()
                
                # Se criado com sucesso, ativar imediatamente
                if hasattr(self, 'end_turn_btn') and self.end_turn_btn:
                    self.end_turn_btn.config(
                        state="normal",
                        bg="#808080", 
                        fg="black"
                    )
                    print("DEBUG: [END_TURN] SUCCESS: Botão End Turn recriado e ativado")
                else:
                    print("DEBUG: [END_TURN] ERROR: Falha ao criar novo botão End Turn")
        except Exception as e:
            print(f"DEBUG: [END_TURN] ERROR: Erro ao criar End Turn seguro: {e}")
    
    def _manter_end_turn_disabled(self):
        """Mantém o botão End Turn disabled enquanto há cartas para processar"""
        try:
            if hasattr(self, 'end_turn_btn') and self.end_turn_btn and self.end_turn_btn.winfo_exists():
                self.end_turn_btn.config(
                    state="disabled",
                    bg="#666666",  # Cor mais escura para indicar disabled
                    fg="#999999"   # Texto mais claro para indicar disabled
                )
                print(f"DEBUG: [GESTÃO_PACOTES] Botão End Turn mantido DISABLED - carta {self._carta_atual_gestao + 1}/{len(self._cartas_gestao)} em processamento")
            else:
                print("DEBUG: [GESTÃO_PACOTES] ERROR: Botão End Turn não encontrado para manter disabled")
        except tk.TclError as e:
            print(f"DEBUG: [GESTÃO_PACOTES] ERROR: Erro ao manter End Turn disabled: {e}")
            # Limpar referência inválida
            self.end_turn_btn = None
    
    def _limpar_gestao_pacotes(self):
        """Limpa todas as variáveis e widgets do sistema de gestão de pacotes"""
        print("DEBUG: [GESTÃO_PACOTES] Limpando sistema de gestão de pacotes")
        
        # Desbloquear interações do carrossel
        self._desbloquear_interacoes_carrossel()
        
        # Remover destaque roxo
        self._remover_destaque_roxo()
        
        # Remover controles
        self._remover_controles_gestao()
        
        # Limpar variáveis
        if hasattr(self, '_cartas_gestao'):
            delattr(self, '_cartas_gestao')
        
        if hasattr(self, '_carta_atual_gestao'):
            delattr(self, '_carta_atual_gestao')
        
        if hasattr(self, '_valores_pacotes'):
            delattr(self, '_valores_pacotes')
        
        print("DEBUG: [GESTÃO_PACOTES] Sistema de gestão de pacotes limpo")

    def end_turn(self):
        # CORREÇÃO CRÍTICA: Preservar estatísticas das cartas antes de terminar turno
        print("DEBUG: End Turn clicado - preservando estatísticas das cartas")
        
        # SUPER BACKUP SYSTEM: Garantir backup completo de todos os trackings críticos
        root = self.master
        
        # 1. Backup das estatísticas das cartas
        if hasattr(self, 'card_stats') and hasattr(self, 'cards'):
            root._backup_card_stats = []
            root._backup_cards = []
            
            for i, stats in enumerate(self.card_stats):
                # Criar cópia profunda das estatísticas
                backup_stats = {
                    'To send': stats['To send'],
                    'Rxd': stats['Rxd'], 
                    'Lost': stats['Lost']
                }
                root._backup_card_stats.append(backup_stats)
                print(f"DEBUG: [END_TURN] Carta {i} estatísticas salvas: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
            
            # Salvar também os caminhos das cartas
            for i, card_path in enumerate(self.cards):
                root._backup_cards.append(card_path)
                print(f"DEBUG: [END_TURN] Carta {i} path salvo: {os.path.basename(card_path) if card_path else 'None'}")
        
        # CORREÇÃO CRÍTICA: Preservar mapeamento de Activities com valores preservados
        if hasattr(self, '_activity_preserved_stats'):
            root = self.master
            root._activity_preserved_stats = self._activity_preserved_stats.copy()
            print(f"DEBUG: [END_TURN] Mapeamento de Activities preservadas salvo: {len(self._activity_preserved_stats)} entries")
            for activity_path, stats in self._activity_preserved_stats.items():
                print(f"DEBUG: [END_TURN] Activity {os.path.basename(activity_path)}: To send={stats['To send']}, Rxd={stats['Rxd']}, Lost={stats['Lost']}")
        
        # CORREÇÃO CRÍTICA: Incrementar primeiro, depois salvar os contadores corretos
        print(f"DEBUG: [END_TURN] ======= INCREMENTANDO CONTADORES DE TURNO =======")
        print(f"DEBUG: [END_TURN] Contadores ANTES do incremento:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # CORREÇÃO CRÍTICA: NÃO incrementar contadores aqui - isso só deve acontecer no próximo dice roll
        # Os contadores permanecem no turno atual até o jogador lançar o dado para o próximo turno
        print(f"DEBUG: [END_TURN] Contadores PERMANECEM NO TURNO ATUAL (não incrementados):")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        print(f"DEBUG: [END_TURN] IMPORTANTE: Incremento só acontece no próximo dice roll!")
        
        # CRÍTICO: SALVAR OS CONTADORES JÁ INCREMENTADOS para preservação
        root = self.master
        # CORREÇÃO CRÍTICA: Salvar valores INCREMENTADOS em vez dos atuais
        next_turn_number = self._current_turn_number + 1
        next_turn = self._current_turn + 1
        next_turn_id = self._current_turn_id + 1
        
        root._backup_turn_counters = {
            '_current_turn_number': next_turn_number,
            '_current_turn': next_turn,
            '_current_turn_id': next_turn_id,
            '_challenge_start_turns': self._challenge_start_turns.copy(),  # CORREÇÃO CRÍTICA: Adicionar tracking
            '_service_real_activation_turns': getattr(self, '_service_real_activation_turns', {}).copy(),  # CORREÇÃO CRÍTICA: Preservar turnos reais de Services
            '_event_duration_tracking': getattr(self, '_event_duration_tracking', {}).copy(),  # CORREÇÃO CRÍTICA: Salvar tracking de Events
            '_event_start_turns': getattr(self, '_event_start_turns', {}).copy(),  # CORREÇÃO CRÍTICA: Salvar start turns de Events
            '_service_data_volume_tracking': getattr(self, '_service_data_volume_tracking', {}).copy(),  # CORREÇÃO CRÍTICA: Preservar tracking Data Volume
            '_pending_data_volume_expiry_overlays': getattr(self, '_pending_data_volume_expiry_overlays', []).copy()  # CORREÇÃO CRÍTICA: Preservar overlays pendentes
        }
        
        print(f"DEBUG: [END_TURN] Valores INCREMENTADOS a serem salvos:")
        print(f"DEBUG: [END_TURN]   Atual -> Próximo turno:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number} -> {next_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn} -> {next_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id} -> {next_turn_id}")
        
        # SUPER BACKUP SYSTEM: Backup completo de todos os trackings críticos
        root._backup_challenge_tracking = self._challenge_start_turns.copy()
        
        # 2. Backup robusto de Services tracking (consolidação múltipla)
        if hasattr(self, '_service_real_activation_turns'):
            root._backup_service_tracking_end_turn = self._service_real_activation_turns.copy()
        else:
            root._backup_service_tracking_end_turn = {}
        
        # Consolidar de múltiplas fontes para máxima preservação
        consolidated_services = getattr(root, '_backup_service_tracking', {}).copy()
        consolidated_services.update(getattr(root, '_service_tracking_backup_imediato', {}))
        consolidated_services.update(root._backup_service_tracking_end_turn)
        root._backup_service_tracking_super = consolidated_services
        
        # 3. Backup robusto de Events tracking (consolidação múltipla)
        if hasattr(self, '_event_duration_tracking'):
            root._backup_event_tracking_end_turn = self._event_duration_tracking.copy()
        else:
            root._backup_event_tracking_end_turn = {}
            
        if hasattr(self, '_event_start_turns'):
            root._backup_event_start_turns_end_turn = self._event_start_turns.copy()
        else:
            root._backup_event_start_turns_end_turn = {}
        
        # Consolidar de múltiplas fontes para máxima preservação
        consolidated_events = getattr(root, '_backup_event_tracking', {}).copy()
        consolidated_events.update(getattr(root, '_event_tracking_backup_imediato', {}))
        consolidated_events.update(root._backup_event_tracking_end_turn)
        root._backup_event_tracking_super = consolidated_events
        
        consolidated_event_starts = getattr(root, '_backup_event_start_turns', {}).copy()
        consolidated_event_starts.update(root._backup_event_start_turns_end_turn)
        root._backup_event_start_turns_super = consolidated_event_starts
        
        # 4. Backup robusto de Data Volume tracking (consolidação múltipla)
        if hasattr(self, '_service_data_volume_tracking'):
            root._backup_data_volume_tracking_end_turn = self._service_data_volume_tracking.copy()
        else:
            root._backup_data_volume_tracking_end_turn = {}
            
        if hasattr(self, '_pending_data_volume_expiry_overlays'):
            root._backup_data_volume_overlays_end_turn = self._pending_data_volume_expiry_overlays.copy()
        else:
            root._backup_data_volume_overlays_end_turn = []
        
        # Consolidar de múltiplas fontes para máxima preservação
        consolidated_data_volume = getattr(root, '_backup_data_volume_tracking', {}).copy()
        consolidated_data_volume.update(getattr(root, '_data_volume_tracking_backup_imediato', {}))
        consolidated_data_volume.update(root._backup_data_volume_tracking_end_turn)
        root._backup_data_volume_tracking_super = consolidated_data_volume
        
        consolidated_data_volume_overlays = getattr(root, '_backup_data_volume_overlays', []).copy()
        consolidated_data_volume_overlays.extend(root._backup_data_volume_overlays_end_turn)
        root._backup_data_volume_overlays_super = consolidated_data_volume_overlays
        
        print(f"DEBUG: [END_TURN] ======= CONTADORES PRESERVADOS =======")
        print(f"DEBUG: [END_TURN] Root object: {root}")
        print(f"DEBUG: [END_TURN] Backup salvo (INCREMENTADOS): {root._backup_turn_counters}")
        print(f"DEBUG: [END_TURN] Challenge tracking salvo: {root._backup_challenge_tracking}")
        print(f"DEBUG: [END_TURN] Services super backup: {len(root._backup_service_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Events super backup: {len(root._backup_event_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Data Volume super backup: {len(root._backup_data_volume_tracking_super)} entries")
        print(f"DEBUG: [END_TURN] Data Volume overlays backup: {len(root._backup_data_volume_overlays_super)} entries")
        print(f"DEBUG: [END_TURN] SUCCESS: PRÓXIMO DICE ROLL RESTAURARÁ OS VALORES INCREMENTADOS!")
        print(f"DEBUG: [END_TURN] ======= FIM PRESERVAÇÃO CONTADORES =======")
        
        # CORREÇÃO CRÍTICA: Verificação de Challenges tempo limite removida do end_turn
        # Agora acontece no próximo dice roll quando os contadores são realmente incrementados
        print("DEBUG: [END_TURN] Verificação de Challenges tempo limite adiada para próximo dice roll")
        
        # NOVO: Verificar serviços TEMPORARY que expiraram
        self._verificar_services_expirados()
        
        # NOVO: Verificar events que expiraram
        self._verificar_events_expirados()
        
        # NOVA CORREÇÃO: Resetar flag Final Phase clicked para o próximo turno
        self._final_phase_clicked_this_turn = False
        self._final_phase_turn_id = None
        print("DEBUG: [END_TURN] Flags Final Phase resetadas para próximo turno - gestão não será restaurada automaticamente")
        
        # CORREÇÃO CRÍTICA: Limpar completamente estado Challenge no final do turno
        # Isto garante que cartas Challenge não persistem para o próximo turno
        print("DEBUG: End Turn clicado - limpando estado Challenge antes de terminar turno")
        
        # Limpar variáveis Challenge do PlayerDashboard
        if hasattr(self, '_store_challenge_carta_path'):
            self._store_challenge_carta_path = None
            print("DEBUG: _store_challenge_carta_path limpo no End Turn")
        
        if hasattr(self, '_store_challenge_carta_tipo'):
            self._store_challenge_carta_tipo = None
            print("DEBUG: _store_challenge_carta_tipo limpo no End Turn")
        
        # Limpar também flags de Challenge
        self._challenge_accepted = False
        print("DEBUG: _challenge_accepted resetado para False no End Turn")
        
        # CORREÇÃO: Reabilitar botão Store no final do turno
        # Isto permite que o jogador use casas Challenge novamente no próximo turno
        self.enable_store_button()
        print("DEBUG: Botão Store reabilitado no End Turn - permite novas interações Challenge")
        
        # Limpar estado Challenge na Store se existir
        if (hasattr(self, 'store_window') and self.store_window and 
            hasattr(self.store_window, 'winfo_exists') and 
            callable(getattr(self.store_window, 'winfo_exists', None))):
            try:
                store_exists = self.store_window.winfo_exists()
                if store_exists:
                    # Limpar todas as variáveis relacionadas com Challenge na Store
                    challenge_attrs = ['fullscreen_carta_path', 'fullscreen_carta_tipo', 
                                     '_backup_fullscreen_carta_path', '_backup_fullscreen_carta_tipo',
                                     '_original_carta_path', '_original_carta_tipo']
                    for attr in challenge_attrs:
                        if hasattr(self.store_window, attr):
                            setattr(self.store_window, attr, None)
                            print(f"DEBUG: Store {attr} limpo no End Turn")
            except Exception as e:
                print(f"DEBUG: Erro ao limpar Store no End Turn: {e}")
        
        print("DEBUG: Estado Challenge completamente limpo no End Turn")
        
        # LIMPEZA ADICIONAL: Limpar estados salvos para evitar restaurações incorretas no próximo turno
        if hasattr(self, '_saved_dashboard_state'):
            self._saved_dashboard_state = None
            print("DEBUG: [END_TURN] Estado salvo do dashboard limpo")
        if hasattr(self, '_estado_botoes_imediato'):
            self._estado_botoes_imediato = None
            print("DEBUG: [END_TURN] Estado imediato dos botões limpo")
        
        # PLACEHOLDER comentado para não bloquear a transição para próximo turno
        # Placeholder: lógica para terminar o turno e passar ao próximo jogador
        # Aqui pode-se implementar a lógica de alternância de jogador
        # import tkinter.messagebox
        # tkinter.messagebox.showinfo("End Turn", "Turno terminado! Próximo jogador...")
        # Exemplo: pode-se limpar a interface ou chamar uma função para o próximo jogador
        # CORREÇÃO CRÍTICA: Definir flag para indicar que vamos para o próximo turno
        # Detectar ambiente para debug específico
        universal_paths = get_universal_paths()
        ambiente = "RASPBERRY PI" if universal_paths['environment'] == 'raspberry_pi' else "DESENVOLVIMENTO"
        
        self._coming_from_end_turn = True
        print(f"DEBUG: [END_TURN] AMBIENTE: {ambiente}")
        print(f"DEBUG: [END_TURN] Flag _coming_from_end_turn definida - próximo dice roll irá incrementar contadores")
        print(f"DEBUG: [END_TURN] Estado atual dos contadores:")
        print(f"DEBUG: [END_TURN]   _current_turn_number: {self._current_turn_number}")
        print(f"DEBUG: [END_TURN]   _current_turn: {self._current_turn}")
        print(f"DEBUG: [END_TURN]   _current_turn_id: {self._current_turn_id}")
        
        # CORREÇÃO FINAL: Limpeza órfã no final do turno para garantir limpeza completa
        print("DEBUG: [END_TURN] === LIMPEZA ÓRFÃ FINAL ===")
        self._cleanup_orphaned_challenge_tracking()
        print("DEBUG: [END_TURN] === FIM LIMPEZA ÓRFÃ FINAL ===")
        
        print("DEBUG: [END_TURN] SUCCESS: Método end_turn() terminado com sucesso - retornando controle para _criar_botao_end_turn()")

    def _aplicar_router_upgrade(self, router_id):
        """
        Aplica o efeito ROUTER UPGRADE baseado no router_id.
        Verifica se existe Small Router ativo correspondente e abre inventário para upgrade.
        """
        print(f"DEBUG: [ROUTER_UPGRADE] Aplicando Router Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID é None - não aplicando upgrade")
            return
        
        # Mapeamento: Small Router -> Medium Router
        equipment_mapping = {
            1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
            2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
            3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_UPGRADE] Router ID {router_id} não suportado")
            return
        
        small_router, medium_router = equipment_mapping[router_id]
        
        # Verificar se existe o Small Router correspondente ATIVO (virado para cima)
        target_small_router = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == small_router:
                target_small_router = equipment_path
                break
        
        if target_small_router:
            print(f"DEBUG: [ROUTER_UPGRADE] Small Router {small_router} ativo encontrado - procedendo com inventário")
            print(f"DEBUG: [ROUTER_UPGRADE] Router ativo: {os.path.basename(target_small_router)}")
            
            # Verificar se o jogador já tem o Medium Router correspondente no inventário
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
            
            if medium_router_exists:
                print(f"DEBUG: [ROUTER_UPGRADE] ERROR: {medium_router} já existe no inventário - upgrade não aplicado")
                return
            
            # Definir contexto de ROUTER UPGRADE e router_id
            self._in_router_upgrade_context = True
            self._router_upgrade_target_id = router_id
            
            # Abrir inventário de equipamentos para seleção
            self._show_equipment_inventory_for_router_upgrade()
            print("DEBUG: [ROUTER_UPGRADE] SUCCESS: Inventário de equipamentos aberto para upgrade")
        else:
            print(f"DEBUG: [ROUTER_UPGRADE] Nenhum Small Router {small_router} ativo encontrado - não é possível fazer upgrade")
            print(f"DEBUG: [ROUTER_UPGRADE] ROUTER UPGRADE só funciona se houver {small_router} ativo (virado para cima)")
            print(f"DEBUG: [ROUTER_UPGRADE] Equipamentos ativos encontrados:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_UPGRADE]   - {os.path.basename(equipment_path)}")

    def _show_equipment_inventory_for_router_upgrade(self):
        """Cria página especializada para ROUTER UPGRADE com equipamentos Small Router filtrados"""
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] Criando página especializada ROUTER UPGRADE")
        
        # Definir contexto específico
        self._in_router_upgrade_context = True
        
        # Obter router_id da Action card ativa
        router_id = getattr(self, '_router_upgrade_target_id', None)
        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Router ID da Action: {router_id}")
        
        if router_id is None:
            print("DEBUG: [ROUTER_UPGRADE_INVENTORY] ERRO: Router ID não definido")
            return
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se necessário
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [ROUTER_UPGRADE_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] TopBar não encontrada, criando fallback")
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] ERRO ao criar TopBar: {e}")
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
        
        # Nome do jogador
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text="ROUTER UPGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Filtrar equipamentos Small Router com specific_id igual ao router_id
        equipamentos_filtrados = []
        all_equipments = self.inventario.get("equipments", [])
        
        for equipment_path in all_equipments:
            try:
                # Extrair número do equipamento do nome do arquivo (Equipment_X.png)
                filename = os.path.basename(equipment_path)
                if filename.startswith("Equipment_") and filename.endswith(".png"):
                    equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
                    
                    # Small Router são Equipment_1, Equipment_2, Equipment_3
                    if 1 <= equipment_num <= 3 and equipment_num == router_id:
                        equipamentos_filtrados.append(equipment_path)
                        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment filtrado: {filename} (router_id={router_id})")
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao processar equipamento {equipment_path}: {e}")
                continue
        
        print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Total equipamentos filtrados: {len(equipamentos_filtrados)}")
        
        # Layout baseado no número de equipamentos
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120
        total_equipments = len(equipamentos_filtrados)
        
        if total_equipments == 1:
            # Carta única - layout centralizado
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Carta única detectada - usando layout centralizado")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
        else:
            # Múltiplas cartas - grid 2xn
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Múltiplas cartas detectadas - usando grid 2xn")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)
        
        # Colocar equipamentos em layout apropriado
        for idx, equipment_path in enumerate(equipamentos_filtrados):
            try:
                if total_equipments == 1:
                    # Carta única - centralizar na posição (0,0)
                    row, col = 0, 0
                else:
                    # Múltiplas cartas - grid 2xn
                    row = idx // 2
                    col = idx % 2
                
                # Verificar se equipamento está ativo
                is_active = self.is_card_active(equipment_path, "equipments")
                
                if is_active:
                    # Equipamento ativo: mostrar virado para cima
                    img = ImageTk.PhotoImage(Image.open(equipment_path).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment ATIVO: {os.path.basename(equipment_path)}")
                else:
                    # Equipamento inativo: mostrar virado para baixo
                    back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Equipment INATIVO: {os.path.basename(equipment_path)}")
                
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Click handler para fullscreen
                def make_click_handler(path):
                    return lambda e: self._show_equipment_fullscreen_router_upgrade(path)
                
                carta_lbl.bind("<Button-1>", make_click_handler(equipment_path))
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao carregar equipment: {e}")
                continue
        
        # Barra inferior
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Barra inferior carregada")
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_INVENTORY] Erro ao carregar barra inferior: {e}")
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)
        
        print("DEBUG: [ROUTER_UPGRADE_INVENTORY] SUCCESS: Página ROUTER UPGRADE criada")

    def _show_equipment_fullscreen_router_upgrade(self, equipment_path):
        """Mostra equipamento em fullscreen para ROUTER UPGRADE com botões de confirmação"""
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(equipment_path)}")
        
        # Verificar se equipamento está ativo
        is_active = self.is_card_active(equipment_path, "equipments")
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Equipment {os.path.basename(equipment_path)} ativo: {is_active}")
        print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] active_equipments: {[os.path.basename(p) for p in self.active_equipments]}")
        
        if not is_active:
            print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Equipamento inativo - não permitindo upgrade")
            return
        
        # Usar o mesmo padrão do fullscreen normal: limpar widgets e usar janela principal
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == getattr(self, 'topbar_label', None):
                continue
            widget.destroy()
        
        # Carregar e exibir imagem do equipamento
        try:
            pil_img = Image.open(equipment_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
            # Fallback: mostrar placeholder
            placeholder = tk.Label(self, text="Equipment Image", font=("Helvetica", 24), fg="white", bg="black")
            placeholder.place(relx=0.5, rely=0.5, anchor="center")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para página ROUTER UPGRADE
        def close_fullscreen():
            print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Fechando fullscreen - voltando para página ROUTER UPGRADE")
            self._show_equipment_inventory_for_router_upgrade()
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de confirmação (roxo, canto superior direito)
        def confirm_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Confirmando upgrade: {os.path.basename(equipment_path)}")
            self._executar_router_upgrade(equipment_path)
        
        confirm_btn = tk.Button(
            self,
            text="✓",
            font=("Helvetica", 24, "bold"),
            bg="#800080",  # Roxo
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_upgrade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] ===== FULLSCREEN CRIADO COM SUCESSO =====")
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] Usando padrão normal de fullscreen (sem Toplevel)")
        print("DEBUG: [ROUTER_UPGRADE_FULLSCREEN] ===== FIM DEBUG FULLSCREEN =====")

    def _executar_router_upgrade(self, small_router_path):
        """Mostra overlay de confirmação para ROUTER UPGRADE"""
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Mostrando overlay de confirmação: {os.path.basename(small_router_path)}")
        
        try:
            # Extrair router_id do nome do arquivo
            filename = os.path.basename(small_router_path)
            router_id = int(filename.replace("Equipment_", "").replace(".png", ""))
            
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Router ID: {router_id}")
            
            # Mostrar overlay de confirmação (como na ativação normal)
            self._mostrar_overlay_confirmacao_router_upgrade(small_router_path, router_id)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERRO: {e}")

    def _mostrar_overlay_confirmacao_router_upgrade(self, small_router_path, router_id):
        """Mostra overlay de confirmação para ROUTER UPGRADE (igual ao de ativação normal)"""
        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Criando overlay: Router ID {router_id}")
        
        # Obter specific_id da carta Equipment através da base de dados
        specific_id = router_id  # Fallback para o router_id caso não encontre na base de dados
        if self.card_database:
            try:
                # Extrair filename da carta
                filename = os.path.basename(small_router_path)
                
                # Determinar cor baseada no diretório
                color = None
                if "/red/" in small_router_path.lower():
                    color = "red"
                elif "/green/" in small_router_path.lower():
                    color = "green"
                elif "/blue/" in small_router_path.lower():
                    color = "blue"
                elif "/yellow/" in small_router_path.lower():
                    color = "yellow"
                
                if color:
                    # Construir equipment_id baseado no filename e cor
                    equipment_id = f"small_router_{router_id}_{color}"
                    equipment_card = self.card_database.get_equipment(equipment_id)
                    
                    if equipment_card:
                        specific_id = equipment_card.specific_id
                        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Specific ID encontrado: {specific_id}")
                    else:
                        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Equipment não encontrado: {equipment_id}")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Cor não detectada no path: {small_router_path}")
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Erro ao obter specific_id: {e}")
        
        # Limpar TODOS os widgets (igual à ativação normal)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (igual à ativação normal)
        try:
            carta_img = Image.open(small_router_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Erro ao carregar imagem: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (igual à ativação normal)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título (igual à ativação normal)
        tk.Label(confirm_frame, text="Router Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirmação com specific_id
        tk.Label(confirm_frame, text=f"Router {specific_id} is going to be upgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para o botão (só botão Ok)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo - sem botão No)
        def confirmar_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] Ok clicado - executando upgrade")
            self._processar_router_upgrade_completo(small_router_path, router_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",  # Roxo (purple)
            fg="white",
            width=8,
            height=2,
            command=confirmar_upgrade,
            cursor="hand2"
        )
        ok_btn.pack(padx=20)
        
        print(f"DEBUG: [ROUTER_UPGRADE_OVERLAY] SUCCESS: Overlay criado - aguardando confirmação")

    def _execute_detection_for_router_upgrade(self, object_name, loading_window):
        """
        Executa detecção YOLO específica para ROUTER UPGRADE que volta para PlayerDashboard principal.
        
        Args:
            object_name: Nome do objeto para deteção
            loading_window: Loading screen já criado
            
        Returns:
            True se o script executou com sucesso, False caso contrário
        """
        try:
            # Usar os utilitários universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Simulando execução do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
                # Simular delay e voltar para PlayerDashboard principal
                if loading_window:
                    def close_loading_and_return_to_dashboard():
                        loading_window.destroy()
                        # CORREÇÃO: Voltar para PlayerDashboard principal, não inventário
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    self.after(3000, close_loading_and_return_to_dashboard)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Script não encontrado")
                    return False
            
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Executando: {script_path} {object_name}")
            
            # Tornar o script executável
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, object_name])
            
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Script iniciado (PID: {process.pid})")
            
            # Monitorar script com loading screen existente
            if loading_window:
                def check_yolo_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO deve estar inicializado - fechar loading screen
                        print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Fechando loading screen - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão
                        def check_script_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_script_completion)
                            else:
                                print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] YOLO terminou - voltando para PlayerDashboard principal")
                                self.deiconify()
                                # CORREÇÃO: Voltar para PlayerDashboard principal, não inventário
                                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                        self.after(1000, check_script_completion)
                    else:
                        # Script terminou antes de inicializar
                        loading_window.destroy()
                        # CORREÇÃO: Voltar para PlayerDashboard principal, não inventário
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_yolo_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False

    def _execute_two_phase_detection_for_router_upgrade(self, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name):
        """
        Executa detecção YOLO em duas fases para ROUTER UPGRADE:
        1. Primeira fase: Detectar objeto antigo (Small Router)
        2. Segunda fase: Detectar objeto novo (Medium Router)  
        3. Finalização: Voltar ao PlayerDashboard principal
        
        Args:
            old_object_name: Nome do objeto antigo para primeira detecção
            new_object_name: Nome do objeto novo para segunda detecção
            loading_window: Loading screen já criado
            old_equipment_name: Nome do equipamento antigo (ex: "Equipment_1.png")
            new_equipment_name: Nome do equipamento novo (ex: "Equipment_4.png")
            
        Returns:
            True se o processo foi iniciado com sucesso, False caso contrário
        """
        try:
            print(f"DEBUG: [TWO_PHASE_DETECTION] === INICIANDO DETECÇÃO EM DUAS FASES ===")
            print(f"DEBUG: [TWO_PHASE_DETECTION] Fase 1: {old_equipment_name} -> {old_object_name}")
            print(f"DEBUG: [TWO_PHASE_DETECTION] Fase 2: {new_equipment_name} -> {new_object_name}")
            
            # Usar os utilitários universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando detecção em duas fases (ambiente: {universal_paths['environment']})")
                # Simular sequência completa e voltar para PlayerDashboard principal
                if loading_window:
                    def simulate_two_phase_detection():
                        # Simular primeira fase (3 segundos)
                        print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando Fase 1: {old_object_name}")
                        
                        def start_phase_2():
                            loading_window.destroy()
                            # Criar loading screen para segunda fase
                            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
                            if phase_2_loading:
                                print(f"DEBUG: [TWO_PHASE_DETECTION] Simulando Fase 2: {new_object_name}")
                                
                                def finish_detection():
                                    phase_2_loading.destroy()
                                    print(f"DEBUG: [TWO_PHASE_DETECTION] Simulação completa - voltando ao PlayerDashboard")
                                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                                
                                self.after(3000, finish_detection)
                        
                        self.after(3000, start_phase_2)
                    
                    self.after(100, simulate_two_phase_detection)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [TWO_PHASE_DETECTION] Script não encontrado")
                    return False
            
            print(f"DEBUG: [TWO_PHASE_DETECTION] Script encontrado: {script_path}")
            
            # Tornar o script executável
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Iniciar primeira fase da detecção
            self._start_phase_1_detection(script_path, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [TWO_PHASE_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False
    
    def _start_phase_1_detection(self, script_path, old_object_name, new_object_name, loading_window, old_equipment_name, new_equipment_name):
        """Inicia a primeira fase da detecção (objeto antigo)"""
        try:
            print(f"DEBUG: [PHASE_1] === INICIANDO FASE 1: {old_equipment_name} ===")
            print(f"DEBUG: [PHASE_1] Executando: {script_path} {old_object_name}")
            
            # Executar script para primeira detecção
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [PHASE_1] Script Fase 1 iniciado (PID: {process.pid})")
            
            # Monitorar primeira fase
            if loading_window:
                def check_phase_1_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [PHASE_1] Fechando loading screen Fase 1 - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [PHASE_1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()
                                # Iniciar segunda fase
                                self._start_phase_2_detection(script_path, new_object_name, new_equipment_name)
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [PHASE_1] Fase 1 terminou inesperadamente")
                        loading_window.destroy()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
                
        except Exception as e:
            print(f"DEBUG: [PHASE_1] Erro na Fase 1: {e}")
            if loading_window:
                loading_window.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _start_phase_2_detection(self, script_path, new_object_name, new_equipment_name):
        """Inicia a segunda fase da detecção (objeto novo)"""
        try:
            print(f"DEBUG: [PHASE_2] === INICIANDO FASE 2: {new_equipment_name} ===")
            
            # Criar novo loading screen para segunda fase
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [PHASE_2] ERRO: Não foi possível criar loading screen Fase 2")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
                
            print(f"DEBUG: [PHASE_2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [PHASE_2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detecção
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [PHASE_2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar segunda fase
            def check_phase_2_initialization():
                poll_result = process.poll()
                if poll_result is None:
                    # YOLO Fase 2 inicializado - fechar loading screen
                    print(f"DEBUG: [PHASE_2] Fechando loading screen Fase 2 - YOLO inicializando")
                    phase_2_loading.destroy()
                    self.withdraw()  # Esconder interface Python
                    
                    # Monitorar conclusão da Fase 2
                    def check_phase_2_completion():
                        poll_result = process.poll()
                        if poll_result is None:
                            self.after(1000, check_phase_2_completion)
                        else:
                            print(f"DEBUG: [PHASE_2] === DETECÇÃO COMPLETA - VOLTANDO AO PLAYERDASHBOARD ===")
                            self.deiconify()
                            # Voltar ao PlayerDashboard principal
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    self.after(1000, check_phase_2_completion)
                else:
                    # Script terminou antes de inicializar
                    print(f"DEBUG: [PHASE_2] Fase 2 terminou inesperadamente")
                    phase_2_loading.destroy()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # Aguardar 4.5 segundos para YOLO inicializar
            self.after(4500, check_phase_2_initialization)
                
        except Exception as e:
            print(f"DEBUG: [PHASE_2] Erro na Fase 2: {e}")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def _processar_router_upgrade_completo(self, small_router_path, router_id):
        """Processa o upgrade completo: troca de equipamento + YOLO detection (igual à ativação normal)"""
        print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Processando upgrade completo: Router {router_id}")
        
        try:
            # Obter object_name da carta (igual à ativação normal)
            object_name = get_equipment_object_name(small_router_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Criando loading screen para object: {object_name}")
                
                # CRIAR LOADING SCREEN IMEDIATAMENTE (igual à ativação normal)
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Loading screen criado - processando upgrade em background")
                    
                    # Função para processar upgrade depois do loading screen estar ativo
                    def processar_upgrade_com_yolo():
                        try:
                            # Mapeamento Small Router -> Medium Router
                            equipment_mapping = {
                                1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
                                2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
                                3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
                            }
                            
                            small_router_file, medium_router_file = equipment_mapping[router_id]
                            
                            # Construir caminhos completos
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] Path original Small Router: {small_router_path}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] dirname(small_router_path): {os.path.dirname(small_router_path)}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PATH] dirname(dirname(small_router_path)): {os.path.dirname(os.path.dirname(small_router_path))}")
                            
                            # CORREÇÃO: Usar o mesmo diretório do Small Router para construir path do Medium Router
                            # Se Small Router está em: /path/color/Equipment_1.png
                            # Medium Router deve estar em: /path/color/Equipment_4.png
                            small_router_dir = os.path.dirname(small_router_path)
                            medium_router_path = os.path.join(small_router_dir, medium_router_file)
                            
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Upgrade: {small_router_file} -> {medium_router_file}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router directory: {small_router_dir}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Caminho Medium Router CORRIGIDO: {medium_router_path}")
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Verificando se arquivo existe: {os.path.exists(medium_router_path)}")
                            
                            # CORREÇÃO: Remover Small Router do inventário
                            if small_router_path in self.inventario.get("equipments", []):
                                self.inventario["equipments"].remove(small_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router removido do inventário")
                            
                            # Verificar se Medium Router existe no inventário
                            if medium_router_path not in self.inventario.get("equipments", []):
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ADICIONANDO Medium Router ao inventário")
                                self.inventario["equipments"].append(medium_router_path)
                            
                            # Remover Small Router dos ativos
                            if small_router_path in self.active_equipments:
                                self.active_equipments.remove(small_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Small Router removido dos ativos")
                            
                            # Adicionar Medium Router aos ativos
                            if medium_router_path not in self.active_equipments:
                                self.active_equipments.append(medium_router_path)
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Medium Router adicionado aos ativos")
                            
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Upgrade executado - iniciando detecção em duas fases")
                            
                            # Obter object_name do Medium Router para segunda detecção
                            medium_router_object_name = get_equipment_object_name(medium_router_path, self.card_database)
                            
                            # Executar detecção em duas fases: Small Router primeiro, depois Medium Router
                            detection_success = self._execute_two_phase_detection_for_router_upgrade(
                                object_name, medium_router_object_name, loading_window, small_router_file, medium_router_file
                            )
                            
                            if detection_success:
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] Detecção em duas fases iniciada com sucesso")
                                # O processo irá gerir automaticamente as duas detecções e voltar ao PlayerDashboard
                            else:
                                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] AVISO: Detecção falhou - fechando loading screen")
                                if loading_window:
                                    loading_window.destroy()
                                # Voltar ao PlayerDashboard em caso de erro
                                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                                
                        except Exception as e:
                            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO no upgrade: {e}")
                            if loading_window:
                                loading_window.destroy()
                            # Voltar ao PlayerDashboard em caso de erro
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
                    # Executar upgrade após 100ms (loading screen já está visível)
                    self.after(100, processar_upgrade_com_yolo)
                    
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO: Loading screen não foi criado - voltando para dashboard")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            else:
                print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] AVISO: Object name não encontrado - voltando para dashboard")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            print("DEBUG: [ROUTER_UPGRADE_PROCESS] SUCCESS: Router upgrade iniciado")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_PROCESS] ERRO durante upgrade: {e}")
            # Voltar ao PlayerDashboard em caso de erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)



    def _show_equipment_inventory_for_router_downgrade(self):
        """Cria página especializada para ROUTER DOWNGRADE com equipamentos Medium Router filtrados"""
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Criando página especializada ROUTER DOWNGRADE")
        
        # Definir contexto específico
        self._in_router_downgrade_context = True
        
        # Obter router_id da Action card ativa
        router_id = getattr(self, '_router_downgrade_target_id', None)
        print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Router ID da Action: {router_id}")
        
        if router_id is None:
            print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] ERRO: Router ID não definido")
            return
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se necessário
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] TopBar não encontrada, criando fallback")
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] ERRO ao criar TopBar: {e}")
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
        
        # Nome do jogador
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text="ROUTER DOWNGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Filtrar equipamentos Medium Router com specific_id igual ao router_id
        equipamentos_filtrados = []
        all_equipments = self.inventario.get("equipments", [])
        
        for equipment_path in all_equipments:
            try:
                # Extrair número do equipamento do nome do arquivo (Equipment_X.png)
                filename = os.path.basename(equipment_path)
                if filename.startswith("Equipment_") and filename.endswith(".png"):
                    equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
                    
                    # Medium Router são Equipment_4, Equipment_5, Equipment_6
                    # Equipment_4 = Medium Router 1, Equipment_5 = Medium Router 2, Equipment_6 = Medium Router 3
                    if 4 <= equipment_num <= 6:
                        medium_router_id = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, Equipment_6 -> 3
                        if medium_router_id == router_id:
                            equipamentos_filtrados.append(equipment_path)
                            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment filtrado: {filename} (router_id={router_id})")
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao processar equipamento {equipment_path}: {e}")
                continue
        
        print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Total equipamentos filtrados: {len(equipamentos_filtrados)}")
        
        # Layout baseado no número de equipamentos
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120
        total_equipments = len(equipamentos_filtrados)
        
        if total_equipments == 1:
            # Carta única - layout centralizado
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Carta única detectada - usando layout centralizado")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
        else:
            # Múltiplas cartas - grid 2xn
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Múltiplas cartas detectadas - usando grid 2xn")
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)
        
        # Colocar equipamentos em layout apropriado
        for idx, equipment_path in enumerate(equipamentos_filtrados):
            try:
                if total_equipments == 1:
                    # Carta única - centralizar na posição (0,0)
                    row, col = 0, 0
                else:
                    # Múltiplas cartas - grid 2xn
                    row = idx // 2
                    col = idx % 2
                
                # Verificar se equipamento está ativo
                is_active = self.is_card_active(equipment_path, "equipments")
                
                if is_active:
                    # Equipamento ativo: mostrar virado para cima
                    img = ImageTk.PhotoImage(Image.open(equipment_path).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment ATIVO: {os.path.basename(equipment_path)}")
                else:
                    # Equipamento inativo: mostrar virado para baixo
                    back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                    print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Equipment INATIVO: {os.path.basename(equipment_path)}")
                
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Click handler para fullscreen
                def make_click_handler(path):
                    return lambda e: self._show_equipment_fullscreen_router_downgrade(path)
                
                carta_lbl.bind("<Button-1>", make_click_handler(equipment_path))
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao carregar equipment: {e}")
                continue
        
        # Barra inferior
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Barra inferior carregada")
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_INVENTORY] Erro ao carregar barra inferior: {e}")
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)
        
        print("DEBUG: [ROUTER_DOWNGRADE_INVENTORY] SUCCESS: Página ROUTER DOWNGRADE criada")

    def _show_equipment_fullscreen_router_downgrade(self, equipment_path):
        """Mostra equipamento em fullscreen para ROUTER DOWNGRADE com botões de confirmação"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(equipment_path)}")
        
        # Verificar se equipamento está ativo
        is_active = self.is_card_active(equipment_path, "equipments")
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Equipment {os.path.basename(equipment_path)} ativo: {is_active}")
        print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] active_equipments: {[os.path.basename(p) for p in self.active_equipments]}")
        
        if not is_active:
            print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Equipamento inativo - não permitindo downgrade")
            return
        
        # Usar o mesmo padrão do fullscreen normal: limpar widgets e usar janela principal
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == getattr(self, 'topbar_label', None):
                continue
            widget.destroy()
        
        # Carregar e exibir imagem do equipamento
        try:
            pil_img = Image.open(equipment_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
            # Fallback: mostrar placeholder
            placeholder = tk.Label(self, text="Equipment Image", font=("Helvetica", 24), fg="white", bg="black")
            placeholder.place(relx=0.5, rely=0.5, anchor="center")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para página ROUTER DOWNGRADE
        def close_fullscreen():
            print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Fechando fullscreen - voltando para página ROUTER DOWNGRADE")
            self._show_equipment_inventory_for_router_downgrade()
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de confirmação (roxo, canto superior direito)
        def confirm_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Confirmando downgrade: {os.path.basename(equipment_path)}")
            self._mostrar_overlay_confirmacao_router_downgrade(equipment_path)
        
        confirm_btn = tk.Button(
            self,
            text="✓",
            font=("Helvetica", 24, "bold"),
            bg="#800080",  # Roxo
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_downgrade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] ===== FULLSCREEN CRIADO COM SUCESSO =====")
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] Usando padrão normal de fullscreen (sem Toplevel)")
        print("DEBUG: [ROUTER_DOWNGRADE_FULLSCREEN] ===== FIM DEBUG FULLSCREEN =====")

    def _mostrar_overlay_confirmacao_router_downgrade(self, equipment_path):
        """Mostra overlay de confirmação para ROUTER DOWNGRADE (usando mesmo método que ROUTER UPGRADE)"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Mostrando confirmação: {os.path.basename(equipment_path)}")
        
        # Limpar TODOS os widgets da janela principal (igual ao ROUTER UPGRADE)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(equipment_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao carregar imagem: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (igual ao ROUTER UPGRADE)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título (igual ao ROUTER UPGRADE)
        tk.Label(confirm_frame, text="Router Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta Equipment
        specific_id = "N/A"
        router_id = None
        try:
            if self.card_database:
                # Extrair informações do caminho
                filename = os.path.basename(equipment_path)
                color = self._get_color_from_path(equipment_path)
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Filename: {filename}, Color: {color}")
                
                # Mapear filename para equipment_id
                match = re.match(r'Equipment_(\d+)\.png', filename)
                if match:
                    equipment_num = int(match.group(1))
                    
                    # Equipment_4.png, Equipment_5.png, Equipment_6.png -> medium_router_1_color, etc
                    if 4 <= equipment_num <= 6:
                        specific_id_num = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, etc
                        router_id = specific_id_num
                        equipment_id = f"medium_router_{specific_id_num}_{color}"
                        
                        # Obter carta da base de dados
                        equipment_result = self.card_database.get_equipment_with_file(equipment_id)
                        
                        if equipment_result:
                            equipment_data, _ = equipment_result
                            # CORREÇÃO: EquipmentCard é um objeto, não um dict - usar atributo diretamente
                            specific_id = str(getattr(equipment_data, 'specific_id', specific_id_num))
                            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment encontrado - specific_id: {specific_id}")
                        else:
                            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment não encontrado na base de dados")
                            specific_id = str(specific_id_num)  # Fallback para número calculado
                    else:
                        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Equipment number fora do range Medium Router: {equipment_num}")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Filename não corresponde ao padrão Equipment_X.png")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Card database não disponível")
                
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao obter specific_id: {e}")
            # Usar fallback baseado em router_id se disponível
            if hasattr(self, '_router_downgrade_target_id') and self._router_downgrade_target_id:
                specific_id = str(self._router_downgrade_target_id)
        
        # Mensagem de confirmação com specific_id (igual ao ROUTER UPGRADE)
        tk.Label(confirm_frame, text=f"Router {specific_id} is going to be downgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o botão (só botão Ok, igual ao ROUTER UPGRADE)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo - sem botão Cancel, igual ao ROUTER UPGRADE)
        def confirmar_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Ok clicado - executando downgrade")
            self._executar_router_downgrade(equipment_path)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",  # Roxo (purple) - igual ao ROUTER UPGRADE
            fg="white",
            width=8,
            height=2,
            command=confirmar_downgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Overlay de confirmação criado")

    def _executar_router_downgrade(self, medium_router_path):
        """Executa o processo de ROUTER DOWNGRADE com detecção em duas fases"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Executando downgrade: {os.path.basename(medium_router_path)}")
        
        try:
            # Extrair router_id do nome do arquivo
            filename = os.path.basename(medium_router_path)
            equipment_num = int(filename.replace("Equipment_", "").replace(".png", ""))
            router_id = equipment_num - 3  # Equipment_4 -> 1, Equipment_5 -> 2, Equipment_6 -> 3
            
            # Mapeamento Medium Router -> Small Router
            equipment_mapping = {
                1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
                2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
                3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
            }
            
            medium_router_file, small_router_file = equipment_mapping[router_id]
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Downgrade: {medium_router_file} -> {small_router_file}")
            
            # NOVA LÓGICA: Executar detecção em duas fases antes de processar downgrade
            # Fase 1: Detectar Medium Router (objeto atual)
            # Fase 2: Detectar Small Router (objeto de destino)
            
            # Obter object names para detecção ANTES de criar loading screen
            old_object_name = get_equipment_object_name(medium_router_path, self.card_database)
            
            # Criar loading screen inicial com object name real
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else "router_medio_vermelho")
            
            if loading_window:
                print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Loading screen criado - iniciando detecção duas fases")
                
                # Construir caminho para Small Router (usar mesmo diretório do Medium Router)
                small_router_path = os.path.join(os.path.dirname(medium_router_path), small_router_file)
                new_object_name = get_equipment_object_name(small_router_path, self.card_database)
                
                old_equipment_name = f"Medium Router {router_id}"
                new_equipment_name = f"Small Router {router_id}"
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Old object: {old_object_name}")
                print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] New object: {new_object_name}")
                
                if old_object_name and new_object_name:
                    # Executar detecção em duas fases
                    success = self._execute_two_phase_detection_for_router_downgrade(
                        old_object_name, new_object_name, loading_window, 
                        old_equipment_name, new_equipment_name, medium_router_path, router_id
                    )
                    
                    if success:
                        print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] SUCCESS: Detecção duas fases iniciada")
                        # Processamento será continuado após detecção bem-sucedida
                        return
                    else:
                        print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: Falha ao iniciar detecção duas fases")
                        if loading_window:
                            loading_window.destroy()
                else:
                    print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: Não foi possível obter object names")
                    if loading_window:
                        loading_window.destroy()
            else:
                print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO: Não foi possível criar loading screen")
            
            # Fallback: se detecção falhar, processar diretamente (desenvolvimento)
            print("DEBUG: [ROUTER_DOWNGRADE_EXECUTE] Fallback: processando downgrade diretamente")
            self._processar_router_downgrade_completo(medium_router_path, router_id)
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_EXECUTE] ERRO durante downgrade: {e}")
            # Limpar flags em caso de erro
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None

    def _execute_two_phase_detection_for_router_downgrade(self, old_object_name, new_object_name, loading_window, 
                                                        old_equipment_name, new_equipment_name, medium_router_path, router_id):
        """
        Executa detecção YOLO em duas fases para ROUTER DOWNGRADE:
        Fase 1: Detectar Medium Router (objeto atual)
        Fase 2: Detectar Small Router (objeto de destino)
        """
        try:
            # Usar os utilitários universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print("DEBUG: [ROUTER_DOWNGRADE_2PHASE] Ambiente não é Raspberry Pi - usando fallback")
                if loading_window:
                    loading_window.destroy()
                # Processar downgrade diretamente no desenvolvimento
                self.after(1000, lambda: self._processar_router_downgrade_completo(medium_router_path, router_id))
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Script não encontrado: {script_path}")
                if loading_window:
                    loading_window.destroy()
                return False
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Iniciando Fase 1: {old_object_name}")
            
            # Iniciar Fase 1: Detecção do Medium Router
            success = self._start_phase_1_detection_downgrade(
                script_path, old_object_name, new_object_name, loading_window, 
                old_equipment_name, new_equipment_name, medium_router_path, router_id
            )
            
            return success
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_2PHASE] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False

    def _start_phase_1_detection_downgrade(self, script_path, old_object_name, new_object_name, loading_window, 
                                         old_equipment_name, new_equipment_name, medium_router_path, router_id):
        """Inicia Fase 1: Detecção do Medium Router atual"""
        try:
            print(f"DEBUG: [DOWNGRADE_PHASE1] Executando: {script_path} {old_object_name}")
            
            # Tornar o script executável
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [DOWNGRADE_PHASE1] Script iniciado (PID: {process.pid})")
            
            # Monitorar inicialização da Fase 1 (igual ao ROUTER UPGRADE)
            def check_phase_1_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [DOWNGRADE_PHASE1] Fechando loading screen Fase 1 - YOLO inicializando")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [DOWNGRADE_PHASE1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Iniciar segunda fase
                                self._start_phase_2_detection_downgrade(
                                    script_path, new_object_name, new_equipment_name, 
                                    medium_router_path, router_id
                                )
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [DOWNGRADE_PHASE1] Fase 1 terminou inesperadamente")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        # Fallback: processar diretamente
                        self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                except Exception as e:
                    print(f"DEBUG: [DOWNGRADE_PHASE1] Erro no monitor: {e}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: processar diretamente
                    self._processar_router_downgrade_completo(medium_router_path, router_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_1_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [DOWNGRADE_PHASE1] Erro: {e}")
            if loading_window and loading_window.winfo_exists():
                loading_window.destroy()
            return False

    def _start_phase_2_detection_downgrade(self, script_path, new_object_name, new_equipment_name, 
                                         medium_router_path, router_id):
        """Inicia Fase 2: Detecção do Small Router de destino (igual ao ROUTER UPGRADE)"""
        try:
            print(f"DEBUG: [DOWNGRADE_PHASE2] === INICIANDO FASE 2: {new_equipment_name} ===")
            
            # Criar novo loading screen para segunda fase
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [DOWNGRADE_PHASE2] ERRO: Não foi possível criar loading screen Fase 2")
                self._processar_router_downgrade_completo(medium_router_path, router_id)
                return
                
            print(f"DEBUG: [DOWNGRADE_PHASE2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [DOWNGRADE_PHASE2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detecção
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [DOWNGRADE_PHASE2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar inicialização da Fase 2 (igual ao ROUTER UPGRADE)
            def check_phase_2_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 2 inicializado - fechar loading screen atual
                        print(f"DEBUG: [DOWNGRADE_PHASE2] Fechando loading screen Fase 2 - YOLO inicializando")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão da Fase 2
                        def check_phase_2_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_2_completion)
                            else:
                                print(f"DEBUG: [DOWNGRADE_PHASE2] Fase 2 completa - processando downgrade")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Processar downgrade completo
                                self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                        self.after(1000, check_phase_2_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [DOWNGRADE_PHASE2] Fase 2 terminou inesperadamente")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        # Fallback: processar diretamente
                        self._processar_router_downgrade_completo(medium_router_path, router_id)
                        
                except Exception as e:
                    print(f"DEBUG: [DOWNGRADE_PHASE2] Erro no monitor: {e}")
                    if phase_2_loading and phase_2_loading.winfo_exists():
                        phase_2_loading.destroy()
                    # Fallback: processar diretamente
                    self._processar_router_downgrade_completo(medium_router_path, router_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_2_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [DOWNGRADE_PHASE2] Erro: {e}")
            return False

    def _processar_router_downgrade_completo(self, medium_router_path, router_id):
        """
        Processa efetivamente o ROUTER DOWNGRADE após detecção bem-sucedida.
        Remove Medium Router e adiciona Small Router correspondente.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Processando downgrade completo")
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Medium Router: {os.path.basename(medium_router_path)}")
        print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] Router ID: {router_id}")
        
        try:
            # Mapeamento: Medium Router -> Small Router
            equipment_mapping = {
                1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
                2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
                3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
            }
            
            medium_router_file, small_router_file = equipment_mapping[router_id]
            
            # PASSO 1: Remover Medium Router dos equipments ativos
            medium_router_path_ativo = None
            for equipment_path in self.active_equipments:
                if os.path.basename(equipment_path) == medium_router_file:
                    medium_router_path_ativo = equipment_path
                    break
            
            if medium_router_path_ativo:
                self.active_equipments.remove(medium_router_path_ativo)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} removido dos equipments ativos")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] AVISO: {medium_router_file} não encontrado nos equipments ativos")
            
            # PASSO 2: Remover Medium Router do inventário
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_inventory = None
            for equipment_path in equipments_inventory:
                if os.path.basename(equipment_path) == medium_router_file:
                    medium_router_inventory = equipment_path
                    break
            
            if medium_router_inventory:
                self.inventario["equipments"].remove(medium_router_inventory)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} removido do inventário")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] AVISO: {medium_router_file} não encontrado no inventário")
            
            # PASSO 3: Adicionar Small Router ao inventário (usar mesmo diretório)
            small_router_path = os.path.join(os.path.dirname(medium_router_path), small_router_file)
            
            # Verificar se já existe no inventário
            small_router_exists = any(
                os.path.basename(equipment_path) == small_router_file 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not small_router_exists:
                self.inventario["equipments"].append(small_router_path)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} adicionado ao inventário")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} já existe no inventário")
            
            # PASSO 4: CORREÇÃO CRÍTICA - Ativar Small Router (igual ao ROUTER UPGRADE)
            # Adicionar Small Router aos equipments ativos para que fique virado para cima
            if small_router_path not in self.active_equipments:
                self.active_equipments.append(small_router_path)
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] CORREÇÃO: {small_router_file} adicionado aos ativos (carta fica virada para cima)")
            else:
                print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {small_router_file} já está nos ativos")
            
            # PASSO 5: Limpar flags de contexto
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] SUCCESS: Router Downgrade aplicado com sucesso!")
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] {medium_router_file} -> {small_router_file} (ATIVO)")
            
            # PASSO 6: Voltar para o PlayerDashboard após processamento completo
            self.after(1000, lambda: self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            ))
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_COMPLETO] ERRO durante processamento: {e}")
            # Limpar flags em caso de erro
            self._in_router_downgrade_context = False
            self._router_downgrade_target_id = None
            
            # Voltar para dashboard mesmo em caso de erro
            self.after(1000, lambda: self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            ))

    def _aplicar_router_downgrade(self, router_id):
        """
        Inicia o processo ROUTER DOWNGRADE baseado no router_id.
        Verifica se o medium router está ativo antes de mostrar overlay de confirmação.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Iniciando Router Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID é None - não aplicando downgrade")
            return
        
        # Validar router_id suportado
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        if router_id not in equipment_mapping:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Router ID {router_id} não suportado")
            return
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORREÇÃO CRÍTICA: Verificar se o medium router está ATIVO antes de mostrar overlay
        medium_router_ativo = any(
            os.path.basename(equipment_path) == medium_router 
            for equipment_path in self.active_equipments
        )
        
        print(f"DEBUG: [ROUTER_DOWNGRADE] Verificando se {medium_router} está ativo...")
        print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
        print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} ativo: {medium_router_ativo}")
        
        if not medium_router_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ERROR: {medium_router} não está ativo - ROUTER DOWNGRADE não pode ser aplicado")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Action_32 foi consumida mas o efeito não se aplica")
            return
        
        # Medium router está ativo - ir DIRETAMENTE para inventário de Equipments
        print(f"DEBUG: [ROUTER_DOWNGRADE] SUCCESS: {medium_router} está ativo - indo para inventário Equipments")
        
        # Armazenar contexto para o fullscreen da carta Equipment
        self._in_router_downgrade_context = True
        self._router_downgrade_target_id = router_id
        
        # Ir diretamente para inventário de Equipments (SEM overlay)
        self._show_equipment_inventory_for_router_downgrade()
        
    def _processar_router_downgrade(self, router_id):
        """
        Processa efetivamente o ROUTER DOWNGRADE baseado no router_id.
        Troca Medium Router ativo por Small Router correspondente.
        """
        print(f"DEBUG: [ROUTER_DOWNGRADE] Processando Router Downgrade para Router ID: {router_id}")
        
        # Mapeamento: Medium Router -> Small Router
        equipment_mapping = {
            1: ("Equipment_4.png", "Equipment_1.png"),  # Medium Router 1 -> Small Router 1
            2: ("Equipment_5.png", "Equipment_2.png"),  # Medium Router 2 -> Small Router 2
            3: ("Equipment_6.png", "Equipment_3.png"),  # Medium Router 3 -> Small Router 3
        }
        
        medium_router, small_router = equipment_mapping[router_id]
        
        # CORREÇÃO: Encontrar e remover medium router dos equipments ativos
        medium_router_path_ativo = None
        for equipment_path in self.active_equipments:
            if os.path.basename(equipment_path) == medium_router:
                medium_router_path_ativo = equipment_path
                break
        
        if medium_router_path_ativo:
            print(f"DEBUG: [ROUTER_DOWNGRADE] Encontrado {medium_router} nos equipments ativos")
            
            # Remover Medium Router dos equipments ativos
            self.active_equipments.remove(medium_router_path_ativo)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido dos equipments ativos")
            
            # Remover Medium Router do inventário também
            equipments_inventory = self.inventario.get("equipments", [])
            medium_router_inventory = None
            for equipment_path in equipments_inventory:
                if os.path.basename(equipment_path) == medium_router:
                    medium_router_inventory = equipment_path
                    break
            
            if medium_router_inventory:
                self.inventario["equipments"].remove(medium_router_inventory)
                print(f"DEBUG: [ROUTER_DOWNGRADE] {medium_router} removido do inventário")
            
            # Construir caminho para Small Router (usar mesma estrutura de diretório)
            base_dir = os.path.dirname(medium_router_path_ativo)
            small_router_path = os.path.join(base_dir, small_router)
            
            # Adicionar Small Router ao inventário (fica inativo por padrão)
            self.inventario["equipments"].append(small_router_path)
            print(f"DEBUG: [ROUTER_DOWNGRADE] {small_router} adicionado ao inventário (inativo)")
            print(f"DEBUG: [ROUTER_DOWNGRADE] SUCCESS: Router Downgrade aplicado com sucesso!")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE] ERROR: {medium_router} não encontrado nos equipments ativos")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Equipments ativos:")
            for equipment_path in self.active_equipments:
                print(f"DEBUG: [ROUTER_DOWNGRADE]   - {os.path.basename(equipment_path)}")

    def _aplicar_link_upgrade(self, router_id):
        """
        Aplica o efeito LINK UPGRADE baseado no router_id.
        Abre página SELECT LINK para seleção do Long Link a ser upgradado.
        Sistema flexível baseado no specific_id da base de dados.
        """
        print(f"DEBUG: [LINK_UPGRADE] Aplicando Link Upgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_UPGRADE] Router ID é None - não aplicando upgrade")
            return
        
        # Sistema flexível: verificar se há Long Links com specific_id = router_id
        long_links_available = self._get_long_links_by_specific_id(router_id)
        
        if not long_links_available:
            print(f"DEBUG: [LINK_UPGRADE] Nenhum Long Link com specific_id {router_id} encontrado no inventário")
            return
        
        # CORREÇÃO: Verificar se pelo menos um Long Link está ATIVO
        active_long_links = [link for link in long_links_available if link in self.active_equipments]
        
        if not active_long_links:
            print(f"DEBUG: [LINK_UPGRADE] ERRO: Long Link com specific_id {router_id} existe mas NÃO está ativo")
            print(f"DEBUG: [LINK_UPGRADE] Long Links encontrados: {[os.path.basename(link) for link in long_links_available]}")
            print(f"DEBUG: [LINK_UPGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
            print(f"DEBUG: [LINK_UPGRADE] Para usar LINK UPGRADE, o Long Link deve estar ativo (carta virada para cima)")
            return
        
        print(f"DEBUG: [LINK_UPGRADE] Long Links ativos encontrados: {len(active_long_links)}")
        
        # Verificar se já existe Short Link com mesmo specific_id
        short_link_exists = self._check_short_link_exists_by_specific_id(router_id)
        
        if short_link_exists:
            print(f"DEBUG: [LINK_UPGRADE] ERRO: Já existe Short Link com specific_id {router_id} no inventário")
            return
        
        print(f"DEBUG: [LINK_UPGRADE] Long Links encontrados: {len(long_links_available)}")
        
        # Definir contexto de LINK UPGRADE e router_id
        self._in_link_upgrade_context = True
        self._link_upgrade_target_id = router_id
        
        # Abrir página SELECT LINK (similar ao REMOVE ROUTER)
        self._show_select_link_page(router_id)
        print("DEBUG: [LINK_UPGRADE] SUCCESS: Página SELECT LINK aberta")
    
    def _get_long_links_by_specific_id(self, specific_id):
        """
        Obtém todos os Long Links no inventário com specific_id correspondente.
        """
        print(f"DEBUG: [LINK_UPGRADE_SELECT] Procurando Long Links com specific_id {specific_id}")
        
        long_links_found = []
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_long_link_with_specific_id(equipment_path, specific_id):
                long_links_found.append(equipment_path)
        
        print(f"DEBUG: [LINK_UPGRADE_SELECT] Encontrados {len(long_links_found)} Long Links")
        return long_links_found
    
    def _show_select_link_page(self, router_id):
        """
        Cria página SELECT LINK para escolher qual Long Link fazer upgrade.
        Layout similar à página REMOVE ROUTER.
        """
        print(f"DEBUG: [SELECT_LINK_PAGE] Criando página SELECT LINK para Router ID {router_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar do jogador - usar TopBar específico da cor do jogador (igual à interface principal)
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                topbar_label.image = topbar_img
                topbar_label.pack(side="top", fill="x")
                print(f"DEBUG: [SELECT_LINK_PAGE] TopBar do jogador {self.player_color} aplicado com sucesso")
            else:
                print(f"DEBUG: [SELECT_LINK_PAGE] TopBar do jogador não encontrado, usando fallback")
                # Criar TopBar fallback com cor do jogador
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao criar TopBar do jogador: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
            topbar_frame.pack(side="top", fill="x")
            topbar_frame.pack_propagate(False)
        
        # Nome do jogador (igual ao inventário original - fundo da cor do jogador e texto preto)
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text="SELECT LINK", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Long Links com specific_id correspondente
        long_links = self._get_long_links_by_specific_id(router_id)
        
        if not long_links:
            # Mensagem se não há Long Links disponíveis
            no_links_msg = tk.Label(self, text="No Long Links available for upgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Botão de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para múltiplas Equipment Long Link
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padrão igual ao REMOVE ROUTER
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necessário
        for idx, link_path in enumerate(long_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_select_link_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior do jogador - usar BelowBar específico da cor do jogador
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [SELECT_LINK_PAGE] Barra inferior do jogador {self.player_color} carregada")
            else:
                print(f"DEBUG: [SELECT_LINK_PAGE] BelowBar do jogador não encontrado, usando fallback")
                # Criar barra inferior fallback com cor do jogador
                belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_PAGE] Erro ao carregar BelowBar do jogador: {e}")
            # Criar barra inferior fallback
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [SELECT_LINK_PAGE] SUCCESS: Página SELECT LINK criada")
    
    def _show_select_link_fullscreen(self, link_path):
        """
        Mostra Long Link em fullscreen com botão roxo para confirmação.
        """
        print(f"DEBUG: [SELECT_LINK_FULLSCREEN] Mostrando fullscreen: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Long Link
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [SELECT_LINK_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para SELECT LINK
        def close_fullscreen():
            router_id = getattr(self, '_link_upgrade_target_id', 1)
            self._show_select_link_page(router_id)
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de confirmação (roxo, canto superior direito)
        def confirm_link_selection():
            self._show_link_upgrade_confirmation(link_path)
        
        confirm_btn = tk.Button(
            self,
            text="✓",
            font=("Helvetica", 24, "bold"),
            bg="#800080",
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_link_selection,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [SELECT_LINK_FULLSCREEN] Fullscreen criado com botões")
    
    def _show_link_upgrade_confirmation(self, link_path):
        """
        Mostra overlay de confirmação Link Upgrade Confirmation.
        """
        print(f"DEBUG: [LINK_UPGRADE_CONFIRMATION] Mostrando confirmação para: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirmação
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(link_path)
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text=f"Long Link {specific_id} is going to be upgraded", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o botão
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo)
        def confirmar_upgrade():
            print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Upgrade confirmado - destruindo interface e iniciando Fase 1")
            # CORREÇÃO: Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Interface destruída - prosseguindo para detecção YOLO")
            self._executar_link_upgrade_phase_1(link_path, specific_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_upgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_UPGRADE_CONFIRMATION] Overlay de confirmação criado")
    
    def _executar_link_upgrade_phase_1(self, long_link_path, specific_id):
        """
        Executa a Fase 1: detecção do Long Link atual com loading + YOLO.
        """
        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Iniciando Fase 1 para: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object name para detecção
            old_object_name = get_equipment_object_name(long_link_path, self.card_database)
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else f"link_longo_{specific_id}")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_PHASE1] Loading screen criado - iniciando detecção")
                
                # Usar utilitários universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script não encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: ir direto para página LINK UPGRADE
                    self._show_link_upgrade_page(long_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Executando: {script_path} {old_object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                process = subprocess.Popen([script_path, old_object_name])
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script iniciado (PID: {process.pid})")
                
                # Monitor de inicialização e conclusão
                def check_phase_1_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda está rodando - YOLO deve ter inicializado
                            print(f"DEBUG: [LINK_UPGRADE_PHASE1] YOLO inicializado - destruindo loading screen")
                            
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclusão
                            def check_phase_1_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detecção completa
                                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Detecção Fase 1 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Ir para página LINK UPGRADE
                                        self._show_link_upgrade_page(long_link_path, specific_id)
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_1_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._show_link_upgrade_page(long_link_path, specific_id)
                            
                            self.after(1000, check_phase_1_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._show_link_upgrade_page(long_link_path, specific_id)
                    except Exception as e:
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro na inicialização: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._show_link_upgrade_page(long_link_path, specific_id)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
            else:
                print("DEBUG: [LINK_UPGRADE_PHASE1] Erro ao criar loading screen - fallback direto")
                self._show_link_upgrade_page(long_link_path, specific_id)
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro: {e}")
            self._show_link_upgrade_page(long_link_path, specific_id)
    
    def _show_link_upgrade_page(self, long_link_path, specific_id):
        """
        Cria página LINK UPGRADE para escolher Short Link.
        Layout similar à página REMOVE ROUTER.
        """
        print(f"DEBUG: [LINK_UPGRADE_PAGE] Criando página LINK UPGRADE para specific_id {specific_id}")
        
        # Salvar referências importantes
        self._current_long_link_path = long_link_path
        self._current_specific_id = specific_id
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar igual à Store - usar awning da Store
        try:
            awning_img_path = os.path.join(IMG_DIR, "Store_awning_v3.png")
            if os.path.exists(awning_img_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_img_path).resize((screen_width, 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                
                # Label pequeno à esquerda do logo (igual à Store)
                left_label = tk.Label(self, text="••••", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                left_label.place(relx=0.46, y=10, anchor="center")
                
                # Logo NetMaster posicionado independentemente (igual à Store)
                try:
                    logo_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "logo_netmaster_store.png")).resize((20, 20)))
                    logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                    logo_lbl.image = logo_img
                    logo_lbl.place(relx=0.5, y=10, anchor="center")
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar logo: {e}")
                
                # Label largo à direita do logo para cobrir área amarela (igual à Store)
                right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                right_logo_label.place(relx=0.53, y=10, anchor="w")
                
                # Label adicional para garantir cobertura completa (igual à Store)
                extra_cover_label = tk.Label(self, text="     ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
                extra_cover_label.place(relx=0.55, y=10, anchor="w")
                
                print(f"DEBUG: [LINK_UPGRADE_PAGE] TopBar da Store aplicado com sucesso")
                
            else:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Store awning não encontrado, usando fallback")
                # Criar TopBar fallback
                topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                topbar_frame.pack(pady=(0, 10), fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao criar TopBar da Store: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            topbar_frame.pack(pady=(0, 10), fill="x")
            topbar_frame.pack_propagate(False)
        
        # Texto "Store" posicionado independentemente (igual à Store)
        store_name_lbl = tk.Label(self, text="Store", 
                                 font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        store_name_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno à direita do nome Store (igual à Store original)
        right_store_label = tk.Label(self, text="•", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_store_label.place(relx=0.6, y=30, anchor="center")
        
        # Título
        title = tk.Label(self, text="LINK UPGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Short Links correspondentes (mesmo specific_id)
        short_links = self._get_short_links_for_upgrade(specific_id)
        
        if not short_links:
            # Mensagem de erro
            no_links_msg = tk.Label(self, text="No Short Links available", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Botão de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_link_upgrade)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para múltiplas cartas Short Link (igual ao SELECT LINK)
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padrão igual ao REMOVE ROUTER
        
        # CORREÇÃO: Layout 2xn sempre (2 colunas, n linhas conforme necessário)
        # Colocar Short Links em grid 2xn
        for idx, link_path in enumerate(short_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Short Link {os.path.basename(link_path)} colocado na linha {row}, coluna {col}")
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_link_upgrade_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior igual à Store - usar BelowBar_store.png
        try:
            belowbar_img_path = os.path.join(IMG_DIR, "BelowBar_store.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [LINK_UPGRADE_PAGE] Barra inferior BelowBar_store.png carregada (igual à Store)")
            else:
                print(f"DEBUG: [LINK_UPGRADE_PAGE] BelowBar_store.png não encontrado, usando fallback")
                # Criar barra inferior fallback
                belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PAGE] Erro ao carregar BelowBar_store.png: {e}")
            # Criar barra inferior fallback
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [LINK_UPGRADE_PAGE] SUCCESS: Página LINK UPGRADE criada")
    
    def _get_short_links_for_upgrade(self, specific_id):
        """
        Obtém cartas Short Link da COR DO JOGADOR com specific_id correspondente na Store.
        Similar ao SELECT LINK mas procura apenas na cor do jogador.
        """
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Obtendo Short Links da cor '{self.player_color}' para specific_id {specific_id}")
        
        # Obter informações do Short Link baseado no specific_id
        short_link_info = self._get_corresponding_short_link_info(specific_id)
        
        if not short_link_info:
            print(f"DEBUG: [LINK_UPGRADE_LINKS] Nenhum Short Link correspondente encontrado")
            return []
        
        short_links_found = []
        filename = short_link_info['filename']
        
        # Usar utilitários universais para detectar caminhos
        universal_paths = get_universal_paths()
        base_dir = universal_paths['base_dir']
        
        # Mapear cor do jogador para nome do diretório (primeira letra maiúscula)
        player_color_dir = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Procurando {filename} na cor {player_color_dir}...")
        
        # Possíveis bases para busca
        possivel_bases = [base_dir]
        
        # Para cada base possível, buscar Short Links
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                continue
                
            # Testar estruturas de diretórios (similar ao _obter_equipments_da_store)
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (minúscula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (maiúscula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [LINK_UPGRADE_LINKS] Usando estrutura: {equipments_base}")
                    break
            
            if not equipments_base:
                continue
                
            # Buscar Short Links APENAS na cor do jogador
            cor_dir = os.path.join(equipments_base, player_color_dir)
            if not os.path.exists(cor_dir):
                print(f"DEBUG: [LINK_UPGRADE_LINKS] Diretório da cor {player_color_dir} não existe: {cor_dir}")
                continue
                
            # CORREÇÃO: Procurar TODAS as cartas com o filename da cor do jogador
            # Se há 3 Equipment_7.png verdes na Store, todas aparecerão
            print(f"DEBUG: [LINK_UPGRADE_LINKS] Procurando em: {cor_dir}")
            
            # Listar todos os arquivos no diretório da cor do jogador
            if os.path.isdir(cor_dir):
                arquivos_na_cor = os.listdir(cor_dir)
                print(f"DEBUG: [LINK_UPGRADE_LINKS] Arquivos encontrados na cor {player_color_dir}: {arquivos_na_cor}")
                
                # Procurar TODAS as instâncias do filename
                for arquivo in arquivos_na_cor:
                    if arquivo == filename:
                        short_link_path = os.path.join(cor_dir, arquivo)
                        short_links_found.append(short_link_path)
                        print(f"DEBUG: [LINK_UPGRADE_LINKS] Short Link encontrado: {short_link_path}")
        
        # NOTA: Se há múltiplas cópias da mesma carta na Store (ex: 3x Equipment_7.png verdes)
        # elas aparecerão na lista. Para simular isto, podemos duplicar o path se necessário
        
        print(f"DEBUG: [LINK_UPGRADE_LINKS] Total de Short Links encontrados: {len(short_links_found)}")
        return short_links_found
    
    def _show_link_upgrade_fullscreen(self, short_link_path):
        """
        Mostra Short Link em fullscreen com botão roxo para confirmação de trade.
        """
        print(f"DEBUG: [LINK_UPGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(short_link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Short Link
        try:
            pil_img = Image.open(short_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para LINK UPGRADE
        def close_fullscreen():
            long_link_path = getattr(self, '_current_long_link_path', None)
            specific_id = getattr(self, '_current_specific_id', 1)
            if long_link_path and specific_id:
                self._show_link_upgrade_page(long_link_path, specific_id)
            else:
                self._voltar_dashboard_apos_link_upgrade()
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de confirmação (roxo, canto superior direito)
        def confirm_trade():
            self._show_link_trade_confirmation(short_link_path)
        
        confirm_btn = tk.Button(
            self,
            text="✓",
            font=("Helvetica", 24, "bold"),
            bg="#800080",
            fg="white",
            width=2,
            height=1,
            borderwidth=0,
            highlightthickness=0,
            command=confirm_trade,
            cursor="hand2",
            activebackground="#9900AA"
        )
        confirm_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [LINK_UPGRADE_FULLSCREEN] Fullscreen criado com botões")
    
    def _voltar_dashboard_apos_select_link(self):
        """Volta para o PlayerDashboard após SELECT LINK"""
        print("DEBUG: [SELECT_LINK] Voltando para PlayerDashboard")
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _show_link_trade_confirmation(self, short_link_path):
        """
        Overlay de confirmação final para o trade Link Upgrade.
        Usa o mesmo estilo do Link Upgrade Confirmation.
        """
        print(f"DEBUG: [LINK_TRADE_CONFIRMATION] Criando overlay de trade para: {os.path.basename(short_link_path)}")
        
        # Salvar referência do Short Link escolhido
        self._chosen_short_link_path = short_link_path
        
        # Limpar widgets (mesmo padrão do Link Upgrade Confirmation)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta Short Link como fundo
        try:
            pil_img = Image.open(short_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_TRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirmação (mesmo padrão)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título (mesmo padrão)
        tk.Label(confirm_frame, text="Link Trade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
         # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(short_link_path)
        
        # Mensagem de confirmação (mesmo padrão)
        tk.Label(confirm_frame, text=f"Short Link {specific_id} is going to be added \nto your inventory", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o botão (mesmo padrão)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo - mesmo padrão do Link Upgrade Confirmation)
        def confirmar_trade():
            print("DEBUG: [LINK_TRADE_CONFIRMATION] Trade confirmado - destruindo fullscreen e iniciando Fase 2")
            # CORREÇÃO: Destruir completamente a interface fullscreen antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_TRADE_CONFIRMATION] Interface fullscreen destruída - prosseguindo para detecção YOLO")
            self._executar_link_upgrade_phase_2()
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_trade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_TRADE_CONFIRMATION] Overlay de trade criado")
    
    def _executar_link_upgrade_phase_2(self):
        """
        Executa a Fase 2: detecção do Short Link novo + conclusão do upgrade.
        """
        short_link_path = getattr(self, '_chosen_short_link_path', '')
        long_link_path = getattr(self, '_current_long_link_path', '')
        specific_id = getattr(self, '_current_specific_id', 1)
        
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Iniciando Fase 2")
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Short Link: {os.path.basename(short_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object name do Short Link
            new_object_name = get_equipment_object_name(short_link_path, self.card_database)
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, new_object_name if new_object_name else f"short_link_{specific_id}")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_PHASE2] Loading screen criado - iniciando detecção")
                
                # Usar utilitários universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script não encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: completar upgrade sem YOLO
                    self._complete_link_upgrade()
                    return
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Executando: {script_path} {new_object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                process = subprocess.Popen([script_path, new_object_name])
                
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script iniciado (PID: {process.pid})")
                
                # Monitor de inicialização e conclusão
                def check_phase_2_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda está rodando - YOLO deve ter inicializado
                            print(f"DEBUG: [LINK_UPGRADE_PHASE2] YOLO inicializado - destruindo loading screen")
                            
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclusão
                            def check_phase_2_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detecção completa
                                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Detecção Fase 2 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Completar upgrade
                                        self._complete_link_upgrade()
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_2_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._complete_link_upgrade()
                            
                            self.after(1000, check_phase_2_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._complete_link_upgrade()
                    except Exception as e:
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro na inicialização: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._complete_link_upgrade()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_2_initialization)
            else:
                print("DEBUG: [LINK_UPGRADE_PHASE2] Erro ao criar loading screen - fallback direto")
                self._complete_link_upgrade()
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro: {e}")
            self._complete_link_upgrade()
    
    def _complete_link_upgrade(self):
        """
        Completa o processo de Link Upgrade: remove Long Link, adiciona Short Link.
        """
        long_link_path = getattr(self, '_current_long_link_path', '')
        short_link_path = getattr(self, '_chosen_short_link_path', '')
        
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Completando upgrade")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Removendo: {os.path.basename(long_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Adicionando: {os.path.basename(short_link_path)}")
        
        try:
            # Usar existing helper functions para completar trade
            success = self._perform_link_upgrade_database_transaction(long_link_path, short_link_path)
            
            if success:
                # Mostrar mensagem de sucesso e voltar ao dashboard
                self._show_upgrade_success_message()
            else:
                # Mostrar mensagem de erro
                self._show_upgrade_error_message()
                
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_COMPLETE] Erro ao completar upgrade: {e}")
            self._show_upgrade_error_message()
    
    def _perform_link_upgrade_database_transaction(self, long_link_path, short_link_path):
        """
        Executa a transação de base de dados para Link Upgrade: remove Long Link e adiciona Short Link.
        
        Args:
            long_link_path: Caminho para o Long Link a ser removido
            short_link_path: Caminho para o Short Link a ser adicionado
            
        Returns:
            bool: True se transação foi bem-sucedida, False caso contrário
        """
        try:
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Iniciando transação")
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link: {os.path.basename(long_link_path)}")
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link: {os.path.basename(short_link_path)}")
            
            # PASSO 1: Remover Long Link do inventário
            if long_link_path in self.inventario.get("equipments", []):
                self.inventario["equipments"].remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link removido do inventário")
            else:
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] AVISO: Long Link não encontrado no inventário")
            
            # PASSO 2: Remover Long Link dos ativos (se estiver ativo)
            if long_link_path in self.active_equipments:
                self.active_equipments.remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link removido dos ativos")
            
            # PASSO 3: Adicionar Short Link ao inventário
            # Verificar se já existe no inventário
            short_link_filename = os.path.basename(short_link_path)
            short_link_exists = any(
                os.path.basename(equipment_path) == short_link_filename 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not short_link_exists:
                self.inventario["equipments"].append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link adicionado ao inventário")
            else:
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link já existe no inventário")
            
            # PASSO 4: Ativar Short Link (carta fica virada para cima)
            if short_link_path not in self.active_equipments:
                self.active_equipments.append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Short Link adicionado aos ativos (carta virada para cima)")
            
            # PASSO 5: Devolver Long Link para a Store (se existir)
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(long_link_path, "equipments")
                    print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Long Link devolvido à Store")
                except Exception as store_e:
                    print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] ERRO ao devolver à Store: {store_e}")
            
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] Transação completa com sucesso")
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_TRANSACTION] ERRO na transação: {e}")
            return False
    
    def _show_upgrade_success_message(self):
        """
        Mostra mensagem de sucesso do Link Upgrade.
        """
        print("DEBUG: [LINK_UPGRADE_SUCCESS] Mostrando mensagem de sucesso")
        
        # Criar overlay
        overlay = tk.Toplevel(self)
        overlay.configure(bg="black")
        overlay.attributes("-alpha", 0.9)
        overlay.attributes("-fullscreen", True)
        overlay.attributes("-topmost", True)
        overlay.grab_set()
        overlay.focus_set()
        
        # Frame central
        frame = tk.Frame(overlay, bg="#1B5E20", relief="raised", bd=3, padx=30, pady=25)
        frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Título
        title = tk.Label(frame, text="Link Upgrade Completed!", 
                        font=("Helvetica", 24, "bold"), fg="white", bg="#1B5E20")
        title.pack(pady=(0, 20))
        
        # Mensagem
        msg = tk.Label(frame, text="Your Long Link has been\nsuccessfully upgraded to Short Link!", 
                      font=("Helvetica", 16), fg="white", bg="#1B5E20", justify="center")
        msg.pack(pady=(0, 25))
        
        # Botão OK
        def return_dashboard():
            print("DEBUG: [LINK_UPGRADE_SUCCESS] Voltando para PlayerDashboard")
            overlay.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        ok_btn = tk.Button(frame, text="Continue", font=("Helvetica", 16, "bold"), 
                          bg="#4CAF50", fg="white", width=15, height=2,
                          command=return_dashboard)
        ok_btn.pack()
        
        # Auto-close após 3 segundos
        self.after(3000, return_dashboard)
    
    def _show_upgrade_error_message(self):
        """
        Mostra mensagem de erro do Link Upgrade.
        """
        print("DEBUG: [LINK_UPGRADE_ERROR] Mostrando mensagem de erro")
        
        # Criar overlay
        overlay = tk.Toplevel(self)
        overlay.configure(bg="black")
        overlay.attributes("-alpha", 0.9)
        overlay.attributes("-fullscreen", True)
        overlay.attributes("-topmost", True)
        overlay.grab_set()
        overlay.focus_set()
        
        # Frame central
        frame = tk.Frame(overlay, bg="#B71C1C", relief="raised", bd=3, padx=30, pady=25)
        frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Título
        title = tk.Label(frame, text="Link Upgrade Failed", 
                        font=("Helvetica", 24, "bold"), fg="white", bg="#B71C1C")
        title.pack(pady=(0, 20))
        
        # Mensagem
        msg = tk.Label(frame, text="There was an error processing\nyour Link Upgrade. Please try again.", 
                      font=("Helvetica", 16), fg="white", bg="#B71C1C", justify="center")
        msg.pack(pady=(0, 25))
        
        # Botão OK
        def return_dashboard():
            print("DEBUG: [LINK_UPGRADE_ERROR] Voltando para PlayerDashboard")
            overlay.destroy()
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        ok_btn = tk.Button(frame, text="Back to Dashboard", font=("Helvetica", 16, "bold"), 
                          bg="#F44336", fg="white", width=18, height=2,
                          command=return_dashboard)
        ok_btn.pack()
    
    def _voltar_dashboard_apos_link_upgrade(self):
        """Volta para o PlayerDashboard após LINK UPGRADE"""
        print("DEBUG: [LINK_UPGRADE] Voltando para PlayerDashboard")
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _find_long_link_by_specific_id(self, specific_id):
        """
        Encontra Long Link no inventário com specific_id correspondente.
        Usa a base de dados integrada para determinar dinamicamente o equipment_id.
        """
        print(f"DEBUG: [LINK_UPGRADE_SEARCH] Procurando Long Link com specific_id {specific_id}")
        
        if not self.card_database:
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Base de dados não disponível - usando fallback")
            return self._find_long_link_fallback(specific_id)
        
        try:
            # Obter cor do jogador para construir equipment_id
            player_color = self.player_color.lower()
            equipment_id = f"long_link_{specific_id}_{player_color}"
            
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Procurando equipment_id: {equipment_id}")
            
            # Verificar se existe na base de dados
            equipment_card = self.card_database.get_equipment(equipment_id)
            if not equipment_card:
                print(f"DEBUG: [LINK_UPGRADE_SEARCH] Equipment {equipment_id} não encontrado na base de dados")
                return None
            
            # Procurar no inventário do jogador
            equipments_inventory = self.inventario.get("equipments", [])
            
            for equipment_path in equipments_inventory:
                # Verificar se o caminho corresponde ao Long Link procurado
                if self._is_long_link_with_specific_id(equipment_path, specific_id):
                    print(f"DEBUG: [LINK_UPGRADE_SEARCH] ENCONTRADO: {os.path.basename(equipment_path)}")
                    return equipment_path
            
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Long Link com specific_id {specific_id} não encontrado no inventário")
            return None
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_SEARCH] Erro: {e}")
            return None
    
    def _check_short_link_exists_by_specific_id(self, specific_id):
        """
        Verifica se já existe Short Link no inventário com specific_id correspondente.
        """
        print(f"DEBUG: [LINK_UPGRADE_CHECK] Verificando Short Link com specific_id {specific_id}")
        
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_short_link_with_specific_id(equipment_path, specific_id):
                print(f"DEBUG: [LINK_UPGRADE_CHECK] CONFLITO: {os.path.basename(equipment_path)} já existe")
                return True
        
        print(f"DEBUG: [LINK_UPGRADE_CHECK] Short Link com specific_id {specific_id} não existe - upgrade possível")
        return False
    
    def _is_long_link_with_specific_id(self, equipment_path, specific_id):
        """
        Verifica se um caminho de equipment corresponde a Long Link com specific_id.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        # Long Link: Equipment_10.png (id=1), Equipment_11.png (id=2), Equipment_12.png (id=3)
        long_link_mapping = {
            "Equipment_10.png": 1,
            "Equipment_11.png": 2, 
            "Equipment_12.png": 3
        }
        
        return long_link_mapping.get(filename) == specific_id
    
    def _is_short_link_with_specific_id(self, equipment_path, specific_id):
        """
        Verifica se um caminho de equipment corresponde a Short Link com specific_id.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        # Short Link: Equipment_7.png (id=1), Equipment_8.png (id=2), Equipment_9.png (id=3)
        short_link_mapping = {
            "Equipment_7.png": 1,
            "Equipment_8.png": 2,
            "Equipment_9.png": 3
        }
        
        return short_link_mapping.get(filename) == specific_id
    
    def _find_long_link_fallback(self, specific_id):
        """
        Fallback para encontrar Long Link quando base de dados não está disponível.
        """
        # Mapeamento fallback baseado nos filenames
        long_link_files = {
            1: "Equipment_10.png",
            2: "Equipment_11.png", 
            3: "Equipment_12.png"
        }
        
        if specific_id not in long_link_files:
            return None
        
        target_filename = long_link_files[specific_id]
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if os.path.basename(equipment_path) == target_filename:
                return equipment_path
        
        return None
    
    def _get_equipment_specific_id_from_path(self, equipment_path):
        """
        Obtém o specific_id de um equipment baseado no seu caminho.
        """
        filename = os.path.basename(equipment_path)
        
        # Mapeamento Equipment_X.png -> specific_id
        equipment_mapping = {
            # Small Router
            "Equipment_1.png": 1, "Equipment_2.png": 2, "Equipment_3.png": 3,
            # Medium Router  
            "Equipment_4.png": 1, "Equipment_5.png": 2, "Equipment_6.png": 3,
            # Short Link
            "Equipment_7.png": 1, "Equipment_8.png": 2, "Equipment_9.png": 3,
            # Long Link
            "Equipment_10.png": 1, "Equipment_11.png": 2, "Equipment_12.png": 3
        }
        
        return equipment_mapping.get(filename)
    
    def _get_equipment_info_from_path(self, equipment_path):
        """
        Obtém informações detalhadas de um equipment baseado no seu caminho.
        """
        filename = os.path.basename(equipment_path)
        specific_id = self._get_equipment_specific_id_from_path(equipment_path)
        
        if not specific_id:
            return None
        
        # Determinar tipo baseado no filename
        if filename in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]:
            equipment_type = "small_router"
        elif filename in ["Equipment_4.png", "Equipment_5.png", "Equipment_6.png"]:
            equipment_type = "medium_router"
        elif filename in ["Equipment_7.png", "Equipment_8.png", "Equipment_9.png"]:
            equipment_type = "short_link"
        elif filename in ["Equipment_10.png", "Equipment_11.png", "Equipment_12.png"]:
            equipment_type = "long_link"
        else:
            return None
        
        return {
            "filename": filename,
            "equipment_type": equipment_type,
            "specific_id": specific_id,
            "path": equipment_path
        }
    
    def _get_corresponding_short_link_info(self, specific_id):
        """
        Obtém informações do Short Link correspondente baseado no specific_id.
        """
        # Mapeamento specific_id -> filename do Short Link
        short_link_mapping = {
            1: "Equipment_7.png",
            2: "Equipment_8.png", 
            3: "Equipment_9.png"
        }
        
        filename = short_link_mapping.get(specific_id)
        if not filename:
            return None
        
        return {
            "filename": filename,
            "equipment_type": "short_link", 
            "specific_id": specific_id
        }

    def _show_equipment_inventory_for_link_upgrade(self):
        """Abre inventário de equipamentos especificamente para LINK UPGRADE"""
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Criando inventário específico para LINK UPGRADE")
        
        # Definir contexto específico
        self._in_link_upgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_UPGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_UPGRADE_INVENTORY] SUCCESS: Inventário específico para LINK UPGRADE criado")

    def _executar_link_upgrade(self, long_link_path, link_id):
        """Executa o processo de LINK UPGRADE com detecção YOLO em duas fases (igual ao ROUTER UPGRADE)"""
        print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Executando upgrade: {os.path.basename(long_link_path)}")
        
        try:
            # Sistema flexível baseado no specific_id da base de dados
            long_link_specific_id = self._get_equipment_specific_id_from_path(long_link_path)
            
            if long_link_specific_id != link_id:
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: specific_id {long_link_specific_id} não corresponde ao link_id {link_id}")
                return
            
            # Obter informações do Long Link da base de dados
            long_link_info = self._get_equipment_info_from_path(long_link_path)
            
            # Calcular Short Link correspondente (mesmo specific_id, diferente tipo)
            short_link_info = self._get_corresponding_short_link_info(link_id)
            
            if not long_link_info or not short_link_info:
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: Não foi possível obter informações dos equipments")
                return
            
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Upgrade: {long_link_info['filename']} -> {short_link_info['filename']}")
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Long Link specific_id: {long_link_specific_id}")
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Short Link specific_id: {link_id}")
            
            # NOVA LÓGICA: Executar detecção em duas fases antes de processar upgrade
            # Fase 1: Detectar Long Link (objeto atual)
            # Fase 2: Detectar Short Link (objeto de destino)
            
            # Obter object names para detecção ANTES de criar loading screen
            old_object_name = get_equipment_object_name(long_link_path, self.card_database)
            
            # Criar loading screen inicial com object name real
            loading_window = create_yolo_loading_screen(self, old_object_name if old_object_name else "ligacao_longa_vermelha")
            
            if loading_window:
                print("DEBUG: [LINK_UPGRADE_EXECUTE] Loading screen criado - iniciando detecção duas fases")
                
                # Construir caminho para Short Link (usar mesmo diretório do Long Link)
                short_link_filename = short_link_info['filename']
                short_link_path = os.path.join(os.path.dirname(long_link_path), short_link_filename)
                new_object_name = get_equipment_object_name(short_link_path, self.card_database)
                
                old_equipment_name = f"Long Link {link_id}"
                new_equipment_name = f"Short Link {link_id}"
                
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] Old object: {old_object_name}")
                print(f"DEBUG: [LINK_UPGRADE_EXECUTE] New object: {new_object_name}")
                
                if old_object_name and new_object_name:
                    # Executar detecção em duas fases
                    success = self._execute_two_phase_detection_for_link_upgrade(
                        old_object_name, new_object_name, loading_window, 
                        old_equipment_name, new_equipment_name, long_link_path, link_id
                    )
                    
                    if success:
                        print("DEBUG: [LINK_UPGRADE_EXECUTE] SUCCESS: Detecção duas fases iniciada")
                        # Processamento será continuado após detecção bem-sucedida
                        return
                    else:
                        print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: Falha ao iniciar detecção duas fases")
                        if loading_window:
                            loading_window.destroy()
                else:
                    print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: Não foi possível obter object names")
                    if loading_window:
                        loading_window.destroy()
            else:
                print("DEBUG: [LINK_UPGRADE_EXECUTE] ERRO: Não foi possível criar loading screen")
            
            # Fallback: se detecção falhar, processar diretamente (desenvolvimento)
            print("DEBUG: [LINK_UPGRADE_EXECUTE] Fallback: processando upgrade diretamente")
            self._processar_link_upgrade_completo(long_link_path, link_id)
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_EXECUTE] ERRO durante upgrade: {e}")
            # Limpar flags em caso de erro
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None

    def _execute_two_phase_detection_for_link_upgrade(self, old_object_name, new_object_name, loading_window, 
                                                     old_equipment_name, new_equipment_name, long_link_path, link_id):
        """
        Executa detecção YOLO em duas fases para LINK UPGRADE:
        Fase 1: Detectar Long Link (objeto atual)
        Fase 2: Detectar Short Link (objeto de destino)
        """
        try:
            # Usar os utilitários universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print("DEBUG: [LINK_UPGRADE_2PHASE] Ambiente não é Raspberry Pi - usando fallback")
                if loading_window:
                    loading_window.destroy()
                # Processar upgrade diretamente no desenvolvimento
                self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                print(f"DEBUG: [LINK_UPGRADE_2PHASE] Script não encontrado: {script_path}")
                if loading_window:
                    loading_window.destroy()
                # Fallback: processar diretamente
                self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
                return False
            
            print(f"DEBUG: [LINK_UPGRADE_2PHASE] Script encontrado: {script_path}")
            
            # Iniciar Fase 1: Detectar Long Link
            success = self._start_phase_1_detection_link_upgrade(
                script_path, old_object_name, new_object_name, loading_window,
                old_equipment_name, new_equipment_name, long_link_path, link_id
            )
            
            return success
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_2PHASE] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            # Fallback: processar diretamente
            self.after(1000, lambda: self._processar_link_upgrade_completo(long_link_path, link_id))
            return False

    def _start_phase_1_detection_link_upgrade(self, script_path, old_object_name, new_object_name, loading_window, 
                                             old_equipment_name, new_equipment_name, long_link_path, link_id):
        """Inicia a Fase 1 da detecção: Long Link"""
        try:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Iniciando Fase 1: {old_object_name}")
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Executando: {script_path} {old_object_name}")
            
            # Executar script para primeira detecção
            process = subprocess.Popen([script_path, old_object_name])
            
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Script Fase 1 iniciado (PID: {process.pid})")
            
            # Monitorar inicialização da Fase 1 (igual ao ROUTER UPGRADE)
            def check_phase_1_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 1 inicializado - fechar loading screen atual
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fechando loading screen Fase 1 - YOLO inicializando")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão da Fase 1
                        def check_phase_1_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_1_completion)
                            else:
                                print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fase 1 completa - iniciando Fase 2")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Iniciar Fase 2
                                self._start_phase_2_detection_link_upgrade(
                                    script_path, new_object_name, new_equipment_name, long_link_path, link_id
                                )
                        
                        self.after(1000, check_phase_1_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [LINK_UPGRADE_PHASE1] Fase 1 terminou inesperadamente")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        # Fallback: processar diretamente
                        self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro no monitor: {e}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: processar diretamente
                    self._processar_link_upgrade_completo(long_link_path, link_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_1_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE1] Erro: {e}")
            return False

    def _start_phase_2_detection_link_upgrade(self, script_path, new_object_name, new_equipment_name, 
                                             long_link_path, link_id):
        """Inicia a Fase 2 da detecção: Short Link"""
        try:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Iniciando Fase 2: {new_object_name}")
            
            # Criar loading screen para Fase 2
            phase_2_loading = create_yolo_loading_screen(self, new_object_name)
            
            if not phase_2_loading:
                print(f"DEBUG: [LINK_UPGRADE_PHASE2] ERRO: Não foi possível criar loading screen Fase 2")
                self._processar_link_upgrade_completo(long_link_path, link_id)
                return
                
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Loading screen Fase 2 criado para: {new_object_name}")
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Executando: {script_path} {new_object_name}")
            
            # Executar script para segunda detecção
            process = subprocess.Popen([script_path, new_object_name])
            
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Script Fase 2 iniciado (PID: {process.pid})")
            
            # Monitorar inicialização da Fase 2 (igual ao ROUTER UPGRADE)
            def check_phase_2_initialization():
                try:
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO Fase 2 inicializado - fechar loading screen atual
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fechando loading screen Fase 2 - YOLO inicializando")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão da Fase 2
                        def check_phase_2_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_phase_2_completion)
                            else:
                                print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fase 2 completa - processando upgrade")
                                self.deiconify()  # Mostrar interface Python novamente
                                # Processar upgrade completo
                                self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                        self.after(1000, check_phase_2_completion)
                    else:
                        # Script terminou antes de inicializar
                        print(f"DEBUG: [LINK_UPGRADE_PHASE2] Fase 2 terminou inesperadamente")
                        if phase_2_loading and phase_2_loading.winfo_exists():
                            phase_2_loading.destroy()
                        # Fallback: processar diretamente
                        self._processar_link_upgrade_completo(long_link_path, link_id)
                        
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro no monitor: {e}")
                    if phase_2_loading and phase_2_loading.winfo_exists():
                        phase_2_loading.destroy()
                    # Fallback: processar diretamente
                    self._processar_link_upgrade_completo(long_link_path, link_id)
            
            # Aguardar 4.5 segundos para YOLO inicializar (igual ao ROUTER UPGRADE)
            self.after(4500, check_phase_2_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_PHASE2] Erro: {e}")
            return False

    def _processar_link_upgrade_completo(self, long_link_path, link_id):
        """
        Processa efetivamente o LINK UPGRADE após detecção bem-sucedida.
        Remove Long Link e adiciona Short Link correspondente (ativo).
        """
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Processando upgrade completo")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Long Link: {os.path.basename(long_link_path)}")
        print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Link ID: {link_id}")
        
        try:
            # Sistema flexível baseado no specific_id
            long_link_info = self._get_equipment_info_from_path(long_link_path)
            short_link_info = self._get_corresponding_short_link_info(link_id)
            
            if not long_link_info or not short_link_info:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO: Não foi possível obter informações dos equipments")
                return
            
            long_link_file = long_link_info['filename']
            short_link_file = short_link_info['filename']
            
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Sistema flexível: {long_link_file} -> {short_link_file}")
            
            # PASSO 1: Remover Long Link do inventário
            if long_link_path in self.inventario.get("equipments", []):
                self.inventario["equipments"].remove(long_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {long_link_file} removido do inventário")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] AVISO: {long_link_file} não encontrado no inventário")
            
            # PASSO 2: Adicionar Short Link ao inventário (usar mesmo diretório)
            short_link_path = os.path.join(os.path.dirname(long_link_path), short_link_file)
            
            # Verificar se já existe no inventário
            short_link_exists = any(
                os.path.basename(equipment_path) == short_link_file 
                for equipment_path in self.inventario.get("equipments", [])
            )
            
            if not short_link_exists:
                self.inventario["equipments"].append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} adicionado ao inventário")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} já existe no inventário")
            
            # PASSO 3: CORREÇÃO CRÍTICA - Ativar Short Link (diferente da lógica anterior)
            # Adicionar Short Link aos equipments ativos para que fique virado para cima
            if short_link_path not in self.active_equipments:
                self.active_equipments.append(short_link_path)
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] CORREÇÃO: {short_link_file} adicionado aos ativos (carta fica virada para cima)")
            else:
                print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {short_link_file} já está nos ativos")
            
            # PASSO 4: Enviar Long Link para a Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(long_link_path, "equipments", "neutral")
                    print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Long Link enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Erro ao enviar Long Link para Store: {e}")
            
            # PASSO 5: Limpar flags de contexto
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None
            
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] SUCCESS: Link Upgrade aplicado com sucesso!")
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] {long_link_file} -> {short_link_file} (ATIVO)")
            
            # PASSO 6: Voltar IMEDIATAMENTE para o PlayerDashboard após processamento completo
            # (Sem delay para evitar qualquer display intermediário indesejado)
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] Voltando diretamente ao PlayerDashboard")
            self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            )
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO durante processamento: {e}")
            # Limpar flags em caso de erro
            self._in_link_upgrade_context = False
            self._link_upgrade_target_id = None
            
            # Voltar para dashboard mesmo em caso de erro
            print(f"DEBUG: [LINK_UPGRADE_COMPLETO] ERRO - Voltando diretamente ao PlayerDashboard")
            self.playerdashboard_interface(
                self.player_name, self.saldo, self.other_players
            )

    def _aplicar_link_downgrade(self, router_id):
        """
        Aplica o efeito LINK DOWNGRADE baseado no router_id.
        Similar ao LINK UPGRADE mas inverso: Short Link (inventário) → Long Link (Store)
        """
        print(f"DEBUG: [LINK_DOWNGRADE] Iniciando Link Downgrade para Router ID: {router_id}")
        
        if router_id is None:
            print(f"DEBUG: [LINK_DOWNGRADE] Router ID é None - cancelando")
            return
        
        # Mapear router_id para specific_id (mesmo mapeamento do LINK UPGRADE)
        specific_id = router_id  # router_id 1 -> specific_id 1, etc.
        
        print(f"DEBUG: [LINK_DOWNGRADE] Router ID {router_id} -> Specific ID {specific_id}")
        
        # Verificar se há Short Links com specific_id correspondente no inventário do jogador
        short_links_available = self._get_short_links_by_specific_id_from_inventory(specific_id)
        
        if not short_links_available:
            print(f"DEBUG: [LINK_DOWNGRADE] Nenhum Short Link com specific_id {specific_id} encontrado no inventário")
            print(f"DEBUG: [LINK_DOWNGRADE] LINK DOWNGRADE requer Short Links no inventário do jogador")
            return
        
        # CORREÇÃO: Verificar se pelo menos um Short Link está ATIVO
        active_short_links = [link for link in short_links_available if link in self.active_equipments]
        
        if not active_short_links:
            print(f"DEBUG: [LINK_DOWNGRADE] ERRO: Short Link com specific_id {specific_id} existe mas NÃO está ativo")
            print(f"DEBUG: [LINK_DOWNGRADE] Short Links encontrados: {[os.path.basename(link) for link in short_links_available]}")
            print(f"DEBUG: [LINK_DOWNGRADE] Equipments ativos: {[os.path.basename(eq) for eq in self.active_equipments]}")
            print(f"DEBUG: [LINK_DOWNGRADE] Para usar LINK DOWNGRADE, o Short Link deve estar ativo (carta virada para cima)")
            return
        
        print(f"DEBUG: [LINK_DOWNGRADE] Short Links ativos encontrados: {len(active_short_links)}")
        print(f"DEBUG: [LINK_DOWNGRADE] {len(short_links_available)} Short Link(s) encontrado(s)")
        
        # Definir contexto de LINK DOWNGRADE
        self._in_link_downgrade_context = True
        self._link_downgrade_target_id = router_id
        
        # Ir para página SELECT LINK (mas com Short Links em vez de Long Links)
        self._show_select_short_link_page(router_id)
    
    def _get_short_links_by_specific_id_from_inventory(self, specific_id):
        """
        Obtém todos os Short Links no inventário com specific_id correspondente.
        Similar ao _get_long_links_by_specific_id mas para Short Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_SELECT] Procurando Short Links com specific_id {specific_id}")
        
        short_links_found = []
        equipments_inventory = self.inventario.get("equipments", [])
        
        for equipment_path in equipments_inventory:
            if self._is_short_link_with_specific_id(equipment_path, specific_id):
                short_links_found.append(equipment_path)
        
        print(f"DEBUG: [LINK_DOWNGRADE_SELECT] Encontrados {len(short_links_found)} Short Links")
        return short_links_found
    
    def _show_select_short_link_page(self, router_id):
        """
        Cria página SELECT LINK para Short Links (inverso da página Long Links).
        Layout idêntico mas com Short Links em vez de Long Links.
        """
        print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Criando página SELECT LINK para Short Links - Router ID {router_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar do jogador
        try:
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            if os.path.exists(topbar_img_path):
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                topbar_label.image = topbar_img
                topbar_label.pack(side="top", fill="x")
                topbar_label._is_topbar = True
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] TopBar do jogador {self.player_color} carregado")
            else:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] TopBar não encontrado, usando fallback")
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar TopBar: {e}")
        
        # Nome do jogador (igual ao inventário original - fundo da cor do jogador e texto preto)
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título da página
        title = tk.Label(self, text="SELECT LINK", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Short Links com specific_id correspondente
        short_links = self._get_short_links_by_specific_id_from_inventory(router_id)
        
        if not short_links:
            # Mensagem se não há Short Links disponíveis
            no_links_msg = tk.Label(self, text="No Short Links available for downgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Botão de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para múltiplos Short Links
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padrão
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necessário
        for idx, link_path in enumerate(short_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta (vai para confirmação de downgrade)
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_select_short_link_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior do jogador
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] BelowBar do jogador {self.player_color} carregado")
            else:
                print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] BelowBar não encontrado, usando fallback")
                belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_PAGE] Erro ao carregar BelowBar: {e}")
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [SELECT_SHORT_LINK_PAGE] SUCCESS: Página SELECT LINK (Short Links) criada")
    
    def _show_select_short_link_fullscreen(self, link_path):
        """
        Mostra Short Link em fullscreen com botão roxo para confirmação de downgrade.
        """
        print(f"DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] Mostrando fullscreen: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Short Link
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para SELECT LINK
        def close_fullscreen():
            router_id = getattr(self, '_link_downgrade_target_id', 1)
            self._show_select_short_link_page(router_id)
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão ROXO (canto superior direito) - confirma downgrade
        def confirm_downgrade():
            self._show_link_downgrade_confirmation(link_path)
        
        purple_btn = tk.Button(
            self, 
            text="✓", 
            font=("Helvetica", 24, "bold"), 
            bg="#800080", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=confirm_downgrade, 
            cursor="hand2", 
            activebackground="#9900AA"
        )
        purple_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [SELECT_SHORT_LINK_FULLSCREEN] SUCCESS: Fullscreen criado com botões")
    
    def _show_link_downgrade_confirmation(self, link_path):
        """
        Mostra overlay de confirmação Link Downgrade Confirmation.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Mostrando confirmação para: {os.path.basename(link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            pil_img = Image.open(link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirmação
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(link_path)
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text=f"Short Link {specific_id} is going to be downgraded", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o botão
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo)
        def confirmar_downgrade():
            print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Downgrade confirmado - destruindo interface e iniciando Fase 1")
            # Salvar Short Link path para uso posterior
            self._link_downgrade_short_link_path = link_path
            # Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Interface destruída - prosseguindo para detecção YOLO")
            self._executar_link_downgrade_phase_1(link_path, specific_id)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_downgrade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_DOWNGRADE_CONFIRMATION] Overlay de confirmação criado")
    
    def _executar_link_downgrade_phase_1(self, short_link_path, specific_id):
        """
        Phase 1 de LINK DOWNGRADE: Detectar Short Link atual.
        Após detecção, vai para página LINK DOWNGRADE com Long Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Iniciando Phase 1 para Short Link: {os.path.basename(short_link_path)}")
        
        try:
            # Obter object_name do Short Link para detecção YOLO
            if self.card_database:
                object_name = get_equipment_object_name(short_link_path, self.card_database)
                
                if not object_name:
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Nenhum object_name encontrado - fallback direto")
                    self._show_link_downgrade_page(short_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Object name para detecção: {object_name}")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Base de dados não disponível - fallback direto")
                self._show_link_downgrade_page(short_link_path, specific_id)
                return
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print("DEBUG: [LINK_DOWNGRADE_PHASE1] Loading screen criado - iniciando detecção")
                
                # Usar utilitários universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Script não encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    self._show_link_downgrade_page(short_link_path, specific_id)
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Executando: {script_path} {object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                subprocess.run(['chmod', '+x', script_path], check=True)
                process = subprocess.Popen([script_path, object_name])
                
                # Monitor de inicialização (aguardar YOLO carregar)
                def check_phase_1_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda rodando - YOLO inicializado com sucesso
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] YOLO inicializado - destruindo loading")
                            
                            # Destruir loading screen
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclusão
                            def check_phase_1_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detecção completa
                                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Detecção Phase 1 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Ir para página LINK DOWNGRADE
                                        self._show_link_downgrade_page(short_link_path, specific_id)
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_1_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._show_link_downgrade_page(short_link_path, specific_id)
                            
                            self.after(1000, check_phase_1_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._show_link_downgrade_page(short_link_path, specific_id)
                    except Exception as e:
                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro na inicialização: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._show_link_downgrade_page(short_link_path, specific_id)
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_1_initialization)
            else:
                print("DEBUG: [LINK_DOWNGRADE_PHASE1] Erro ao criar loading screen - fallback direto")
                self._show_link_downgrade_page(short_link_path, specific_id)
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PHASE1] Erro: {e}")
            self._show_link_downgrade_page(short_link_path, specific_id)
    
    def _show_link_downgrade_page(self, short_link_path, specific_id):
        """
        Cria página LINK DOWNGRADE para escolher Long Link.
        Inverso da página LINK UPGRADE: título "LINK DOWNGRADE" e Long Links da Store.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Criando página LINK DOWNGRADE para specific_id {specific_id}")
        
        # Salvar estado da interface
        self._save_dashboard_state()
        
        # Limpar widgets (exceto TopBar)
        for widget in self.winfo_children():
            if hasattr(widget, '_is_topbar') and widget._is_topbar:
                continue
            widget.destroy()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar igual à Store - usar awning da Store
        try:
            awning_img_path = os.path.join(IMG_DIR, "Store_awning_v3.png")
            if os.path.exists(awning_img_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_img_path).resize((screen_width, 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                awning_label._is_topbar = True
                
                # Label pequeno à esquerda do logo (igual à Store)
                left_label = tk.Label(self, text="••••", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                left_label.place(relx=0.46, y=10, anchor="center")
                
                # Logo NetMaster posicionado independentemente (igual à Store)
                try:
                    logo_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "logo_netmaster_store.png")).resize((20, 20)))
                    logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                    logo_lbl.image = logo_img
                    logo_lbl.place(relx=0.5, y=10, anchor="center")
                except Exception as e:
                    print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar logo: {e}")
                
                # Label largo à direita do logo para cobrir área amarela (igual à Store)
                right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
                right_logo_label.place(relx=0.53, y=10, anchor="w")
                
                # Label adicional para garantir cobertura completa (igual à Store)
                extra_cover_label = tk.Label(self, text="     ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
                extra_cover_label.place(relx=0.55, y=10, anchor="w")
                
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] TopBar da Store aplicado com sucesso")
                
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Store awning não encontrado, usando fallback")
                # Criar TopBar fallback
                topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                topbar_frame.pack(pady=(0, 10), fill="x")
                topbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao criar TopBar da Store: {e}")
            # Criar TopBar fallback em caso de erro
            topbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            topbar_frame.pack(pady=(0, 10), fill="x")
            topbar_frame.pack_propagate(False)
        
        # Texto "Store" posicionado independentemente (igual à Store)
        store_name_lbl = tk.Label(self, text="Store", 
                                 font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        store_name_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno à direita do nome Store (igual à Store original)
        right_store_label = tk.Label(self, text="•", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_store_label.place(relx=0.6, y=30, anchor="center")
        
        # Título da página - LINK DOWNGRADE (em vez de LINK UPGRADE)
        title = tk.Label(self, text="LINK DOWNGRADE", font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Obter Long Links para downgrade (da Store da cor do jogador)
        long_links = self._get_long_links_for_downgrade(specific_id)
        
        if not long_links:
            # Mensagem se não há Long Links disponíveis
            no_links_msg = tk.Label(self, text="No Long Links available for downgrade", 
                                   font=("Helvetica", 18), fg="red", bg="black")
            no_links_msg.place(relx=0.5, rely=0.5, anchor="center")
            
            # Botão de volta
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 16), 
                               bg="#AAAAAA", fg="white", width=10, height=2,
                               command=self._voltar_dashboard_apos_select_link)
            back_btn.place(relx=0.5, rely=0.7, anchor="center")
            return
        
        # Layout grid 2xn para múltiplos Long Links
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 85, 120  # Tamanho padrão
        
        # Grid 2xn - sempre 2 colunas, n linhas conforme necessário
        for idx, link_path in enumerate(long_links):
            row = idx // 2
            col = idx % 2
            
            try:
                # Carregar e redimensionar imagem
                pil_img = Image.open(link_path)
                pil_img = pil_img.resize((card_w, card_h), Image.Resampling.LANCZOS)
                card_img = ImageTk.PhotoImage(pil_img)
                
                # Criar label da carta
                card_lbl = tk.Label(matriz_frame, image=card_img, cursor="hand2", bg="black")
                card_lbl.image = card_img
                card_lbl.grid(row=row, column=col, padx=10, pady=10)
                
                # Bind para clique na carta
                card_lbl.bind("<Button-1>", lambda e, path=link_path: self._show_link_downgrade_fullscreen(path))
                
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar carta {os.path.basename(link_path)}: {e}")
        
        # Barra inferior da Store (igual à página LINK UPGRADE)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, "BelowBar_store.png")
            if os.path.exists(belowbar_img_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] BelowBar_store carregado")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PAGE] BelowBar_store não encontrado, usando fallback")
                belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
                belowbar_frame.pack(side="bottom", fill="x")
                belowbar_frame.pack_propagate(False)
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PAGE] Erro ao carregar BelowBar_store: {e}")
            belowbar_frame = tk.Frame(self, bg="#DC8392", height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        print("DEBUG: [LINK_DOWNGRADE_PAGE] SUCCESS: Página LINK DOWNGRADE criada")
    
    def _get_long_links_for_downgrade(self, specific_id):
        """
        Obtém cartas Long Link da COR DO JOGADOR com specific_id correspondente na Store.
        Inverso do _get_short_links_for_upgrade: procura Long Links em vez de Short Links.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Obtendo Long Links da cor '{self.player_color}' para specific_id {specific_id}")
        
        # Obter informações do Long Link baseado no specific_id
        long_link_info = self._get_corresponding_long_link_info(specific_id)
        
        if not long_link_info:
            print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Nenhum Long Link correspondente encontrado")
            return []
        
        long_links_found = []
        filename = long_link_info['filename']
        
        # Usar utilitários universais para detectar caminhos
        universal_paths = get_universal_paths()
        base_dir = universal_paths['base_dir']
        
        # Mapear cor do jogador para nome do diretório (primeira letra maiúscula)
        player_color_dir = self.player_color.capitalize()  # red -> Red, blue -> Blue, etc.
        
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Procurando {filename} na cor {player_color_dir}...")
        
        # Possíveis bases para busca
        possivel_bases = [base_dir]
        
        # Para cada base possível, buscar Long Links
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                continue
                
            # Testar estruturas de diretórios (similar ao _obter_equipments_da_store)
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (minúscula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (maiúscula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Usando estrutura: {equipments_base}")
                    break
            
            if not equipments_base:
                continue
                
            # Buscar Long Links APENAS na cor do jogador
            cor_dir = os.path.join(equipments_base, player_color_dir)
            if not os.path.exists(cor_dir):
                print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Diretório da cor {player_color_dir} não existe: {cor_dir}")
                continue
                
            # Procurar TODAS as cartas com o filename da cor do jogador
            print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Procurando em: {cor_dir}")
            
            # Listar todos os arquivos no diretório da cor do jogador
            if os.path.isdir(cor_dir):
                arquivos_na_cor = os.listdir(cor_dir)
                print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Arquivos encontrados na cor {player_color_dir}: {arquivos_na_cor}")
                
                # Procurar TODAS as instâncias do filename
                for arquivo in arquivos_na_cor:
                    if arquivo == filename:
                        long_link_path = os.path.join(cor_dir, arquivo)
                        long_links_found.append(long_link_path)
                        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Long Link encontrado: {long_link_path}")
        
        print(f"DEBUG: [LINK_DOWNGRADE_LINKS] Total de Long Links encontrados: {len(long_links_found)}")
        return long_links_found
    
    def _get_corresponding_long_link_info(self, specific_id):
        """
        Obtém informações do Long Link correspondente ao specific_id.
        Inverso do _get_corresponding_short_link_info.
        """
        # Mapeamento: specific_id -> Long Link filename
        mapping = {
            1: "Equipment_10.png",  # Long Link 1
            2: "Equipment_11.png",  # Long Link 2
            3: "Equipment_12.png",  # Long Link 3
        }
        
        filename = mapping.get(specific_id)
        if filename:
            return {'filename': filename, 'specific_id': specific_id}
        return None
    
    def _show_link_downgrade_fullscreen(self, long_link_path):
        """
        Mostra Long Link em fullscreen com botão roxo para confirmação de trade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_FULLSCREEN] Mostrando fullscreen: {os.path.basename(long_link_path)}")
        
        # Limpar widgets
        for widget in self.winfo_children():
            widget.destroy()
        
        # Carregar e exibir imagem do Long Link
        try:
            pil_img = Image.open(long_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            card_img = ImageTk.PhotoImage(pil_img)
            card_lbl = tk.Label(self, image=card_img, bg="black")
            card_lbl.image = card_img
            card_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_FULLSCREEN] Erro ao carregar imagem: {e}")
        
        # Botão X (cinzento, canto superior esquerdo) - volta para LINK DOWNGRADE
        def close_fullscreen():
            router_id = getattr(self, '_link_downgrade_target_id', 1)
            specific_id = router_id
            short_link_path = getattr(self, '_link_downgrade_source_path', None)
            self._show_link_downgrade_page(short_link_path, specific_id)
        
        x_btn = tk.Button(
            self, 
            text="✖", 
            font=("Helvetica", 24, "bold"), 
            bg="#AAAAAA", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=close_fullscreen, 
            cursor="hand2", 
            activebackground="#CCCCCC"
        )
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão ROXO (canto superior direito) - confirma trade
        def confirm_trade():
            self._show_link_downgrade_trade_confirmation(long_link_path)
        
        purple_btn = tk.Button(
            self, 
            text="✓", 
            font=("Helvetica", 24, "bold"), 
            bg="#800080", 
            fg="white", 
            width=2, 
            height=1, 
            borderwidth=0, 
            highlightthickness=0, 
            command=confirm_trade, 
            cursor="hand2", 
            activebackground="#9900AA"
        )
        purple_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [LINK_DOWNGRADE_FULLSCREEN] SUCCESS: Fullscreen criado com botões")
    
    def _show_link_downgrade_trade_confirmation(self, long_link_path):
        """
        Overlay de confirmação final para o trade Link Downgrade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_TRADE] Criando overlay de trade para: {os.path.basename(long_link_path)}")
        
        # Salvar referência do Long Link escolhido
        self._link_downgrade_long_link_path = long_link_path
        
        # Limpar widgets 
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto
        self.config(bg="black")
        
        # Carregar imagem da carta Long Link como fundo
        try:
            pil_img = Image.open(long_link_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            
            bg_img = ImageTk.PhotoImage(pil_img)
            bg_lbl = tk.Label(self, image=bg_img, bg="black")
            bg_lbl.image = bg_img
            bg_lbl.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_TRADE] Erro ao carregar imagem de fundo: {e}")
        
        # Frame para a dialog de confirmação
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Trade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
         # Obter specific_id da carta
        specific_id = self._get_equipment_specific_id_from_path(long_link_path)
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text=f"Long Link {specific_id} is going to be added \nto your inventory", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 30))
        
        # Frame para o botão
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão Ok (roxo)
        def confirmar_trade():
            print("DEBUG: [LINK_DOWNGRADE_TRADE] Trade confirmado - destruindo interface e iniciando Fase 2")
            # Destruir completamente a interface antes do loading screen
            for widget in self.winfo_children():
                widget.destroy()
            self.config(bg="black")
            print("DEBUG: [LINK_DOWNGRADE_TRADE] Interface destruída - prosseguindo para detecção YOLO")
            self._executar_link_downgrade_phase_2(long_link_path)
        
        ok_btn = tk.Button(
            btns_frame,
            text="Ok",
            font=("Helvetica", 16, "bold"),
            bg="#8A2BE2",
            fg="white",
            width=8,
            height=2,
            command=confirmar_trade
        )
        ok_btn.pack()
        
        print("DEBUG: [LINK_DOWNGRADE_TRADE] Overlay de trade criado")
    
    def _executar_link_downgrade_phase_2(self, long_link_path):
        """
        Phase 2 de LINK DOWNGRADE: Detectar Long Link da Store.
        Após detecção, completa o downgrade.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Iniciando Phase 2 para Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Obter object_name do Long Link para detecção YOLO
            if self.card_database:
                object_name = get_equipment_object_name(long_link_path, self.card_database)
                
                if not object_name:
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Nenhum object_name encontrado - fallback direto")
                    self._complete_link_downgrade()
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Object name para detecção: {object_name}")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Base de dados não disponível - fallback direto")
                self._complete_link_downgrade()
                return
            
            # Criar loading screen
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print("DEBUG: [LINK_DOWNGRADE_PHASE2] Loading screen criado - iniciando detecção")
                
                # Usar utilitários universais para detectar script
                universal_paths = get_universal_paths()
                script_path = universal_paths['detection_script']
                
                if not os.path.exists(script_path):
                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Script não encontrado: {script_path}")
                    if loading_window and loading_window.winfo_exists():
                        loading_window.destroy()
                    # Fallback: completar downgrade sem YOLO
                    self._complete_link_downgrade()
                    return
                
                print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Executando: {script_path} {object_name}")
                
                # Esconder interface Python
                self.withdraw()
                
                # Executar script YOLO
                subprocess.run(['chmod', '+x', script_path], check=True)
                process = subprocess.Popen([script_path, object_name])
                
                # Monitor de inicialização (aguardar YOLO carregar)
                def check_phase_2_initialization():
                    try:
                        if process.poll() is None:
                            # Script ainda rodando - YOLO inicializado com sucesso
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] YOLO inicializado - destruindo loading")
                            
                            # Destruir loading screen
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            
                            # Monitor de conclusão
                            def check_phase_2_completion():
                                try:
                                    if process.poll() is not None:
                                        # Script terminou - detecção completa
                                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Detecção Phase 2 completa")
                                        self.deiconify()  # Mostrar interface Python
                                        # Completar o downgrade
                                        self._complete_link_downgrade()
                                    else:
                                        # Continuar monitorando
                                        self.after(1000, check_phase_2_completion)
                                except Exception as e:
                                    print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro no monitor: {e}")
                                    self.deiconify()
                                    self._complete_link_downgrade()
                            
                            self.after(1000, check_phase_2_completion)
                        else:
                            # Script terminou antes de inicializar
                            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Script terminou inesperadamente")
                            if loading_window and loading_window.winfo_exists():
                                loading_window.destroy()
                            self.deiconify()
                            self._complete_link_downgrade()
                    except Exception as e:
                        print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro na inicialização: {e}")
                        if loading_window and loading_window.winfo_exists():
                            loading_window.destroy()
                        self.deiconify()
                        self._complete_link_downgrade()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_phase_2_initialization)
            else:
                print("DEBUG: [LINK_DOWNGRADE_PHASE2] Erro ao criar loading screen - fallback direto")
                self._complete_link_downgrade()
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_PHASE2] Erro: {e}")
            self._complete_link_downgrade()
    
    def _complete_link_downgrade(self):
        """
        Completa o LINK DOWNGRADE fazendo a troca na base de dados.
        Short Link (inventário) -> Long Link (Store)
        """
        print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Completando Link Downgrade")
        
        try:
            # Obter paths salvos
            short_link_path = getattr(self, '_link_downgrade_short_link_path', None)
            long_link_path = getattr(self, '_link_downgrade_long_link_path', None)
            
            if not short_link_path or not long_link_path:
                print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Erro: paths não encontrados")
                self._show_downgrade_error_message()
                return
            
            # Realizar transação na base de dados
            success = self._perform_link_downgrade_database_transaction(short_link_path, long_link_path)
            
            if success:
                # CORREÇÃO: Ir diretamente para o dashboard após sucesso
                print("DEBUG: [LINK_DOWNGRADE_COMPLETE] SUCCESS: Transação completa, voltando ao dashboard")
                self._voltar_dashboard_apos_link_downgrade()
            else:
                self._show_downgrade_error_message()
                
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_COMPLETE] Erro: {e}")
            self._show_downgrade_error_message()
    
    def _perform_link_downgrade_database_transaction(self, short_link_path, long_link_path):
        """
        Realiza a transação de LINK DOWNGRADE na base de dados.
        Remove Short Link do inventário, adiciona Long Link ao inventário.
        """
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Executando transação")
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link: {os.path.basename(short_link_path)}")
        print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link: {os.path.basename(long_link_path)}")
        
        try:
            # Desativar Short Link antes de removê-lo (se estiver ativo)
            try:
                if self.is_card_active(short_link_path, "equipments"):
                    self.deactivate_card(short_link_path, "equipments")
                    print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link desativado: {os.path.basename(short_link_path)}")
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Aviso ao desativar Short Link: {e}")
            
            # Remover Short Link do inventário do jogador
            if short_link_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(short_link_path)
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Short Link removido do inventário")
            else:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Erro: Short Link não encontrado no inventário")
                return False
            
            # Adicionar Long Link ao inventário do jogador
            self.inventario["equipments"].append(long_link_path)
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link adicionado ao inventário")
            
            # CORREÇÃO: Ativar automaticamente o Long Link após o downgrade
            try:
                self.activate_card("equipments", long_link_path)
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Long Link ativado automaticamente: {os.path.basename(long_link_path)}")
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Aviso: Não foi possível ativar Long Link automaticamente: {e}")
                # Não falhar a transação por causa disso, o jogador pode ativar manualmente
            
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] SUCCESS: Transação completa")
            return True
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_TRANSACTION] Erro na transação: {e}")
            return False
    
    def _show_downgrade_success_message(self):
        """Mostra mensagem de sucesso do LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_SUCCESS] Mostrando mensagem de sucesso")
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        
        # Mensagem de sucesso
        success_label = tk.Label(self, text="LINK DOWNGRADE SUCCESSFUL!", 
                               font=("Helvetica", 24, "bold"), 
                               fg="#00FF00", bg="black")
        success_label.place(relx=0.5, rely=0.4, anchor="center")
        
        # Mensagem adicional
        info_label = tk.Label(self, text="Short Link has been converted to Long Link", 
                            font=("Helvetica", 16), 
                            fg="white", bg="black")
        info_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Botão para voltar ao dashboard
        back_btn = tk.Button(self, text="Continue", font=("Helvetica", 16), 
                           bg="#00AA00", fg="white", width=15, height=2,
                           command=self._voltar_dashboard_apos_link_downgrade)
        back_btn.place(relx=0.5, rely=0.65, anchor="center")
        
        print("DEBUG: [LINK_DOWNGRADE_SUCCESS] SUCCESS: Mensagem de sucesso criada")
    
    def _show_downgrade_error_message(self):
        """Mostra mensagem de erro do LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_ERROR] Mostrando mensagem de erro")
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        
        # Mensagem de erro
        error_label = tk.Label(self, text="LINK DOWNGRADE FAILED!", 
                             font=("Helvetica", 24, "bold"), 
                             fg="#FF0000", bg="black")
        error_label.place(relx=0.5, rely=0.4, anchor="center")
        
        # Mensagem adicional
        info_label = tk.Label(self, text="An error occurred during the downgrade process", 
                            font=("Helvetica", 16), 
                            fg="white", bg="black")
        info_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Botão para voltar ao dashboard
        back_btn = tk.Button(self, text="Continue", font=("Helvetica", 16), 
                           bg="#AA0000", fg="white", width=15, height=2,
                           command=self._voltar_dashboard_apos_link_downgrade)
        back_btn.place(relx=0.5, rely=0.65, anchor="center")
        
        print("DEBUG: [LINK_DOWNGRADE_ERROR] SUCCESS: Mensagem de erro criada")
    
    def _voltar_dashboard_apos_link_downgrade(self):
        """Volta ao dashboard principal após LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_RETURN] Retornando ao dashboard")
        
        # Limpar flags de contexto
        self._in_link_downgrade_context = False
        self._link_downgrade_target_id = None
        self._link_downgrade_short_link_path = None
        self._link_downgrade_long_link_path = None
        
        # Voltar à interface principal
        self.playerdashboard_interface(
            self.player_name, 
            self.saldo, 
            self.other_players, 
            show_store_button=True
        )

    def _show_equipment_inventory_for_link_downgrade(self):
        """Abre inventário de equipamentos especificamente para LINK DOWNGRADE"""
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Criando inventário específico para LINK DOWNGRADE")
        
        # Definir contexto específico
        self._in_link_downgrade_context = True
        
        # Chamar inventário de equipamentos usando show_inventory_matrix
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] Chamando show_inventory_matrix para equipments")
        self.show_inventory_matrix(["equipments"])
        
        print("DEBUG: [LINK_DOWNGRADE_INVENTORY] SUCCESS: Inventário específico para LINK DOWNGRADE criado")

    def _aplicar_add_router(self):
        """Abre página para escolher router gratuito (Equipment_1, Equipment_2, ou Equipment_3) da Store"""
        print("DEBUG: [ADD_ROUTER] Iniciando página de seleção de router")
        try:
            self._criar_router_selection_page()
            print("DEBUG: [ADD_ROUTER] SUCCESS: Página de seleção criada com sucesso")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] ERROR: Erro ao criar página de seleção: {e}")
            import traceback
            print(f"DEBUG: [ADD_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def _aplicar_remove_router(self):
        """Abre página de inventário específica para REMOVE ROUTER mostrando apenas Small Routers ativos"""
        print("DEBUG: [REMOVE_ROUTER] Iniciando processo REMOVE ROUTER")
        try:
            # Verificar se há equipamentos no inventário
            equipments_inventory = self.inventario.get("equipments", [])
            if not equipments_inventory:
                print("DEBUG: [REMOVE_ROUTER] Inventário de equipamentos vazio")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            # Verificar se há Small Routers (Equipment_1, Equipment_2, Equipment_3) ATIVOS
            small_routers_active = []
            for equipment_path in equipments_inventory:
                equipment_filename = os.path.basename(equipment_path)
                # Verificar se é Small Router (Equipment_1, Equipment_2 ou Equipment_3)
                if any(router_name in equipment_filename for router_name in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]):
                    # Verificar se está ativo (virado para cima)
                    if self.is_card_active(equipment_path, "equipments"):
                        small_routers_active.append(equipment_path)
            
            if not small_routers_active:
                print("DEBUG: [REMOVE_ROUTER] Nenhum Small Router ativo encontrado - não é possível remover routers")
                print("DEBUG: [REMOVE_ROUTER] REMOVE ROUTER só funciona se houver Equipment_1, Equipment_2 ou Equipment_3 ativos (virados para cima)")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                return
            
            print(f"DEBUG: [REMOVE_ROUTER] {len(small_routers_active)} Small Router(s) ativo(s) encontrado(s)")
            for router in small_routers_active:
                print(f"DEBUG: [REMOVE_ROUTER] Small Router ativo: {os.path.basename(router)}")
            
            # Definir contexto REMOVE ROUTER
            self._in_remove_router_context = True
            self._remove_router_phase = "select_router"  # Fase 1: Selecionar router para remover
            self._small_routers_active = small_routers_active
            
            # Mostrar inventário específico apenas com Small Routers ativos (SEM botão Back)
            self._show_remove_router_inventory()
            print("DEBUG: [REMOVE_ROUTER] SUCCESS: Inventário específico para REMOVE ROUTER criado")
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER] ERROR: Erro ao abrir inventário: {e}")
            import traceback
            print(f"DEBUG: [REMOVE_ROUTER] Traceback completo: {traceback.format_exc()}")
            # Fallback - retornar ao dashboard principal se houve erro
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _show_remove_router_inventory(self):
        """Cria inventário específico para REMOVE ROUTER com layout EXATAMENTE igual ao inventário normal"""
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] Criando inventário específico para REMOVE ROUTER")
        
        # Determinar que cartas mostrar baseado na fase
        if getattr(self, '_remove_router_phase', 'select_router') == 'select_router':
            # Fase 1: Mostrar apenas Small Routers ativos
            cards_to_show = getattr(self, '_small_routers_active', [])
            title_text = "REMOVE ROUTER"
        else:
            # Fase 2: Mostrar apenas Links com mesmo specific_id
            cards_to_show = getattr(self, '_links_to_remove', [])
            title_text = "REMOVE LINKS"
        
        print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Fase: {getattr(self, '_remove_router_phase', 'select_router')}")
        print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Cartas a mostrar: {len(cards_to_show)}")
        
        # Limpar widgets (menos barra superior) - IGUAL AO INVENTÁRIO NORMAL
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()

        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se não existir - IGUAL AO INVENTÁRIO NORMAL
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Arquivo TopBar não encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [REMOVE_ROUTER_INVENTORY] TopBar fallback criada após erro!")
        
        # --- Nome do jogador --- IGUAL AO INVENTÁRIO NORMAL
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Marcar contexto para página especial
        self._in_router_selection_page = True
        
        # Título EXATAMENTE igual ao inventário normal (sobre a barra superior)
        title_label = tk.Label(self, text=title_text, font=("Helvetica", 22, "bold"),
                              fg="white", bg="black")  # CORREÇÃO: fg=white, bg=black igual ao inventário normal
        title_label.place(relx=0.5, y=65, anchor="n")
        
        # Se não há cartas, mostrar mensagem
        if not cards_to_show:
            if getattr(self, '_remove_router_phase', 'select_router') == 'select_router':
                message = "No active Small Routers found"
            else:
                message = "All associated links removed!"
            
            no_cards_label = tk.Label(self, text=message, font=("Helvetica", 16), 
                                     bg="black", fg="white")
            no_cards_label.place(relx=0.5, rely=0.5, anchor="center")
        else:
            # CORREÇÃO CRÍTICA: Usar EXATAMENTE o mesmo layout do inventário normal
            # Layout em grade pequena 2x2 com cartas 85x120 - IGUAL AO INVENTÁRIO NORMAL
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            
            # CORREÇÃO: Usar tamanhos pequenos iguais ao inventário normal
            card_w, card_h = 85, 120  # Tamanhos PEQUENOS igual ao inventário normal
            n_col = 2  # 2 colunas igual ao inventário normal
            
            for idx, carta_path in enumerate(cards_to_show):
                row = idx // n_col
                col = idx % n_col
                
                try:
                    # CORREÇÃO: Carregar imagem com tamanho pequeno igual ao inventário normal
                    carta_img = Image.open(carta_path)
                    carta_img = carta_img.resize((card_w, card_h), Image.LANCZOS)
                    carta_photo = ImageTk.PhotoImage(carta_img)
                    
                    # Criar label da carta clicável EXATAMENTE igual ao inventário normal
                    carta_lbl = tk.Label(matriz_frame, image=carta_photo, bg="black", cursor="hand2")
                    carta_lbl.image = carta_photo
                    carta_lbl.grid(row=row, column=col, padx=8, pady=8)  # CORREÇÃO: usar grid igual ao inventário normal
                    
                    # Bind para abrir fullscreen
                    carta_lbl.bind("<Button-1>", lambda e, path=carta_path: self._show_remove_router_card_fullscreen(path))
                    
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Carta colocada na linha {row}, coluna {col}: {os.path.basename(carta_path)}")
                    
                except Exception as e:
                    print(f"DEBUG: [REMOVE_ROUTER_INVENTORY] Erro ao carregar carta {carta_path}: {e}")
        
        # --- BARRA INFERIOR COM IMAGEM EXATAMENTE igual ao inventário normal ---
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada na página REMOVE ROUTER")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png na página REMOVE ROUTER: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)
        
        # Saldo no canto inferior direito - IGUAL AO INVENTÁRIO NORMAL
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))
        
        print("DEBUG: [REMOVE_ROUTER_INVENTORY] SUCCESS: Inventário específico criado com layout IDÊNTICO ao normal")
    
    def _show_remove_router_card_fullscreen(self, carta_path):
        """Mostra carta em fullscreen com botões X cinza e ✓ roxo (completamente fullscreen)"""
        print(f"DEBUG: [REMOVE_ROUTER_FULLSCREEN] Mostrando carta: {os.path.basename(carta_path)}")
        
        # CORREÇÃO: Limpar TODOS os widgets para fullscreen completo (incluindo TopBar)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.configure(bg="black")
        
        try:
            # Carregar e centralizar imagem da carta (completamente fullscreen)
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular ratio para ocupar máximo da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com imagem da carta centralizada
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_FULLSCREEN] Erro ao carregar carta: {e}")
        
        # Botão X no canto superior ESQUERDO
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), 
                         bg="#AAAAAA", fg="white", width=2, height=1, 
                         borderwidth=0, highlightthickness=0, 
                         command=self._voltar_remove_router_inventory, 
                         cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão ✓ ROXO (canto superior direito) - Confirmar remoção
        # Verificar se é router ou link para usar função correta
        current_phase = getattr(self, '_remove_router_phase', 'select_router')
        if current_phase == 'remove_links':
            # Fase 2: Confirmar remoção de link
            check_btn = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"),
                                bg="#8A2BE2", fg="white", width=2, height=1,
                                borderwidth=0, highlightthickness=0,
                                command=lambda: self._confirmar_remocao_link(carta_path),
                                cursor="hand2", activebackground="#7B68EE")
        else:
            # Fase 1: Confirmar remoção de router
            check_btn = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"),
                                bg="#8A2BE2", fg="white", width=2, height=1,
                                borderwidth=0, highlightthickness=0,
                                command=lambda: self._confirmar_remocao_router(carta_path),
                                cursor="hand2", activebackground="#7B68EE")
        check_btn.place(relx=0.98, rely=0, anchor="ne")
        
        print("DEBUG: [REMOVE_ROUTER_FULLSCREEN] Fullscreen completo criado com botões X cinza (esquerda) e ✓ ROXO (direita)")
    
    def _remover_link_automaticamente(self, carta_path):
        """Remove um link automaticamente durante a fase 2 do REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_LINK_AUTO] Removendo link: {os.path.basename(carta_path)}")
        
        try:
            # Remover link do inventário e lista de ativos
            if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido do inventário")
                
            if carta_path in self.active_equipments:
                self.active_equipments.remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido da lista de ativos")
            
            # Devolver carta à Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                    print(f"DEBUG: [REMOVE_LINK_AUTO] Link enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [REMOVE_LINK_AUTO] Erro ao enviar link para Store: {e}")
            
            # Remover da lista de links a remover
            if hasattr(self, '_links_to_remove') and carta_path in self._links_to_remove:
                self._links_to_remove.remove(carta_path)
                print(f"DEBUG: [REMOVE_LINK_AUTO] Link removido da lista de remoção")
            
            # Verificar se ainda há links para remover
            if hasattr(self, '_links_to_remove') and len(self._links_to_remove) > 0:
                print(f"DEBUG: [REMOVE_LINK_AUTO] Ainda há {len(self._links_to_remove)} links para remover")
                # Voltar ao inventário para mostrar links restantes
                self._show_remove_router_inventory()
            else:
                print("DEBUG: [REMOVE_LINK_AUTO] Todos os links removidos, finalizando processo")
                # Todos os links foram removidos, finalizar processo
                self._finalizar_remove_router()
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_LINK_AUTO] Erro durante remoção automática: {e}")
            self._voltar_dashboard_apos_remove_router()
    
    def _voltar_remove_router_inventory(self):
        """Volta para o inventário específico do REMOVE ROUTER"""
        print("DEBUG: [REMOVE_ROUTER] Voltando para inventário REMOVE ROUTER")
        self._show_remove_router_inventory()
    
    def _confirmar_remocao_router(self, carta_path):
        """Mostra overlay de confirmação para remoção do router"""
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Iniciando confirmação para: {os.path.basename(carta_path)}")
        
        # Obter specific_id do router
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar interface
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        
        # Carregar imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            carta_label = tk.Label(self, image=carta_photo, bg="black")
            carta_label.image = carta_photo
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao carregar imagem: {e}")
        
        # Frame para overlay de confirmação
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        title_label = tk.Label(confirm_frame, text="Router Removal Confirmation",
                              font=("Helvetica", 16, "bold"), fg="yellow", bg="black")
        title_label.pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Do you want to remove the router {router_id}?"
        message_label = tk.Label(confirm_frame, text=message_text,
                               font=("Helvetica", 16), fg="white", bg="black")
        message_label.pack(pady=(0, 10))
        
        # Mensagem adicional
        info_label = tk.Label(confirm_frame, text="Don't forget to remove\nthe associated queue and link",
                            font=("Helvetica", 14), fg="white", bg="black")
        info_label.pack(pady=(0, 20))
        
        # Frame para botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        # Botão No - Voltar ao inventário
        no_btn = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"),
                          bg="#F44336", fg="white", width=8,
                          command=self._voltar_remove_router_inventory)
        no_btn.pack(side="left", padx=20, pady=10)
        
        # Botão Yes - Processar remoção
        yes_btn = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"),
                           bg="#4CAF50", fg="white", width=8,
                           command=lambda: self._processar_remocao_router(carta_path, router_id))
        yes_btn.pack(side="left", padx=20, pady=10)
        
        print("DEBUG: [REMOVE_ROUTER_CONFIRM] Overlay de confirmação criado")
    
    def _processar_remocao_router(self, carta_path, router_id):
        """Processa a remoção do router e mostra links associados"""
        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Processando remoção router ID {router_id}")
        
        try:
            # NOVA FUNCIONALIDADE: Criar loading screen e executar script de detecção
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Carta Equipment detectada - criando loading screen")
            
            # Obter object_name da carta
            object_name = get_equipment_object_name(carta_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Criando loading screen para object: {object_name}")
                
                # Criar loading screen imediatamente
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Loading screen criado com sucesso")
                    
                    # Executar script de detecção com monitor correto
                    detection_success = self._execute_detection_with_router_continuation(object_name, loading_window, carta_path, router_id)
                    
                    if detection_success:
                        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Script de detecção iniciado com sucesso")
                        return  # Sair aqui - a continuação será tratada pelo monitor
                    else:
                        print(f"DEBUG: [REMOVE_ROUTER_PROCESS] AVISO: Script de detecção falhou")
                        # Fechar loading screen em caso de erro
                        if loading_window:
                            loading_window.destroy()
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_PROCESS] ERRO: Não foi possível criar loading screen")
            else:
                print(f"DEBUG: [REMOVE_ROUTER_PROCESS] AVISO: Object name não encontrado para carta Equipment")
            
            # Fallback: processar remoção diretamente se detecção YOLO falhar
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Fallback: processando remoção sem detecção YOLO")
            self._continue_router_removal_after_detection(carta_path, router_id)
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_PROCESS] Erro durante processamento: {e}")
            self._voltar_dashboard_apos_remove_router()
    
    def _confirmar_remocao_link(self, carta_path):
        """Mostra overlay de confirmação para remoção de link"""
        try:
            print(f"DEBUG: [CONFIRM_LINK] Confirmando remoção de link: {os.path.basename(carta_path)}")
            
            # Obter specific_id do link (se existir)
            link_id = self._get_equipment_specific_id(carta_path)
            
            # Limpar interface
            for widget in self.winfo_children():
                widget.destroy()
            self.configure(bg="black")
            
            # Carregar imagem da carta como fundo
            try:
                carta_img = Image.open(carta_path)
                screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                
                ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                carta_photo = ImageTk.PhotoImage(carta_resized)
                
                carta_label = tk.Label(self, image=carta_photo, bg="black")
                carta_label.image = carta_photo
                carta_label.place(relx=0.5, rely=0.5, anchor="center")
                
            except Exception as e:
                print(f"DEBUG: [CONFIRM_LINK] Erro ao carregar imagem: {e}")
            
            # Frame para overlay de confirmação
            confirm_frame = tk.Frame(self, bg="black")
            confirm_frame.pack(expand=True)
            
            # Título
            title_label = tk.Label(confirm_frame, text="Link Removal Confirmation",
                                  font=("Helvetica", 16, "bold"), fg="yellow", bg="black")
            title_label.pack(pady=(40, 20))
            
            # Mensagem principal
            message_text = f"Link {link_id} is going to be removed" if link_id else "This link is going to be removed"
            message_label = tk.Label(confirm_frame, text=message_text,
                                   font=("Helvetica", 16), fg="white", bg="black")
            message_label.pack(pady=(0, 20))
            
            # Frame para botão
            btns_frame = tk.Frame(confirm_frame, bg="black")
            btns_frame.pack(pady=30)
            
            # Botão Ok - Processar remoção do link
            ok_btn = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"),
                              bg="#4CAF50", fg="white", width=10,
                              command=lambda: self._processar_remocao_link(carta_path))
            ok_btn.pack(pady=10)
            
            print("DEBUG: [CONFIRM_LINK] Overlay de confirmação de link criado")
            
        except Exception as e:
            print(f"DEBUG: [CONFIRM_LINK] Erro ao criar overlay: {e}")
            self._show_remove_router_inventory()
    
    def _execute_detection_with_router_continuation(self, object_name, loading_window, carta_path, router_id):
        """Executa detecção YOLO e continua processamento de router após terminar"""
        def continuation_callback():
            # Processar remoção de router após detecção YOLO
            self._continue_router_removal_after_detection(carta_path, router_id)
        
        return execute_detection_with_continuation(object_name, self, loading_window, continuation_callback)
    
    def _continue_router_removal_after_detection(self, carta_path, router_id):
        """Continua o processamento de remoção de router após a detecção YOLO"""
        try:
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Continuando remoção router após detecção YOLO")
            
            # Remover router do inventário e lista de ativos
            if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                self.inventario["equipments"].remove(carta_path)
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router removido do inventário")
                
            if carta_path in self.active_equipments:
                self.active_equipments.remove(carta_path)
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router removido da lista de ativos")
            
            # Devolver carta à Store
            if hasattr(self, 'store_window') and self.store_window:
                try:
                    self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                    print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Router enviado para Store")
                except Exception as e:
                    print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Erro ao enviar router para Store: {e}")
            
            # Encontrar links ativos com mesmo specific_id
            links_associados = self._find_active_links_with_same_id(router_id)
            
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Links encontrados com ID {router_id}: {len(links_associados)}")
            for link in links_associados:
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Link associado: {os.path.basename(link)}")
            
            if links_associados:
                # Mudar para fase 2: remover links
                self._remove_router_phase = "remove_links"
                self._links_to_remove = links_associados
                self._router_id_being_removed = router_id
                
                print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Mudando para fase 2: remover {len(links_associados)} links")
                self._show_remove_router_inventory()
            else:
                # Sem links associados, finalizar processo
                print("DEBUG: [REMOVE_ROUTER_CONTINUE] Nenhum link associado, finalizando processo")
                self._finalizar_remove_router()
                
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONTINUE] Erro: {e}")
            self._finalizar_remove_router()
    
    def _execute_detection_with_link_continuation(self, object_name, loading_window, carta_path):
        """Executa detecção YOLO e continua processamento de link após terminar"""
        def continuation_callback():
            # Processar remoção de link após detecção YOLO
            self._continue_link_removal_after_detection(carta_path)
        
        return execute_detection_with_continuation(object_name, self, loading_window, continuation_callback)
    
    def _continue_link_removal_after_detection(self, carta_path):
        """Continua o processamento de remoção de link após a detecção YOLO"""
        try:
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Continuando remoção link após detecção YOLO")
            
            # Remover link usando a função automática existente
            # CORREÇÃO: A função _remover_link_automaticamente já decide se volta ao inventário ou finaliza
            # baseado na quantidade de links restantes, então não devemos chamar _finalizar_remove_router aqui
            self._remover_link_automaticamente(carta_path)
            
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Link processado - decisão de navegação feita por _remover_link_automaticamente")
            
        except Exception as e:
            print(f"DEBUG: [PROCESS_LINK_CONTINUE] Erro ao processar remoção: {e}")
            self._finalizar_remove_router()
    
    def _processar_remocao_link(self, carta_path):
        """Processa a remoção do link após confirmação"""
        try:
            print(f"DEBUG: [PROCESS_LINK] Processando remoção de link: {os.path.basename(carta_path)}")
            
            # NOVA FUNCIONALIDADE: Criar loading screen e executar script de detecção
            print(f"DEBUG: [PROCESS_LINK] Carta Equipment detectada - criando loading screen")
            
            # Obter object_name da carta
            object_name = get_equipment_object_name(carta_path, self.card_database)
            
            if object_name:
                print(f"DEBUG: [PROCESS_LINK] Criando loading screen para object: {object_name}")
                
                # Criar loading screen imediatamente
                loading_window = create_yolo_loading_screen(self, object_name)
                
                if loading_window:
                    print(f"DEBUG: [PROCESS_LINK] Loading screen criado com sucesso")
                    
                    # Executar script de detecção com monitor correto
                    detection_success = self._execute_detection_with_link_continuation(object_name, loading_window, carta_path)
                    
                    if detection_success:
                        print(f"DEBUG: [PROCESS_LINK] Script de detecção iniciado com sucesso")
                        return  # Sair aqui - a continuação será tratada pelo monitor
                    else:
                        print(f"DEBUG: [PROCESS_LINK] AVISO: Script de detecção falhou")
                        # Fechar loading screen em caso de erro
                        if loading_window:
                            loading_window.destroy()
                else:
                    print(f"DEBUG: [PROCESS_LINK] ERRO: Não foi possível criar loading screen")
            else:
                print(f"DEBUG: [PROCESS_LINK] AVISO: Object name não encontrado para carta Equipment")
            
            # Fallback: remover link diretamente se detecção falhar
            self._remover_link_automaticamente(carta_path)
            self._finalizar_remove_router()
            
        except Exception as e:
            print(f"DEBUG: [PROCESS_LINK] Erro ao processar remoção: {e}")
            self._finalizar_remove_router()

    def _finalizar_remove_router(self):
        """Finaliza o processo REMOVE ROUTER e volta ao dashboard"""
        print("DEBUG: [REMOVE_ROUTER] Finalizando processo REMOVE ROUTER")
        
        # CORREÇÃO CRÍTICA: Fazer backup dos trackings antes da reconstrução
        # Isso garante que Challenges, Events e Services ativos não sejam perdidos
        print("DEBUG: [REMOVE_ROUTER] Fazendo backup dos trackings antes de reconstruir interface")
        self._backup_turn_counters_before_reconstruction()
        
        # Limpar contexto REMOVE ROUTER
        self._in_remove_router_context = False
        self._remove_router_phase = None
        self._small_routers_active = []
        self._links_to_remove = []
        self._router_id_being_removed = None
        self._in_router_selection_page = False  # Limpar flag de página especial
        
        # Voltar ao dashboard principal
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
    
    def _voltar_dashboard_apos_remove_router(self):
        """Volta ao dashboard após completar ou cancelar REMOVE ROUTER"""
        print("DEBUG: [REMOVE_ROUTER] Voltando ao dashboard")
        self._finalizar_remove_router()
    
    def _criar_router_selection_page(self):
        """Cria página completa para seleção de router da Store (padrão igual Store_v2.py)"""
        print("DEBUG: [ADD_ROUTER] ======= INICIANDO CRIAÇÃO DA PÁGINA =======")
        print("DEBUG: [ADD_ROUTER] Criando página de seleção de router")
        
        # PROTEÇÃO: Marcar que estamos numa página especial (impede callbacks automáticos)
        self._in_router_selection_page = True
        print("DEBUG: [ADD_ROUTER] Flag _in_router_selection_page = True")
        
        # VERIFICAÇÃO DE SEGURANÇA: Garantir que esta função só é chamada em contexto válido
        if not hasattr(self, 'cards') or not self.cards:
            print("DEBUG: [ADD_ROUTER] ERRO - Cards não disponíveis, abortando")
            return
        
        # FORÇA ATUALIZAÇÃO DA INTERFACE (crítico para Raspberry Pi)
        self.update_idletasks()
        self.update()
        
        # Limpar interface atual (IGUAL STORE_V2.PY)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        print("DEBUG: [ADD_ROUTER] Interface limpa e fundo preto definido")
        
        # FORÇA SEGUNDA ATUALIZAÇÃO APÓS LIMPEZA
        self.update_idletasks()
        self.update()
        
        # Barra superior com Store_awning_v3.png (como pedido)
        try:
            # Usar Store_awning_v3.png como especificado
            awning_path = os.path.join(os.path.dirname(__file__), "img", "Store_awning_v3.png")
            if os.path.exists(awning_path):
                awning_img = ImageTk.PhotoImage(Image.open(awning_path).resize((self.winfo_screenwidth(), 50)))
                awning_label = tk.Label(self, image=awning_img, bg="black")
                awning_label.image = awning_img
                awning_label.pack(pady=(0, 10), fill="x")
                print("DEBUG: [ADD_ROUTER] Header com Store_awning_v3.png criado")
            else:
                raise FileNotFoundError("Store_awning_v3.png não encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar Store_awning_v3.png: {e} - usando fallback")
            # Fallback simples
            header_frame = tk.Frame(self, bg="#4CAF50", height=50)
            header_frame.pack(fill="x", pady=(0, 10))
            header_label = tk.Label(header_frame, text="NetMaster", font=("Helvetica", 18, "bold"), 
                                  fg="white", bg="#4CAF50")
            header_label.pack(expand=True)

        # Label pequeno à esquerda do logo (como na Store)
        left_label = tk.Label(self, text="••••", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        left_label.place(relx=0.46, y=10, anchor="center")
        
        # Logo NetMaster posicionado independentemente (igual Store_v2.py)
        try:
            # Tentar carregar o logo do diretório img
            # Usar os utilitários universais para encontrar o logo
            logo_img_path = find_existing_path("img/logo_netmaster_store.png")
            if not logo_img_path:
                # Fallback local
                logo_img_path = os.path.join(os.path.dirname(__file__), "img", "logo_netmaster_store.png")
            
            if os.path.exists(logo_img_path):
                logo_img = ImageTk.PhotoImage(Image.open(logo_img_path).resize((20, 20)))
                logo_lbl = tk.Label(self, image=logo_img, bg="#DC8392")
                logo_lbl.image = logo_img
                logo_lbl.place(relx=0.5, y=10, anchor="center")
                print("DEBUG: [ADD_ROUTER] Logo NetMaster adicionado com sucesso")
            else:
                print("DEBUG: [ADD_ROUTER] Logo não encontrado em nenhum diretório")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar logo: {e}")
        
        # Label largo à direita do logo para cobrir área amarela (ajustado)
        right_logo_label = tk.Label(self, text="     ", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_logo_label.place(relx=0.52, y=10, anchor="w")
        
        # Label adicional para garantir cobertura completa (reduzido)
        extra_cover_label = tk.Label(self, text="  ", font=("Helvetica", 10), bg="#DC8392", fg="#DC8392")
        extra_cover_label.place(relx=0.54, y=10, anchor="w")
        
        # Texto "Store" posicionado independentemente (como na Store)
        title_lbl = tk.Label(self, text="Store", 
                            font=("Helvetica", 15, "bold"), bg="#DC8392", fg="black")
        title_lbl.place(relx=0.5, y=30, anchor="center")
        
        # Label pequeno à direita do título (igual Store original)
        right_title_label = tk.Label(self, text="•", font=("Helvetica", 12, "bold"), bg="#DC8392", fg="#DC8392")
        right_title_label.place(relx=0.6, y=30, anchor="center")

        # Tamanho das cartas - igual ao da Store (75x110)
        card_w, card_h = 75, 110

        # Obter equipamentos disponíveis sincronizados com o inventário
        routers_disponiveis = self._obter_equipments_sincronizados()
        
        print(f"DEBUG: [ADD_ROUTER] Routers disponíveis sincronizados: {len(routers_disponiveis)}")
        
        # Paginação (igual Store_v2.py, mesmo que só tenhamos 3 routers)
        cards_per_page = 4  # Igual à Store_v2.py
        total_pages = max(1, (len(routers_disponiveis) + cards_per_page - 1) // cards_per_page)
        page = 0  # Sempre página 0 para routers
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        routers_page = routers_disponiveis[start_idx:end_idx]
        
        # Frame para os routers (centralizado, movido mais para cima)
        self.matriz_frame = tk.Frame(self, bg="black")
        self.matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        n_col = 2  # 2 colunas para layout 2xn como solicitado
        card_w, card_h = 75, 110  # Tamanho das cartas de router
        
        # Variáveis para seleção
        self.router_selection = None
        self.router_buttons = []
        
        # Callback para seleção de router
        def make_router_selection_callback(router_path, router_idx):
            def callback(event=None):
                print(f"DEBUG: [ADD_ROUTER] Router selecionado: {os.path.basename(router_path)}")
                self._selecionar_router_page(router_path, router_idx)
            return callback
        
        # Criar grid de routers em layout 2xn
        for i, router_path in enumerate(routers_page):
            row = i // n_col
            col = i % n_col
            
            # Frame para router + label
            router_frame = tk.Frame(self.matriz_frame, bg="black")
            router_frame.grid(row=row, column=col, padx=15, pady=8)
            
            # Carregar imagem do router
            try:
                # Verificar se é placeholder ou arquivo real
                if router_path.startswith("PLACEHOLDER_"):
                    # Criar imagem placeholder
                    placeholder_img = Image.new('RGB', (card_w, card_h), color='#4A4A4A')
                    router_img = ImageTk.PhotoImage(placeholder_img)
                    print(f"DEBUG: [ADD_ROUTER] Placeholder criado para {router_path}")
                else:
                    # Carregar imagem real
                    img = ImageTk.PhotoImage(Image.open(router_path).resize((card_w, card_h)))
                    router_img = img
                    print(f"DEBUG: [ADD_ROUTER] Imagem carregada: {os.path.basename(router_path)}")
            except Exception as e:
                print(f"DEBUG: [ADD_ROUTER] Erro ao carregar {router_path}: {e}")
                # Fallback: criar imagem simples
                placeholder_img = Image.new('RGB', (card_w, card_h), color='#666666')
                router_img = ImageTk.PhotoImage(placeholder_img)
            
            # Criar botão do router igual à Store_v2.py
            router_btn = tk.Button(router_frame, image=router_img, bg="black", cursor="hand2",
                                  borderwidth=3, relief="raised")
            router_btn.image = router_img  # Manter referência
            router_btn.pack()
            router_btn.bind("<Button-1>", make_router_selection_callback(router_path, i))
            
            # Label com nome do router por baixo
            filename = os.path.basename(router_path)
            router_id = filename.replace("Equipment_", "").replace(".png", "")
            
            router_name_lbl = tk.Label(router_frame, text=f"Router {router_id}", 
                                     font=("Helvetica", 12, "bold"), fg="white", bg="black")
            router_name_lbl.pack(pady=(5, 0))
            
            # Status label (disponível)
            status_lbl = tk.Label(router_frame, text="Available", 
                                font=("Helvetica", 10), fg="#00FF00", bg="black")
            status_lbl.pack()
            
            self.router_buttons.append(router_btn)
        
        # Botões de ação na parte inferior com BelowBar_store.png (como pedido)
        # Barra inferior com BelowBar_store.png
        try:
            belowbar_path = os.path.join(os.path.dirname(__file__), "img", "BelowBar_store.png")
            if os.path.exists(belowbar_path):
                belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_path).resize((self.winfo_screenwidth(), 50)))
                belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
                belowbar_label.image = belowbar_img
                belowbar_label.pack(side="bottom", fill="x")
                print("DEBUG: [ADD_ROUTER] Footer com BelowBar_store.png criado")
            else:
                raise FileNotFoundError("BelowBar_store.png não encontrado")
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER] Erro ao carregar BelowBar_store.png: {e} - usando fallback")
            footer_frame = tk.Frame(self, bg="#4CAF50", height=50)
            footer_frame.pack(side="bottom", fill="x")
        
        # Botões de ação sobrepostos ao footer (igual Store_v2.py)
        buttons_frame = tk.Frame(self, bg="black")
        buttons_frame.place(relx=0.5, rely=0.95, anchor="center")
        
        # Apenas o botão Confirm (sem Cancel button como solicitado)
        self.confirm_button = tk.Button(buttons_frame, text="Confirm", 
                                       font=("Helvetica", 14, "bold"), fg="white", 
                                       bg="#555555", relief="flat", width=10, height=1,
                                       state="disabled", command=self._confirmar_router_selection_page)
        self.confirm_button.pack()
        
        print("DEBUG: [ADD_ROUTER] SUCCESS: Página de seleção de router criada (padrão Store_v2.py)")
        
        # FORÇA ATUALIZAÇÃO FINAL DA INTERFACE
        self.update_idletasks()
        self.update()
        
        # VERIFICAÇÃO FINAL: Confirmar que a página foi criada E está visível
        def verificar_pagina_final():
            if hasattr(self, '_in_router_selection_page') and self._in_router_selection_page:
                widgets_count = len(self.winfo_children())
                print(f"DEBUG: [ADD_ROUTER] SUCCESS: Página ativa com {widgets_count} widgets após verificação final")
                
                # FORÇAR REFRESH VISUAL ADICIONAL
                self.lift()  # Traz a janela para frente
                self.focus_force()  # Força foco
                self.update_idletasks()
                print("DEBUG: [ADD_ROUTER] SUCCESS: Interface forçada para frente e atualizada")
            else:
                print("DEBUG: [ADD_ROUTER] WARNING: Flag de página perdida após verificação final")
        
        # Verificação imediata + verificação com delay
        verificar_pagina_final()
        self.after(100, verificar_pagina_final)
        
        print("DEBUG: [ADD_ROUTER] ======= PÁGINA CRIADA COM SUCESSO =======")
    
    def _obter_equipments_da_store(self):
        """Obtém lista de equipamentos disponíveis na Store"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos disponíveis...")
        
        # Lista dos 3 routers sempre disponíveis para ADD ROUTER
        routers_add_router = ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]
        equipments_encontrados = []
        
        # DETECÇÃO INTELIGENTE DE CAMINHOS
        # Usar os utilitários universais para detectar caminhos
        universal_paths = get_universal_paths()
        print(f"DEBUG: [ADD_ROUTER] Ambiente detectado: {universal_paths['environment']}")
        
        possivel_bases = [universal_paths['base_dir']]
        
        # Se for Raspberry Pi, tentar também caminhos alternativos
        if universal_paths['environment'] == 'raspberry_pi':
            # Adicionar caminhos alternativos possíveis
            additional_bases = get_possible_raspberry_pi_paths("")  # Base paths
            possivel_bases.extend([path for path in additional_bases if path not in possivel_bases])
        
        print(f"DEBUG: [ADD_ROUTER] Bases a testar: {possivel_bases[:3]}")  # Mostrar apenas as primeiras 3
        
        # Para cada base possível, testar se tem estrutura Equipments
        for base_path in possivel_bases:
            if not os.path.exists(base_path):
                print(f"DEBUG: [ADD_ROUTER] ERROR: Base não existe: {base_path}")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] SUCCESS: Testando base: {base_path}")
            
            # Verificar se tem diretório Equipments (teste múltiplas variações)
            # CORREÇÃO: Testar tanto "Equipments" quanto "equipments" para Raspberry Pi
            equipments_variations = [
                os.path.join(base_path, "equipments", "Residential-level"),  # Raspberry Pi (minúscula)
                os.path.join(base_path, "Equipments", "Residential-level"),  # Desenvolvimento (maiúscula)
                os.path.join(base_path, "img", "cartas", "equipments", "Residential-level")  # Fallback
            ]
            
            equipments_base = None
            for variation in equipments_variations:
                if os.path.exists(variation):
                    equipments_base = variation
                    print(f"DEBUG: [ADD_ROUTER] SUCCESS: Encontrou Equipments: {equipments_base}")
                    break
                else:
                    print(f"DEBUG: [ADD_ROUTER] ERROR: Sem Equipments: {variation}")
            
            if not equipments_base:
                print(f"DEBUG: [ADD_ROUTER] ERROR: Nenhuma variação de Equipments encontrada")
                continue
                
            print(f"DEBUG: [ADD_ROUTER] SUCCESS: Encontrou Equipments: {equipments_base}")
            
            # Testar cada cor para encontrar os routers
            for cor in ["Red", "Blue", "Green", "Yellow"]:
                cor_dir = os.path.join(equipments_base, cor)
                if not os.path.exists(cor_dir):
                    print(f"DEBUG: [ADD_ROUTER] ERROR: Cor {cor} não existe: {cor_dir}")
                    continue
                    
                print(f"DEBUG: [ADD_ROUTER] SUCCESS: Testando cor {cor}: {cor_dir}")
                
                # Verificar se tem todos os 3 routers nesta cor
                routers_nesta_cor = []
                for router_filename in routers_add_router:
                    router_path = os.path.join(cor_dir, router_filename)
                    if os.path.exists(router_path):
                        routers_nesta_cor.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router encontrado: {router_path}")
                    else:
                        print(f"DEBUG: [ADD_ROUTER] ERROR: Router missing: {router_path}")
                
                # Se encontramos todos os 3, usar esta cor
                if len(routers_nesta_cor) == 3:
                    equipments_encontrados = routers_nesta_cor
                    print(f"DEBUG: [ADD_ROUTER] CELEBRATION: SUCESSO! Todos os 3 routers encontrados em {cor_dir}")
                    break
            
            # Se encontramos, parar de procurar outras bases
            if equipments_encontrados:
                break
        
        # FALLBACK: Se ainda não encontramos, criar placeholders visuais
        if not equipments_encontrados:
            print("DEBUG: [ADD_ROUTER] WARNING: NENHUM ROUTER ENCONTRADO - Usando placeholders")
            
            # Usar imagens de placeholder ou criar caminhos virtuais
            placeholder_base = "/tmp" if universal_paths['environment'] == 'raspberry_pi' else os.getcwd()
            for i, router_filename in enumerate(routers_add_router, 1):
                placeholder_path = f"PLACEHOLDER_ROUTER_{i}"
                equipments_encontrados.append(placeholder_path)
                print(f"DEBUG: [ADD_ROUTER] NOTE: Placeholder criado: {placeholder_path}")
        
        print(f"DEBUG: [ADD_ROUTER] FINISH: RESULTADO FINAL:")
        print(f"DEBUG: [ADD_ROUTER]   Routers para ADD ROUTER: {len(equipments_encontrados)}")
        for i, router in enumerate(equipments_encontrados, 1):
            print(f"DEBUG: [ADD_ROUTER]   {i}. {router}")
        
        return equipments_encontrados
    
    def _obter_equipments_sincronizados(self):
        """Obtém lista de equipamentos disponíveis sincronizados com o inventário (igual à Store)"""
        print("DEBUG: [ADD_ROUTER] Obtendo equipamentos sincronizados com inventário...")
        
        # Primeiro obter todos os equipments disponíveis
        all_equipments = self._obter_equipments_da_store()
        
        # Filtrar apenas Equipment_1, Equipment_2, Equipment_3
        routers_base = []
        for equipment_path in all_equipments:
            filename = os.path.basename(equipment_path)
            if filename in ["Equipment_1.png", "Equipment_2.png", "Equipment_3.png"]:
                routers_base.append(equipment_path)
        
        print(f"DEBUG: [ADD_ROUTER] Routers base encontrados: {len(routers_base)}")
        
        # Aplicar sincronização com inventário (igual Store_v2.py)
        routers_sincronizados = routers_base.copy()  # Começar com todos
        
        if hasattr(self, 'inventario') and self.inventario:
            print(f"DEBUG: [ADD_ROUTER] Aplicando sincronização com inventário...")
            
            # Verificar equipments no inventário
            equipments_inventario = self.inventario.get("equipments", [])
            if equipments_inventario:
                print(f"DEBUG: [ADD_ROUTER] Equipments no inventário: {len(equipments_inventario)}")
                
                # Remover equipments que já estão no inventário
                routers_filtrados = []
                for router_path in routers_sincronizados:
                    router_filename = os.path.basename(router_path)
                    
                    # Verificar se este equipment está no inventário
                    equipment_no_inventario = False
                    for inv_path in equipments_inventario:
                        if os.path.basename(inv_path) == router_filename:
                            equipment_no_inventario = True
                            print(f"DEBUG: [ADD_ROUTER] Removendo {router_filename} (já no inventário)")
                            break
                    
                    # Se não está no inventário, manter disponível
                    if not equipment_no_inventario:
                        routers_filtrados.append(router_path)
                        print(f"DEBUG: [ADD_ROUTER] Mantendo {router_filename} (disponível)")
                
                routers_sincronizados = routers_filtrados
            else:
                print(f"DEBUG: [ADD_ROUTER] Nenhum equipment no inventário")
        else:
            print(f"DEBUG: [ADD_ROUTER] Sem inventário para sincronizar")
        
        print(f"DEBUG: [ADD_ROUTER] Resultado sincronização:")
        print(f"DEBUG: [ADD_ROUTER]   Routers disponíveis: {len(routers_sincronizados)}")
        for router in routers_sincronizados:
            print(f"DEBUG: [ADD_ROUTER]   - {os.path.basename(router)}")
        
        return routers_sincronizados
    
    def _selecionar_router_page(self, router_path, button_index):
        """Seleciona router na página e atualiza visual dos botões"""
        print(f"DEBUG: [ADD_ROUTER] Router selecionado: {router_path}")
        
        self.router_selection = router_path
        
        # Resetar todos os botões para cor normal
        for btn in self.router_buttons:
            btn.configure(bg="#4A4A4A", relief="raised", borderwidth=3)
        
        # Destacar botão selecionado em roxo
        if button_index < len(self.router_buttons):
            self.router_buttons[button_index].configure(bg="#8A2BE2", relief="sunken", borderwidth=4)
        
        # Ativar botão Confirm e deixar roxo
        self.confirm_button.configure(state="normal", bg="#8A2BE2", cursor="hand2")
    
    def _cancelar_router_selection(self):
        """Cancela seleção e volta ao PlayerDashboard"""
        print("DEBUG: [ADD_ROUTER] Cancelando seleção de router")
        
        # RESETAR FLAG DE PROTEÇÃO
        self._in_router_selection_page = False
        
        # Limpar seleção
        self.router_selection = None
        
        # Restaurar interface do PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _confirmar_router_selection_page(self):
        """Confirma seleção na página e adiciona router gratuito ao inventário do jogador"""
        if not self.router_selection:
            return
            
        print(f"DEBUG: [ADD_ROUTER] Confirmando seleção: {self.router_selection}")
        
        # RESETAR FLAG DE PROTEÇÃO
        self._in_router_selection_page = False
        
        # Preparar caminho do router para adicionar ao inventário
        router_para_inventario = self.router_selection
        
        # Se é placeholder, criar um caminho de equipamento válido baseado no ID
        if router_para_inventario.startswith("PLACEHOLDER_"):
            # Extrair ID do placeholder (ex: PLACEHOLDER_ROUTER_1 -> Equipment_1.png)
            placeholder_id = router_para_inventario.split("_")[-1]  # Pega último número
            router_filename = f"Equipment_{placeholder_id}.png"
            
            # Criar caminho final baseado na cor do jogador
            base_equipments = detect_player_inventory_base_dir()
            color_mapping = {
                "red": "Red",
                "blue": "Blue", 
                "green": "Green",
                "yellow": "Yellow"
            }
            player_color_title = color_mapping.get(self.player_color.lower(), "Red")
            
            router_para_inventario = os.path.join(
                base_equipments, 
                "Equipments", 
                "Residential-level", 
                player_color_title, 
                router_filename
            )
            
            print(f"DEBUG: [ADD_ROUTER] Placeholder convertido para: {router_para_inventario}")
        
        # NOVA FUNCIONALIDADE: Obter object_name para detecção YOLO
        object_name = get_equipment_object_name(router_para_inventario, self.card_database)
        
        if object_name:
            print(f"DEBUG: [ADD_ROUTER] Object name encontrado: {object_name} - mostrando loading screen")
            
            # CRIAR LOADING SCREEN IMEDIATAMENTE
            loading_window = create_yolo_loading_screen(self, object_name)
            
            if loading_window:
                print(f"DEBUG: [ADD_ROUTER] Loading screen criado - processando em background")
                
                # Função para processar adição e detecção em background
                def processar_router_com_yolo():
                    try:
                        # Adicionar router ao inventário do jogador
                        if "equipments" not in self.inventario:
                            self.inventario["equipments"] = []
                            
                        self.inventario["equipments"].append(router_para_inventario)
                        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router adicionado gratuitamente ao inventário!")
                        print(f"DEBUG: [ADD_ROUTER] Inventário equipments agora tem: {len(self.inventario['equipments'])} itens")
                        
                        # Executar script YOLO com continuação personalizada
                        detection_success = self._execute_detection_with_router_continuation(object_name, loading_window, router_para_inventario)
                        
                        if not detection_success:
                            print(f"DEBUG: [ADD_ROUTER] AVISO: Script YOLO falhou - fechando loading screen")
                            if loading_window:
                                loading_window.destroy()
                            # Voltar ao PlayerDashboard em caso de erro
                            self._voltar_playerdashboard_apos_router_selection()
                            
                    except Exception as e:
                        print(f"DEBUG: [ADD_ROUTER] ERRO no processamento: {e}")
                        if loading_window:
                            loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                
                # Executar processamento após 100ms (loading screen já está visível)
                self.after(100, processar_router_com_yolo)
                
            else:
                print(f"DEBUG: [ADD_ROUTER] ERRO: Loading screen não foi criado - continuando normalmente")
                # Fallback: processamento normal se loading screen falhar
                self._processar_router_normal()
        else:
            print(f"DEBUG: [ADD_ROUTER] AVISO: Object name não encontrado - processamento normal")
            # Processamento normal se não conseguir obter object_name
            self._processar_router_normal()
    
    def _processar_router_normal(self):
        """Processa adição de router sem detecção YOLO (fallback)"""
        router_para_inventario = self.router_selection
        
        # Se é placeholder, criar um caminho de equipamento válido baseado no ID
        if router_para_inventario.startswith("PLACEHOLDER_"):
            placeholder_id = router_para_inventario.split("_")[-1]
            router_filename = f"Equipment_{placeholder_id}.png"
            
            base_equipments = detect_player_inventory_base_dir()
            color_mapping = {
                "red": "Red",
                "blue": "Blue", 
                "green": "Green",
                "yellow": "Yellow"
            }
            player_color_title = color_mapping.get(self.player_color.lower(), "Red")
            
            router_para_inventario = os.path.join(
                base_equipments, 
                "Equipments", 
                "Residential-level", 
                player_color_title, 
                router_filename
            )
        
        # Adicionar router ao inventário do jogador
        if "equipments" not in self.inventario:
            self.inventario["equipments"] = []
            
        self.inventario["equipments"].append(router_para_inventario)
        print(f"DEBUG: [ADD_ROUTER] SUCCESS: Router adicionado gratuitamente ao inventário!")
        print(f"DEBUG: [ADD_ROUTER] Inventário equipments agora tem: {len(self.inventario['equipments'])} itens")
        
        # Voltar ao PlayerDashboard
        self._voltar_playerdashboard_apos_router_selection()
    
    def _execute_detection_with_router_continuation(self, object_name, loading_window, router_path):
        """
        Executa detecção YOLO com continuação específica para router selection.
        
        Args:
            object_name: Nome do objeto para detecção
            loading_window: Loading screen ativo
            router_path: Caminho do router adicionado ao inventário
            
        Returns:
            True se iniciou com sucesso, False caso contrário
        """
        try:
            # Usar os utilitários universais para detectar ambiente e caminhos
            universal_paths = get_universal_paths()
            
            if universal_paths['environment'] != 'raspberry_pi':
                print(f"DEBUG: [ADD_ROUTER_DETECTION] Simulando execução do script (ambiente: {universal_paths['environment']}): ./detection_fullscreen.sh {object_name}")
                # Simular delay e fechar loading screen
                if loading_window:
                    def close_loading_and_return():
                        loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                    self.after(3000, close_loading_and_return)
                return True
            
            # Usar o caminho do script detectado automaticamente
            script_path = universal_paths['detection_script']
            
            # Verificar se existe
            if not os.path.exists(script_path):
                alternative_paths = get_possible_raspberry_pi_paths("object_detection/detection_fullscreen.sh")
                alternative_paths.extend(get_possible_raspberry_pi_paths("detection_fullscreen.sh"))
                
                script_path = None
                for path in alternative_paths:
                    if os.path.exists(path):
                        script_path = path
                        break
                
                if not script_path:
                    print(f"DEBUG: [ADD_ROUTER_DETECTION] Script não encontrado")
                    return False
            
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Executando: {script_path} {object_name}")
            
            # Tornar o script executável
            subprocess.run(['chmod', '+x', script_path], check=True)
            
            # Executar script em background
            process = subprocess.Popen([script_path, object_name])
            
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Script iniciado (PID: {process.pid})")
            
            # Monitorar script com loading screen
            if loading_window:
                def check_yolo_initialization():
                    poll_result = process.poll()
                    if poll_result is None:
                        # YOLO deve estar inicializado - fechar loading screen
                        print(f"DEBUG: [ADD_ROUTER_DETECTION] Fechando loading screen - YOLO inicializando")
                        loading_window.destroy()
                        self.withdraw()  # Esconder interface Python
                        
                        # Monitorar conclusão
                        def check_script_completion():
                            poll_result = process.poll()
                            if poll_result is None:
                                self.after(1000, check_script_completion)
                            else:
                                print(f"DEBUG: [ADD_ROUTER_DETECTION] YOLO terminou - voltando ao PlayerDashboard")
                                self.deiconify()
                                self._voltar_playerdashboard_apos_router_selection()
                        
                        self.after(1000, check_script_completion)
                    else:
                        # Script terminou antes de inicializar
                        loading_window.destroy()
                        self._voltar_playerdashboard_apos_router_selection()
                
                # Aguardar 4.5 segundos para YOLO inicializar
                self.after(4500, check_yolo_initialization)
            
            return True
            
        except Exception as e:
            print(f"DEBUG: [ADD_ROUTER_DETECTION] Erro: {e}")
            if loading_window:
                loading_window.destroy()
            return False
    
    def _voltar_playerdashboard_apos_router_selection(self):
        """Volta ao PlayerDashboard após seleção/cancelamento de router"""
        print("DEBUG: [ADD_ROUTER] Voltando ao PlayerDashboard")
        
        # RESETAR FLAG DE PROTEÇÃO (garantia adicional)
        self._in_router_selection_page = False
        
        # Limpar a página atual
        for widget in self.winfo_children():
            widget.destroy()
        
        # Restaurar o PlayerDashboard completo
        # Preservar estado atual
        current_saldo = getattr(self, 'saldo', 1000)
        current_color = getattr(self, 'player_color', 'red')
        current_others = getattr(self, 'other_players', ['green', 'blue', 'yellow'])
        current_name = getattr(self, 'player_name', 'Player')
        current_card_idx = getattr(self, 'selected_card_idx', 0)
        
        # Recriar interface do PlayerDashboard
        self.playerdashboard_interface(
            current_name, 
            current_saldo, 
            current_others,
            show_store_button=True
        )


    def show_inventory_matrix(self, tipos, page=0, back_callback=None):
        # PROTEÇÃO CONTRA LOOP: Marcar que estamos a abrir inventário
        self._inventory_opening = True
        
        # CORREÇÃO CRÍTICA: Salvar estado da interface ANTES de destruir widgets
        print("DEBUG: [show_inventory_matrix] *** SALVANDO ESTADO ANTES DE LIMPAR WIDGETS ***")
        self._save_dashboard_state()
        
        print(f"DEBUG: [show_inventory_matrix] *** FUNÇÃO CHAMADA ***")
        print(f"DEBUG: [show_inventory_matrix] Tipos solicitados: {tipos}")
        print(f"DEBUG: [show_inventory_matrix] Page solicitada: {page}")
        print(f"DEBUG: [show_inventory_matrix] Estado COMPLETO do inventário:")
        total_cartas = 0
        for tipo, cartas_list in self.inventario.items():
            print(f"DEBUG: [show_inventory_matrix]   {tipo}: {len(cartas_list)} cartas")
            total_cartas += len(cartas_list)
            if cartas_list:
                for i, carta in enumerate(cartas_list[:5]):  # Mostrar primeiras 5 para debug
                    print(f"DEBUG: [show_inventory_matrix]     {i+1}. {os.path.basename(carta)}")
        print(f"DEBUG: [show_inventory_matrix] Total de cartas no inventário: {total_cartas}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Criar TopBar se não existir
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            try:
                topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                print(f"DEBUG: [show_inventory_matrix] Criando TopBar: {topbar_img_path}")
                
                if os.path.exists(topbar_img_path):
                    img = Image.open(topbar_img_path).convert("RGBA")
                    img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                    topbar_img = ImageTk.PhotoImage(img)
                    self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                    self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
                    self.topbar_label.pack(side="top", fill="x")
                    print("DEBUG: [show_inventory_matrix] TopBar criada com sucesso!")
                else:
                    print(f"DEBUG: [show_inventory_matrix] Arquivo TopBar não encontrado, criando fallback")
                    # Criar barra superior fallback
                    topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                    topbar_frame.pack(side="top", fill="x")
                    topbar_frame.pack_propagate(False)
                    self.topbar_label = topbar_frame
                    print("DEBUG: [show_inventory_matrix] TopBar fallback criada!")
            except Exception as e:
                print(f"DEBUG: [show_inventory_matrix] ERRO ao criar TopBar: {e}")
                # Criar barra superior fallback em caso de erro
                topbar_frame = tk.Frame(self, bg=self.bar_color, height=60)
                topbar_frame.pack(side="top", fill="x")
                topbar_frame.pack_propagate(False)
                self.topbar_label = topbar_frame
                print("DEBUG: [show_inventory_matrix] TopBar fallback criada após erro!")
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        # Título
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        elif set(tipos) == set(["actions", "events"]):
            title_str = "Actions / Events"
        elif set(tipos) == set(["activities", "challenges"]):
            title_str = "Activities / Challenges"
        else:
            # Para outros casos, mostrar os tipos separados por /
            title_str = " / ".join([t.capitalize() for t in tipos])
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        # Verificar se é Actions/Events ou Activities/Challenges para organização especial em colunas
        if set(tipos) == set(["actions", "events"]):
            # NOVA IMPLEMENTAÇÃO: Fila única centrada combinando Actions e Events
            # CORREÇÃO: Mostrar TODAS as cartas do inventário em fila FIFO única
            cartas_actions_raw = self.inventario.get("actions", [])
            cartas_events_raw = self.inventario.get("events", [])
            
            # NOVA ABORDAGEM: Não filtrar - mostrar todas as cartas, mas marcar quais são válidas
            cartas_actions_filtered = self._filter_action_event_cards(cartas_actions_raw, "actions")
            cartas_events_filtered = self._filter_action_event_cards(cartas_events_raw, "events")
            
            # Combinar Actions e Events numa única fila FIFO cronológica
            # USAR A ORDEM CRONOLÓGICA REAL de adição ao inventário
            chronological_order = self._get_chronological_actions_events_order()
            
            # Filtrar as cartas válidas
            cartas_actions_filtered = self._filter_action_event_cards(cartas_actions_raw, "actions")
            cartas_events_filtered = self._filter_action_event_cards(cartas_events_raw, "events")
            
            # Construir a fila combinada na ordem cronológica
            combined_cards = []
            for card_info in chronological_order:
                carta_path = card_info['path']
                carta_tipo = card_info['type']
                
                # Verificar se a carta ainda existe nos inventários
                if carta_tipo == 'actions' and carta_path in cartas_actions_raw:
                    is_valid = carta_path in cartas_actions_filtered
                    original_idx = cartas_actions_raw.index(carta_path)
                    combined_cards.append({
                        'path': carta_path,
                        'type': 'actions',
                        'original_idx': original_idx,
                        'is_valid': is_valid,
                        'chronological_pos': card_info['timestamp']
                    })
                elif carta_tipo == 'events' and carta_path in cartas_events_raw:
                    is_valid = carta_path in cartas_events_filtered
                    original_idx = cartas_events_raw.index(carta_path)
                    combined_cards.append({
                        'path': carta_path,
                        'type': 'events',
                        'original_idx': original_idx,
                        'is_valid': is_valid,
                        'chronological_pos': card_info['timestamp']
                    })
            
            print(f"DEBUG: [show_inventory_matrix] Fila única Actions+Events: {len(combined_cards)} cartas")
            print(f"DEBUG: [show_inventory_matrix] Actions: {len(cartas_actions_raw)}, Events: {len(cartas_events_raw)}")
            
            # Paginação para fila única usando disposição vertical nx1
            cards_per_page = 2  # Apenas 2 cartas por página para evitar sobreposição
            total_pages = max(1, (len(combined_cards) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cards_page = combined_cards[start_idx:end_idx]
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            n_col = 1  # Uma única coluna centrada
            
            # Processar cartas da página numa fila única vertical
            for idx, card_info in enumerate(cards_page):
                row = idx  # Cada carta numa linha diferente
                col = 0    # Sempre coluna 0 (única coluna)
                
                carta_path = card_info['path']
                carta_tipo = card_info['type']
                original_idx = card_info['original_idx']
                is_valid = card_info['is_valid']
                
                # Calcular posição absoluta na fila combinada
                absolute_position = start_idx + idx
                
                try:
                    # NOVA LÓGICA COM SISTEMA DE SEQUENCIAMENTO:
                    # 1. Usar get_active_cards_for_type para determinar se carta está ativa
                    # 2. Cartas ativas ficam viradas para cima
                    # 3. Cartas inativas ficam viradas para baixo mas são clicáveis para visualização
                    
                    # Obter cartas ativas usando sistema de sequenciamento
                    cartas_ativas_actions = self.get_active_cards_for_type("actions")
                    cartas_ativas_events = self.get_active_cards_for_type("events")
                    
                    # Verificar se a carta atual está ativa
                    is_carta_ativa = False
                    if carta_tipo == "actions":
                        is_carta_ativa = carta_path in cartas_ativas_actions
                    elif carta_tipo == "events":
                        is_carta_ativa = carta_path in cartas_ativas_events
                    
                    # Determinar apresentação da carta
                    if is_carta_ativa and is_valid:
                        # Carta ativa e válida: virada para cima
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_click_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_click_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Carta ATIVA (virada para cima): {carta_tipo} - {os.path.basename(carta_path)}")
                    elif is_valid:
                        # Carta válida mas inativa: virada para baixo mas clicável
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_facedown_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_facedown_handler(carta_path, tipos)
                        
                        # Debugging adicional para cartas inativas
                        if carta_tipo == "actions" and hasattr(self, '_actions_pending_activation'):
                            is_pending = (carta_path in self._actions_pending_activation and 
                                        self._actions_pending_activation[carta_path])
                            if is_pending:
                                print(f"DEBUG: [show_inventory_matrix] Carta INATIVA por sequenciamento (aguardando próximo turno): {carta_tipo} - {os.path.basename(carta_path)}")
                            else:
                                print(f"DEBUG: [show_inventory_matrix] Carta INATIVA (não é primeira na fila): {carta_tipo} - {os.path.basename(carta_path)}")
                        elif carta_tipo == "events" and hasattr(self, '_event_duration_tracking'):
                            tracking_data = self._event_duration_tracking.get(carta_path, {})
                            if tracking_data.get('pending_activation', False):
                                print(f"DEBUG: [show_inventory_matrix] Event INATIVO por sequenciamento (aguardando próximo turno): {os.path.basename(carta_path)}")
                            else:
                                print(f"DEBUG: [show_inventory_matrix] Event INATIVO (não é primeiro na fila): {os.path.basename(carta_path)}")
                        else:
                            print(f"DEBUG: [show_inventory_matrix] Carta INATIVA na fila (pos {absolute_position}): {carta_tipo} - {os.path.basename(carta_path)}")
                    else:
                        # Carta inválida: virada para baixo
                        img = ImageTk.PhotoImage(Image.open(CARD_IMG).resize((card_w, card_h)))
                        cursor_type = "hand2"
                        def make_invalid_handler(path, tipos_param):
                            return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                        click_handler = make_invalid_handler(carta_path, tipos)
                        print(f"DEBUG: [show_inventory_matrix] Carta INVÁLIDA (pos {absolute_position}): {carta_tipo} - {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Carta colocada na linha {row}, coluna {col} (pos absoluta {absolute_position})")
                    
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar carta {carta_tipo}: {e}")
                    continue
            
            # Adicionar setas de navegação para Actions/Events se houver múltiplas páginas
            if total_pages > 1:
                # Seta esquerda (página anterior)
                if page > 0:
                    try:
                        arrow_left_img = ImageTk.PhotoImage(Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((30, 30)))
                        arrow_left_btn = tk.Label(self, image=arrow_left_img, cursor="hand2", bg="black")
                        arrow_left_btn.image = arrow_left_img
                        arrow_left_btn.place(x=50, rely=0.5, anchor="w")
                        arrow_left_btn.bind("<Button-1>", lambda e: self.show_inventory_matrix(tipos, page - 1, back_callback))
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar seta esquerda: {e}")
                
                # Seta direita (próxima página)  
                if page < total_pages - 1:
                    try:
                        # Rotacionar a imagem arrow_left 180 graus para criar seta direita
                        arrow_right_img_pil = Image.open(os.path.join(IMG_DIR, "arrow_left.png")).resize((30, 30)).rotate(180)
                        arrow_right_img = ImageTk.PhotoImage(arrow_right_img_pil)
                        arrow_right_btn = tk.Label(self, image=arrow_right_img, cursor="hand2", bg="black")
                        arrow_right_btn.image = arrow_right_img
                        arrow_right_btn.place(x=self.winfo_screenwidth() - 50, rely=0.5, anchor="e")
                        arrow_right_btn.bind("<Button-1>", lambda e: self.show_inventory_matrix(tipos, page + 1, back_callback))
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar seta direita: {e}")
        elif set(tipos) == set(["activities", "challenges"]):
            # Organização especial: Activities na coluna esquerda, Challenges na coluna direita
            # Estrutura igual ao Actions/Events
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            
            print(f"DEBUG: [show_inventory_matrix] Cartas Activities: {len(cartas_activities)}")
            print(f"DEBUG: [show_inventory_matrix] Cartas Challenges: {len(cartas_challenges)}")
            
            # DEBUG: Verificar se as cartas estão nos inventários corretos
            print("DEBUG: [show_inventory_matrix] === VERIFICAÇÃO DE INVENTÁRIOS ===")
            for i, carta in enumerate(cartas_activities[:3]):  # Mostrar primeiras 3 Activities
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Activities[{i}]: {basename}")
                # Verificar se realmente é uma Activity
                if "activity" not in basename.lower() and "activities" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} NÃO parece ser uma Activity! ***")
            
            for i, carta in enumerate(cartas_challenges[:3]):  # Mostrar primeiras 3 Challenges
                basename = os.path.basename(carta)
                print(f"DEBUG: [show_inventory_matrix] Challenges[{i}]: {basename}")
                # Verificar se realmente é uma Challenge
                if "challenge" not in basename.lower() and "challenges" not in carta.lower():
                    print(f"DEBUG: [show_inventory_matrix] *** ERRO: {basename} NÃO parece ser uma Challenge! ***")
            print("DEBUG: [show_inventory_matrix] === FIM VERIFICAÇÃO ===")
            
            # Calcular total de cartas para paginação (2 linhas, 1 carta de cada tipo por linha)
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid para manter estrutura 2x2
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna da esquerda (col=0)
            activities_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                activities_to_show.append((i, cartas_activities[i]))
            
            # Determinar posições das cartas Activities baseado no número de cartas a mostrar
            activities_row_counter = 0
            for original_idx, carta_path in activities_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar função auxiliar para corrigir closure problem
                    def make_click_handler_activities(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_activities(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Activity COLUNA ESQUERDA (col=0): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row_counter, column=0, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Activity colocada na linha {activities_row_counter}, coluna 0 (ESQUERDA)")
                    activities_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Activity: {e}")
                    continue
            
            # Colocar Challenges na coluna da direita (col=1)
            challenges_to_show = []
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                challenges_to_show.append((i, cartas_challenges[i]))
            
            # Determinar posições das cartas Challenges baseado no número de cartas a mostrar
            challenges_row_counter = 0
            for original_idx, carta_path in challenges_to_show:
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    cursor_type = "hand2"
                    # Usar função auxiliar para corrigir closure problem
                    def make_click_handler_challenges(path, tipos_param):
                        return lambda e: self.show_card_fullscreen_inventory(path, tipos_param, page)
                    click_handler = make_click_handler_challenges(carta_path, tipos)
                    print(f"DEBUG: [show_inventory_matrix] Challenge COLUNA DIREITA (col=1): {os.path.basename(carta_path)}")
                    
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row_counter, column=1, padx=8, pady=8)
                    
                    if click_handler:
                        carta_lbl.bind("<Button-1>", click_handler)
                    
                    print(f"DEBUG: [show_inventory_matrix] Challenge colocado na linha {challenges_row_counter}, coluna 1 (DIREITA)")
                    challenges_row_counter += 1
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] Erro ao carregar Challenge: {e}")
                    continue
        else:
            # Organização normal para outros tipos
            cartas = []
            for t in tipos:
                cartas_tipo = self.inventario.get(t, [])
                print(f"DEBUG: [show_inventory_matrix] Cartas de {t}: {len(cartas_tipo)}")
                cartas += cartas_tipo
            
            print(f"DEBUG: [show_inventory_matrix] Total de cartas a mostrar: {len(cartas)}")
            # Paginação igual ao Activities/Challenges
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Igual ao Activities/Challenges
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    # Determinar o tipo da carta para verificar se está ativa
                    carta_tipo = None
                    if len(tipos) == 1:
                        carta_tipo = tipos[0]
                    else:
                        # Se são múltiplos tipos, tentar determinar pelo caminho da carta
                        path_lower = carta_path.lower()
                        if "/users/" in path_lower or "user_" in os.path.basename(path_lower):
                            carta_tipo = "users"
                        elif "/equipments/" in path_lower or "equipment_" in os.path.basename(path_lower):
                            carta_tipo = "equipments"
                        elif "/services/" in path_lower or "service_" in os.path.basename(path_lower):
                            carta_tipo = "services"
                    
                    # Verificar se a carta está ativa para Users/Equipments/Services
                    # CORREÇÃO: Sempre verificar estado ativo, independentemente de Next Phase
                    # As cartas que foram ativadas em turnos anteriores devem aparecer viradas para cima
                    is_active = False
                    if carta_tipo in ["users", "equipments", "services"]:
                        is_active = self.is_card_active(carta_path, carta_tipo)
                    
                    # Escolher imagem baseada no estado da carta
                    if carta_tipo in ["users", "equipments", "services"]:
                        # Verificar se é User_1.png - sempre virada para cima
                        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                        
                        if is_user_1:
                            # User_1.png sempre virada para cima
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] User_1.png SEMPRE virada para cima: {os.path.basename(carta_path)}")
                        elif is_active:
                            # Carta ativa: mostrar virada para cima (independentemente de Next Phase)
                            img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} ATIVA (virada para cima): {os.path.basename(carta_path)}")
                        else:
                            # Carta inativa: mostrar virada para baixo usando imagem específica da cor do jogador
                            back_card_colored = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                            img = ImageTk.PhotoImage(Image.open(back_card_colored).resize((card_w, card_h)))
                            print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} INATIVA (virada para baixo com cor {self.player_color}): {os.path.basename(carta_path)}")
                    else:
                        # Para outros tipos (activities, etc), mostrar normalmente
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_matrix] Carta {carta_tipo} normal: {os.path.basename(carta_path)}")
                        
                except Exception as e:
                    print(f"DEBUG: [show_inventory_matrix] ERRO ao processar carta {os.path.basename(carta_path)}: {e}")
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_inventory(p, t, pg))
        # Setas de navegação à direita
        if total_pages > 1:
            seta_x = 0.90
            if page > 0:
                seta_cima = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page-1, back_callback))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix(tipos, page+1, back_callback))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((self.screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Botão Back centrado na parte inferior - criado após a barra para ficar por cima
        # NOVA FUNCIONALIDADE: Desabilitar botão Back durante ROUTER UPGRADE, ROUTER DOWNGRADE ou LINK UPGRADE
        is_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
        is_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
        is_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
        
        if back_callback:
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_callback)
        else:
            def back_to_dashboard():
                # PROTEÇÃO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
                self._inventory_opening = False
                # CORREÇÃO CRÍTICA: Restaurar estado ANTES de recriar interface
                # Isto garante que o estado é preservado corretamente
                saved_state = getattr(self, '_saved_dashboard_state', None)
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                # Restaurar estado imediatamente após recriar interface
                if saved_state:
                    self._saved_dashboard_state = saved_state
                    self._restore_dashboard_state()
            back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard)
        
        # Desabilitar botão se estivermos em contexto ROUTER UPGRADE, ROUTER DOWNGRADE, LINK UPGRADE ou LINK DOWNGRADE
        if is_router_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_UPGRADE] Botão Back DESABILITADO durante contexto ROUTER UPGRADE")
        elif is_router_downgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [ROUTER_DOWNGRADE] Botão Back DESABILITADO durante contexto ROUTER DOWNGRADE")
        elif is_link_upgrade_context:
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_UPGRADE] Botão Back DESABILITADO durante contexto LINK UPGRADE")
        elif getattr(self, '_in_link_downgrade_context', False):
            back_btn.config(state='disabled', bg="#555555")
            print(f"DEBUG: [LINK_DOWNGRADE] Botão Back DESABILITADO durante contexto LINK DOWNGRADE")
        else:
            back_btn.config(state='normal')
            print(f"DEBUG: [INVENTORY] Botão Back HABILITADO (não em contexto ROUTER/LINK)")
            
        back_btn.place(relx=0.5, rely=0.98, anchor="s")
        
        # Salvar referência do botão Back para poder reabilitar posteriormente
        self._back_button = back_btn

        # Saldo no canto inferior direito - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))

    def show_card_fullscreen_inventory(self, carta_path, tipos, page=0):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Botão X para fechar
        def voltar_inventario():
            # Se for inventário de Activities/Challenges, volta para show_inventory_matrix_carrossel
            if set(tipos) == set(["activities", "challenges"]):
                self.show_inventory_matrix_carrossel(tipos, page)
            else:
                self.show_inventory_matrix(tipos, page)
        # Botão X para fechar - movido para canto superior esquerdo
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Se for Users, Equipments, Services, Activities ou Challenges, mostrar botão de venda APENAS se estiver numa casa do tipo correspondente
        # Para Activities/Challenges: podem ser vendidas quando estás numa casa Activities
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # Determinar o tipo da carta atual PRIMEIRO
        carta_tipo = None
        if len(tipos) == 1:
            carta_tipo = tipos[0]
        elif set(tipos) == set(["activities", "challenges"]):
            # Se é uma página Activities/Challenges, determinar tipo pela carta específica
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo = "challenges"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "activities" in carta_dirname:
                    carta_tipo = "activities"
                elif "challenges" in carta_dirname:
                    carta_tipo = "challenges"
        elif set(tipos) == set(["actions", "events"]):
            # Se é uma página Actions/Events, determinar tipo pela carta específica
            carta_basename = os.path.basename(carta_path).lower()
            if "action" in carta_basename or "actions" in carta_basename:
                carta_tipo = "actions"
            elif "event" in carta_basename or "events" in carta_basename:
                carta_tipo = "events"
            else:
                # Tentar determinar pelo caminho da pasta
                carta_dirname = os.path.dirname(carta_path).lower()
                if "actions" in carta_dirname:
                    carta_tipo = "actions"
                elif "events" in carta_dirname:
                    carta_tipo = "events"
        
        print(f"DEBUG: [FULLSCREEN] Carta tipo determinado: '{carta_tipo}' para carta: {os.path.basename(carta_path)} com tipos: {tipos}")
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do inventário - Next Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se Final Phase estiver ativo, NÃO pode vender nenhuma carta
        elif getattr(self, '_final_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do inventário - Final Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        # IMPORTANTE: Se está numa casa START, NÃO pode vender nenhuma carta
        elif casa_atual_tipo == "start":
            print(f"DEBUG: NÃO pode vender carta do inventário - está numa casa START (nenhuma venda permitida)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            print(f"DEBUG: Verificando possibilidade de venda no inventário - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # CORREÇÃO: Verificar se pode vender considerando casas de outros jogadores
            current_other_player_house = getattr(self, 'current_other_player_house', False)
            print(f"DEBUG: current_other_player_house = {current_other_player_house}")
            
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo OU numa casa de outro jogador do mesmo tipo
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                # Incluindo casas de outros jogadores
                if casa_atual_tipo == carta_tipo or (current_other_player_house and casa_atual_tipo == carta_tipo):
                    pode_vender = True
        
        # NOVA FUNCIONALIDADE: Botão verde ✓ para equipment no contexto REMOVE ROUTER
        # PRIORIDADE MÁXIMA: Este botão deve aparecer ANTES de qualquer outro
        # Condições: estamos no contexto REMOVE ROUTER, carta é equipment
        if (carta_tipo == "equipments" and 
            getattr(self, '_in_remove_router_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto REMOVE ROUTER detectado: {os.path.basename(carta_path)}")
            
            def processar_remove_router():
                """Remove o router selecionado e volta à interface principal"""
                print(f"DEBUG: [REMOVE_ROUTER_GO] Processando remoção do router: {os.path.basename(carta_path)}")
                
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Router removido do inventário")
                    
                    # Devolver carta ao baralho da Store (se há referência)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Router devolvido ao baralho da Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_GO] Erro ao devolver router à Store: {e}")
                    
                    # Limpar flag do contexto REMOVE ROUTER
                    self._in_remove_router_context = False
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Flag de contexto REMOVE ROUTER limpa")
                    
                    # Voltar à interface principal
                    print(f"DEBUG: [REMOVE_ROUTER_GO] Voltando à interface principal")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_GO] ERRO: Router não encontrado no inventário")
            
            # Botão verde ✓ no canto superior direito para processar remoção
            btn_remove_router = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#4CAF50", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                command=processar_remove_router, 
                cursor="hand2", 
                activebackground="#43d17a"
            )
            btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
            print(f"DEBUG: [FULLSCREEN] Botão ✓ verde configurado para remoção do router")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto ROUTER UPGRADE
        # PRIORIDADE: Este botão deve aparecer ANTES de qualquer outro (exceto REMOVE ROUTER)
        # Condições: estamos no contexto ROUTER UPGRADE, carta é equipment do tipo Small Router correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Small Router correto para o router_id da Action
            router_upgrade_target_id = getattr(self, '_router_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Router upgrade target ID: {router_upgrade_target_id}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # MODIFICAÇÃO: Para ROUTER UPGRADE, verificar se é o router correto E está ativo (virado para cima)
            # Conforme solicitado pelo usuário: "O botão certo vermelho só aparece na carta virada para cima"
            is_target_router = (equipment_id == router_upgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_UPGRADE_CHECK] NOVA REGRA: Router upgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # CORREÇÃO SOLICITADA: Apenas mostrar botão se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_UPGRADE] Small Router correto E ATIVO encontrado para upgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar upgrade
                btn_router_upgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para upgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router não é o target correto - não mostrando botão")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_UPGRADE] Router correto mas INATIVO (virado para baixo) - não mostrando botão conforme solicitado")
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto ROUTER DOWNGRADE
        # Condições: estamos no contexto ROUTER DOWNGRADE, carta é equipment do tipo Medium Router correspondente e ATIVO
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_router_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto ROUTER DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Medium Router correto para o router_id da Action
            router_downgrade_target_id = getattr(self, '_router_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade target ID: {router_downgrade_target_id}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Verificar se é o router correto E está ativo (virado para cima)
            is_target_router = (equipment_id == router_downgrade_target_id)
            is_active_equipment = self.is_card_active(carta_path, "equipments")
            
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is target router: {is_target_router}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Is active equipment: {is_active_equipment}")
            print(f"DEBUG: [ROUTER_DOWNGRADE_CHECK] Router downgrade apenas para cartas ATIVAS (viradas para cima)")
            
            # Apenas mostrar botão se router correto E ativo
            if is_target_router and is_active_equipment:
                print(f"DEBUG: [ROUTER_DOWNGRADE] Medium Router correto E ATIVO encontrado para downgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar downgrade
                btn_router_downgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_router_downgrade_confirmation(router_downgrade_target_id), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_router_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para downgrade do router")
            else:
                if not is_target_router:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router não é o target correto - não mostrando botão")
                elif not is_active_equipment:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Router correto mas INATIVO (virado para baixo) - não mostrando botão")
                else:
                    print(f"DEBUG: [ROUTER_DOWNGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto LINK UPGRADE
        # Condições: estamos no contexto LINK UPGRADE, carta é equipment do tipo Long Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_upgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK UPGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Long Link correto para o router_id da Action
            link_upgrade_target_id = getattr(self, '_link_upgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Link upgrade target ID: {link_upgrade_target_id}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK UPGRADE, verificar se é o link correto (Long Link)
            is_target_link = (equipment_id == link_upgrade_target_id)
            
            # Mapear equipment_id para nomes de Long Links
            long_link_mapping = {
                1: "Equipment_10.png",  # Long Link 1
                2: "Equipment_11.png",  # Long Link 2
                3: "Equipment_12.png",  # Long Link 3
            }
            
            expected_long_link = long_link_mapping.get(link_upgrade_target_id)
            is_long_link = (os.path.basename(carta_path) == expected_long_link) if expected_long_link else False
            
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Expected long link: {expected_long_link}")
            print(f"DEBUG: [LINK_UPGRADE_CHECK] Is long link: {is_long_link}")
            
            # Apenas mostrar botão se link correto
            if is_target_link and is_long_link:
                print(f"DEBUG: [LINK_UPGRADE] Long Link correto encontrado para upgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar upgrade
                btn_link_upgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_upgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_upgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para upgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_UPGRADE] Link não é o target correto - não mostrando botão")
                elif not is_long_link:
                    print(f"DEBUG: [LINK_UPGRADE] Equipment não é Long Link - não mostrando botão")
                else:
                    print(f"DEBUG: [LINK_UPGRADE] Condições não atendidas - não mostrando botão")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para equipment no contexto LINK DOWNGRADE
        # Condições: estamos no contexto LINK DOWNGRADE, carta é equipment do tipo Short Link correspondente
        elif (carta_tipo == "equipments" and 
              getattr(self, '_in_link_downgrade_context', False)):
            
            print(f"DEBUG: [FULLSCREEN] Equipment no contexto LINK DOWNGRADE detectado: {os.path.basename(carta_path)}")
            
            # Verificar se é o Short Link correto para o router_id da Action
            link_downgrade_target_id = getattr(self, '_link_downgrade_target_id', None)
            equipment_id = self._get_equipment_specific_id(carta_path)
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Link downgrade target ID: {link_downgrade_target_id}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Equipment specific ID: {equipment_id}")
            
            # Para LINK DOWNGRADE, verificar se é o link correto (Short Link)
            is_target_link = (equipment_id == link_downgrade_target_id)
            
            # Mapear equipment_id para nomes de Short Links
            short_link_mapping = {
                1: "Equipment_7.png",   # Short Link 1
                2: "Equipment_8.png",   # Short Link 2
                3: "Equipment_9.png",   # Short Link 3
            }
            
            expected_short_link = short_link_mapping.get(link_downgrade_target_id)
            is_short_link = (os.path.basename(carta_path) == expected_short_link) if expected_short_link else False
            
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is target link: {is_target_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Expected short link: {expected_short_link}")
            print(f"DEBUG: [LINK_DOWNGRADE_CHECK] Is short link: {is_short_link}")
            
            # Apenas mostrar botão se link correto
            if is_target_link and is_short_link:
                print(f"DEBUG: [LINK_DOWNGRADE] Short Link correto encontrado para downgrade")
                
                # Botão vermelho ✓ no canto superior direito para processar downgrade
                btn_link_downgrade = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#F44336", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=lambda: self.show_link_downgrade_confirmation(carta_path, carta_tipo, tipos, page), 
                    cursor="hand2", 
                    activebackground="#d32f2f"
                )
                btn_link_downgrade.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para downgrade do link")
            else:
                if not is_target_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Link não é o target correto - não mostrando botão")
                elif not is_short_link:
                    print(f"DEBUG: [LINK_DOWNGRADE] Equipment não é Short Link - não mostrando botão")
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE] Condições não atendidas - não mostrando botão")
        
        # Botão de venda com checkmark no canto superior direito (substitui o botão verde picoin)
        # APENAS se NÃO for uma carta Activities/Challenges, porque essas têm layout especial
        # IMPORTANTE: User_1.png nunca pode ser vendida
        # IMPORTANTE: Cartas ATIVAS (Users/Equipments/Services viradas para cima) nunca podem ser vendidas
        # IMPORTANTE: NÃO mostrar se já estamos no contexto REMOVE ROUTER
        elif (carta_tipo not in ["activities", "challenges"] and 
              not getattr(self, '_in_remove_router_context', False)):
            
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # NOVA VERIFICAÇÃO: Cartas ativas não podem ser vendidas
            is_carta_ativa = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_carta_ativa = self.is_card_active(carta_path, carta_tipo)
            
            if pode_vender and not is_user_1 and not is_carta_ativa:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo}")
                def abrir_confirm():
                    # Guardar informações para navegação correta
                    self._origem_venda = "inventario"
                    self._tipos_venda = None
                    self._page_venda = 0
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Botão com checkmark (✓) no canto superior direito
                btn_sell = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
                btn_sell.place(relx=0.98, rely=0, anchor="ne")
            elif is_user_1:
                print(f"DEBUG: User_1.png NÃO pode ser vendida")
            elif is_carta_ativa:
                print(f"DEBUG: Carta {carta_tipo} ATIVA (virada para cima) NÃO pode ser vendida - apenas cartas inativas podem ser vendidas")
            elif not pode_vender:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: activities (para Activities/Challenges) ou {carta_tipo} (para outros tipos)")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para remover Actions ativas após Next Phase
        # Condições: Next Phase ativo, antes de Final Phase, carta Action ativa, página Actions/Events
        # CORREÇÃO PROBLEMA 1: Verificar se a carta não está virada para baixo
        print(f"DEBUG: [FULLSCREEN] Verificando condições para botão vermelho ✓:")
        print(f"DEBUG: [FULLSCREEN]   carta_tipo: '{carta_tipo}'")
        print(f"DEBUG: [FULLSCREEN]   tipos: {tipos}")
        print(f"DEBUG: [FULLSCREEN]   set(tipos) == set(['actions', 'events']): {set(tipos) == set(['actions', 'events'])}")
        print(f"DEBUG: [FULLSCREEN]   _next_phase_active: {getattr(self, '_next_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_active: {getattr(self, '_final_phase_active', False)}")
        print(f"DEBUG: [FULLSCREEN]   _final_phase_gestao_ativa: {getattr(self, '_final_phase_gestao_ativa', False)}")
        
        # CORREÇÃO PROBLEMA 1: Verificar se a carta está virada para baixo
        carta_basename = os.path.basename(carta_path).lower()
        is_carta_virada_para_baixo = carta_basename.startswith("back_card_")
        
        # CORREÇÃO CRÍTICA: Para cartas Actions, verificar também a lógica do sistema
        if carta_tipo == "actions" and not is_carta_virada_para_baixo:
            # Verificar se é a primeira carta Action e se uma Action foi removida recentemente
            cartas_actions = self.inventario.get("actions", [])
            if cartas_actions and carta_path == cartas_actions[0] and getattr(self, '_action_recently_removed', False):
                is_carta_virada_para_baixo = True
                print(f"DEBUG: [FULLSCREEN] Carta Action detectada como virada para baixo pela lógica do sistema (Action removida recentemente)")
        
        print(f"DEBUG: [FULLSCREEN]   is_carta_virada_para_baixo: {is_carta_virada_para_baixo}")
        
        # CORREÇÃO PROBLEMA 1: Durante gestão de pacotes, permitir botão vermelho
        # A gestão de pacotes acontece quando _final_phase_gestao_ativa é True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        print(f"DEBUG: [FULLSCREEN]   gestao_pacotes_ativa: {gestao_pacotes_ativa}")
        print(f"DEBUG: [FULLSCREEN]   final_phase_normal: {final_phase_normal}")
        
        # CORREÇÃO PROBLEMA 1: Durante gestão de pacotes, permitir botão vermelho
        # A gestão de pacotes acontece quando _final_phase_gestao_ativa é True
        gestao_pacotes_ativa = getattr(self, '_final_phase_gestao_ativa', False)
        final_phase_normal = getattr(self, '_final_phase_active', False) and not gestao_pacotes_ativa
        
        if (carta_tipo == "actions" and 
            set(tipos) == set(["actions", "events"]) and
            getattr(self, '_next_phase_active', False) and 
            not final_phase_normal and  # CORREÇÃO: Permite durante gestão de pacotes
            not is_carta_virada_para_baixo):  # CORREÇÃO: NÃO mostrar botão se carta está virada para baixo
            
            # Verificar se a carta Action está realmente ativa usando o método oficial
            cartas_ativas_actions = self.get_active_cards_for_type("actions")
            is_action_ativa = carta_path in cartas_ativas_actions
            
            if is_action_ativa:
                print(f"DEBUG: [FULLSCREEN] Action ativa detectada após Next Phase: {os.path.basename(carta_path)}")
            else:
                print(f"DEBUG: [FULLSCREEN] Action INATIVA no inventário: {os.path.basename(carta_path)}")
            
            if is_action_ativa:
                print(f"DEBUG: [FULLSCREEN] Action ativa detectada após Next Phase: {os.path.basename(carta_path)}")
                
                def mostrar_action_info_overlay():
                    """Mostra overlay com informações da carta Action usando estilo similar ao overlay de Event"""
                    import re
                    import os
                    
                    print(f"DEBUG: [ACTION_INFO] Mostrando informações da Action: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Action da base de dados
                    action_title = "Action Information"
                    action_description = "Description not available"
                    action_target_router = "N/A"
                    action_effect = "Effect description not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Action_43" -> "action_43")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Action_(\d+)', filename)
                            
                            if match:
                                action_id = f"action_{match.group(1)}"
                                action_card = self.card_database.get_action(action_id)
                                
                                if action_card:
                                    action_title = action_card.title
                                    action_description = action_card.description
                                    action_effect = action_card.effect_description
                                    # Determinar o target baseado no router_id e tipo de ação
                                    if action_card.router_id:
                                        action_target_router = str(action_card.router_id)
                                    elif ActionType and action_card.action_type in [ActionType.ADD_ROUTER, ActionType.REMOVE_ROUTER]:
                                        # Para ADD/REMOVE ROUTER, mostrar texto específico
                                        action_target_router = "New Router" if action_card.action_type == ActionType.ADD_ROUTER else "Last router added"
                                    elif action_card.title in ["ADD ROUTER", "REMOVE ROUTER"]:
                                        # Fallback usando o título quando ActionType não está disponível
                                        action_target_router = "New Router" if action_card.title == "ADD ROUTER" else "Last router added"
                                    else:
                                        action_target_router = "N/A"
                                    
                                    print(f"DEBUG: [ACTION_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [ACTION_INFO]   Title: {action_title}")
                                    print(f"DEBUG: [ACTION_INFO]   Description: {action_description}")
                                    print(f"DEBUG: [ACTION_INFO]   Router ID: {action_target_router}")
                                    print(f"DEBUG: [ACTION_INFO]   Action Type: {action_card.action_type}")
                                    print(f"DEBUG: [ACTION_INFO]   Effect: {action_effect}")
                                else:
                                    print(f"DEBUG: [ACTION_INFO] Action não encontrada na base de dados: {action_id}")
                            else:
                                print(f"DEBUG: [ACTION_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [ACTION_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de Event)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o máximo possível da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter referência
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # Título (valor do campo title da carta Action)
                    print(f"DEBUG: [ACTION_INFO] Criando título com texto: {repr(action_title)}")
                    title_label = tk.Label(info_frame, text=action_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descrição da Action (texto branco)
                    print(f"DEBUG: [ACTION_INFO] Criando descrição com texto: {repr(action_description)}")
                    desc_label = tk.Label(info_frame, text=action_description, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target: Mostrar informação apropriada dependendo do tipo de Action
                    print(f"DEBUG: [ACTION_INFO] Criando target com router ID: {repr(action_target_router)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    # Determinar texto do target baseado no tipo de router_id
                    if action_target_router in ["New Router", "Any Router", "Last router added"]:
                        target_text = action_target_router
                    else:
                        target_text = f"Residential Router {action_target_router}"
                    
                    target_label_value = tk.Label(target_frame, text=target_text, 
                                                font=("Helvetica", 13, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Effect description (texto roxo)
                    print(f"DEBUG: [ACTION_INFO] Criando efeito com texto: {repr(action_effect)}")
                    effect_label = tk.Label(info_frame, text=action_effect, 
                                         font=("Helvetica", 12, "bold"), fg="#9966CC", bg="black",
                                         wraplength=600, justify="center")
                    effect_label.pack(pady=(0, 30))
                    
                    # Frame para o botão
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def remover_action_do_inventario():
                        """Remove a carta Action do inventário e aplica seus efeitos (ROUTER UPGRADE/DOWNGRADE)"""
                        print(f"DEBUG: [REMOVE_ACTION] Removendo Action do inventário: {os.path.basename(carta_path)}")
                        
                        # NOVA FUNCIONALIDADE: Aplicar efeitos da carta Action antes de removê-la
                        try:
                            if self.card_database:
                                # Extrair ID da carta Action
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Action_(\d+)', filename)
                                
                                if match:
                                    action_id = f"action_{match.group(1)}"
                                    action_card = self.card_database.get_action(action_id)
                                    
                                    if action_card:
                                        print(f"DEBUG: [ACTION_EFFECT] Aplicando efeito da Action {action_card.title}")
                                        print(f"DEBUG: [ACTION_EFFECT] Action Type: {action_card.action_type}")
                                        print(f"DEBUG: [ACTION_EFFECT] Router ID: {action_card.router_id}")
                                        
                                        # Aplicar efeitos específicos baseados no tipo de Action
                                        if ActionType and action_card.action_type == ActionType.ROUTER_UPGRADE:
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ROUTER_DOWNGRADE:
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_UPGRADE:
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.LINK_DOWNGRADE:
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif ActionType and action_card.action_type == ActionType.ADD_ROUTER:
                                            self._aplicar_add_router()
                                        elif ActionType and action_card.action_type == ActionType.REMOVE_ROUTER:
                                            self._aplicar_remove_router()
                                        elif action_card.title == "ROUTER UPGRADE":  # Fallback usando título
                                            self._aplicar_router_upgrade(action_card.router_id)
                                        elif action_card.title == "ROUTER DOWNGRADE":  # Fallback usando título
                                            self._aplicar_router_downgrade(action_card.router_id)
                                        elif action_card.title == "LINK UPGRADE":  # Fallback usando título
                                            self._aplicar_link_upgrade(action_card.router_id)
                                        elif action_card.title == "LINK DOWNGRADE":  # Fallback usando título
                                            self._aplicar_link_downgrade(action_card.router_id)
                                        elif action_card.title == "ADD ROUTER":  # Fallback usando título
                                            self._aplicar_add_router()
                                        elif action_card.title == "REMOVE ROUTER":  # Fallback usando título
                                            self._aplicar_remove_router()
                                        else:
                                            print(f"DEBUG: [ACTION_EFFECT] Action tipo {action_card.action_type} não implementado ainda")
                                    else:
                                        print(f"DEBUG: [ACTION_EFFECT] Action não encontrada na base de dados: {action_id}")
                                else:
                                    print(f"DEBUG: [ACTION_EFFECT] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [ACTION_EFFECT] Erro ao aplicar efeito da Action: {e}")
                        
                        # Remover carta do inventário
                        if "actions" in self.inventario and carta_path in self.inventario["actions"]:
                            self.inventario["actions"].remove(carta_path)
                            print(f"DEBUG: [REMOVE_ACTION] Carta removida do inventário do jogador")
                            
                            # Marcar que uma Action foi removida para a próxima carta ficar virada para baixo
                            self._action_recently_removed = True
                            print(f"DEBUG: [REMOVE_ACTION] Flag _action_recently_removed definida para True")
                            
                            # NOVA LÓGICA: Marcar próximas Actions como pendentes de ativação
                            self._mark_next_actions_as_pending()
                            
                            # Devolver carta ao baralho da Store (se há referência)
                            if hasattr(self, 'store_window') and self.store_window:
                                try:
                                    self.store_window.adicionar_carta_ao_baralho(carta_path, "actions", "neutral")
                                    print(f"DEBUG: [REMOVE_ACTION] Carta devolvida ao baralho da Store")
                                except Exception as e:
                                    print(f"DEBUG: [REMOVE_ACTION] Erro ao devolver carta à Store: {e}")
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ADD ROUTER abriu página de seleção
                            if getattr(self, '_in_router_selection_page', False):
                                print(f"DEBUG: [REMOVE_ACTION] ADD ROUTER ativo - mantendo página de seleção de routers")
                                return  # Interrompe aqui, não volta ao inventário
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se REMOVE ROUTER abriu página de inventário de equipments
                            if getattr(self, '_in_remove_router_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] REMOVE ROUTER ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ROUTER UPGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_router_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER UPGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se ROUTER DOWNGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_router_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] ROUTER DOWNGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se LINK UPGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_link_upgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK UPGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # CORREÇÃO CRÍTICA: NÃO voltar ao inventário se LINK DOWNGRADE abriu página de inventário de equipments
                            if getattr(self, '_in_link_downgrade_context', False):
                                print(f"DEBUG: [REMOVE_ACTION] LINK DOWNGRADE ativo - mantendo página de inventário de equipments")
                                return  # Interrompe aqui, não volta ao inventário Actions/Events
                            
                            # Voltar para a página de inventário Actions/Events
                            print(f"DEBUG: [REMOVE_ACTION] Voltando para inventário Actions/Events")
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir página de inventário Actions/Events
                            self.show_inventory_matrix(['actions', 'events'], page)
                        else:
                            print(f"DEBUG: [REMOVE_ACTION] ERRO: Carta não encontrada no inventário Actions")
                    
                    # Botão Go! (roxo para remover a action)
                    ok_button = tk.Button(btn_frame, text="Go!", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=remover_action_do_inventario)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [ACTION_INFO] Overlay de informações da Action criado e exibido")
                
                # Botão verde ✓ no canto superior direito
                btn_remove = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#4CAF50", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_action_info_overlay, 
                    cursor="hand2", 
                    activebackground="#43d17a"
                )
                btn_remove.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ verde configurado para mostrar overlay de informações da Action")
        
        # NOVA FUNCIONALIDADE: Botão vermelho ✓ para remover Events expirados
        # Condições: carta Event expirada, página Actions/Events (INDEPENDENTE de Next Phase)
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not final_phase_normal and  # CORREÇÃO: Permite durante gestão de pacotes
              not is_carta_virada_para_baixo):  # CORREÇÃO: NÃO mostrar botão se carta está virada para baixo
            
            # CORREÇÃO CRÍTICA: Verificar se este Event está na posição 0 da fila cronológica
            chronological_order = self._get_chronological_actions_events_order()
            is_event_do_topo = False
            
            # Apenas o primeiro item da fila (posição 0) pode ser considerado "Event do topo"
            if chronological_order and len(chronological_order) > 0:
                first_entry = chronological_order[0]
                is_event_do_topo = (first_entry['type'] == 'events' and first_entry['path'] == carta_path)
                
                # CORREÇÃO CRÍTICA: Event do topo só é realmente "do topo" se estiver ATIVO
                # Verificar se Event está ativo no tracking (não pode estar pendente)
                if is_event_do_topo:
                    if (hasattr(self, '_event_duration_tracking') and 
                        carta_path in self._event_duration_tracking):
                        event_data = self._event_duration_tracking[carta_path]
                        is_active = event_data.get('is_active', False)
                        is_pending = event_data.get('pending_activation', False)
                        
                        if not is_active or is_pending:
                            print(f"DEBUG: [FULLSCREEN] Event na posição 0 mas INATIVO ou PENDENTE - não é considerado 'do topo'")
                            print(f"DEBUG: [FULLSCREEN]   is_active: {is_active}, is_pending: {is_pending}")
                            is_event_do_topo = False
                    else:
                        print(f"DEBUG: [FULLSCREEN] Event na posição 0 mas SEM tracking - não é considerado 'do topo'")
                        is_event_do_topo = False
            
            print(f"DEBUG: [FULLSCREEN] Event {os.path.basename(carta_path)} está na posição 0? {is_event_do_topo}")
            
            if is_event_do_topo:
                # Verificar se o Event expirou
                current_turn = getattr(self, '_current_turn', 0)
                is_event_expirado = False
                
                # GARANTIR que o Event do topo está ativo
                self._ensure_active_event_tracking()
                
                # CORREÇÃO: Verificar expiração apenas se Event está ativo
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    
                    event_data = self._event_duration_tracking[carta_path]
                    is_active = event_data.get('is_active', False)
                    start_turn = event_data.get('start_turn')
                    duration_turns = event_data.get('duration_turns')
                    
                    print(f"DEBUG: [FULLSCREEN] Verificando expiração Event {os.path.basename(carta_path)}:")
                    print(f"DEBUG: [FULLSCREEN]   É ativo? {is_active}")
                    print(f"DEBUG: [FULLSCREEN]   Turno atual: {current_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Turno início: {start_turn}")
                    print(f"DEBUG: [FULLSCREEN]   Duration: {duration_turns}")
                    
                    # Só verificar expiração se Event está ativo e tem start_turn válido
                    if is_active and start_turn is not None and duration_turns is not None:
                        # CORREÇÃO: Verificar se é duração variável
                        if duration_turns == "variable":
                            print(f"DEBUG: [FULLSCREEN]   Event com duração variável - ainda não expirou")
                            print(f"DEBUG: [FULLSCREEN]   Aguardando lançamento do dado para determinar duração")
                            is_event_expirado = False
                        else:
                            turns_elapsed = current_turn - start_turn
                            print(f"DEBUG: [FULLSCREEN]   Turnos decorridos: {turns_elapsed}")
                            print(f"DEBUG: [FULLSCREEN]   Expira neste turno? {turns_elapsed >= duration_turns}")
                            
                            # CORREÇÃO: No turno de expiração, mostrar botão ✓ para remoção
                            is_event_expirado = (turns_elapsed >= duration_turns)
                    else:
                        print(f"DEBUG: [FULLSCREEN]   Event não está ativo - não calcular expiração")
                        is_event_expirado = False
                else:
                    # CORREÇÃO: Se não há tracking, tentar obter dados da base de dados
                    print(f"DEBUG: [FULLSCREEN] Event sem tracking - verificando base de dados: {os.path.basename(carta_path)}")
                    
                    # Tentar obter duration da base de dados
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            event_id = self._extract_event_id_from_path(carta_path)
                            if event_id:
                                event_data = self.card_database.get_event(event_id)
                                if event_data:
                                    duration_turns = event_data.duration_turns
                                    
                                    # CORREÇÃO: Verificar se é duração variável
                                    if duration_turns == "variable":
                                        print(f"DEBUG: [FULLSCREEN] Event com duração variável da BD - ainda não expirou")
                                        print(f"DEBUG: [FULLSCREEN]   Event com duração 'variable' NÃO deve expirar até dado ser lançado")
                                        is_event_expirado = False
                                    else:
                                        # CORREÇÃO CRÍTICA: Para Events com duração fixa SEM tracking,
                                        # não assumir que começaram no turno 1. Em vez disso, 
                                        # considerar que NÃO devem expirar sem tracking válido
                                        print(f"DEBUG: [FULLSCREEN] Event com duração fixa ({duration_turns}) mas SEM tracking válido")
                                        print(f"DEBUG: [FULLSCREEN]   CORREÇÃO: Events sem tracking NÃO devem expirar automaticamente")
                                        print(f"DEBUG: [FULLSCREEN]   Isto evita expiração incorreta de Events com duração variável já processados")
                                        is_event_expirado = False
                                        
                                        # DEBUG: Mostrar o que seria a lógica antiga (incorreta)
                                        old_start_turn = 1
                                        old_turns_elapsed = current_turn - old_start_turn
                                        old_would_expire = (old_turns_elapsed >= duration_turns)
                                        print(f"DEBUG: [FULLSCREEN]   LÓGICA ANTIGA (incorreta): start_turn={old_start_turn}, elapsed={old_turns_elapsed}, would_expire={old_would_expire}")
                                        print(f"DEBUG: [FULLSCREEN]   LÓGICA NOVA (correta): Event não expira sem tracking válido")
                        except Exception as e:
                            print(f"DEBUG: [FULLSCREEN] Erro ao obter dados do Event da BD: {e}")
                            is_event_expirado = False
                
                if is_event_expirado:
                    print(f"DEBUG: [FULLSCREEN] Event no turno de expiração detectado: {os.path.basename(carta_path)}")
                    
                    def mostrar_overlay_expiracao():
                        """Mostra overlay de confirmação para Event expirado"""
                        print(f"DEBUG: [OVERLAY_EVENT] Mostrando overlay de expiração para: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_event_expirado(carta_path)
                    
                    # Botão vermelho ✓ no canto superior direito (aparece no turno de expiração)
                    btn_remove_event = tk.Button(
                        self, 
                        text="✓", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF4444", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_overlay_expiracao, 
                        cursor="hand2", 
                        activebackground="#CC3333"
                    )
                    btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para mostrar overlay de Event que expira neste turno")
                else:
                    print(f"DEBUG: [FULLSCREEN] Event do topo ainda não expirou: {os.path.basename(carta_path)}")
                    
                    # FUNCIONALIDADE: Botão ⓘ para mostrar informações do Event não expirado
                    def mostrar_info_event():
                        """Mostra overlay com informações do Event ativo usando o estilo do overlay de ativação"""
                        import re
                        import os
                        
                        print(f"DEBUG: [EVENT_INFO] Mostrando informações do Event: {os.path.basename(carta_path)}")
                        
                        # Obter dados da carta Event da base de dados
                        event_title = "Event Information"
                        event_effect = "Effect description not available"
                        event_target = "Target not available"
                        
                        try:
                            if self.card_database:
                                # Extrair ID da carta (ex: "Event_367" -> "event_367")
                                filename = os.path.basename(carta_path)
                                match = re.match(r'Event_(\d+)', filename)
                                
                                if match:
                                    event_id = f"event_{match.group(1)}"
                                    event_card = self.card_database.get_event(event_id)
                                    
                                    if event_card:
                                        event_title = event_card.title
                                        event_effect = event_card.effect_description
                                        # Determinar o target baseado nos campos target_link e target_queue
                                        if event_card.target_link:
                                            event_target = event_card.target_link
                                        elif event_card.target_queue:
                                            event_target = event_card.target_queue
                                        else:
                                            event_target = "Target not specified"
                                        
                                        print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                        print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                        print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                        print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                    else:
                                        print(f"DEBUG: [EVENT_INFO] Event não encontrado na base de dados: {event_id}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                        except Exception as e:
                            print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                        
                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativação)
                        for widget in self.winfo_children():
                            widget.destroy()
                        
                        # Definir fundo preto para a janela
                        self.config(bg="black")
                        
                        # Carregar a imagem da carta como fundo
                        try:
                            carta_img = Image.open(carta_path)
                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                            
                            # Calcular o ratio para ocupar o máximo possível da tela
                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                            carta_photo = ImageTk.PhotoImage(carta_resized)
                            
                            # Label com a imagem da carta como fundo
                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                            carta_label.image = carta_photo  # Manter referência
                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                            
                        except Exception as e:
                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                            self.config(bg="black")
                        
                        # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                        info_frame = tk.Frame(self, bg="black")
                        info_frame.pack(expand=True)
                        
                        # Título (roxo)
                        print(f"DEBUG: [EVENT_INFO] Criando título com texto: {repr(event_title)}")
                        title_label = tk.Label(info_frame, text=event_title, 
                                font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                                wraplength=650, justify="center")
                        title_label.pack(pady=(40, 20))
                        
                        # Descrição do Event
                        print(f"DEBUG: [EVENT_INFO] Criando descrição com texto: {repr(event_effect)}")
                        desc_label = tk.Label(info_frame, text=event_effect, 
                                           font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                           wraplength=600, justify="center")
                        desc_label.pack(pady=(0, 20))
                        
                        # Target do Event
                        print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                        target_frame = tk.Frame(info_frame, bg="black")
                        target_frame.pack(pady=(0, 20))
                        
                        target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                     font=("Helvetica", 13, "bold"), fg="#9966CC", bg="black")
                        target_label_prefix.pack(side="left")
                        
                        target_label_value = tk.Label(target_frame, text=event_target, 
                                                    font=("Helvetica", 13, "bold"), fg="white", bg="black")
                        target_label_value.pack(side="left")
                        
                        # Frame para o botão
                        btn_frame = tk.Frame(info_frame, bg="black")
                        btn_frame.pack(pady=30)
                        
                        def fechar_overlay():
                            print(f"DEBUG: [EVENT_INFO] Fechando overlay de informações")
                            # Ir para a página de inventário Actions/Events
                            # Limpa tudo menos a barra superior
                            for widget in self.winfo_children():
                                if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                    continue
                                widget.destroy()
                            # Abrir página de inventário Actions/Events
                            self.show_inventory_matrix(['actions', 'events'])
                        
                        # Botão OK (roxo para combinar com o tema do Event)
                        ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                           bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                        ok_button.pack(pady=10)
                        
                        print(f"DEBUG: [EVENT_INFO] Overlay de informações criado e exibido")
                    
                    # Botão i laranja no canto superior direito (apenas quando Event ainda não expirou)
                    btn_info_event = tk.Button(
                        self, 
                        text="i", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#FF9800", 
                        fg="black", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        command=mostrar_info_event, 
                        cursor="hand2", 
                        activebackground="#E68900"
                    )
                    btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [FULLSCREEN] Botão i roxo configurado para informações do Event ativo")
                    
                    # NOVA FUNCIONALIDADE: Verificar se Event do topo tem duration_turns variável
                    # Se sim, mostrar botão "?" para determinar duração com dado
                    if hasattr(self, 'card_database') and self.card_database:
                        try:
                            import re
                            # Extrair ID da carta Event
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card and event_card.duration_turns == "variable":
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com duração variável detectado: {os.path.basename(carta_path)}")
                                    
                                    def mostrar_overlay_dado_duration():
                                        """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar duração")
                                        
                                        # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informação)
                                        for widget in self.winfo_children():
                                            widget.destroy()
                                        
                                        # Definir fundo preto para a janela
                                        self.config(bg="black")
                                        
                                        # Carregar a imagem da carta como fundo (igual ao overlay do botão "i")
                                        try:
                                            carta_img = Image.open(carta_path)
                                            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                            
                                            # Calcular o ratio para ocupar o máximo possível da tela
                                            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                            carta_photo = ImageTk.PhotoImage(carta_resized)
                                            
                                            # Label com a imagem da carta como fundo
                                            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                            carta_label.image = carta_photo  # Manter referência
                                            carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                            
                                        except Exception as e:
                                            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                            self.config(bg="black")
                                        
                                        # Frame central para o overlay (usar pack(expand=True) para dimensionamento dinâmico)
                                        overlay_frame = tk.Frame(self, bg="black")
                                        overlay_frame.pack(expand=True)
                                        
                                        # Título roxo
                                        title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                             font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                        title_label.pack(pady=(40, 30))
                                        
                                        # Dado (inicialmente em branco)
                                        blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                        dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                        dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                        dice_label.image = dice_img
                                        dice_label.pack(pady=20)
                                        
                                        # Botão Go!
                                        go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                            bg="#005c75", fg="white", width=8)
                                        go_button.pack(pady=20)
                                        
                                        def iniciar_animacao_dado():
                                            """Inicia a animação do dado e define a duração"""
                                            print(f"DEBUG: [VARIABLE_DURATION] Iniciando animação do dado")
                                            
                                            # Esconder botão Go!
                                            go_button.pack_forget()
                                            
                                            # Animação do dado (25 frames + resultado final)
                                            frames = 25
                                            results = [random.randint(1, 6) for _ in range(frames)]
                                            final_result = random.randint(1, 6)
                                            results.append(final_result)
                                            
                                            def animar_frame(frame_index=0):
                                                if frame_index < len(results):
                                                    n = results[frame_index]
                                                    dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                    
                                                    try:
                                                        new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                        dice_label.config(image=new_dice_img)
                                                        dice_label.image = new_dice_img
                                                    except Exception as e:
                                                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                    
                                                    # Próximo frame após 100ms
                                                    overlay_frame.after(100, animar_frame, frame_index + 1)
                                                else:
                                                    # Animação terminou - aplicar resultado
                                                    print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                    
                                                    # Atualizar duration_turns na base de dados (temporariamente na instância)
                                                    if event_card:
                                                        event_card.duration_turns = final_result
                                                        print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                    
                                                    # Atualizar tracking de duração se Event já está ativo
                                                    if (hasattr(self, '_event_duration_tracking') and 
                                                        carta_path in self._event_duration_tracking):
                                                        # CORREÇÃO CRÍTICA: PRESERVAR start_turn original - apenas atualizar duration e expires_turn
                                                        # O start_turn deve permanecer como o turno quando o Event foi realmente ativado
                                                        existing_tracking = self._event_duration_tracking[carta_path]
                                                        start_turn_original = existing_tracking.get('start_turn')
                                                        
                                                        # CORREÇÃO: Se start_turn for None, usar turno atual
                                                        if start_turn_original is None:
                                                            turno_atual = max(
                                                                getattr(self, '_current_turn', 0),
                                                                getattr(self, '_current_turn_number', 0),
                                                                getattr(self, '_current_turn_id', 0)
                                                            )
                                                            start_turn_original = turno_atual
                                                            self._event_duration_tracking[carta_path]['start_turn'] = start_turn_original
                                                            print(f"DEBUG: [VARIABLE_DURATION] start_turn era None, definido para turno atual: {start_turn_original}")
                                                        
                                                        # Só atualizar duration_turns e expires_turn baseado no start_turn ORIGINAL
                                                        self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                        # NÃO atualizar start_turn - manter o original!
                                                        # self._event_duration_tracking[carta_path]['start_turn'] = turno_atual  # REMOVIDO!
                                                        self._event_duration_tracking[carta_path]['expires_turn'] = start_turn_original + final_result
                                                        
                                                        print(f"DEBUG: [VARIABLE_DURATION] Tracking de duração atualizado:")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {start_turn_original} (PRESERVADO - turno original quando Event foi ativado)")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {start_turn_original + final_result}")
                                                    else:
                                                        # CORREÇÃO: Se não há tracking, criar agora com turno atual
                                                        turno_atual = max(
                                                            getattr(self, '_current_turn', 0),
                                                            getattr(self, '_current_turn_number', 0),
                                                            getattr(self, '_current_turn_id', 0)
                                                        )
                                                        
                                                        if not hasattr(self, '_event_duration_tracking'):
                                                            self._event_duration_tracking = {}
                                                        
                                                        self._event_duration_tracking[carta_path] = {
                                                            'start_turn': turno_atual,
                                                            'duration_turns': final_result,
                                                            'expires_turn': turno_atual + final_result,
                                                            'is_active': True
                                                        }
                                                        
                                                        print(f"DEBUG: [VARIABLE_DURATION] Tracking criado para Event de duração variável:")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {turno_atual} (turno atual - quando dado foi lançado)")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {turno_atual + final_result}")
                                                        print(f"DEBUG: [VARIABLE_DURATION]   is_active: True")
                                                    
                                                    # Aguardar 2 segundos antes de fechar
                                                    def fechar_overlay():
                                                        print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay após definir duração")
                                                        # Voltar para inventário Actions/Events
                                                        for widget in self.winfo_children():
                                                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                                continue
                                                            widget.destroy()
                                                        self.show_inventory_matrix(['actions', 'events'], page)
                                                    
                                                    overlay_frame.after(2000, fechar_overlay)
                                            
                                            animar_frame()
                                        
                                        go_button.config(command=iniciar_animacao_dado)
                                    
                                    # Botão "?" na mesma posição do botão Player dos Challenges
                                    # (canto inferior direito)
                                    btn_variable_duration = tk.Button(
                                        self, 
                                        text="?", 
                                        font=("Helvetica", 24, "bold"), 
                                        bg="#9966CC", 
                                        fg="white", 
                                        width=2, 
                                        height=1, 
                                        borderwidth=0, 
                                        highlightthickness=0, 
                                        command=mostrar_overlay_dado_duration, 
                                        cursor="hand2", 
                                        activebackground="#7744AA"
                                    )
                                    btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                    print(f"DEBUG: [VARIABLE_DURATION] Botão ? roxo criado para Event do topo com duração variável")
                                else:
                                    print(f"DEBUG: [VARIABLE_DURATION] Event do topo com duração fixa: {event_card.duration_turns if event_card else 'N/A'}")
                        except Exception as e:
                            print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar duração variável do Event do topo: {e}")
            else:
                print(f"DEBUG: [FULLSCREEN] Event não é do topo da lista - botão não mostrado")
        
        # NOVA FUNCIONALIDADE: Para Events não expirados em qualquer posição (não só do topo)
        # Botão ⓘ para mostrar informações do Event
        elif (carta_tipo == "events" and 
              set(tipos) == set(["actions", "events"]) and
              not is_carta_virada_para_baixo):
            
            print(f"DEBUG: [FULLSCREEN] Verificando Event não-do-topo para botão ⓘ: {os.path.basename(carta_path)}")
            
            # Verificar se o Event ainda está ativo (não expirado)
            current_turn = getattr(self, '_current_turn', 0)
            is_event_ativo = True  # Por padrão, assume que está ativo
            
            if (hasattr(self, '_event_duration_tracking') and 
                carta_path in self._event_duration_tracking):
                
                event_data = self._event_duration_tracking[carta_path]
                start_turn = event_data['start_turn']
                duration_turns = event_data['duration_turns']
                turns_elapsed = current_turn - start_turn
                is_event_ativo = (turns_elapsed < duration_turns)
                
                print(f"DEBUG: [FULLSCREEN] Event tracking - Ativo? {is_event_ativo} (turnos: {turns_elapsed}/{duration_turns})")
            
            if is_event_ativo:
                print(f"DEBUG: [FULLSCREEN] Event ativo detectado - criando botão ?")
                
                def mostrar_info_event_geral():
                    """Mostra overlay com informações do Event ativo usando o estilo do overlay de ativação"""
                    import re
                    import os
                    
                    print(f"DEBUG: [EVENT_INFO] Mostrando informações do Event: {os.path.basename(carta_path)}")
                    
                    # Obter dados da carta Event da base de dados
                    event_title = "Event Information"
                    event_effect = "Effect description not available"
                    event_target = "Target not available"
                    
                    try:
                        if self.card_database:
                            # Extrair ID da carta (ex: "Event_367" -> "event_367")
                            filename = os.path.basename(carta_path)
                            match = re.match(r'Event_(\d+)', filename)
                            
                            if match:
                                event_id = f"event_{match.group(1)}"
                                event_card = self.card_database.get_event(event_id)
                                
                                if event_card:
                                    event_title = event_card.title
                                    event_effect = event_card.effect_description
                                    # Determinar o target baseado nos campos target_link e target_queue
                                    if event_card.target_link:
                                        event_target = event_card.target_link
                                    elif event_card.target_queue:
                                        event_target = event_card.target_queue
                                    else:
                                        event_target = "Target not specified"
                                    
                                    print(f"DEBUG: [EVENT_INFO] Dados obtidos da base de dados:")
                                    print(f"DEBUG: [EVENT_INFO]   Title: {event_title}")
                                    print(f"DEBUG: [EVENT_INFO]   Effect: {event_effect}")
                                    print(f"DEBUG: [EVENT_INFO]   Target: {event_target}")
                                else:
                                    print(f"DEBUG: [EVENT_INFO] Event não encontrado na base de dados: {event_id}")
                            else:
                                print(f"DEBUG: [EVENT_INFO] Erro ao extrair ID do filename: {filename}")
                    except Exception as e:
                        print(f"DEBUG: [EVENT_INFO] Erro ao obter dados da base de dados: {e}")
                    
                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de ativação)
                    for widget in self.winfo_children():
                        widget.destroy()
                    
                    # Definir fundo preto para a janela
                    self.config(bg="black")
                    
                    # Carregar a imagem da carta como fundo
                    try:
                        carta_img = Image.open(carta_path)
                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                        
                        # Calcular o ratio para ocupar o máximo possível da tela
                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                        carta_photo = ImageTk.PhotoImage(carta_resized)
                        
                        # Label com a imagem da carta como fundo
                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                        carta_label.image = carta_photo  # Manter referência
                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                    except Exception as e:
                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                        self.config(bg="black")
                    
                    # Frame para a dialog de informação (centro da tela) - usar pack(expand=True) para dimensionamento dinâmico
                    info_frame = tk.Frame(self, bg="black")
                    info_frame.pack(expand=True)
                    
                    # Título (roxo)
                    print(f"DEBUG: [EVENT_INFO] Criando título com texto: {repr(event_title)}")
                    title_label = tk.Label(info_frame, text=event_title, 
                            font=("Helvetica", 18, "bold"), fg="#9966CC", bg="black",
                            wraplength=650, justify="center")
                    title_label.pack(pady=(40, 20))
                    
                    # Descrição do Event
                    print(f"DEBUG: [EVENT_INFO] Criando descrição com texto: {repr(event_effect)}")
                    desc_label = tk.Label(info_frame, text=event_effect, 
                                       font=("Helvetica", 12, "bold"), fg="white", bg="black",
                                       wraplength=600, justify="center")
                    desc_label.pack(pady=(0, 20))
                    
                    # Target do Event
                    print(f"DEBUG: [EVENT_INFO] Criando target com texto: {repr(event_target)}")
                    target_frame = tk.Frame(info_frame, bg="black")
                    target_frame.pack(pady=(0, 20))
                    
                    target_label_prefix = tk.Label(target_frame, text="Target: ", 
                                                 font=("Helvetica", 14, "bold"), fg="#9966CC", bg="black")
                    target_label_prefix.pack(side="left")
                    
                    target_label_value = tk.Label(target_frame, text=event_target, 
                                                font=("Helvetica", 14, "bold"), fg="white", bg="black")
                    target_label_value.pack(side="left")
                    
                    # Frame para o botão
                    btn_frame = tk.Frame(info_frame, bg="black")
                    btn_frame.pack(pady=30)
                    
                    def fechar_overlay():
                        print(f"DEBUG: [EVENT_INFO] Fechando overlay de informações")
                        # Ir para a página de inventário Actions/Events
                        # Limpa tudo menos a barra superior
                        for widget in self.winfo_children():
                            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                continue
                            widget.destroy()
                        # Abrir página de inventário Actions/Events
                        self.show_inventory_matrix(['actions', 'events'])
                    
                    # Botão OK (roxo para combinar com o tema do Event)
                    ok_button = tk.Button(btn_frame, text="OK", font=("Helvetica", 14, "bold"), 
                                       bg="#9966CC", fg="white", width=8, command=fechar_overlay)
                    ok_button.pack(pady=10)
                    
                    print(f"DEBUG: [EVENT_INFO] Overlay de informações criado e exibido")
                
                # Botão i laranja no canto superior direito (Events não do topo da lista)
                btn_info_event = tk.Button(
                    self, 
                    text="i", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF9800", 
                    fg="black", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=mostrar_info_event_geral, 
                    cursor="hand2", 
                    activebackground="#E68900"
                )
                btn_info_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão i roxo configurado para informações do Event ativo")
                
                # NOVA FUNCIONALIDADE: Verificar se Event tem duration_turns variável
                # Se sim, mostrar botão "?" para determinar duração com dado
                if hasattr(self, 'card_database') and self.card_database:
                    try:
                        import re
                        # Extrair ID da carta Event
                        filename = os.path.basename(carta_path)
                        match = re.match(r'Event_(\d+)', filename)
                        
                        if match:
                            event_id = f"event_{match.group(1)}"
                            event_card = self.card_database.get_event(event_id)
                            
                            if event_card and event_card.duration_turns == "variable":
                                print(f"DEBUG: [VARIABLE_DURATION] Event com duração variável detectado: {os.path.basename(carta_path)}")
                                
                                def mostrar_overlay_dado_duration():
                                    """Mostra overlay para rolar dado e definir duration_turns do Event"""
                                    print(f"DEBUG: [VARIABLE_DURATION] Iniciando overlay de dado para determinar duração")
                                    
                                    # Limpar TODOS os widgets para fullscreen completo (igual ao overlay de informação)
                                    for widget in self.winfo_children():
                                        widget.destroy()
                                    
                                    # Definir fundo preto para a janela
                                    self.config(bg="black")
                                    
                                    # Carregar a imagem da carta como fundo (igual ao overlay do botão "i")
                                    try:
                                        carta_img = Image.open(carta_path)
                                        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                                        
                                        # Calcular o ratio para ocupar o máximo possível da tela
                                        ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                                        new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                                        carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                                        carta_photo = ImageTk.PhotoImage(carta_resized)
                                        
                                        # Label com a imagem da carta como fundo
                                        carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                                        carta_label.image = carta_photo  # Manter referência
                                        carta_label.place(relx=0.5, rely=0.5, anchor="center")
                                        
                                    except Exception as e:
                                        print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
                                        self.config(bg="black")
                                    
                                    # Frame central para o overlay (usar pack(expand=True) para dimensionamento dinâmico)
                                    overlay_frame = tk.Frame(self, bg="black")
                                    overlay_frame.pack(expand=True)
                                    
                                    # Título roxo
                                    title_label = tk.Label(overlay_frame, text="   Roll for duration \nof the Event   ", 
                                                         font=("Helvetica", 22, "bold"), fg="#9966CC", bg="black")
                                    title_label.pack(pady=(40, 30))
                                    
                                    # Dado (inicialmente em branco)
                                    blank_dice_path = os.path.join(IMG_DIR, "dice", "Dice_blank.png")
                                    dice_img = ImageTk.PhotoImage(Image.open(blank_dice_path).resize((100, 100)))
                                    dice_label = tk.Label(overlay_frame, image=dice_img, bg="black")
                                    dice_label.image = dice_img
                                    dice_label.pack(pady=20)
                                    
                                    # Botão Go!
                                    go_button = tk.Button(overlay_frame, text="Go!", font=("Helvetica", 16, "bold"), 
                                                        bg="#005c75", fg="white", width=8)
                                    go_button.pack(pady=20)
                                    
                                    def iniciar_animacao_dado():
                                        """Inicia a animação do dado e define a duração"""
                                        print(f"DEBUG: [VARIABLE_DURATION] Iniciando animação do dado")
                                        
                                        # Esconder botão Go!
                                        go_button.pack_forget()
                                        
                                        # Animação do dado (25 frames + resultado final)
                                        frames = 25
                                        results = [random.randint(1, 6) for _ in range(frames)]
                                        final_result = random.randint(1, 6)
                                        results.append(final_result)
                                        
                                        def animar_frame(frame_index=0):
                                            if frame_index < len(results):
                                                n = results[frame_index]
                                                dice_path = os.path.join(IMG_DIR, "dice", f"Dice_{n}.png")
                                                
                                                try:
                                                    new_dice_img = ImageTk.PhotoImage(Image.open(dice_path).resize((100, 100)))
                                                    dice_label.config(image=new_dice_img)
                                                    dice_label.image = new_dice_img
                                                except Exception as e:
                                                    print(f"DEBUG: [VARIABLE_DURATION] Erro ao carregar imagem do dado: {e}")
                                                
                                                # Próximo frame após 100ms
                                                overlay_frame.after(100, animar_frame, frame_index + 1)
                                            else:
                                                # Animação terminou - aplicar resultado
                                                print(f"DEBUG: [VARIABLE_DURATION] Dado rolado: {final_result}")
                                                
                                                # Atualizar duration_turns na base de dados (temporariamente na instância)
                                                if event_card:
                                                    event_card.duration_turns = final_result
                                                    print(f"DEBUG: [VARIABLE_DURATION] Duration_turns atualizado para: {final_result}")
                                                
                                                # Atualizar tracking de duração se Event já está ativo
                                                if (hasattr(self, '_event_duration_tracking') and 
                                                    carta_path in self._event_duration_tracking):
                                                    # CORREÇÃO CRÍTICA: PRESERVAR start_turn original - apenas atualizar duration e expires_turn
                                                    # O start_turn deve permanecer como o turno quando o Event foi realmente ativado
                                                    existing_tracking = self._event_duration_tracking[carta_path]
                                                    start_turn_original = existing_tracking.get('start_turn')
                                                    
                                                    # CORREÇÃO: Se start_turn for None, usar turno atual
                                                    if start_turn_original is None:
                                                        turno_atual = max(
                                                            getattr(self, '_current_turn', 0),
                                                            getattr(self, '_current_turn_number', 0),
                                                            getattr(self, '_current_turn_id', 0)
                                                        )
                                                        start_turn_original = turno_atual
                                                        self._event_duration_tracking[carta_path]['start_turn'] = start_turn_original
                                                        print(f"DEBUG: [VARIABLE_DURATION] start_turn era None, definido para turno atual: {start_turn_original}")
                                                    
                                                    # Só atualizar duration_turns e expires_turn baseado no start_turn ORIGINAL
                                                    self._event_duration_tracking[carta_path]['duration_turns'] = final_result
                                                    # NÃO atualizar start_turn - manter o original!
                                                    # self._event_duration_tracking[carta_path]['start_turn'] = turno_atual  # REMOVIDO!
                                                    self._event_duration_tracking[carta_path]['expires_turn'] = start_turn_original + final_result
                                                    
                                                    print(f"DEBUG: [VARIABLE_DURATION] Tracking de duração atualizado:")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {start_turn_original} (PRESERVADO - turno original quando Event foi ativado)")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {start_turn_original + final_result}")
                                                else:
                                                    # CORREÇÃO: Se não há tracking, criar agora com turno atual
                                                    turno_atual = max(
                                                        getattr(self, '_current_turn', 0),
                                                        getattr(self, '_current_turn_number', 0),
                                                        getattr(self, '_current_turn_id', 0)
                                                    )
                                                    
                                                    if not hasattr(self, '_event_duration_tracking'):
                                                        self._event_duration_tracking = {}
                                                    
                                                    self._event_duration_tracking[carta_path] = {
                                                        'start_turn': turno_atual,
                                                        'duration_turns': final_result,
                                                        'expires_turn': turno_atual + final_result,
                                                        'is_active': True
                                                    }
                                                    
                                                    print(f"DEBUG: [VARIABLE_DURATION] Tracking criado para Event de duração variável:")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   start_turn: {turno_atual} (turno atual - quando dado foi lançado)")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   duration_turns: {final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   expires_turn: {turno_atual + final_result}")
                                                    print(f"DEBUG: [VARIABLE_DURATION]   is_active: True")
                                                
                                                # Aguardar 2 segundos antes de fechar
                                                def fechar_overlay():
                                                    print(f"DEBUG: [VARIABLE_DURATION] Fechando overlay após definir duração")
                                                    # Voltar para inventário Actions/Events
                                                    for widget in self.winfo_children():
                                                        if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                                                            continue
                                                        widget.destroy()
                                                    self.show_inventory_matrix(['actions', 'events'], page)
                                                
                                                overlay_frame.after(2000, fechar_overlay)
                                        
                                        animar_frame()
                                    
                                    go_button.config(command=iniciar_animacao_dado)
                                
                                # Botão "?" na mesma posição do botão Player dos Challenges
                                # (canto inferior direito)
                                btn_variable_duration = tk.Button(
                                    self, 
                                    text="?", 
                                    font=("Helvetica", 24, "bold"), 
                                    bg="#9966CC", 
                                    fg="white", 
                                    width=2, 
                                    height=1, 
                                    borderwidth=0, 
                                    highlightthickness=0, 
                                    command=mostrar_overlay_dado_duration, 
                                    cursor="hand2", 
                                    activebackground="#7744AA"
                                )
                                btn_variable_duration.place(relx=0.5, rely=0, anchor="n")
                                print(f"DEBUG: [VARIABLE_DURATION] Botão ? roxo criado para Event com duração variável")
                            else:
                                print(f"DEBUG: [VARIABLE_DURATION] Event com duração fixa: {event_card.duration_turns if event_card else 'N/A'}")
                    except Exception as e:
                        print(f"DEBUG: [VARIABLE_DURATION] Erro ao verificar duração variável: {e}")
            else:
                # Event expirado - mostrar botão ✓ vermelho para remoção
                print(f"DEBUG: [FULLSCREEN] Event expirado detectado - criando botão ✓ vermelho")
                
                def remover_event_expirado():
                    """Remove a carta Event expirada do inventário e retorna para o baralho da Store"""
                    print(f"DEBUG: [REMOVE_EVENT] Removendo Event expirado do inventário: {os.path.basename(carta_path)}")
                    
                    # Remover carta do inventário
                    if "events" in self.inventario and carta_path in self.inventario["events"]:
                        self.inventario["events"].remove(carta_path)
                        print(f"DEBUG: [REMOVE_EVENT] Carta removida do inventário do jogador")
                        
                        # Remover do tracking de duração
                        if hasattr(self, '_event_duration_tracking') and carta_path in self._event_duration_tracking:
                            del self._event_duration_tracking[carta_path]
                            print(f"DEBUG: [REMOVE_EVENT] Event removido do tracking de duração")
                        
                        # Devolver carta ao baralho da Store (se há referência)
                        if hasattr(self, 'store_window') and self.store_window:
                            try:
                                self.store_window.adicionar_carta_ao_baralho(carta_path, "events", "neutral")
                                print(f"DEBUG: [REMOVE_EVENT] Carta devolvida ao baralho da Store")
                            except Exception as e:
                                print(f"DEBUG: [REMOVE_EVENT] Erro ao devolver carta à Store: {e}")
                        
                        # Voltar para a página de inventário Actions/Events
                        print(f"DEBUG: [REMOVE_EVENT] Voltando para inventário Actions/Events")
                        # Obter a página atual se disponível
                        current_page = getattr(self, '_current_inventory_page', 0)
                        self.show_inventory_matrix(["actions", "events"], current_page)
                    else:
                        print(f"DEBUG: [REMOVE_EVENT] ERRO: Carta não encontrada no inventário Events")
                
                # Botão vermelho ✓ no canto superior direito (aparece quando Event está expirado)
                btn_remove_event = tk.Button(
                    self, 
                    text="✓", 
                    font=("Helvetica", 24, "bold"), 
                    bg="#FF4444", 
                    fg="white", 
                    width=2, 
                    height=1, 
                    borderwidth=0, 
                    highlightthickness=0, 
                    command=remover_event_expirado, 
                    cursor="hand2", 
                    activebackground="#CC3333"
                )
                btn_remove_event.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [FULLSCREEN] Botão ✓ vermelho configurado para remoção de Event expirado")
        else:
            # Debug para quando o botão vermelho não é criado
            if carta_tipo == "actions":
                print(f"DEBUG: [FULLSCREEN] Botão vermelho ✓ NÃO criado para Actions:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                if gestao_pacotes_ativa:
                    print(f"DEBUG: [FULLSCREEN]   Durante gestão de pacotes - botão DEVERIA aparecer!")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Fora da gestão de pacotes - verificar outras condições")
            elif carta_tipo == "events":
                print(f"DEBUG: [FULLSCREEN] Botão vermelho ✓ NÃO criado para Events:")
                print(f"DEBUG: [FULLSCREEN]   Tipos corretos? {set(tipos) == set(['actions', 'events'])}")
                print(f"DEBUG: [FULLSCREEN]   Next Phase ativo? {getattr(self, '_next_phase_active', False)}")
                print(f"DEBUG: [FULLSCREEN]   Final Phase normal bloqueando? {final_phase_normal}")
                print(f"DEBUG: [FULLSCREEN]   Carta virada para baixo? {is_carta_virada_para_baixo}")
                
                # CORREÇÃO: Verificar se é Event do topo usando ordem cronológica
                chronological_order = self._get_chronological_actions_events_order()
                is_event_do_topo_debug = False
                # CRÍTICO: Apenas o primeiro item da fila (posição 0) pode ser "Event do topo"
                if chronological_order and len(chronological_order) > 0:
                    first_entry = chronological_order[0]
                    is_event_do_topo_debug = (first_entry['type'] == 'events' and first_entry['path'] == carta_path)
                print(f"DEBUG: [FULLSCREEN]   É Event do topo cronológico? {is_event_do_topo_debug}")
                
                # Verificar detalhes da expiração
                current_turn = getattr(self, '_current_turn', 0)
                if (hasattr(self, '_event_duration_tracking') and 
                    carta_path in self._event_duration_tracking):
                    event_data = self._event_duration_tracking[carta_path]
                    start_turn = event_data['start_turn']
                    duration_turns = event_data['duration_turns']
                    turns_elapsed = current_turn - start_turn
                    is_expired = (turns_elapsed >= duration_turns)
                    print(f"DEBUG: [FULLSCREEN]   Event tracking encontrado - Expirado? {is_expired} (turnos: {turns_elapsed}/{duration_turns})")
                else:
                    print(f"DEBUG: [FULLSCREEN]   Event não encontrado no tracking de duração")
        
        # Para Activities e Challenges, layout especial com botões específicos
        # IMPORTANTE: Limpar qualquer estado de venda anterior para garantir comportamento correto
        self._origem_venda = None
        self._tipos_venda = None
        self._page_venda = None
        self._current_sell_page = None
        self._inventario_conjunto = None
        
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [FULLSCREEN] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            print(f"DEBUG: [FULLSCREEN] Casa atual: {getattr(self, 'current_casa_tipo', 'neutral')}")
            print(f"DEBUG: [FULLSCREEN] Next Phase ativo: {getattr(self, '_next_phase_active', False)}")
            
            # Para Activities: botão ✔ abre página de confirmação de venda (se pode vender)
            # Para Challenges: botão ✔ aceita para carrossel (comportamento original)
            if carta_tipo == "activities" and pode_vender:
                # Botão ✔ canto superior direito (para venda)
                btn_certo = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_certo.place(relx=0.98, rely=0, anchor="ne")
                
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informações para navegação correta
                    self._origem_venda = "inventario"
                    # Se viemos de um inventário Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._tipos_venda = ["activities", "challenges"]
                        self._inventario_conjunto = True
                        print(f"DEBUG: Guardando contexto inventário conjunto Activities/Challenges")
                    else:
                        self._tipos_venda = None
                        self._inventario_conjunto = False
                        print(f"DEBUG: Guardando contexto inventário individual: {carta_tipo}")
                    # Guardar a página atual baseada no parâmetro da função
                    self._page_venda = page
                    self._current_sell_page = page
                    print(f"DEBUG: Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                btn_certo.config(command=abrir_confirm_activities)
                print(f"DEBUG: [FULLSCREEN] Botão ✔ configurado para venda de Activities")
            
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                # POSICIONAMENTO ESPECÍFICO DOS BOTÕES:
                # - Activities: Switch no canto superior direito
                # - Challenges: Switch no canto inferior direito, Quit no canto superior direito
                
                # BOTÃO SWITCH PARA CARROSSEL
                btn_switch_carrossel = None
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [FULLSCREEN] VERIFICAÇÃO SWITCH CARROSSEL ({carta_tipo}):")
                print(f"DEBUG: [FULLSCREEN]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [FULLSCREEN]   has_valid_positions: {has_valid_positions}")
                print(f"DEBUG: [FULLSCREEN]   pode_vender: {pode_vender}")
                
                # NOVA VERIFICAÇÃO: Para Activities, verificar se há Challenges no inventário (restrição Activity↔Activity)
                pode_fazer_troca_activity = True
                if carta_tipo == "activities":
                    challenges_no_inventario = len(self.inventario.get('challenges', []))
                    print(f"DEBUG: [FULLSCREEN] Verificando restrição Activity↔Activity - Challenges no inventário: {challenges_no_inventario}")
                    if challenges_no_inventario > 0:
                        pode_fazer_troca_activity = False
                        print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - Restrição Activity↔Activity ativa (Challenges no inventário)")
                
                if next_phase_active and has_valid_positions and pode_fazer_troca_activity:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_carrossel.image = switch_img  # Manter referência
                            
                            # POSICIONAMENTO ESPECÍFICO POR TIPO:
                            if carta_tipo == "activities":
                                # Activities: Switch no canto superior direito
                                btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                                print(f"DEBUG: [FULLSCREEN] SUCCESS: Botão Switch Activity posicionado no canto superior direito")
                            else:  # carta_tipo == "challenges"
                                # Challenges: Switch no canto inferior direito (máximo canto possível)
                                btn_switch_carrossel.place(relx=1.0, rely=1.0, anchor="se")
                                print(f"DEBUG: [FULLSCREEN] SUCCESS: Botão Switch Challenge posicionado no canto inferior direito (máximo canto)")
                            
                            print(f"DEBUG: [FULLSCREEN] SUCCESS: Botão Switch carrossel CRIADO - Next Phase ativo + posições válidas + sem restrição Activity↔Activity")
                        else:
                            print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - imagem não encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_carrossel = None
                        print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - erro ao carregar imagem: {e}")
                else:
                    if not next_phase_active:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - Next Phase NÃO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - SEM posições válidas no carrossel")
                    elif carta_tipo == "activities" and not pode_fazer_troca_activity:
                        print(f"DEBUG: [FULLSCREEN] ERROR: Botão Switch carrossel NÃO criado - Restrição Activity↔Activity (Challenges no inventário)")
                
                # Configurar comando do botão Switch
                def aceitar_carta():
                    # NOVA LÓGICA: Só mostrar overlay se vai SUBSTITUIR uma carta (não quando vai colocar numa posição vazia)
                    print("DEBUG: [FULLSCREEN] Verificando se vai substituir carta existente ou colocar em posição vazia")
                    
                    # Obter a posição de destino mais provável (primeira posição vazia ou acessível)
                    posicao_destino = None
                    carta_na_posicao_destino = None
                    
                    if hasattr(self, 'carrossel_idx_selecao') and self.carrossel_idx_selecao is not None:
                        # Se há uma posição específica selecionada, usar essa
                        posicao_destino = self.carrossel_idx_selecao
                    else:
                        # Encontrar a primeira posição acessível (vazia ou não)
                        if hasattr(self, 'cards'):
                            for i, carta_carrossel in enumerate(self.cards):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                    
                    # Verificar se há uma carta real na posição de destino
                    vai_substituir_carta = False
                    if posicao_destino is not None and hasattr(self, 'cards') and posicao_destino < len(self.cards):
                        carta_na_posicao_destino = self.cards[posicao_destino]
                        # Se não é back_card, significa que há uma carta real para substituir
                        if not os.path.basename(carta_na_posicao_destino).startswith("back_card_"):
                            vai_substituir_carta = True
                            print(f"DEBUG: [FULLSCREEN] Vai SUBSTITUIR carta existente na posição {posicao_destino}: {os.path.basename(carta_na_posicao_destino)}")
                        else:
                            print(f"DEBUG: [FULLSCREEN] Vai COLOCAR em posição VAZIA {posicao_destino}")
                    
                    if vai_substituir_carta:
                        print("DEBUG: [FULLSCREEN] Substituição detectada - mostrando overlay de confirmação")
                        self._mostrar_overlay_confirmacao_troca(carta_path, [carta_tipo], 0)
                    else:
                        print("DEBUG: [FULLSCREEN] Colocação em posição vazia - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, [carta_tipo], 0)
                
                if btn_switch_carrossel is not None:
                    btn_switch_carrossel.config(command=aceitar_carta)
                    print(f"DEBUG: [FULLSCREEN] Botão Switch configurado para aceitar {carta_tipo} no carrossel")
                
                # BOTÃO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase)
                if carta_tipo == "challenges" and not next_phase_active:
                    print(f"DEBUG: [FULLSCREEN] Criando botão Quit Challenge no canto superior direito")
                    
                    # Botão vermelho com símbolo de check (✓) para quit challenge
                    btn_quit_challenge = tk.Button(
                        self, 
                        text="✓", 
                        font=("Helvetica", 24, "bold"), 
                        bg="#DC143C", 
                        fg="white", 
                        width=2, 
                        height=1, 
                        borderwidth=0, 
                        highlightthickness=0, 
                        cursor="hand2", 
                        activebackground="#B22222"
                    )
                    # Challenge: Quit no canto superior direito
                    btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
                    
                    # Comando do botão quit
                    def mostrar_confirmacao_quit():
                        print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                        self._mostrar_overlay_quit_challenge(carta_path)
                    
                    btn_quit_challenge.config(command=mostrar_confirmacao_quit)
                    print(f"DEBUG: [FULLSCREEN] SUCCESS: Botão Quit Challenge criado no canto superior direito")
        
        # Para Users, Equipments e Services, adicionar botão de ativação/desativação
        # IMPORTANTE: APENAS após Next Phase ser ativado
        elif carta_tipo in ["users", "equipments", "services"]:
            # Verificar se é User_1.png - tratamento especial
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            if is_user_1:
                # Para User_1.png, não criar nenhum botão adicional além do X
                pass
            else:
                # NOVA FUNCIONALIDADE: Botão vermelho especial para REMOVE ROUTER context
                # Deve aparecer quando estamos no contexto REMOVE ROUTER e a carta está ativa
                if (carta_tipo == "equipments" and 
                    getattr(self, '_in_remove_router_context', False) and
                    self.is_card_active(carta_path, carta_tipo)):
                    
                    print(f"DEBUG: [REMOVE_ROUTER] Carta Equipment ativa detectada no contexto REMOVE ROUTER: {os.path.basename(carta_path)}")
                    
                    # Verificar se é um router ou um link com mesmo ID
                    is_link = self._is_link_card(carta_path)
                    is_removing_links = getattr(self, '_removing_associated_links', False)
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    
                    if is_link and is_removing_links:
                        # Verificar se o link tem o mesmo specific_id do router que foi removido
                        link_id = self._get_equipment_specific_id(carta_path)
                        if str(link_id) == str(router_id_being_removed):
                            print(f"DEBUG: [REMOVE_ROUTER] Link com ID {link_id} corresponde ao router removido {router_id_being_removed}")
                            
                            # Botão vermelho ✔ para remoção do link
                            btn_remove_link = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def remover_link():
                                self.show_remove_link_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_remove_link.config(command=remover_link)
                            btn_remove_link.place(relx=0.98, rely=0, anchor="ne")
                            print(f"DEBUG: [REMOVE_ROUTER] Botão ✔ vermelho configurado para remoção do link")
                        else:
                            print(f"DEBUG: [REMOVE_ROUTER] Link ID {link_id} não corresponde ao router removido {router_id_being_removed}")
                    elif not is_link and not is_removing_links:
                        # Router normal - usar confirmação de router
                        btn_remove_router = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                        def remover_router():
                            self.show_remove_router_confirmation(carta_path, carta_tipo, tipos, page)
                        btn_remove_router.config(command=remover_router)
                        btn_remove_router.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [REMOVE_ROUTER] Botão ✔ vermelho configurado para remoção do router")
                    
                else:
                    # CORREÇÃO: Botões de ativação/desativação só aparecem DEPOIS de Next Phase ser ativado
                    # Antes disso, as cartas são apenas para visualização
                    next_phase_active = getattr(self, '_next_phase_active', False)
                    final_phase_active = getattr(self, '_final_phase_active', False)
                    
                    # CORREÇÃO CRÍTICA: NÃO criar botões de ativação/desativação quando estamos em contextos especiais
                    # Os botões vermelhos especiais devem ter prioridade sobre os botões de ativação/desativação
                    in_router_upgrade_context = getattr(self, '_in_router_upgrade_context', False)
                    in_router_downgrade_context = getattr(self, '_in_router_downgrade_context', False)
                    in_link_upgrade_context = getattr(self, '_in_link_upgrade_context', False)
                    in_link_downgrade_context = getattr(self, '_in_link_downgrade_context', False)
                    
                    # NOVA FUNCIONALIDADE: Verificar expiração de Services ANTES de criar botões normais
                    if carta_tipo == "services":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Verificando expiração para Service: {os.path.basename(carta_path)}")
                        is_expired = self._is_service_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Resultado da verificação de expiração: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service EXPIRADO - criando botão vermelho de expiração")
                            # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                            red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao():
                                print(f"DEBUG: Mostrando overlay de expiração para Service {carta_path}")
                                self._mostrar_overlay_service_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao)
                            return  # Não criar outros botões se o Service expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_SERVICE] Service NÃO expirado - continuando com lógica normal")
                    
                    # NOVA FUNCIONALIDADE: Verificar expiração de Events ANTES de criar botões normais
                    if carta_tipo == "events":
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Verificando expiração para Event: {os.path.basename(carta_path)}")
                        is_expired = self._is_event_expired(carta_path)
                        print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Resultado da verificação de expiração: {is_expired}")
                        
                        if is_expired:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event EXPIRADO - criando botão vermelho de expiração")
                            # Botão certo vermelho para mostrar overlay de expiração (mesmo formato que botão de desativação)
                            red_check_btn = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), 
                                                     bg="#F44336", fg="white", width=2, height=1, 
                                                     borderwidth=0, highlightthickness=0, cursor="hand2", 
                                                     activebackground="#D32F2F")
                            red_check_btn.place(relx=0.98, rely=0, anchor="ne")
                            
                            def mostrar_overlay_expiracao_event():
                                print(f"DEBUG: Mostrando overlay de expiração para Event {carta_path}")
                                self._mostrar_overlay_event_expirado(carta_path)
                            
                            red_check_btn.config(command=mostrar_overlay_expiracao_event)
                            return  # Não criar outros botões se o Event expirou
                        else:
                            print(f"DEBUG: [FULLSCREEN_INVENTORY_EVENT] Event NÃO expirado - continuando com lógica normal")
                    
                    # Só mostrar botões de ativação/desativação se Next Phase estiver ativo E não estiver em Final Phase E não estiver em contextos especiais
                    if next_phase_active and not final_phase_active and not in_router_upgrade_context and not in_router_downgrade_context and not in_link_upgrade_context and not in_link_downgrade_context:
                        # Verificar se a carta está ativa
                        is_active = self.is_card_active(carta_path, carta_tipo)
                        
                        if is_active:
                            # Carta ativa: botão para desativar (vermelho com ✔)
                            btn_activate = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#F44336", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#D32F2F")
                            def desativar_carta():
                                self.show_deactivation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=desativar_carta)
                        else:
                            # Carta inativa: botão para ativar (verde com ✔)
                            btn_activate = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                            def ativar_carta():
                                self.show_activation_confirmation(carta_path, carta_tipo, tipos, page)
                            btn_activate.config(command=ativar_carta)
                        
                        # Posicionar o botão no canto superior direito
                        btn_activate.place(relx=0.98, rely=0, anchor="ne")
                        print(f"DEBUG: [FULLSCREEN] Botão de ativação/desativação criado para {carta_tipo} - Next Phase ativo")
                    else:
                        print(f"DEBUG: [FULLSCREEN] Botão de ativação/desativação NÃO criado para {carta_tipo} - Next Phase: {next_phase_active}, Final Phase: {final_phase_active}, Router Upgrade Context: {in_router_upgrade_context}, Router Downgrade Context: {in_router_downgrade_context}, Link Upgrade Context: {in_link_upgrade_context}, Link Downgrade Context: {in_link_downgrade_context}")

    def show_inventory_for_sell(self, carta_tipo, store_window=None, page=0):
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Verificar se o jogador pode vender cartas deste tipo na casa atual
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - Next Phase está ativo (vendas desabilitadas)")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # IMPORTANTE: Se está numa casa START, NÃO pode vender nenhuma carta
        if casa_atual_tipo == "start":
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - está numa casa START (nenhuma venda permitida)")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        # Normalizar o tipo da casa atual (equipments vs equipment)
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        # Verificar se pode vender nesta casa (no inventário próprio, qualquer cor serve)
        # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
        pode_vender_tipo = False
        if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
            pode_vender_tipo = (casa_atual_tipo == carta_tipo)
        
        if not pode_vender_tipo:
            print(f"DEBUG: NÃO pode vender cartas {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")
            # Volta à Store ou PlayerDashboard se não pode vender
            if store_window:
                store_window.deiconify()
                store_window.lift()
                store_window.focus_force()
                self.withdraw()
            else:
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            return
        
        print(f"DEBUG: Pode vender cartas {carta_tipo} do inventário - está numa casa {casa_atual_tipo}")
        
        # Garantir que a janela está visível e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que não está minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store está escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # Força update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com paginação
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no inventário: {len(cartas)}")
        
        # Paginação
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimensões que outras páginas de inventário
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                # CORREÇÃO: Verificar se a carta está ativa antes de permitir venda
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas não podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualização (não pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualização (cartas ativas não podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar página atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a lógica de verificação adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORREÇÃO: Verificar se a carta está ativa para determinar como mostrá-la
                # Cartas ATIVAS devem aparecer viradas para cima (não podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta está ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima (mas não pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa: virada para cima (NÃO pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (NÃO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa: virada para baixo (PODE ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card não existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            
            # CORREÇÃO: Cursor diferente dependendo se a carta pode ser vendida
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            
            # Cartas ativas e User_1.png são apenas para visualização (cursor normal)
            # Cartas inativas podem ser vendidas (cursor hand2)
            if is_user_1 or is_active:
                cursor_type = "arrow"  # Cursor normal para cartas que não podem ser vendidas
            else:
                cursor_type = "hand2"  # Cursor de mão para cartas que podem ser vendidas
            
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor=cursor_type)
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navegação (se houver mais de uma página)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (página anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (página seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # Força update final para garantir que tudo é exibido
        self.update_idletasks()
        self.update()
        
        # Botão voltar
        if store_window:
            def voltar_para_store():
                print("DEBUG: PlayerDashboard voltar_para_store chamado")
                try:
                    # Primeiro, esconde o PlayerDashboard
                    print("DEBUG: Escondendo PlayerDashboard...")
                    self.withdraw()
                    
                    # Aguarda um pouco para garantir que foi escondido
                    print("DEBUG: Aguardando para processar volta à Store...")
                    self.after(100, lambda: self._process_back_to_store(store_window))
                    
                except Exception as e:
                    print(f"DEBUG: Erro ao iniciar volta para store: {e}")
                    import traceback
                    traceback.print_exc()
                    
            def _process_back_to_store(store_window):
                print("DEBUG: Processando volta à Store...")
                try:
                    # Verificar se a Store ainda existe
                    if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                        print("DEBUG: Store existe, forçando exibição...")
                        # Força a Store a aparecer
                        store_window.deiconify()
                        store_window.state('normal')
                        store_window.lift()
                        store_window.focus_force()
                        
                        # CORREÇÃO: Voltar para a interface principal da Store (não para página de compra específica)
                        print(f"DEBUG: Botão Back - Chamando voltar_para_store da Store...")
                        store_window.after(50, lambda: store_window.voltar_para_store())
                        print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                        
                    else:
                        print("DEBUG: Store não existe mais, voltando ao PlayerDashboard")
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                        
                except Exception as e:
                    print(f"DEBUG: Erro ao processar volta à Store: {e}")
                    import traceback
                    traceback.print_exc()
                    # Em caso de erro, volta ao PlayerDashboard
                    try:
                        self.deiconify()
                        self.lift()
                        self.focus_force()
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    except Exception as fallback_e:
                        print(f"DEBUG: Erro crítico no fallback: {fallback_e}")
            
            # Adiciona o método auxiliar à instância
            self._process_back_to_store = _process_back_to_store
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário de venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário de venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Botão voltar - criado após a barra para ficar por cima
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell terminado com sucesso")

    def show_inventory_for_sell_after_sale(self, carta_tipo, store_window=None, page=0):
        """Versão especial de show_inventory_for_sell que ignora verificações de casa após uma venda bem-sucedida"""
        # Garantir que page nunca seja None
        if page is None:
            page = 0
        print(f"DEBUG: show_inventory_for_sell_after_sale chamado - carta_tipo: {carta_tipo}, page: {page}")
        
        # Garantir que a janela está visível e no estado correto
        self.deiconify()
        self.state('normal')  # Garantir que não está minimizada
        self.lift()
        self.focus_force()
        
        # Garantir que a Store está escondida
        if store_window and hasattr(store_window, 'withdraw'):
            store_window.withdraw()
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso")
        
        # Força update para garantir que a limpeza foi feita
        self.update_idletasks()
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # --- Nome do jogador ---
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        
        # Título
        title = tk.Label(self, text=carta_tipo.capitalize(), font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Cartas do tipo com paginação
        cartas = self.inventario.get(carta_tipo, [])
        print(f"DEBUG: Cartas encontradas no inventário após venda: {len(cartas)}")
        
        # Paginação
        cards_per_page = 4  # 2 linhas x 2 colunas (grid 2x2)
        total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
        page = max(0, min(page, total_pages - 1))
        start_idx = page * cards_per_page
        end_idx = start_idx + cards_per_page
        cartas_page = cartas[start_idx:end_idx]
        
        # Recria o frame para as cartas
        matriz_frame = tk.Frame(self, bg="black")
        matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
        n_col = 2  # Grid 2x2 como solicitado
        card_w, card_h = 85, 120  # Mesmas dimensões que outras páginas de inventário
        self._sell_imgs = []
        
        def make_fullscreen_callback(carta_path):
            def callback(event=None):
                print(f"DEBUG: Carta clicada para venda: {carta_path}")
                
                # Verificar se a carta está ativa (não pode ser vendida)
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                # User_1.png e cartas ativas não podem ser vendidas, mas podem ser visualizadas
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                if is_user_1:
                    print(f"DEBUG: User_1.png clicada - apenas visualização (não pode ser vendida)")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                elif is_active:
                    print(f"DEBUG: Carta ATIVA clicada - apenas visualização (cartas ativas não podem ser vendidas): {os.path.basename(carta_path)}")
                    # Apenas mostrar a carta em fullscreen, sem opção de venda
                    self.show_card_fullscreen_readonly(carta_path, carta_tipo)
                else:
                    print(f"DEBUG: Carta INATIVA clicada para venda: {carta_path}")
                    
                    # Guardar página atual para retornar ao mesmo local
                    self._current_sell_page = page
                    # IMPORTANTE: Para cartas inativas, sempre usar show_card_fullscreen_sell que tem a lógica de verificação adequada
                    self.show_card_fullscreen_sell(carta_path, carta_tipo, store_window)
            return callback
        
        for idx, carta_path in enumerate(cartas_page):
            try:
                # CORREÇÃO: Verificar se a carta está ativa para determinar como mostrá-la
                # Cartas ATIVAS devem aparecer viradas para cima (não podem ser vendidas)
                # Cartas INATIVAS devem aparecer viradas para baixo (podem ser vendidas)
                
                # IMPORTANTE: User_1.png sempre virada para cima, independente do estado
                is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
                
                # Verificar se a carta está ativa
                is_active = False
                if carta_tipo in ["users", "equipments", "services"]:
                    is_active = self.is_card_active(carta_path, carta_tipo)
                
                if is_user_1:
                    # User_1.png sempre virada para cima
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] User_1.png SEMPRE VIRADA PARA CIMA: {os.path.basename(carta_path)}")
                elif is_active:
                    # Carta ativa - mostrar virada para cima (não pode ser vendida)
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} ATIVA - VIRADA PARA CIMA (NÃO pode ser vendida): {os.path.basename(carta_path)}")
                else:
                    # Carta inativa - mostrar virada para baixo (pode ser vendida)
                    back_card_path = os.path.join(IMG_DIR, "cartas", f"back_card_{self.player_color.lower()}.png")
                    if os.path.exists(back_card_path):
                        img = ImageTk.PhotoImage(Image.open(back_card_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] Carta {carta_tipo} INATIVA - VIRADA PARA BAIXO (pode ser vendida): {os.path.basename(carta_path)}")
                    else:
                        # Fallback se back_card não existir
                        img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                        print(f"DEBUG: [show_inventory_for_sell_after_sale] FALLBACK - carta {carta_tipo} virada para cima: {os.path.basename(carta_path)}")
                
                self._sell_imgs.append(img)
            except Exception as e:
                print(f"DEBUG: Erro ao carregar carta {carta_path}: {e}")
                continue
            carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
            carta_lbl.image = img  # type: ignore[attr-defined]
            carta_lbl.grid(row=idx//n_col, column=idx%n_col, padx=8, pady=8)
            carta_lbl.bind("<Button-1>", make_fullscreen_callback(carta_path))
        
        if not cartas:
            no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
            no_cards_lbl.pack(pady=20)
        
        # Setas de navegação (se houver mais de uma página)
        if total_pages > 1:
            seta_x = 0.90
            # Seta para cima (página anterior)
            if page > 0:
                seta_up_btn = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), 
                                       bg="#222", fg="white", width=2, height=1,
                                       command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page-1))
                seta_up_btn.place(relx=seta_x, rely=0.35, anchor="center")
            
            # Seta para baixo (página seguinte)
            if page < total_pages - 1:
                seta_down_btn = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), 
                                         bg="#222", fg="white", width=2, height=1,
                                         command=lambda: self.show_inventory_for_sell_after_sale(carta_tipo, store_window, page+1))
                seta_down_btn.place(relx=seta_x, rely=0.65, anchor="center")
        
        # --- BARRA INFERIOR COM IMAGEM ---
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            bottombar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            bottombar_img = ImageTk.PhotoImage(Image.open(bottombar_img_path).resize((screen_width, 50)))
            bottombar_label = tk.Label(self, image=bottombar_img, bg="black")
            bottombar_label.image = bottombar_img  # type: ignore[attr-defined]
            bottombar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada no inventário de venda após venda")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png no inventário de venda após venda: {e}")
            # Fallback: criar uma barra simples da cor do jogador se a imagem não existir
            bottombar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            bottombar_frame.pack(side="bottom", fill="x")
            bottombar_frame.pack_propagate(False)

        # Saldo e piccoin no canto inferior direito, sobre a barra inferior
        coin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
        coin_lbl = tk.Label(self, image=coin_img, bg=self.bar_color)
        coin_lbl.image = coin_img  # type: ignore[attr-defined]
        coin_lbl.place(x=screen_width-100, rely=1.0, y=-25, anchor="w")
        
        saldo_lbl = tk.Label(self, text=f"{self.saldo}", 
                           font=("Helvetica", 16, "bold"), fg="black", bg=self.bar_color)
        saldo_lbl.place(x=screen_width-70, rely=1.0, y=-25, anchor="w")

        # Botão voltar - criado após a barra para ficar por cima
        def voltar_para_store():
            print("DEBUG: PlayerDashboard voltar_para_store chamado (após venda)")
            try:
                # Primeiro, esconde o PlayerDashboard
                print("DEBUG: Escondendo PlayerDashboard...")
                self.withdraw()
                
                # Aguarda um pouco para garantir que foi escondido
                print("DEBUG: Aguardando para processar volta à Store...")
                self.after(100, lambda: self._process_back_to_store_after_sale(store_window))
                
            except Exception as e:
                print(f"DEBUG: Erro ao iniciar volta para store após venda: {e}")
                import traceback
                traceback.print_exc()
        
        def _process_back_to_store_after_sale(store_window):
            print("DEBUG: Processando volta à Store após venda...")
            try:
                # Verificar se a Store ainda existe
                if hasattr(store_window, 'winfo_exists') and store_window.winfo_exists():
                    print("DEBUG: Store existe, forçando exibição...")
                    # Força a Store a aparecer
                    store_window.deiconify()
                    store_window.state('normal')
                    store_window.lift()
                    store_window.focus_force()
                    
                    # CORREÇÃO: Voltar para a interface principal da Store (não para página de compra específica)
                    print(f"DEBUG: Botão Back - Chamando voltar_para_store da Store...")
                    store_window.after(50, lambda: store_window.voltar_para_store())
                    print(f"DEBUG: Interface principal da Store restaurada com sucesso")
                    
                else:
                    print("DEBUG: Store não existe mais, voltando ao PlayerDashboard")
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    
            except Exception as e:
                print(f"DEBUG: Erro ao processar volta à Store após venda: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, volta ao PlayerDashboard
                try:
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback após venda: {fallback_e}")
                    traceback.print_exc()
        
        # Adiciona o método auxiliar à instância
        self._process_back_to_store_after_sale = _process_back_to_store_after_sale
        
        if store_window:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=voltar_para_store)
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")
        else:
            btn_voltar = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=lambda: self.playerdashboard_interface(self.player_name, self.saldo, self.other_players))
            btn_voltar.place(relx=0.5, rely=0.98, anchor="s")

        print("DEBUG: show_inventory_for_sell_after_sale terminado com sucesso")

    def show_card_fullscreen_sell(self, carta_path, carta_tipo, store_window=None):
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X para fechar - movido para canto superior esquerdo
        def fechar():
            # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
            current_page = getattr(self, '_current_sell_page', 0)
            # IMPORTANTE: Usar versão especial que ignora verificações de casa
            self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
        
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=fechar, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão de venda APENAS se estiver numa casa do tipo correspondente
        # Verificar se o jogador está numa casa do tipo correspondente (no inventário próprio, qualquer cor serve)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        casa_atual_cor = getattr(self, 'current_casa_cor', 'neutral')
        current_other_player_house = getattr(self, 'current_other_player_house', False)
        
        print(f"DEBUG: Verificando possibilidade de venda fullscreen no inventário - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}, casa_atual_cor: {casa_atual_cor}, other_player_house: {current_other_player_house}")
        
        # IMPORTANTE: User_1.png NUNCA pode ser vendida
        is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
        if is_user_1:
            print(f"DEBUG: User_1.png NÃO pode ser vendida - apenas botão X disponível")
            pode_vender = False
        else:
            # CORREÇÃO: Verificar se a carta está ATIVA (cartas ativas nunca podem ser vendidas)
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            
            if is_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} - carta está ATIVA (cartas ativas não podem ser vendidas)")
                pode_vender = False
            # IMPORTANTE: Se Next Phase está ativo, também não pode vender (dupla verificação)
            elif getattr(self, '_next_phase_active', False):
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - Next Phase está ativo (vendas desabilitadas)")
                pode_vender = False
            # IMPORTANTE: Se está numa casa de outro jogador, PODE vender cartas INATIVAS do inventário do tipo correspondente
            elif current_other_player_house:
                print(f"DEBUG: Casa de outro jogador detectada - verificando se pode vender {carta_tipo} INATIVO")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Em casas de outros jogadores, pode vender se o tipo da casa corresponder ao tipo da carta E carta está INATIVA
                if carta_tipo in ["users", "equipments", "services", "activities", "challenges"]:
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                        print(f"DEBUG: PODE vender carta {carta_tipo} INATIVA - está numa casa {casa_atual_tipo} de outro jogador")
                    else:
                        print(f"DEBUG: NÃO pode vender carta {carta_tipo} - casa {casa_atual_tipo} não corresponde")
            else:
                # Lógica original para casas próprias ou neutras - só pode vender cartas INATIVAS
                print(f"DEBUG: Casa própria ou neutra - verificando regras normais (apenas cartas INATIVAS)")
                # Normalizar o tipo da casa atual (equipments vs equipment)
                if casa_atual_tipo == "equipment":
                    casa_atual_tipo = "equipments"
                
                # Verificar se pode vender cartas INATIVAS
                if carta_tipo in ["users", "equipments", "services"]:
                    # Para estas cartas, precisa estar na casa do mesmo tipo E carta deve estar INATIVA
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
                elif carta_tipo in ["activities", "challenges"]:
                    # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                    if casa_atual_tipo == carta_tipo:
                        pode_vender = True
        
        # Botão de venda com checkmark no canto superior direito (substitui o botão verde picoin)
        if pode_vender:
            if current_other_player_house:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo} de outro jogador ({casa_atual_cor})")
            else:
                print(f"DEBUG: Pode vender carta {carta_tipo} INATIVA do inventário - está numa casa {casa_atual_tipo}")
            def abrir_confirm():
                self.show_sell_confirmation(carta_path, carta_tipo, store_window)
            
            # Botão com checkmark (✓) no canto superior direito
            btn_sell = tk.Button(self, text="✓", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=abrir_confirm, cursor="hand2", activebackground="#43d17a")
            btn_sell.place(relx=0.98, rely=0, anchor="ne")
        else:
            # Verificar motivo específico para não poder vender
            is_user_1 = (carta_tipo == "users" and "User_1.png" in os.path.basename(carta_path))
            is_active = False
            if carta_tipo in ["users", "equipments", "services"]:
                is_active = self.is_card_active(carta_path, carta_tipo)
            next_phase_active = getattr(self, '_next_phase_active', False)
            
            if is_user_1:
                print(f"DEBUG: User_1.png - apenas botão X disponível (nunca pode ser vendida)")
            elif is_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} - carta está ATIVA (cartas ativas não podem ser vendidas)")
            elif next_phase_active:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - Next Phase ativo (vendas desabilitadas)")
            elif current_other_player_house:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa de outro jogador ({casa_atual_cor}) do tipo {casa_atual_tipo}, necessário: {carta_tipo}")
            else:
                print(f"DEBUG: NÃO pode vender carta {carta_tipo} do inventário - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")

    def show_sell_confirmation(self, carta_path, carta_tipo, store_window=None):
        import tkinter.messagebox
        
        # LOGGING DETALHADO PARA DEBUG
        print(f"DEBUG: [VENDA INÍCIO] ===== PROCESSO DE VENDA INICIADO =====")
        print(f"DEBUG: [VENDA INÍCIO] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [VENDA INÍCIO] Tipo: {carta_tipo}")
        print(f"DEBUG: [VENDA INÍCIO] Store fornecida: {store_window is not None}")
        if store_window:
            print(f"DEBUG: [VENDA INÍCIO] Store ID: {getattr(store_window, '_store_id', 'Sem ID')}")
            print(f"DEBUG: [VENDA INÍCIO] Player cor: {self.player_color}")
            print(f"DEBUG: [VENDA INÍCIO] Store casa_cor: {getattr(store_window, 'casa_cor', 'Não definida')}")
            print(f"DEBUG: [VENDA INÍCIO] Store casa_tipo: {getattr(store_window, 'casa_tipo', 'Não definido')}")
        
        # Definir variáveis necessárias
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # PRIMEIRO: Limpar tudo e mostrar a carta em fullscreen como fundo (igual à compra)
        for widget in self.winfo_children():
            widget.destroy()
        self.configure(bg="black")
        
        # Mostrar a carta em fullscreen como fundo (igual à imagem de compra)
        try:
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            
            # Área disponível: toda a tela (igual à compra)
            available_width = screen_width
            available_height = screen_height
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(available_width/img_w, available_height/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Carta em fullscreen como fundo
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # Manter referência para evitar garbage collection
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
            print("DEBUG: Carta carregada em fullscreen como fundo")
            
        except Exception as e:
            print(f"DEBUG: ERRO ao carregar carta para fundo: {e}")
            # Mostrar um placeholder em caso de erro
            carta_real_lbl = tk.Label(self, text="Erro ao carregar carta", font=("Helvetica", 20), fg="red", bg="black")
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center")
        
        # SEGUNDO: Frame de confirmação (igual ao layout da compra na imagem)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        tk.Label(confirm_frame, text="Are you sure you want to sell?", font=("Helvetica", 16, "bold"), fg="white", bg="black").pack(pady=(40, 20))
        
        # Saldo atual (igual à confirmação de compra)
        tk.Label(confirm_frame, text=f"Your balance: {self.saldo}", font=("Helvetica", 16), fg="yellow", bg="black").pack(pady=(0, 10))
        
        # Valor da carta (usando base de dados integrada)
        valor = self._extrair_valor_venda_carta(carta_path)
        if valor is None:
            print("DEBUG: Valor não encontrado, usando fallback")
            valor = self._extrair_valor_fallback(carta_path)
        
        value_frame = tk.Frame(confirm_frame, bg="black")
        value_frame.pack(pady=(0, 30))
        
        tk.Label(value_frame, text="Card value: ", 
                font=("Helvetica", 16), fg="white", bg="black").pack(side="left")
        tk.Label(value_frame, text=str(valor), 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(side="left", padx=(5, 5))
        
        # Ícone da moeda (igual à confirmação de compra)
        try:
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((24,24)))
            picoin_lbl = tk.Label(value_frame, image=picoin_img, bg="black")
            picoin_lbl.image = picoin_img
            picoin_lbl.pack(side="left")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar ícone da moeda: {e}")
        
        # Frame para os botões (igual à confirmação de compra)
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack()
        
        def confirmar():
            print("DEBUG: Confirmar venda - início")
            print(f"DEBUG: Variáveis de controle - _inventario_conjunto: {getattr(self, '_inventario_conjunto', 'None')}")
            print(f"DEBUG: Variáveis de controle - _tipos_venda: {getattr(self, '_tipos_venda', 'None')}")
            print(f"DEBUG: Variáveis de controle - _current_sell_page: {getattr(self, '_current_sell_page', 'None')}")
            try:
                # CORREÇÃO: Lógica de venda correta
                # Player vende a carta: perde a carta, ganha dinheiro
                # Store compra a carta: ganha a carta, perde dinheiro
                if valor is not None and valor > 0:
                    # Player recebe o dinheiro pela venda
                    self.saldo += valor
                    print(f"DEBUG: Player vendeu carta por {valor}, novo saldo: {self.saldo}")
                    
                    # Store paga pela carta (perde dinheiro)
                    if store_window:
                        store_window.saldo -= valor
                        print(f"DEBUG: Store pagou {valor}, novo saldo: {store_window.saldo}")
                        
                        # IMPORTANTE: Devolver a carta aos baralhos da Store (sincronização)
                        # CORREÇÃO: Especificar a cor do jogador que está vendendo
                        if hasattr(store_window, 'adicionar_carta_ao_baralho'):
                            print(f"DEBUG: [VENDA EXECUÇÃO] ===== ADICIONANDO CARTA DE VOLTA À STORE =====")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Carta: {os.path.basename(carta_path)}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Tipo: {carta_tipo}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Cor do jogador vendedor: {self.player_color}")
                            
                            # Determinar a cor correta para adicionar a carta
                            cor_carta = self._get_color_from_path(carta_path)
                            # As cartas vendidas sempre vão para o baralho da cor do jogador
                            if not cor_carta:
                                cor_carta = self.player_color
                            
                            print(f"DEBUG: [VENDA EXECUÇÃO] Cor da carta determinada: {cor_carta}")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Casa atual da Store: tipo='{store_window.casa_tipo}', cor='{store_window.casa_cor}'")
                            
                            # Estado ANTES da adição
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_antes = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECUÇÃO] ANTES: {cartas_antes} cartas de {carta_tipo} na cor {cor_carta}")
                            else:
                                print(f"DEBUG: [VENDA EXECUÇÃO] ANTES: Baralho {cor_carta}/{carta_tipo} não existe ou vazio")
                            
                            # CHAMAR A FUNÇÃO DE ADICIONAR
                            print(f"DEBUG: [VENDA EXECUÇÃO] Chamando store_window.adicionar_carta_ao_baralho()")
                            print(f"DEBUG: [VENDA EXECUÇÃO] Parâmetros: carta_path={os.path.basename(carta_path)}, carta_tipo={carta_tipo}, carta_cor={cor_carta}")
                            
                            # CORREÇÃO ADICIONAL: Verificar se a função existe e chamá-la com try/except
                            try:
                                store_window.adicionar_carta_ao_baralho(carta_path, carta_tipo, cor_carta)
                                print(f"DEBUG: [VENDA EXECUÇÃO] adicionar_carta_ao_baralho executada COM SUCESSO")
                            except Exception as e:
                                print(f"DEBUG: [VENDA EXECUÇÃO] ERRO ao chamar adicionar_carta_ao_baralho: {e}")
                                # Fallback manual de sincronização
                                print(f"DEBUG: [VENDA EXECUÇÃO] Executando sincronização manual...")
                                if hasattr(store_window, 'cartas'):
                                    if cor_carta not in store_window.cartas:
                                        store_window.cartas[cor_carta] = {}
                                    if carta_tipo not in store_window.cartas[cor_carta]:
                                        store_window.cartas[cor_carta][carta_tipo] = []
                                    if carta_path not in store_window.cartas[cor_carta][carta_tipo]:
                                        store_window.cartas[cor_carta][carta_tipo].append(carta_path)
                                        print(f"DEBUG: [VENDA EXECUÇÃO] Carta adicionada manualmente ao baralho local")
                                    
                                    # Sincronização com baralho global
                                    try:
                                        from Store import baralhos
                                        if baralhos and cor_carta in baralhos and carta_tipo in baralhos[cor_carta]:
                                            if carta_path not in baralhos[cor_carta][carta_tipo]:
                                                baralhos[cor_carta][carta_tipo].append(carta_path)
                                                print(f"DEBUG: [VENDA EXECUÇÃO] Carta adicionada manualmente ao baralho global")
                                    except Exception as global_sync_error:
                                        print(f"DEBUG: [VENDA EXECUÇÃO] Erro na sincronização global: {global_sync_error}")
                            
                            
                            # Estado DEPOIS da adição
                            if hasattr(store_window, 'cartas') and cor_carta in store_window.cartas and carta_tipo in store_window.cartas[cor_carta]:
                                cartas_depois = len(store_window.cartas[cor_carta][carta_tipo])
                                print(f"DEBUG: [VENDA EXECUÇÃO] DEPOIS: {cartas_depois} cartas de {carta_tipo} na cor {cor_carta}")
                                
                                # Verificar se a carta específica está lá
                                carta_encontrada = carta_path in store_window.cartas[cor_carta][carta_tipo]
                                print(f"DEBUG: [VENDA EXECUÇÃO] Carta {os.path.basename(carta_path)} encontrada no baralho: {carta_encontrada}")
                                
                                # Listar algumas cartas para debug
                                cartas_sample = [os.path.basename(c) for c in store_window.cartas[cor_carta][carta_tipo][-3:]]
                                print(f"DEBUG: [VENDA EXECUÇÃO] Últimas 3 cartas no baralho: {cartas_sample}")
                            else:
                                print(f"DEBUG: [VENDA EXECUÇÃO] DEPOIS: Baralho {cor_carta}/{carta_tipo} ainda não existe!")
                            
                            print(f"DEBUG: [VENDA EXECUÇÃO] ===== ADIÇÃO CONCLUÍDA =====")
                        else:
                            print(f"DEBUG: [VENDA EXECUÇÃO] ERRO: Store não tem método adicionar_carta_ao_baralho")
                
                # Remove carta do inventário do Player
                if carta_tipo in self.inventario and carta_path in self.inventario[carta_tipo]:
                    self.inventario[carta_tipo].remove(carta_path)
                    print(f"DEBUG: Carta removida do inventário do Player: {carta_path}")
                
                print(f"DEBUG: Venda confirmada - Player saldo: {self.saldo}")
                
                # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
                # Se viemos de um inventário Activities/Challenges conjunto, voltar para esse
                if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                    print("DEBUG: Voltando para inventário conjunto Activities/Challenges")
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORREÇÃO: Verificar se a página ainda é válida após a venda
                    cartas_totais = []
                    for t in self._tipos_venda:
                        cartas_totais += self.inventario.get(t, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                    # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_matrix_carrossel com tipos: {self._tipos_venda}, page: {current_page}")
                    self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
                else:
                    print("DEBUG: Voltando para inventário do tipo específico")
                    # Caso normal: voltar para inventário do tipo específico
                    current_page = getattr(self, '_current_sell_page', 0)
                    # CORREÇÃO: Verificar se a página ainda é válida após a venda
                    cartas_restantes = self.inventario.get(carta_tipo, [])
                    cards_per_page = 4
                    total_pages = max(1, (len(cartas_restantes) + cards_per_page - 1) // cards_per_page) if cartas_restantes else 1
                    # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                    if current_page is None:
                        current_page = 0
                    if total_pages is None:
                        total_pages = 1
                    current_page = min(current_page, total_pages - 1)
                    print(f"DEBUG: Cartas restantes: {len(cartas_restantes)}, total_pages: {total_pages}, current_page: {current_page}")
                    print(f"DEBUG: Chamando show_inventory_for_sell_after_sale com carta_tipo: {carta_tipo}, page: {current_page}")
                    # IMPORTANTE: Usar versão especial que ignora verificações de casa para voltar após venda
                    self.show_inventory_for_sell_after_sale(carta_tipo, store_window, current_page)
                
                # Limpar variáveis de controle
                self._origem_venda = None
                self._tipos_venda = None
                self._page_venda = None
                self._current_sell_page = None
                self._inventario_conjunto = None
                
                print("DEBUG: Venda confirmada com sucesso - limpeza concluída")
                
            except Exception as e:
                print(f"DEBUG: ERRO na confirmação: {e}")
                import traceback
                traceback.print_exc()
                # Em caso de erro, tentar voltar à interface principal
                try:
                    print("DEBUG: Tentando voltar à interface principal após erro")
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar venda - carta_tipo: {carta_tipo}")
            
            # CORREÇÃO: Voltar para a página de inventário correta onde o utilizador estava
            # Se viemos de um inventário Activities/Challenges conjunto, voltar para esse
            if getattr(self, '_inventario_conjunto', False) and hasattr(self, '_tipos_venda') and self._tipos_venda:
                print("DEBUG: Voltando para inventário conjunto Activities/Challenges")
                current_page = getattr(self, '_current_sell_page', 0)
                # CORREÇÃO: Verificar se a página ainda é válida (mesmo sem venda, por segurança)
                cartas_totais = []
                for t in self._tipos_venda:
                    cartas_totais += self.inventario.get(t, [])
                cards_per_page = 4
                total_pages = max(1, (len(cartas_totais) + cards_per_page - 1) // cards_per_page) if cartas_totais else 1
                # IMPORTANTE: Garantir que current_page e total_pages são números válidos
                if current_page is None:
                    current_page = 0
                if total_pages is None:
                    total_pages = 1
                current_page = min(current_page, total_pages - 1)
                print(f"DEBUG: Cartas totais: {len(cartas_totais)}, total_pages: {total_pages}, current_page: {current_page}")
                self.show_inventory_matrix_carrossel(self._tipos_venda, current_page)
            else:
                # Caso normal: voltar para inventário do tipo específico
                current_page = getattr(self, '_current_sell_page', 0)
                # IMPORTANTE: Garantir que current_page é um número válido
                if current_page is None:
                    current_page = 0
                # IMPORTANTE: Para cancelamento, usar função normal que mostra todas as cartas
                print(f"DEBUG: Cancelamento - chamando show_inventory_for_sell normal com carta_tipo: {carta_tipo}, page: {current_page}")
                self.show_inventory_for_sell(carta_tipo, store_window, current_page)
            
            # Limpar variáveis de controle
            self._origem_venda = None
            self._tipos_venda = None
            self._page_venda = None
            self._current_sell_page = None
            self._inventario_conjunto = None
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação criados - Yes e No")
        print(f"DEBUG: Função confirmar configurada: {confirmar}")
        print(f"DEBUG: Função cancelar configurada: {cancelar}")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def _voltar_inventario_apos_ativacao(self, tipos, page):
        """Método auxiliar para voltar ao inventário após ativação"""
        try:
            # Recriar a TopBar
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada após ativação")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        except Exception as e:
            print(f"DEBUG: Erro ao voltar ao inventário: {e}")

    def _voltar_inventario_e_verificar_bandwidth(self, tipos, page):
        """Método para voltar ao inventário e verificar BANDWIDTH após mostrar inventário"""
        try:
            # Primeiro, ir para o inventário
            self._voltar_inventario_apos_ativacao(tipos, page)
            
            # Verificar BANDWIDTH APÓS mostrar o inventário (com delay para garantir que interface carregou)
            def verificar_bandwidth_apos_inventario():
                if not self._has_active_bandwidth_services():
                    print(f"DEBUG: User ativado mas BANDWIDTH não encontrado - mostrando erro sobre inventário")
                    # Mostrar mensagem de erro sobre o inventário
                    self._show_bandwidth_required_message(tipos, page)
            
            # Verificar após 100ms para garantir que inventário foi carregado
            self.after(100, verificar_bandwidth_apos_inventario)
            
        except Exception as e:
            print(f"DEBUG: Erro ao voltar ao inventário e verificar BANDWIDTH: {e}")

    def _voltar_inventario_sem_ativar_e_mostrar_erro_bandwidth(self, tipos, page):
        """Método para mostrar erro BANDWIDTH diretamente (tela dedicada que funciona no Raspberry Pi)"""
        print(f"DEBUG: [BANDWIDTH_ERROR] === MOSTRANDO TELA DE ERRO BANDWIDTH ===")
        print(f"DEBUG: [BANDWIDTH_ERROR] Tipos: {tipos}, Page: {page}")
        print(f"DEBUG: Tentativa de ativar User BLOQUEADA - Nenhum Service BANDWIDTH ativo")
        
        # Mostrar tela de erro DIRETAMENTE (abordagem que garante visibilidade no Raspberry Pi)
        self._show_bandwidth_required_message(tipos, page)

    def show_activation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma página de confirmação para ativação de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirmação de ativação para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Activation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text="Do you want to activate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando ativação da carta {carta_path}")
            
            # NOVA VERIFICAÇÃO BANDWIDTH LOGO NO INÍCIO para cartas User
            if carta_tipo in ["user", "users"]:
                print(f"DEBUG: [ACTIVATION] Carta User detectada - verificando BANDWIDTH")
                
                if not self._has_active_bandwidth_services():
                    print(f"DEBUG: [BANDWIDTH_ERROR] User activation BLOCKED - No active BANDWIDTH services")
                    # Mostrar novo overlay de erro sequencial (substitui o overlay de ativação)
                    self._show_bandwidth_error_overlay(tipos, page)
                    return
                
                print(f"DEBUG: [ACTIVATION] BANDWIDTH verificado OK - procedendo com ativação User")
            
            try:
                # CORREÇÃO CRÍTICA: Para cartas Equipment, mostrar loading screen IMEDIATAMENTE
                if carta_tipo in ["equipment", "equipments"]:
                    print(f"DEBUG: [ACTIVATION] Carta Equipment detectada - mostrando loading screen IMEDIATAMENTE")
                    
                    # Obter object_name da carta
                    object_name = get_equipment_object_name(carta_path, self.card_database)
                    
                    if object_name:
                        print(f"DEBUG: [ACTIVATION] Criando loading screen para object: {object_name}")
                        
                        # CRIAR LOADING SCREEN IMEDIATAMENTE - ANTES DE TUDO
                        loading_window = create_yolo_loading_screen(self, object_name)
                        
                        if loading_window:
                            print(f"DEBUG: [ACTIVATION] Loading screen criado - executando ativação em background")
                            
                            # Função para processar ativação depois do loading screen estar ativo
                            def processar_ativacao_com_yolo():
                                try:
                                    # Ativar a carta
                                    self.activate_card(carta_tipo, carta_path)
                                    print(f"DEBUG: [ACTIVATION] Carta ativada - iniciando YOLO")
                                    
                                    # Executar script YOLO (sem criar loading screen novamente)
                                    detection_success = execute_detection_script_direct(object_name, self, loading_window)
                                    
                                    if detection_success:
                                        print(f"DEBUG: [ACTIVATION] Script YOLO iniciado com sucesso")
                                    else:
                                        print(f"DEBUG: [ACTIVATION] AVISO: Script YOLO falhou - fechando loading screen")
                                        if loading_window:
                                            loading_window.destroy()
                                        
                                        self._voltar_inventario_apos_ativacao(tipos, page)
                                        
                                except Exception as e:
                                    print(f"DEBUG: [ACTIVATION] ERRO na ativação: {e}")
                                    if loading_window:
                                        loading_window.destroy()
                                    
                                    self._voltar_inventario_apos_ativacao(tipos, page)
                            
                            # Executar ativação após 100ms (loading screen já está visível)
                            self.after(100, processar_ativacao_com_yolo)
                            
                        else:
                            print(f"DEBUG: [ACTIVATION] ERRO: Loading screen não foi criado - continuando normalmente")
                            
                            # Fallback: ativação normal se loading screen falhar
                            self.activate_card(carta_tipo, carta_path)
                            self._voltar_inventario_apos_ativacao(tipos, page)
                    else:
                        print(f"DEBUG: [ACTIVATION] AVISO: Object name não encontrado - ativação normal")
                        
                        # Ativação normal se não conseguir obter object_name
                        self.activate_card(carta_tipo, carta_path)
                        self._voltar_inventario_apos_ativacao(tipos, page)
                else:
                    # Para cartas não-Equipment, ativação normal
                    print(f"DEBUG: [ACTIVATION] Carta não-Equipment - ativação normal")
                    self.activate_card(carta_tipo, carta_path)
                    self._voltar_inventario_apos_ativacao(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar ativação: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o inventário
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada após erro na ativação")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar após erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar ativação - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao inventário
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada após cancelar ativação")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação de ativação criados - Yes e No")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_deactivation_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra uma página de confirmação para desativação de carta com a carta como fundo"""
        print(f"DEBUG: Mostrando confirmação de desativação para {carta_path}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela (igual à venda)
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo (usar place igual à venda)
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela) - fundo preto com letras brancas
        # Usar pack(expand=True) para dimensionamento dinâmico, igual às páginas de venda
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Deactivation Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem de confirmação
        tk.Label(confirm_frame, text="Do you want to deactivate this card?", 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar():
            print(f"DEBUG: Confirmando desativação da carta {carta_path}")
            try:
                # NOVA FUNCIONALIDADE: Criar loading screen ANTES de qualquer ação para Equipment
                if carta_tipo in ["equipment", "equipments"]:
                    print(f"DEBUG: [DEACTIVATION] Carta Equipment detectada - criando loading screen")
                    
                    # Obter object_name da carta
                    object_name = get_equipment_object_name(carta_path, self.card_database)
                    
                    if object_name:
                        print(f"DEBUG: [DEACTIVATION] Criando loading screen para object: {object_name}")
                        
                        # Criar loading screen imediatamente
                        loading_window = create_yolo_loading_screen(self, object_name)
                        
                        if loading_window:
                            print(f"DEBUG: [DEACTIVATION] Loading screen criado com sucesso")
                            
                            # Desativar a carta
                            self.deactivate_card(carta_path, carta_tipo)
                            
                            # Executar script de detecção diretamente com loading screen existente
                            detection_success = execute_detection_script_direct(object_name, self, loading_window)
                            
                            if detection_success:
                                print(f"DEBUG: [DEACTIVATION] Script de detecção executado com sucesso")
                            else:
                                print(f"DEBUG: [DEACTIVATION] AVISO: Script de detecção falhou")
                                # Fechar loading screen em caso de erro
                                if loading_window:
                                    loading_window.destroy()
                        else:
                            print(f"DEBUG: [DEACTIVATION] ERRO: Não foi possível criar loading screen")
                            # Fallback sem loading screen
                            self.deactivate_card(carta_path, carta_tipo)
                    else:
                        print(f"DEBUG: [DEACTIVATION] AVISO: Object name não encontrado para carta Equipment")
                        # Fallback sem detecção
                        self.deactivate_card(carta_path, carta_tipo)
                else:
                    # Para cartas que não são Equipment, desativar normalmente
                    self.deactivate_card(carta_path, carta_tipo)
                
                # Para cartas não-Equipment, recriar TopBar e voltar ao inventário
                if carta_tipo not in ["equipment", "equipments"]:
                    # Recriar a TopBar antes de voltar ao inventário
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada após confirmar desativação")
                    except Exception as e:
                        print(f"DEBUG: Erro ao recriar TopBar: {e}")
                    
                    # Voltar para a página de inventário
                    self.show_inventory_matrix(tipos, page)
                
            except Exception as e:
                print(f"DEBUG: Erro ao confirmar desativação: {e}")
                traceback.print_exc()
                # Em caso de erro, voltar para o inventário
                try:
                    # Recriar a TopBar mesmo em caso de erro
                    screen_width = self.winfo_screenwidth()
                    topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
                    try:
                        img = Image.open(topbar_img_path).convert("RGBA")
                        img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                        topbar_img = ImageTk.PhotoImage(img)
                        self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                        self.topbar_label.image = topbar_img
                        self.topbar_label.pack(side="top", fill="x")
                        print("DEBUG: TopBar recriada após erro na desativação")
                    except Exception as topbar_e:
                        print(f"DEBUG: Erro ao recriar TopBar após erro: {topbar_e}")
                    
                    self.show_inventory_matrix(tipos, page)
                except Exception as fallback_e:
                    print(f"DEBUG: ERRO CRÍTICO no fallback: {fallback_e}")
                    traceback.print_exc()
        
        def cancelar():
            print(f"DEBUG: Cancelar desativação - carta_tipo: {carta_tipo}")
            
            # Recriar a TopBar antes de voltar ao inventário
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: TopBar recriada após cancelar desativação")
            except Exception as e:
                print(f"DEBUG: Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        # Botões No e Yes (posições trocadas)
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: Botões de confirmação de desativação criados - Yes e No")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_remove_router_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para remoção de router no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Mostrando confirmação de remoção do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Do you want to remove the router {router_id}?"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Confirmando remoção do router {router_id}")
            try:
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido do inventário")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (página de inventário de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao enviar router para Store: {e}")
                    
                    # Verificar se há links ativos com o mesmo specific_id
                    links_ativos_mesmo_id = self._find_active_links_with_same_id(router_id)
                    
                    if links_ativos_mesmo_id:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Links ativos encontrados com ID {router_id}: {len(links_ativos_mesmo_id)}")
                        # Manter contexto ativo para remoção de links
                        self._in_remove_router_context = True
                        # Adicionar flag específica para indicar que estamos agora removendo links
                        self._removing_associated_links = True
                        self._router_id_being_removed = router_id
                        # Voltar ao inventário de equipments para remover links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Nenhum link ativo encontrado com ID {router_id}")
                        # Limpar flag do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        # Voltar à interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Voltando à interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO: Router não encontrado no inventário")
                    # Em caso de erro, voltar ao inventário
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao confirmar remoção: {e}")
                # Em caso de erro, voltar ao inventário
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao():
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Cancelando remoção do router")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Botões No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Overlay de confirmação de remoção criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_router_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para upgrade de router no contexto ROUTER UPGRADE"""
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Mostrando confirmação de upgrade do router: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        router_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Confirmando upgrade do router {router_id}")
            try:
                # Mapeamento: Small Router -> Medium Router
                equipment_mapping = {
                    1: ("Equipment_1.png", "Equipment_4.png"),  # Small Router 1 -> Medium Router 1
                    2: ("Equipment_2.png", "Equipment_5.png"),  # Small Router 2 -> Medium Router 2
                    3: ("Equipment_3.png", "Equipment_6.png"),  # Small Router 3 -> Medium Router 3
                }
                
                if router_id not in equipment_mapping:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Router ID {router_id} não suportado")
                    return
                
                small_router, medium_router = equipment_mapping[router_id]
                
                # Verificar se o jogador já tem o Medium Router correspondente no inventário
                equipments_inventory = self.inventario.get("equipments", [])
                medium_router_exists = any(os.path.basename(eq) == medium_router for eq in equipments_inventory)
                
                if medium_router_exists:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERROR: {medium_router} já existe no inventário - upgrade não aplicado")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Small Router do inventário e ativos
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido do inventário")
                    
                    # Remover da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router removido da lista de equipments ativos")
                    
                    # Construir caminho para Medium Router (usar mesma estrutura de diretório)
                    base_dir = os.path.dirname(carta_path)
                    medium_router_path = os.path.join(base_dir, medium_router)
                    
                    # Adicionar Medium Router ao inventário (virado para baixo)
                    self.inventario["equipments"].append(medium_router_path)
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] {medium_router} adicionado ao inventário (virado para baixo)")
                    
                    # Enviar Small Router para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Small Router enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao enviar Small Router para Store: {e}")
                    
                    # Limpar flags do contexto ROUTER UPGRADE
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    
                    # Voltar à página de inventário de Equipments
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] SUCCESS: Router Upgrade aplicado com sucesso!")
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Voltando à página de inventário de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] ERRO: Small Router não encontrado no inventário")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_router_upgrade_context = False
                    self._router_upgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Erro ao confirmar upgrade: {e}")
                # Limpar flags e voltar à página de inventário de Equipments
                self._in_router_upgrade_context = False
                self._router_upgrade_target_id = None
                # REABILITAR BOTÃO BACK quando Ok é clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [ROUTER_UPGRADE] Botão Back REABILITADO após clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_UPGRADE_CONFIRM] Overlay de confirmação de upgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_router_downgrade_confirmation(self, router_id):
        """Mostra confirmação específica para downgrade de router no contexto ROUTER DOWNGRADE"""
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Mostrando confirmação de downgrade do Router ID: {router_id}")
        
        # Salvar estado antes de limpar widgets
        self._save_dashboard_state()
        
        # Obter carta Equipment que está sendo processada para downgrade
        carta_path = None
        try:
            # Mapear router_id para carta Equipment correspondente
            router_to_equipment = {
                1: "Equipment_4.png",  # Medium Router 1
                2: "Equipment_5.png",  # Medium Router 2  
                3: "Equipment_6.png",  # Medium Router 3
            }
            
            if router_id in router_to_equipment:
                equipment_filename = router_to_equipment[router_id]
                # Encontrar caminho completo da carta no inventário
                for eq_path in self.inventario.get("equipments", []):
                    if os.path.basename(eq_path) == equipment_filename:
                        carta_path = eq_path
                        break
                        
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta encontrada para fundo: {carta_path}")
        except Exception as e:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao obter carta para fundo: {e}")
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo (similar ao overlay de upgrade)
        if carta_path and os.path.exists(carta_path):
            try:
                carta_img = Image.open(carta_path)
                screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
                
                # Calcular o ratio para ocupar o máximo possível da tela
                ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
                new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
                carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
                carta_photo = ImageTk.PhotoImage(carta_resized)
                
                # Label com a imagem da carta como fundo
                carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
                carta_label.image = carta_photo  # Manter referência
                carta_label.place(relx=0.5, rely=0.5, anchor="center")
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Carta carregada como fundo: {os.path.basename(carta_path)}")
                
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
                self.config(bg="black")
        else:
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Nenhuma carta encontrada para fundo, usando fundo preto")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Router Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Router {router_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Confirmando downgrade do router {router_id}")
            try:
                # Processar efetivamente o downgrade
                self._processar_router_downgrade(router_id)
                
                # CORREÇÃO CRÍTICA: Limpar flags do contexto ROUTER DOWNGRADE ANTES de abrir inventário
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Limpando flags de contexto...")
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] SUCCESS: Router Downgrade aplicado com sucesso!")
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Voltando ao inventário normal de equipamentos")
                
                # CORREÇÃO: Voltar ao inventário normal de equipments (não específico para downgrade)
                # Isso garante que o botão Back e botões de ativação/desativação funcionem normalmente
                self.show_inventory_matrix(["equipments"])
                    
            except Exception as e:
                print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar ao dashboard principal
                self._in_router_downgrade_context = False
                self._router_downgrade_target_id = None
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [ROUTER_DOWNGRADE_CONFIRM] Overlay de confirmação de downgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_remove_link_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para remoção de link no contexto REMOVE ROUTER"""
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Mostrando confirmação de remoção do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Removal Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal com specific_id
        message_text = f"Link {link_id} is going to be removed"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 10))
        
        # Mensagem adicional
        tk.Label(confirm_frame, text="Don't forget to remove \nthe associated queue and link", 
                font=("Helvetica", 14), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Confirmando remoção do link {link_id}")
            try:
                # Remover carta do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido do inventário")
                    
                    # Remover carta da lista de equipments ativos
                    if carta_path in self.active_equipments:
                        self.active_equipments.remove(carta_path)
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link removido da lista de equipments ativos")
                    
                    # Enviar carta para a Store (página de inventário de Equipments)
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao enviar link para Store: {e}")
                    
                    # Verificar se há mais links ativos com o mesmo ID
                    router_id_being_removed = getattr(self, '_router_id_being_removed', None)
                    links_restantes = self._find_active_links_with_same_id(router_id_being_removed) if router_id_being_removed else []
                    
                    if links_restantes:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Ainda há {len(links_restantes)} link(s) ativo(s) com ID {router_id_being_removed}")
                        # Continuar no contexto de remoção de links
                        self._voltar_ao_inventario_equipments(tipos, page)
                    else:
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Todos os links com ID {router_id_being_removed} foram removidos")
                        # Limpar flags do contexto REMOVE ROUTER
                        self._in_remove_router_context = False
                        self._removing_associated_links = False
                        self._router_id_being_removed = None
                        # Voltar à interface principal do PlayerDashboard
                        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Voltando à interface principal")
                        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                else:
                    print(f"DEBUG: [REMOVE_LINK_CONFIRM] ERRO: Link não encontrado no inventário")
                    # Em caso de erro, voltar ao inventário
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [REMOVE_LINK_CONFIRM] Erro ao confirmar remoção: {e}")
                # Em caso de erro, voltar ao inventário
                self._voltar_ao_inventario_equipments(tipos, page)
        
        def cancelar_remocao_link():
            print(f"DEBUG: [REMOVE_LINK_CONFIRM] Cancelando remoção do link")
            self._voltar_ao_inventario_equipments(tipos, page)
        
        # Botões No e Yes
        btn_no = tk.Button(btns_frame, text="No", font=("Helvetica", 14, "bold"), 
                          bg="#F44336", fg="white", width=8, command=cancelar_remocao_link)
        btn_yes = tk.Button(btns_frame, text="Yes", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_remocao_link)
        btn_no.pack(side="left", padx=20, pady=10)
        btn_yes.pack(side="left", padx=20, pady=10)
        
        print(f"DEBUG: [REMOVE_LINK_CONFIRM] Overlay de confirmação de remoção de link criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def _find_active_links_with_same_id(self, router_id):
        """Encontra links ativos com o mesmo specific_id do router removido"""
        try:
            links_ativos = []
            
            # Verificar equipments ativos
            for carta_path in self.active_equipments:
                if self._is_link_card(carta_path):
                    link_id = self._get_equipment_specific_id(carta_path)
                    if str(link_id) == str(router_id):
                        links_ativos.append(carta_path)
                        print(f"DEBUG: [FIND_ACTIVE_LINKS] Link ativo encontrado: {os.path.basename(carta_path)} com ID {link_id}")
            
            return links_ativos
        except Exception as e:
            print(f"DEBUG: [FIND_ACTIVE_LINKS] Erro ao procurar links ativos: {e}")
            return []

    def _is_link_card(self, carta_path):
        """Verifica se uma carta é do tipo Link (Short Link ou Long Link)"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_7.png" -> "equipment_7")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    equipment_id = f"equipment_{match.group(1)}"
                    equipment_card = self.card_database.get_equipment(equipment_id)
                    
                    if equipment_card:
                        return equipment_card.category == "Link"
            
            # Fallback: verificar pelo número da carta
            # Equipment_7 a Equipment_12 são Links
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                return 7 <= card_num <= 12
                
        except Exception as e:
            print(f"DEBUG: [IS_LINK_CARD] Erro ao verificar se carta é link: {e}")
        
        return False

    def _get_equipment_specific_id(self, carta_path):
        """Obtém o specific_id de uma carta de equipment da base de dados"""
        try:
            if self.card_database:
                import re
                import os
                
                # Extrair ID da carta (ex: "Equipment_2.png" -> "2")
                filename = os.path.basename(carta_path)
                match = re.match(r'Equipment_(\d+)', filename)
                
                if match:
                    card_num = int(match.group(1))
                    
                    # Mapear número da carta para equipment_id na base de dados
                    if 1 <= card_num <= 3:
                        # Small Router
                        equipment_id = f"small_router_{card_num}_red"  # Usar cor genérica
                    elif 4 <= card_num <= 6:
                        # Medium Router
                        equipment_id = f"medium_router_{card_num-3}_red"  # Usar cor genérica
                    elif 7 <= card_num <= 9:
                        # Short Link
                        equipment_id = f"short_link_{card_num-6}_red"  # Usar cor genérica
                    elif 10 <= card_num <= 12:
                        # Long Link
                        equipment_id = f"long_link_{card_num-9}_red"  # Usar cor genérica
                    else:
                        equipment_id = None
                    
                    if equipment_id:
                        equipment_card = self.card_database.get_equipment(equipment_id)
                        
                        if equipment_card:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment {equipment_id} specific_id: {equipment_card.specific_id}")
                            return equipment_card.specific_id
                        else:
                            print(f"DEBUG: [SPECIFIC_ID] Equipment não encontrado na base de dados: {equipment_id}")
                    else:
                        print(f"DEBUG: [SPECIFIC_ID] Número de carta inválido: {card_num}")
                else:
                    print(f"DEBUG: [SPECIFIC_ID] Erro ao extrair ID do filename: {filename}")
        except Exception as e:
            print(f"DEBUG: [SPECIFIC_ID] Erro ao obter specific_id: {e}")
        
        # Fallback: extrair specific_id baseado no número da carta
        try:
            import re
            filename = os.path.basename(carta_path)
            match = re.search(r'Equipment_(\d+)', filename)
            if match:
                card_num = int(match.group(1))
                # Calcular specific_id baseado no mapeamento
                if 1 <= card_num <= 3:
                    return card_num  # Small Router: 1, 2, 3
                elif 4 <= card_num <= 6:
                    return card_num - 3  # Medium Router: 1, 2, 3
                elif 7 <= card_num <= 9:
                    return card_num - 6  # Short Link: 1, 2, 3
                elif 10 <= card_num <= 12:
                    return card_num - 9  # Long Link: 1, 2, 3
        except:
            pass
        
        return "N/A"

    def _voltar_ao_inventario_equipments(self, tipos, page):
        """Método auxiliar para voltar ao inventário de equipments com TopBar"""
        try:
            # Recriar a TopBar
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            try:
                img = Image.open(topbar_img_path).convert("RGBA")
                img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
                topbar_img = ImageTk.PhotoImage(img)
                self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
                self.topbar_label.image = topbar_img
                self.topbar_label.pack(side="top", fill="x")
                print("DEBUG: [REMOVE_ROUTER_CONFIRM] TopBar recriada")
            except Exception as e:
                print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] Erro ao recriar TopBar: {e}")
            
            # Voltar para a página de inventário
            self.show_inventory_matrix(tipos, page)
            
        except Exception as e:
            print(f"DEBUG: [REMOVE_ROUTER_CONFIRM] ERRO CRÍTICO no fallback: {e}")
            # Última tentativa: voltar à interface principal
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    # Corrigir aceitação de carta Challenge/Activity para adicionar ao carrossel
    def aceitar_carta_challenge_activity(self, carta_path, carta_tipo):
        # Chamar isto ao aceitar uma carta Challenge/Activity
        
        # CORREÇÃO CRÍTICA: Registar turno de início se for Challenge
        if carta_tipo == 'challenges' or 'Challenge' in os.path.basename(carta_path):
            # CORREÇÃO CRÍTICA RASPBERRY PI: Detectar se estamos em ambiente Pi e ajustar turno se necessário
            universal_paths = get_universal_paths()
            is_raspberry_pi = universal_paths['environment'] == 'raspberry_pi'
            
            # CORREÇÃO ESPECÍFICA: Se no Pi o turno parece estar 1 à frente do esperado, ajustar
            turno_aceitacao = self._current_turn_number
            
            if is_raspberry_pi:
                # No Raspberry Pi, verificar se o turno atual parece estar incrementado demais
                # Correção para Raspberry Pi: garantir que o turno registado é o turno atual real
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Turno atual: {turno_aceitacao}")
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Mantendo turno correto para registo")
                
                # CORREÇÃO: No Raspberry Pi, usar o turno atual tal como está
                # O problema anterior era que estávamos a subtrair 1, causando registo incorreto
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - TURNO MANTIDO: {turno_aceitacao}")
                print(f"DEBUG: [ACEITAR_CHALLENGE_ACTIVITY] RASPBERRY PI - Challenge será registado com turno {turno_aceitacao}")
            
            self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
            print(f"DEBUG: [aceitar_carta_challenge_activity] Challenge {os.path.basename(carta_path)} registado para turno {turno_aceitacao} (original: {self._current_turn_number})")
        
        self.adicionar_carta_carrossel(carta_path, carta_tipo)
        # ... resto do fluxo de aceitação ...
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_link_upgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para upgrade de link no contexto LINK UPGRADE"""
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Mostrando confirmação de upgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Upgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be upgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_upgrade():
            print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Ok clicado - executando upgrade com detecção YOLO")
            self._executar_link_upgrade(carta_path, link_id)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_upgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_UPGRADE_CONFIRM] Overlay de confirmação de upgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    def show_link_downgrade_confirmation(self, carta_path, carta_tipo, tipos, page):
        """Mostra confirmação específica para downgrade de link no contexto LINK DOWNGRADE"""
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Mostrando confirmação de downgrade do link: {os.path.basename(carta_path)}")
        
        # Obter specific_id da carta de equipment
        link_id = self._get_equipment_specific_id(carta_path)
        
        # Limpar TODOS os widgets (incluindo a barra superior para fullscreen completo)
        for widget in self.winfo_children():
            widget.destroy()
        
        # Definir fundo preto para a janela
        self.config(bg="black")
        
        # Carregar a imagem da carta como fundo
        try:
            carta_img = Image.open(carta_path)
            screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
            
            # Calcular o ratio para ocupar o máximo possível da tela
            ratio = min(screen_width/carta_img.width, screen_height/carta_img.height)
            new_w, new_h = int(carta_img.width * ratio), int(carta_img.height * ratio)
            carta_resized = carta_img.resize((new_w, new_h), Image.LANCZOS)
            carta_photo = ImageTk.PhotoImage(carta_resized)
            
            # Label com a imagem da carta como fundo
            carta_label = tk.Label(self, image=carta_photo, bg="black", borderwidth=0, highlightthickness=0)
            carta_label.image = carta_photo  # Manter referência
            carta_label.place(relx=0.5, rely=0.5, anchor="center")
            
        except Exception as e:
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao carregar imagem da carta: {e}")
            self.config(bg="black")
        
        # Frame para a dialog de confirmação (centro da tela)
        confirm_frame = tk.Frame(self, bg="black")
        confirm_frame.pack(expand=True)
        
        # Título
        tk.Label(confirm_frame, text="Link Downgrade Confirmation", 
                font=("Helvetica", 16, "bold"), fg="yellow", bg="black").pack(pady=(40, 20))
        
        # Mensagem principal
        message_text = f"Link {link_id} is going to be downgraded"
        tk.Label(confirm_frame, text=message_text, 
                font=("Helvetica", 16), fg="white", bg="black").pack(pady=(0, 20))
        
        # Frame para os botões
        btns_frame = tk.Frame(confirm_frame, bg="black")
        btns_frame.pack(pady=30)
        
        def confirmar_downgrade():
            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Confirmando downgrade do link {link_id}")
            try:
                # Mapeamento: Short Link -> Long Link
                equipment_mapping = {
                    1: ("Equipment_7.png", "Equipment_10.png"),   # Short Link 1 -> Long Link 1
                    2: ("Equipment_8.png", "Equipment_11.png"),   # Short Link 2 -> Long Link 2
                    3: ("Equipment_9.png", "Equipment_12.png"),   # Short Link 3 -> Long Link 3
                }
                
                if link_id not in equipment_mapping:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Link ID {link_id} não suportado")
                    return
                
                short_link, long_link = equipment_mapping[link_id]
                
                # Verificar se o jogador já tem o Long Link correspondente no inventário
                equipments_inventory = self.inventario.get("equipments", [])
                long_link_exists = any(os.path.basename(eq) == long_link for eq in equipments_inventory)
                
                if long_link_exists:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ERROR: {long_link} já existe no inventário - downgrade não aplicado")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    return
                
                # Remover Short Link do inventário
                if "equipments" in self.inventario and carta_path in self.inventario["equipments"]:
                    self.inventario["equipments"].remove(carta_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link removido do inventário")
                    
                    # Construir caminho para Long Link (usar mesma estrutura de diretório)
                    base_dir = os.path.dirname(carta_path)
                    long_link_path = os.path.join(base_dir, long_link)
                    
                    # Adicionar Long Link ao inventário (fica inativo por padrão)
                    self.inventario["equipments"].append(long_link_path)
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] {long_link} adicionado ao inventário (inativo)")
                    
                    # Enviar Short Link para a Store
                    if hasattr(self, 'store_window') and self.store_window:
                        try:
                            self.store_window.adicionar_carta_ao_baralho(carta_path, "equipments", "neutral")
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Short Link enviado para Store")
                        except Exception as e:
                            print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao enviar Short Link para Store: {e}")
                    
                    # Limpar flags do contexto LINK DOWNGRADE
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    
                    # Voltar à página de inventário de Equipments
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] SUCCESS: Link Downgrade aplicado com sucesso!")
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Voltando à página de inventário de Equipments")
                    self._voltar_ao_inventario_equipments(tipos, page)
                else:
                    print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] ERRO: Short Link não encontrado no inventário")
                    # Limpar flags e voltar à página de inventário de Equipments
                    self._in_link_downgrade_context = False
                    self._link_downgrade_target_id = None
                    # REABILITAR BOTÃO BACK quando Ok é clicado
                    if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                        self._back_button.config(state='normal', bg="#808080")
                        print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok")
                    self._voltar_ao_inventario_equipments(tipos, page)
                    
            except Exception as e:
                print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Erro ao confirmar downgrade: {e}")
                # Limpar flags e voltar à página de inventário de Equipments
                self._in_link_downgrade_context = False
                self._link_downgrade_target_id = None
                # REABILITAR BOTÃO BACK quando Ok é clicado (mesmo em caso de erro)
                if hasattr(self, '_back_button') and self._back_button.winfo_exists():
                    self._back_button.config(state='normal', bg="#808080")
                    print(f"DEBUG: [LINK_DOWNGRADE] Botão Back REABILITADO após clicar Ok (erro)")
                self._voltar_ao_inventario_equipments(tipos, page)
        
        # Apenas botão Ok
        btn_ok = tk.Button(btns_frame, text="Ok", font=("Helvetica", 14, "bold"), 
                           bg="#4CAF50", fg="white", width=8, command=confirmar_downgrade)
        btn_ok.pack(padx=20, pady=10)
        
        print(f"DEBUG: [LINK_DOWNGRADE_CONFIRM] Overlay de confirmação de downgrade criado")
        
        # Force update para garantir que os botões estão visíveis
        self.update_idletasks()
        self.update()

    # Corrigir fullscreen do carrossel: botão X volta sempre à interface principal
    def show_card_fullscreen_carrossel(self, carta_path):
        print(f"DEBUG: [FULLSCREEN] === FUNÇÃO show_card_fullscreen_carrossel CHAMADA ===")
        print(f"DEBUG: [FULLSCREEN] Carta: {os.path.basename(carta_path)}")
        print(f"DEBUG: [FULLSCREEN] Caminho completo: {carta_path}")
        
        # CORREÇÃO CRÍTICA: Salvar estado da interface ANTES de destruir widgets
        print(f"DEBUG: [FULLSCREEN] === SALVANDO ESTADO ANTES DE FULLSCREEN ===")
        self._save_dashboard_state()
        
        # Preservar valores das barras de progresso ANTES de destruir os widgets
        saved_progress_values = {}
        if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
            try:
                for stat in self.progress_bars:
                    # Verificar se o widget ainda existe antes de acessar seus valores
                    if self.progress_bars[stat].winfo_exists():
                        saved_progress_values[stat] = {
                            'value': self.progress_bars[stat]['value'],
                            'maximum': self.progress_bars[stat]['maximum']
                        }
                print(f"DEBUG: Valores das barras preservados antes de fullscreen: {saved_progress_values}")
            except Exception as e:
                print(f"DEBUG: Erro ao preservar valores das barras: {e}")
        
        # CORREÇÃO CRÍTICA: Usar estado salvo da dashboard em vez de verificar widgets atuais
        # Os widgets podem ter sido recriados ou removidos entre o salvamento do estado e o fullscreen
        botoes_plus_visiveis = {
            'rxd_visivel': False,
            'lost_visivel': False
        }
        botao_seta_visivel = False
        
        # Verificar se temos estado salvo da dashboard
        if hasattr(self, '_saved_dashboard_state'):
            state = self._saved_dashboard_state
            controles_estavam_visiveis = state.get('controles_gestao_visiveis', False)
            seta_estava_visivel = state.get('botao_seta_visivel', False)
            
            # NOVA LÓGICA: Usar flags específicas dos botões se disponíveis
            btn_plus_rxd_estava_visivel = state.get('btn_plus_rxd_visivel', False)
            btn_plus_lost_estava_visivel = state.get('btn_plus_lost_visivel', False)
            btn_seta_estava_visivel = state.get('btn_seta_visivel', False)
            
            print(f"DEBUG: [FULLSCREEN] Estado salvo da dashboard:")
            print(f"DEBUG: [FULLSCREEN]   controles_gestao_visiveis: {controles_estavam_visiveis}")
            print(f"DEBUG: [FULLSCREEN]   botao_seta_visivel: {seta_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_rxd_visivel: {btn_plus_rxd_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_plus_lost_visivel: {btn_plus_lost_estava_visivel}")
            print(f"DEBUG: [FULLSCREEN]   btn_seta_visivel: {btn_seta_estava_visivel}")
            
            # Priorizar flags específicas sobre flags genéricas
            if btn_plus_rxd_estava_visivel or btn_plus_lost_estava_visivel:
                botoes_plus_visiveis = {
                    'rxd_visivel': btn_plus_rxd_estava_visivel,
                    'lost_visivel': btn_plus_lost_estava_visivel
                }
                print(f"DEBUG: [FULLSCREEN] Usando flags específicas dos botões +")
            elif controles_estavam_visiveis:
                # Fallback para lógica anterior
                botoes_plus_visiveis = {
                    'rxd_visivel': True,
                    'lost_visivel': True
                }
                print(f"DEBUG: [FULLSCREEN] Usando flag genérica - assumindo ambos os botões + ativos")
            
            # Para botão seta, priorizar flag específica
            if btn_seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível (flag específica)")
            elif seta_estava_visivel:
                botao_seta_visivel = True
                print(f"DEBUG: [FULLSCREEN] Botão seta estava visível (flag genérica)")
        else:
            print(f"DEBUG: [FULLSCREEN] WARNING: Estado da dashboard não encontrado - usando detecção de widgets atual")
            # Fallback para detecção atual se não temos estado salvo
            botoes_plus_visiveis = {
                'rxd_visivel': hasattr(self, '_btn_plus_rxd') and self._btn_plus_rxd is not None and self._btn_plus_rxd.winfo_exists(),
                'lost_visivel': hasattr(self, '_btn_plus_lost') and self._btn_plus_lost is not None and self._btn_plus_lost.winfo_exists()
            }
            botao_seta_visivel = hasattr(self, '_btn_seta') and self._btn_seta is not None and self._btn_seta.winfo_exists()
        
        print(f"DEBUG: [FULLSCREEN] Estado FINAL dos botões + preservado: {botoes_plus_visiveis}")
        print(f"DEBUG: [FULLSCREEN] Estado FINAL do botão seta preservado: {botao_seta_visivel}")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X para fechar - canto superior esquerdo (cinza)
        def voltar_dashboard():
            print(f"DEBUG: [FULLSCREEN X] Iniciando retorno do fullscreen para dashboard")
            print(f"DEBUG: [FULLSCREEN X] Estado preservado: gestao_ativa={getattr(self, '_final_phase_gestao_ativa', False)}")
            
            # Preservar seleção da carta do carrossel ao voltar do fullscreen
            selected_carta = getattr(self, 'selected_carousel_card', None)
            selected_index = getattr(self, 'selected_carousel_index', None)
            
            print(f"DEBUG: [FULLSCREEN X] Recriando interface principal...")
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
            
            # Restaurar seleção da carta após recriar interface
            if selected_carta is not None and selected_index is not None:
                self.selected_carousel_card = selected_carta
                self.selected_carousel_index = selected_index
                print(f"DEBUG: [FULLSCREEN X] Seleção da carta restaurada: índice {selected_index}")
            
            # RESTAURAR ESTADO USANDO O SISTEMA NOVO DE CAPTURA IMEDIATA
            print(f"DEBUG: [FULLSCREEN X] Chamando _restore_dashboard_state()...")
            self._restore_dashboard_state()
            
            # Restaurar valores das barras de progresso após recriar interface
            if saved_progress_values and hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                for stat, values in saved_progress_values.items():
                    if stat in self.progress_bars and stat in self.progress_labels:
                        self.progress_bars[stat]['maximum'] = values['maximum']
                        self.progress_bars[stat]['value'] = values['value']
                        self.progress_labels[stat]['text'] = str(int(values['value']))
                print(f"DEBUG: [FULLSCREEN X] Valores das barras restaurados: {saved_progress_values}")
        x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_dashboard, cursor="hand2", activebackground="#CCCCCC")
        x_btn.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão Switch no canto superior direito com imagem switch_card.png
        # SÓ APARECE EM ACTIVITIES/CHALLENGES DURANTE NEXT PHASE (MAS NÃO DURANTE FINAL PHASE)
        # CORREÇÃO PROBLEMA 2: Verificar tipo da carta para restringir funcionalidade
        switch_btn = None
        
        # Verificar se é uma carta de Activity ou Challenge
        carta_name = os.path.basename(carta_path).lower()
        is_activity_or_challenge = ("activity" in carta_name or "challenge" in carta_name)
        is_activity_card = "activity" in carta_name
        is_challenge_card = "challenge" in carta_name
        next_phase_active = getattr(self, '_next_phase_active', False)
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICAÇÃO BOTÃO SWITCH ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] carta_name: {carta_name}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] final_phase_active: {final_phase_active}")
        
        # NOVA VERIFICAÇÃO: Verificar se há cartas disponíveis para troca no inventário
        has_available_cards_for_switch = False
        if is_activity_or_challenge and next_phase_active and not final_phase_active:
            # CORREÇÃO: Para Activities no carrossel, verificar se há outras Activities no inventário
            # Activity só pode trocar com Activity quando NÃO há Challenges no inventário
            if is_activity_card:
                activity_cards = self.inventario.get("activities", [])
                challenge_cards = self.inventario.get("challenges", [])
                # APLICAR MESMA RESTRIÇÃO: Activity NÃO pode trocar se há Challenges no inventário
                if len(challenge_cards) > 0:
                    has_available_cards_for_switch = False
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - NÃO pode trocar: há {len(challenge_cards)} Challenges no inventário (restrição Activity→Activity)")
                else:
                    has_available_cards_for_switch = len(activity_cards) > 0
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Activity - pode trocar: {len(activity_cards)} Activities no inventário, 0 Challenges")
            
            # CORREÇÃO CRÍTICA: Para Challenges no carrossel, verificar se há OUTRAS CHALLENGES no inventário
            # Challenge só pode trocar com outra Challenge
            elif is_challenge_card:
                challenge_cards = self.inventario.get("challenges", [])
                has_available_cards_for_switch = len(challenge_cards) > 0
                print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge card - Challenges no inventário: {len(challenge_cards)}, pode trocar: {has_available_cards_for_switch}")
        
        # RESTRIÇÃO: No Next Phase, só Activities podem ser trocadas (Challenges não)
        # Challenges no carrossel devem ser apenas visualizadas, não trocadas
        # MODIFICAÇÃO: Mostrar switch para Challenges também, mas com funcionalidade limitada
        # NOVA RESTRIÇÃO: Só mostrar switch se há cartas disponíveis para troca
        should_show_switch = (is_activity_or_challenge and next_phase_active and 
                            not final_phase_active and has_available_cards_for_switch)
        
        print(f"DEBUG: [CARROSSEL FULLSCREEN] has_available_cards_for_switch: {has_available_cards_for_switch}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] should_show_switch: {should_show_switch}")
        
        # Durante Final Phase, não mostrar botão Switch
        # Durante Next Phase, só mostrar para Activities (não para Challenges)
        if should_show_switch:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    switch_btn = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    switch_btn.image = switch_img  # Manter referência
                    
                    # NOVA FUNCIONALIDADE: Mover switch para canto inferior direito se é Challenge (máximo canto)
                    if is_challenge_card:
                        switch_btn.place(relx=1.0, rely=1.0, anchor="se")  # Canto inferior direito (máximo canto possível)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Botão Switch posicionado no canto inferior direito (Challenge - máximo canto)")
                    else:
                        switch_btn.place(relx=0.98, rely=0, anchor="ne")  # Canto superior direito (Activity)
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Botão Switch posicionado no canto superior direito (Activity)")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - imagem switch_card.png não encontrada em {switch_img_path}")
            except Exception as e:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - erro ao carregar imagem: {e}")
        else:
            if not has_available_cards_for_switch:
                if is_challenge_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - Não há Activities no inventário para trocar")
                elif is_activity_card:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - Não há Challenges no inventário para trocar")
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - Carta não é Activity nem Challenge")
            elif is_challenge_card and next_phase_active:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - Challenge não pode ser trocada no Next Phase")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] ERROR: Botão Switch NÃO criado - condições não atendidas")
        
        # Configurar comando do botão Switch (abrir inventário para troca)
        def abrir_inventario_troca():
            # CORREÇÃO PROBLEMA 2: Verificações de segurança adicionais
            print(f"DEBUG: [abrir_inventario_troca] Iniciando verificações para carta: {os.path.basename(carta_path)}")
            
            # Verificar se a carta atual não é uma carta virada para baixo
            if "back_card" in os.path.basename(carta_path).lower():
                print("DEBUG: [abrir_inventario_troca] ERROR: Não é possível trocar uma carta virada para baixo")
                return
            
            # NOVA VERIFICAÇÃO: Só permitir troca se for Activity
            carta_basename = os.path.basename(carta_path).lower()
            if "challenge" in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ERROR: Challenges do carrossel não podem ser trocadas no Next Phase")
                return
            
            if "activity" not in carta_basename:
                print("DEBUG: [abrir_inventario_troca] ERROR: Só Activities podem ser trocadas")
                return
            
            # Verificar se Next Phase está ativo
            if not getattr(self, '_next_phase_active', False):
                print("DEBUG: [abrir_inventario_troca] ERROR: Troca só permitida durante Next Phase")
                return
            
            print(f"DEBUG: [abrir_inventario_troca] SUCCESS: Verificações passaram - abrindo inventário para troca")
            
            # Guardar a carta atual do carrossel para troca
            self.carta_carrossel_para_troca = carta_path
            # Encontrar o índice da carta no carrossel
            try:
                self.carrossel_idx_selecao = self.cards.index(carta_path)
                print(f"DEBUG: [abrir_inventario_troca] Carta encontrada no carrossel índice: {self.carrossel_idx_selecao}")
            except ValueError:
                print(f"DEBUG: [abrir_inventario_troca] WARNING:  Carta não encontrada no carrossel - usando índice 0")
                self.carrossel_idx_selecao = 0
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        
        if switch_btn is not None:
            switch_btn.config(command=abrir_inventario_troca)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Botão Switch configurado para abrir inventário de troca")
        
        # NOVA FUNCIONALIDADE: Botão Quit Challenge (canto superior direito, vermelho com unicode ✓)
        # CORREÇÃO: Se Challenge na Final Phase, mostrar botão completion em vez de quit
        quit_btn = None
        
        # Verificar se Challenge atingiu Final Phase (n_turns completos)
        challenge_na_final_phase = False
        if is_challenge_card:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge detectado - verificando Final Phase")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] === ESTADO COMPLETO DO SISTEMA ===")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge path: {carta_path}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge basename: {os.path.basename(carta_path)}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _current_turn_number: {self._current_turn_number}")
            print(f"DEBUG: [CARROSSEL FULLSCREEN] _challenge_start_turns: {self._challenge_start_turns}")
            
            # Obter dados da carta Challenge
            dados_carta = self._obter_dados_carta(carta_path)
            print(f"DEBUG: [CARROSSEL FULLSCREEN] dados_carta retornados: {dados_carta}")
            
            if dados_carta:
                n_turns = dados_carta.get('n_turns', 0)
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns da carta extraído: {n_turns}")
                print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns tipo: {type(n_turns)}")
                
                if n_turns > 0:
                    # Verificar quantos turnos passaram desde que foi ativada
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === CALCULANDO TURNOS DECORRIDOS ===")
                    turns_elapsed = self._get_turns_elapsed_for_challenge(carta_path)
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed retornado: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed tipo: {type(turns_elapsed)}")
                    
                    # COMPARAÇÃO CRÍTICA
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === COMPARAÇÃO CRÍTICA ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed >= n_turns: {turns_elapsed >= n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed > 1: {turns_elapsed > 1}")
                    
                    # CORREÇÃO: Overlay só aparece quando completar n_turns E não estar no turno de ativação
                    challenge_na_final_phase = (turns_elapsed >= n_turns) and (turns_elapsed > 1)
                    
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] === VERIFICAÇÃO FINAL PHASE CHALLENGE ===")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge: {os.path.basename(carta_path)}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] n_turns limite: {n_turns}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] turns_elapsed: {turns_elapsed}")
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase (calculado): {challenge_na_final_phase}")
                    
                    # DETALHES ADICIONAIS PARA DEBUG
                    if carta_path in self._challenge_start_turns:
                        start_turn = self._challenge_start_turns[carta_path]
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Registo encontrado - Start turn: {start_turn}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Cálculo: {self._current_turn_number} - {start_turn} + 1 = {turns_elapsed}")
                    else:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] WARNING: SEM REGISTO DE INÍCIO - usando turno padrão")
                    
                    # EXEMPLOS ESPECÍFICOS PARA DEBUG
                    if "Challenge_12" in os.path.basename(carta_path) and n_turns == 2:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_12 (n_turns=2) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 2")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Está na Final Phase? {challenge_na_final_phase}")
                    
                    if "Challenge_13" in os.path.basename(carta_path) and n_turns == 4:
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] === EXEMPLO Challenge_13 (n_turns=4) ===")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Aceito no turno: {self._challenge_start_turns.get(carta_path, 'SEM REGISTO')}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Turno atual: {self._current_turn_number}")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Deve estar na Final Phase a partir do turno 4")
                        print(f"DEBUG: [CARROSSEL FULLSCREEN] Está na Final Phase? {challenge_na_final_phase}")
                    
                else:
                    print(f"DEBUG: [CARROSSEL FULLSCREEN] Challenge sem n_turns válido ({n_turns})")
            else:
                print(f"DEBUG: [CARROSSEL FULLSCREEN] Não foi possível obter dados da carta Challenge")
        else:
            print(f"DEBUG: [CARROSSEL FULLSCREEN] Não é uma carta Challenge")
        
        # CORREÇÃO: Remover completamente todos os botões Challenge no fullscreen
        # Os botões roxos (→) foram removidos conforme solicitado pelo utilizador
        print(f"DEBUG: [CARROSSEL FULLSCREEN] === BOTÕES CHALLENGE REMOVIDOS ===")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] challenge_na_final_phase: {challenge_na_final_phase}")
        print(f"DEBUG: [CARROSSEL FULLSCREEN] SUCCESS: Todos os botões Challenge foram removidos do fullscreen")

    # --- Carrossel: começa vazio e só adiciona Activities/Challenges aceites ---
    def adicionar_carta_carrossel(self, carta_path, carta_tipo):
        # CORREÇÃO CRÍTICA: Remover duplo registo de Challenge
        # O tracking do Challenge já foi feito em aceitar_carta_challenge_activity
        # Este método deve apenas adicionar ao carrossel visual, não registar novamente
        
        # Inicializar carrossel se não existir
        if not hasattr(self, 'carrossel'):
            self.carrossel = []
            print("DEBUG: [CARROSSEL] self.carrossel inicializado como lista vazia")
        
        if carta_tipo in ["activities", "challenges"] and carta_path not in self.carrossel:
            self.carrossel.append(carta_path)
            print(f"DEBUG: [CARROSSEL] Carta adicionada à lista: {os.path.basename(carta_path)}")
            
            # CORREÇÃO: Reset dos valores quando carta é adicionada ao carrossel
            posicao_carrossel = len(self.carrossel) - 1  # Última posição adicionada
            self._reset_card_values_on_activation(carta_path, posicao_carrossel)
            
            # CORREÇÃO CRÍTICA: NÃO registar Challenge novamente aqui!
            # O tracking já foi feito em aceitar_carta_challenge_activity
            if carta_tipo == "challenges":
                print(f"DEBUG: [CARROSSEL] Challenge {os.path.basename(carta_path)} TRACKING JÁ FEITO - não registar novamente")
                print(f"DEBUG: [CARROSSEL] Tracking atual: {self._challenge_start_turns}")
            
            self.atualizar_carrossel()

    def atualizar_carrossel(self):
        # Atualiza o carrossel para mostrar apenas as cartas em self.carrossel
        # (Implementação depende do teu método atual, mas deve usar self.carrossel)
        pass

    # No método onde o jogador aceita uma carta de Activities ou Challenges:
    # Chamar self.adicionar_carta_carrossel(carta_path, carta_tipo)
    
    def _check_user_inventory_for_carousel_access(self):
        """
        Verifica que User IDs o jogador tem no inventário e se estão virados para cima (ativos ou visíveis).
        User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
        Durante Next Phase, só conta cartas User que estejam viradas para cima.
        """
        user_ids = []
        user_cards = self.inventario.get("users", [])
        next_phase_active = getattr(self, '_next_phase_active', False)
        
        for carta_path in user_cards:
            carta_name = os.path.basename(carta_path)
            if carta_name.startswith("User_") and carta_name.endswith(".png"):
                try:
                    # Extrair número do nome: User_2.png -> 2
                    numero_str = carta_name.replace("User_", "").replace(".png", "")
                    numero = int(numero_str)
                    
                    # Verificar se a carta está virada para cima
                    is_face_up = False
                    if numero == 1:
                        # User_1.png sempre virada para cima
                        is_face_up = True
                    elif next_phase_active:
                        # Durante Next Phase, verificar se a carta está ativa (virada para cima)
                        is_face_up = self.is_card_active(carta_path, "users")
                    else:
                        # Antes de Next Phase, todas as cartas (exceto User_1) estão viradas para baixo
                        is_face_up = False
                    
                    # Só adicionar à lista se estiver virada para cima
                    if is_face_up:
                        # User_2.png corresponde ao User ID 1, User_3.png ao User ID 2, etc.
                        user_id = numero - 1
                        if user_id >= 1:  # User ID começa em 1
                            user_ids.append(user_id)
                            print(f"DEBUG: User_{numero}.png ATIVO - User ID {user_id} disponível para carrossel")
                    else:
                        print(f"DEBUG: User_{numero}.png INATIVO - User ID não disponível para carrossel")
                        
                except (ValueError, IndexError):
                    continue
        
        # Cache dos User IDs para performance
        self._cached_user_ids = sorted(user_ids)
        print(f"DEBUG: User IDs ativos/visíveis encontrados no inventário: {self._cached_user_ids}")
        return self._cached_user_ids
    
    def _can_access_carousel_position(self, carrossel_idx):
        """
        Verifica se o jogador pode aceder a uma posição específica do carrossel durante Next Phase.
        Só pode clicar numa carta virada para baixo se tiver o User ID correspondente.
        Posição 0 (primeira carta da esquerda) requer User ID 1, posição 1 requer User ID 2, etc.
        """
        if not getattr(self, '_next_phase_active', False):
            # Se Next Phase não está ativo, pode aceder a qualquer posição
            return True
        
        # Durante Next Phase, verificar se tem o User ID necessário
        required_user_id = carrossel_idx + 1  # Posição 0 -> User ID 1, posição 1 -> User ID 2, etc.
        user_ids = self._check_user_inventory_for_carousel_access()
        
        can_access = required_user_id in user_ids
        print(f"DEBUG: Posição {carrossel_idx} requer User ID {required_user_id}, tem acesso: {can_access}")
        return can_access
    
    def _has_valid_carousel_positions(self):
        """
        Verifica se há posições válidas no carrossel onde o jogador pode colocar cartas.
        Durante Next Phase, só pode colocar cartas em posições que correspondem a User IDs ativos.
        """
        next_phase_active = getattr(self, '_next_phase_active', False)
        print(f"DEBUG: [_has_valid_carousel_positions] === INICIANDO VERIFICAÇÃO ===")
        print(f"DEBUG: [_has_valid_carousel_positions] Next Phase ativo: {next_phase_active}")
        
        if not next_phase_active:
            # Se Next Phase não está ativo, sempre pode colocar cartas
            print(f"DEBUG: [_has_valid_carousel_positions] Next Phase INATIVO - retornando True")
            return True
        
        # Durante Next Phase, verificar se há pelo menos uma posição acessível
        user_ids = self._check_user_inventory_for_carousel_access()
        print(f"DEBUG: [_has_valid_carousel_positions] User IDs disponíveis: {user_ids}")
        
        # Verificar se há cartas viradas para baixo em posições com User IDs correspondentes
        valid_positions_found = False
        for i, carta_path in enumerate(self.cards):
            carta_basename = os.path.basename(carta_path)
            is_back_card = carta_basename.startswith("back_card_")
            required_user_id = i + 1  # Posição 0 -> User ID 1, etc.
            has_user_id = required_user_id in user_ids
            
            print(f"DEBUG: [_has_valid_carousel_positions] Pos {i}: '{carta_basename}' -> back_card: {is_back_card}, req_user_id: {required_user_id}, has_user: {has_user_id}")
            
            if is_back_card and has_user_id:
                print(f"DEBUG: [_has_valid_carousel_positions] SUCCESS: Posição {i} VÁLIDA para User ID {required_user_id}")
                valid_positions_found = True
        
        if not valid_positions_found:
            print("DEBUG: [_has_valid_carousel_positions] ERROR: NENHUMA posição válida no carrossel")
        
        print(f"DEBUG: [_has_valid_carousel_positions] === RESULTADO: {valid_positions_found} ===")
        return valid_positions_found
    
    def _teste_adicionar_user_cards(self):
        """
        Função de teste para adicionar cartas User/Equipment/Service ao inventário para testar o sistema de ativação.
        Esta função pode ser removida em produção.
        """
        # Simular caminhos de cartas para teste (usar a cor do player)
        color_name = self.player_color.capitalize()  # Red, Blue, Green, Yellow
        
        test_cards = {
            "users": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_2.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Users/Residential-level/{color_name}/User_3.png",
            ],
            "equipments": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Equipments/Residential-level/{color_name}/Equipment_2.png",
            ],
            "services": [
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_1.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_2.png",
                f"/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster/Services/Residential-level/{color_name}/Service_5.png",
            ]
        }
        
        # Adicionar ao inventário para teste
        for card_type, card_paths in test_cards.items():
            for carta_path in card_paths:
                if os.path.exists(carta_path) and carta_path not in self.inventario[card_type]:
                    self.inventario[card_type].append(carta_path)
                    print(f"DEBUG: [TESTE] Carta {card_type} adicionada ao inventário: {os.path.basename(carta_path)}")
        
        # Atualizar cache e destaques se necessário
        self._check_user_inventory_for_carousel_access()
        # IMPORTANTE: Só atualizar destaques se estivermos na interface principal e Next Phase estiver ativo
        # Evita erro de widgets destruídos durante transições
        if (getattr(self, '_next_phase_active', False) and 
            hasattr(self, 'card_labels') and 
            self.card_labels and 
            not getattr(self, '_inventory_opening', False)):
            try:
                self._update_carousel_highlights()
            except Exception as e:
                print(f"DEBUG: [TESTE] Erro ao atualizar destaques do carrossel: {e}")
        
        print(f"DEBUG: [TESTE] Inventário atual após adicionar cartas de teste:")
        for tipo, cartas in self.inventario.items():
            if cartas:
                print(f"DEBUG: [TESTE]   {tipo}: {len(cartas)} cartas")
                for carta in cartas[:3]:  # Mostrar primeiras 3
                    print(f"DEBUG: [TESTE]     - {os.path.basename(carta)}")
        
        print(f"DEBUG: [TESTE] Estado inicial das cartas ativas:")
        print(f"DEBUG: [TESTE]   Users ativos: {[os.path.basename(c) for c in self.active_users]} (máx: {self.max_users})")
        print(f"DEBUG: [TESTE]   Equipments ativos: {[os.path.basename(c) for c in self.active_equipments]} (sem limite)")
        print(f"DEBUG: [TESTE]   Services ativos: {[os.path.basename(c) for c in self.active_services]} (sem limite)")
        print(f"DEBUG: [TESTE] NOTA: Ativação só funciona após clicar 'Next Phase'")
        print(f"DEBUG: [TESTE] Inventário Users atual: {[os.path.basename(c) for c in self.inventario['users']]}")
    
    def _update_carousel_highlights(self):
        """
        Atualiza os destaques roxos das cartas do carrossel baseado nos User IDs disponíveis.
        Chama esta função quando Next Phase é ativado ou quando o inventário de Users muda.
        """
        if not hasattr(self, 'card_labels') or not self.card_labels:
            print("DEBUG: _update_carousel_highlights - card_labels não existe ou está vazio, saltando atualização")
            return
        
        # Usar a função de seleção que já inclui a lógica de User IDs
        self._update_carousel_selection_highlights()
    
    def _debug_force_highlight_update(self):
        """
        Função de debug para forçar atualização dos destaques do carrossel.
        Útil para testar o sistema manualmente.
        """
        print("DEBUG: [FORÇA] Forçando atualização dos destaques do carrossel...")
        self._check_user_inventory_for_carousel_access()
        self._update_carousel_highlights()
        print("DEBUG: [FORÇA] Atualização dos destaques concluída")



    def abrir_inventario_para_carrossel(self, carrossel_idx):
        # Verificar se estamos numa casa onde podemos vender Activities ou Challenges
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # PROTEÇÃO CONTRA LOOP: Se já estamos a mostrar inventário, não abrir novamente
        if getattr(self, '_inventory_opening', False):
            return
        
        # BLOQUEIO DURANTE FINAL PHASE: Não permite abrir inventário
        if getattr(self, '_final_phase_active', False):
            print(f"DEBUG: Abertura de inventário BLOQUEADA durante Final Phase")
            return
        
        # CONTROLO DE ACESSO DURANTE NEXT PHASE
        if getattr(self, '_next_phase_active', False):
            if not self._can_access_carousel_position(carrossel_idx):
                print(f"DEBUG: Acesso negado à posição {carrossel_idx} do carrossel durante Next Phase")
                return
        
        # IMPORTANTE: Se Next Phase está ativo, sempre abrir inventário no modo Next Phase
        if getattr(self, '_next_phase_active', False):
            print("DEBUG: Next Phase ativo - abrindo inventário no modo Next Phase")
            # Abre o inventário de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])
        # Se estivermos numa casa Activities ou Challenges E Next Phase NÃO está ativo, mostrar inventário para venda
        elif casa_atual_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Em casa {casa_atual_tipo} - abrindo inventário para venda (Activities + Challenges)")
            self.show_inventory_matrix(["activities", "challenges"], page=0)
        else:
            # CORREÇÃO: Sempre permitir acesso a Activities/Challenges para cartas viradas para baixo
            # mesmo que não esteja numa casa Activities/Challenges - o controlo de venda é feito dentro do inventário
            print("DEBUG: Abrindo inventário Activities/Challenges - acesso sempre permitido para cartas viradas para baixo")
            
            # NOVA RESTRIÇÃO: Verificar se é tentativa de trocar Activity ativa por outra Activity
            carta_atual_carrossel = self.cards[carrossel_idx] if carrossel_idx < len(self.cards) else None
            
            if (carta_atual_carrossel and 
                "Activity" in os.path.basename(carta_atual_carrossel) and 
                len(self.inventario.get('challenges', [])) > 0):
                
                print("DEBUG: RESTRIÇÃO: Não é possível trocar Activity ativa enquanto houver Challenges no inventário")
                self._mostrar_mensagem_restricao_activity()
                return
            
            # Abre o inventário de Activities/Challenges para escolher carta para o carrossel
            self.carrossel_idx_selecao = carrossel_idx
            self.show_inventory_matrix_carrossel(["activities", "challenges"])

    def show_inventory_matrix_carrossel(self, tipos, page=0):
        print(f"DEBUG: show_inventory_matrix_carrossel chamado - tipos: {tipos}, page: {page}")
        
        # PROTEÇÃO CONTRA LOOP: Marcar que estamos a abrir inventário
        self._inventory_opening = True
        
        # Inventário em grelha 2x2 com navegação por páginas
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no carrossel")
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        name_lbl = tk.Label(self, text=self.player_name, font=("Helvetica", 18, "bold"), bg=self.bar_color, fg="black", borderwidth=0)
        name_lbl.place(relx=0.5, y=25, anchor="n")
        if len(tipos) == 1:
            title_str = tipos[0].capitalize()
        else:
            title_str = "Activities / Challenges"
        title = tk.Label(self, text=title_str, font=("Helvetica", 22, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # VERIFICAR SE É ACTIVITIES/CHALLENGES PARA LAYOUT ESPECIAL EM COLUNAS
        if set(tipos) == set(["activities", "challenges"]):
            print("DEBUG: Activities/Challenges detectado - usando layout em colunas")
            
            # Separar cartas por tipo
            cartas_activities = self.inventario.get("activities", [])
            cartas_challenges = self.inventario.get("challenges", [])
            print(f"DEBUG: Activities: {len(cartas_activities)} cartas, Challenges: {len(cartas_challenges)} cartas")
            
            # Paginação baseada no maior número de cartas de qualquer tipo
            max_cards = max(len(cartas_activities), len(cartas_challenges))
            cards_per_page = 2  # 2 linhas, 1 carta de cada tipo por linha
            total_pages = max(1, (max_cards + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            card_w, card_h = 85, 120
            
            # Configurar colunas do grid
            matriz_frame.grid_columnconfigure(0, weight=1, minsize=card_w + 16)  # Coluna Activities
            matriz_frame.grid_columnconfigure(1, weight=1, minsize=card_w + 16)  # Coluna Challenges
            
            # Colocar Activities na coluna 0 (esquerda)
            activities_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_activities))):
                carta_path = cartas_activities[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=activities_row, column=0, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Activity configurada para modo Next Phase na posição ({activities_row}, 0): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Activity adicionada na posição ({activities_row}, 0): {os.path.basename(carta_path)}")
                    
                    activities_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Activity {carta_path}")
                    continue
            
            # Colocar Challenges na coluna 1 (direita)
            challenges_row = 0
            for i in range(start_idx, min(end_idx, len(cartas_challenges))):
                carta_path = cartas_challenges[i]
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                    carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                    carta_lbl.image = img  # type: ignore[attr-defined]
                    carta_lbl.grid(row=challenges_row, column=1, padx=8, pady=8)
                    
                    # Configurar comportamento baseado no modo
                    if getattr(self, '_next_phase_active', False):
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                        print(f"DEBUG: Challenge configurado para modo Next Phase na posição ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    else:
                        carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                        print(f"DEBUG: Challenge adicionado na posição ({challenges_row}, 1): {os.path.basename(carta_path)}")
                    
                    challenges_row += 1
                except Exception:
                    print(f"DEBUG: Erro ao carregar Challenge {carta_path}")
                    continue
            
            # Se não há cartas em nenhuma das colunas
            if activities_row == 0 and challenges_row == 0:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.grid(row=0, column=0, columnspan=2, pady=20)
                print("DEBUG: Nenhuma carta de Activities/Challenges - adicionado label 'Sem cartas disponíveis!'")
            
        else:
            # Layout normal para outros tipos (comportamento original)
            cartas = []
            for t in tipos:
                cartas += self.inventario.get(t, [])
            print(f"DEBUG: Cartas encontradas no inventário: {len(cartas)} cartas")
            
            # Paginação
            cards_per_page = 4
            total_pages = max(1, (len(cartas) + cards_per_page - 1) // cards_per_page)
            page = max(0, min(page, total_pages - 1))
            start_idx = page * cards_per_page
            end_idx = start_idx + cards_per_page
            cartas_page = cartas[start_idx:end_idx]
            print(f"DEBUG: Página {page}/{total_pages-1}, mostrando cartas {start_idx} a {end_idx-1}, cartas na página: {len(cartas_page)}")
            
            matriz_frame = tk.Frame(self, bg="black")
            matriz_frame.place(relx=0.5, rely=0.5, anchor="center")
            n_col = 2
            card_w, card_h = 85, 120  # Reduzido para não tapar o título
            
            for idx, carta_path in enumerate(cartas_page):
                row = idx // n_col
                col = idx % n_col
                try:
                    img = ImageTk.PhotoImage(Image.open(carta_path).resize((card_w, card_h)))
                except Exception:
                    print(f"DEBUG: Erro ao carregar carta {carta_path}")
                    continue
                carta_lbl = tk.Label(matriz_frame, image=img, bg="black", cursor="hand2")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=row, column=col, padx=8, pady=8)
                
                # Verificar se Next Phase está ativo para comportamento especial
                if getattr(self, '_next_phase_active', False):
                    # No modo Next Phase, primeira carta clicada vai direto para fullscreen com X e ✔
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_next_phase_selection(p, t, pg))
                    print(f"DEBUG: Carta {idx} configurada para modo Next Phase na posição ({row}, {col}): {os.path.basename(carta_path)}")
                else:
                    # Comportamento normal - ir para seleção do carrossel
                    carta_lbl.bind("<Button-1>", lambda e, p=carta_path, t=tipos, pg=page: self.show_card_fullscreen_carrossel_selecao(p, t, pg))
                    print(f"DEBUG: Carta {idx} adicionada na posição ({row}, {col}): {os.path.basename(carta_path)}")
            
            if not cartas_page:
                no_cards_lbl = tk.Label(matriz_frame, text="Sem cartas disponíveis!", font=("Helvetica", 16), bg="black", fg="white")
                no_cards_lbl.pack(pady=20)
                print("DEBUG: Nenhuma carta na página - adicionado label 'Sem cartas disponíveis!'")
        
        # Setas de navegação
        if total_pages > 1:
            # Coordenadas para alinhar as setas à direita da grelha de cartas
            # Assume que a grelha está centrada em relx=0.5, então relx=0.85 fica à direita
            seta_x = 0.90
            # Seta para cima (▲) - parte superior direita da grelha
            if page > 0:
                seta_cima = tk.Button(self, text="▲", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page-1))
                seta_cima.place(relx=seta_x, rely=0.38, anchor="center")
                print("DEBUG: Seta para cima adicionada")
            # Seta para baixo (▼) - parte inferior direita da grelha
            if page < total_pages - 1:
                seta_baixo = tk.Button(self, text="▼", font=("Helvetica", 18, "bold"), bg="#222", fg="white", width=2, command=lambda: self.show_inventory_matrix_carrossel(tipos, page+1))
                seta_baixo.place(relx=seta_x, rely=0.62, anchor="center")
                print("DEBUG: Seta para baixo adicionada")
        
        # Adicionar barra inferior com imagem BelowBar_X.png (onde X é a cor do jogador)
        try:
            belowbar_img_path = os.path.join(IMG_DIR, f"BelowBar_{self.player_color.lower()}.png")
            belowbar_img = ImageTk.PhotoImage(Image.open(belowbar_img_path).resize((screen_width, 50)))
            belowbar_label = tk.Label(self, image=belowbar_img, bg="black")
            belowbar_label.image = belowbar_img  # type: ignore[attr-defined]
            belowbar_label.pack(side="bottom", fill="x")
            print(f"DEBUG: Barra inferior BelowBar_{self.player_color.lower()}.png carregada com sucesso")
        except Exception as e:
            print(f"DEBUG: Erro ao carregar BelowBar_{self.player_color.lower()}.png: {e}")
            # Fallback: criar uma barra colorida se a imagem não existir
            belowbar_frame = tk.Frame(self, bg=self.bar_color, height=50)
            belowbar_frame.pack(side="bottom", fill="x")
            belowbar_frame.pack_propagate(False)

        # Botão Back centrado na parte inferior - criado após a barra para ficar por cima
        def back_to_dashboard_carrossel():
            # PROTEÇÃO CONTRA LOOP: Limpar flag antes de voltar ao dashboard
            self._inventory_opening = False
            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
        back_btn = tk.Button(self, text="Back", font=("Helvetica", 14, "bold"), bg="#808080", fg="white", width=6, command=back_to_dashboard_carrossel)
        back_btn.place(relx=0.5, rely=0.98, anchor="s")

        # Saldo no canto inferior direito - criado após para ficar por cima
        self.after(100, lambda: self.create_coin_saldo_overlay(screen_width, screen_height, self.saldo))
        
        print(f"DEBUG: show_inventory_matrix_carrossel terminado com sucesso")

    def show_card_fullscreen_carrossel_selecao(self, carta_path, tipos, page=0):
        # Mostra carta em fullscreen com botões ✔ (aceitar) e ✖ (cancelar)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no fullscreen carrossel, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen carrossel")
        
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        # Botão ✖ canto superior esquerdo - volta para página de inventário
        def voltar_inventario():
            self.show_inventory_matrix_carrossel(tipos, page)
        btn_x = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        # Botão Switch canto superior direito (APENAS se NÃO for Activities vendável)
        # Para Activities vendáveis, o botão ✔ irá ocupar esta posição
        carta_tipo_temp = "challenges"  # Valor padrão
        if set(tipos) == set(["activities", "challenges"]):
            carta_basename = os.path.basename(carta_path).lower()
            if "activity" in carta_basename or "activities" in carta_basename:
                carta_tipo_temp = "activities"
            elif "challenge" in carta_basename or "challenges" in carta_basename:
                carta_tipo_temp = "challenges"
        
        # Verificar se é Activities vendável
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        if casa_atual_tipo == "equipment":
            casa_atual_tipo = "equipments"
        
        activities_vendavel = (carta_tipo_temp == "activities" and 
                              not getattr(self, '_next_phase_active', False) and 
                              casa_atual_tipo == "activities")
        
        # Só criar botão Switch se NÃO for Activities vendável E se Next Phase estiver ativo E com posições válidas
        next_phase_active = getattr(self, '_next_phase_active', False)
        has_valid_positions = self._has_valid_carousel_positions()
        
        print(f"DEBUG: [CARROSSEL] VERIFICAÇÃO SWITCH PRINCIPAL:")
        print(f"DEBUG: [CARROSSEL]   activities_vendavel: {activities_vendavel}")
        print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
        print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
        
        if not activities_vendavel and next_phase_active and has_valid_positions:
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_carrossel = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                    btn_switch_carrossel.image = switch_img  # Manter referência
                    btn_switch_carrossel.place(relx=0.98, rely=0, anchor="ne")
                    
                    # CORREÇÃO: Aplicar a mesma lógica de detecção de substituição
                    def switch_com_detecao_substituicao():
                        print("DEBUG: [CARROSSEL_SELECAO] Verificando se vai substituir carta no carrossel")
                        
                        # Detectar posição de destino
                        posicao_destino = self.carrossel_idx_selecao
                        if posicao_destino is None:
                            # Se não há seleção específica, usar primeira posição acessível
                            for i in range(len(self.cards)):
                                if self._can_access_carousel_position(i):
                                    posicao_destino = i
                                    break
                        
                        # Verificar se a posição de destino contém uma carta real (não back_card)
                        vai_substituir_carta = False
                        if posicao_destino is not None and posicao_destino < len(self.cards):
                            carta_na_posicao_destino = self.cards[posicao_destino]
                            vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                        
                        if vai_substituir_carta:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai substituir carta existente - mostrando overlay de confirmação")
                            self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                        else:
                            print("DEBUG: [CARROSSEL_SELECAO] Vai colocar em posição vazia - indo diretamente para aceitar carta")
                            self.aceitar_carta_carrossel(carta_path, tipos, page)
                    
                    btn_switch_carrossel.config(command=switch_com_detecao_substituicao)
                    print(f"DEBUG: [CARROSSEL] SUCCESS: Botão Switch principal CRIADO - condições atendidas")
                else:
                    btn_switch_carrossel = None
                    print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch principal NÃO criado - imagem não encontrada em {switch_img_path}")
            except Exception as e:
                btn_switch_carrossel = None
                print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch principal NÃO criado - erro ao carregar imagem: {e}")
        else:
            btn_switch_carrossel = None
            if activities_vendavel:
                print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch principal NÃO criado - Activities vendável irá usar posição para botão ✔")
            elif not next_phase_active:
                print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch principal NÃO criado - Next Phase NÃO ATIVO")
            elif not has_valid_positions:
                print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch principal NÃO criado - SEM posições válidas no carrossel")
        
        # Adicionar lógica de venda (igual ao show_card_fullscreen_inventory)
        pode_vender = False
        casa_atual_tipo = getattr(self, 'current_casa_tipo', 'neutral')
        
        # IMPORTANTE: Se Next Phase estiver ativo, NÃO pode vender nenhuma carta
        if getattr(self, '_next_phase_active', False):
            print(f"DEBUG: NÃO pode vender carta do carrossel - Next Phase está ativo (vendas desabilitadas)")
            pode_vender = False
        else:
            # Normalizar o tipo da casa atual (equipments vs equipment)
            if casa_atual_tipo == "equipment":
                casa_atual_tipo = "equipments"
            
            # Determinar o tipo da carta atual
            carta_tipo = None
            if len(tipos) == 1:
                carta_tipo = tipos[0]
            elif set(tipos) == set(["activities", "challenges"]):
                # Se é uma página Activities/Challenges, determinar tipo pela carta específica
                carta_basename = os.path.basename(carta_path).lower()
                if "activity" in carta_basename or "activities" in carta_basename:
                    carta_tipo = "activities"
                elif "challenge" in carta_basename or "challenges" in carta_basename:
                    carta_tipo = "challenges"
                else:
                    # Tentar determinar pelo caminho da pasta
                    carta_dirname = os.path.dirname(carta_path).lower()
                    if "activities" in carta_dirname:
                        carta_tipo = "activities"
                    elif "challenges" in carta_dirname:
                        carta_tipo = "challenges"
            
            print(f"DEBUG: Verificando possibilidade de venda carrossel - carta_tipo: {carta_tipo}, casa_atual_tipo: {casa_atual_tipo}")
            
            # Verificar se pode vender
            if carta_tipo in ["users", "equipments", "services"]:
                # Para estas cartas, precisa estar na casa do mesmo tipo
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
            elif carta_tipo in ["activities", "challenges"]:
                # Activities só podem ser vendidas numa casa Activities, Challenges só numa casa Challenges
                if casa_atual_tipo == carta_tipo:
                    pode_vender = True
        
        # Adicionar lógica de venda (igual ao show_card_fullscreen_inventory)
        # IMPORTANTE: Para Activities e Challenges, usar layout especial sem botão picoin verde
        if pode_vender and carta_tipo not in ["activities", "challenges"]:
            print(f"DEBUG: Pode vender carta {carta_tipo} do carrossel - está numa casa {casa_atual_tipo}")
            picoin_img = ImageTk.PhotoImage(Image.open(COIN_IMG).resize((48,48)))
            def abrir_confirm():
                # Guardar informações para navegação correta
                self._origem_venda = "carrossel"
                self._tipos_venda = tipos
                self._page_venda = page
                self._current_sell_page = page
                # CORREÇÃO: Se viemos de um inventário Activities/Challenges, guardar isso
                if set(tipos) == set(["activities", "challenges"]):
                    self._inventario_conjunto = True
                else:
                    self._inventario_conjunto = False
                print(f"DEBUG: Iniciando venda do carrossel - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
            btn_picoin = tk.Button(self, image=picoin_img, bg="#4CAF50", borderwidth=0, command=abrir_confirm, cursor="hand2")
            btn_picoin.image = picoin_img  # type: ignore[attr-defined]
            btn_picoin.place(relx=0, rely=1, anchor="sw")
        elif pode_vender and carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: Carta {carta_tipo} pode ser vendida mas usa layout especial - botão ✔ já configurado acima")
        else:
            print(f"DEBUG: NÃO pode vender carta {carta_tipo} do carrossel - casa atual: {casa_atual_tipo}, necessário: {carta_tipo}")
        
        # Para Activities e Challenges no carrossel, aplicar layout especial similar ao inventário
        if carta_tipo in ["activities", "challenges"]:
            print(f"DEBUG: [CARROSSEL] Processando carta tipo {carta_tipo} - pode_vender: {pode_vender}")
            
            # Para Activities que podem ser vendidas, reconfigurar o botão Switch para venda
            if carta_tipo == "activities" and pode_vender:
                # Substituir comando do botão Switch para abrir venda em vez de aceitar para carrossel
                def abrir_confirm_activities():
                    # Limpar estado anterior e guardar informações para navegação correta
                    self._origem_venda = "carrossel"
                    self._tipos_venda = tipos
                    self._page_venda = page
                    self._current_sell_page = page
                    # Se viemos de um inventário Activities/Challenges, guardar isso
                    if set(tipos) == set(["activities", "challenges"]):
                        self._inventario_conjunto = True
                    else:
                        self._inventario_conjunto = False
                    print(f"DEBUG: [CARROSSEL] Iniciando venda Activities - carta_tipo: {carta_tipo}, inventario_conjunto: {getattr(self, '_inventario_conjunto', False)}, page: {page}")
                    self.show_sell_confirmation(carta_path, carta_tipo, store_window=None)
                
                # Criar botão de venda adicional (✔) para Activities vendáveis na mesma posição padrão
                btn_venda_activities = tk.Button(self, text="✔", font=("Helvetica", 24, "bold"), bg="#4CAF50", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#43d17a")
                btn_venda_activities.place(relx=0.98, rely=0, anchor="ne")  # Posição consistente com inventário
                btn_venda_activities.config(command=abrir_confirm_activities)
                print(f"DEBUG: [CARROSSEL] Botão ✔ criado para venda de Activities na posição padrão")
                
                # Reposicionar botão Switch para baixo para não conflitar
                # IMPORTANTE: SÓ APARECE DURANTE NEXT PHASE E COM POSIÇÕES VÁLIDAS
                next_phase_active = getattr(self, '_next_phase_active', False)
                has_valid_positions = self._has_valid_carousel_positions()
                
                print(f"DEBUG: [CARROSSEL] VERIFICAÇÃO SWITCH ADICIONAL (Activities):")
                print(f"DEBUG: [CARROSSEL]   next_phase_active: {next_phase_active}")
                print(f"DEBUG: [CARROSSEL]   has_valid_positions: {has_valid_positions}")
                
                if next_phase_active and has_valid_positions:
                    try:
                        switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                        if os.path.exists(switch_img_path):
                            switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                            btn_switch_adicional = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900")
                            btn_switch_adicional.image = switch_img  # Manter referência
                            btn_switch_adicional.place(relx=1, rely=1, anchor="se")
                            print(f"DEBUG: [CARROSSEL] SUCCESS: Botão Switch adicional CRIADO - Next Phase ativo + posições válidas")
                        else:
                            btn_switch_adicional = None
                            print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch adicional NÃO criado - imagem não encontrada em {switch_img_path}")
                    except Exception as e:
                        btn_switch_adicional = None
                        print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch adicional NÃO criado - erro ao carregar imagem: {e}")
                else:
                    btn_switch_adicional = None
                    if not next_phase_active:
                        print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch adicional NÃO criado - Next Phase NÃO ATIVO")
                    elif not has_valid_positions:
                        print(f"DEBUG: [CARROSSEL] ERROR: Botão Switch adicional NÃO criado - SEM posições válidas no carrossel")
                
                def switch_action():
                    # CORREÇÃO: Aplicar a mesma lógica de detecção de progresso
                    print("DEBUG: [CARROSSEL] Verificando progresso do carrossel para Switch adicional")
                    
                    # Verificar se temos cartas ativas no carrossel com progresso
                    carrossel_tem_progresso = False
                    if hasattr(self, 'cards') and hasattr(self, 'card_stats'):
                        for i, carta_carrossel in enumerate(self.cards):
                            if not os.path.basename(carta_carrossel).startswith("back_card_"):
                                # Há carta ativa no carrossel - verificar se tem progresso
                                if i < len(self.card_stats):
                                    stats = self.card_stats[i]
                                    if stats.get('To send', 0) > 0 or stats.get('Rxd', 0) > 0 or stats.get('Lost', 0) > 0:
                                        carrossel_tem_progresso = True
                                        break
                    
                    if carrossel_tem_progresso:
                        print("DEBUG: [CARROSSEL] Carrossel tem progresso - mostrando overlay de confirmação")
                        self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                    else:
                        print("DEBUG: [CARROSSEL] Carrossel sem progresso - indo diretamente para aceitar carta")
                        self.aceitar_carta_carrossel(carta_path, tipos, page)
                
                if btn_switch_adicional is not None:
                    btn_switch_adicional.config(command=switch_action)
                    print(f"DEBUG: [CARROSSEL] Botão Switch adicional configurado para Activities")
            
            # Para Challenges ou Activities que não podem ser vendidas, manter comportamento original do Switch
            elif carta_tipo == "challenges" or (carta_tipo == "activities" and not pode_vender):
                print(f"DEBUG: [CARROSSEL] Botão Switch mantém comportamento original para {carta_tipo} (aceitar no carrossel)")
        
        # BOTÃO QUIT CHALLENGE (apenas para Challenges ANTES de Next Phase) - INVENTÁRIO
        if carta_tipo == "challenges" and not getattr(self, '_next_phase_active', False):
            print(f"DEBUG: [CARROSSEL_INVENTARIO] Criando botão Quit Challenge no canto superior direito")
            
            # Botão vermelho com símbolo de check (✓) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            
            # Posição específica para inventário - verificar se há botão Switch no canto superior direito
            if btn_switch_carrossel is not None:
                # Se há botão Switch, posicionar o quit Challenge ligeiramente abaixo
                btn_quit_challenge.place(relx=0.98, rely=0.08, anchor="ne")
            else:
                # Se não há botão Switch, posicionar no canto superior direito
                btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do botão quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE_INVENTARIO] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [CARROSSEL_INVENTARIO] SUCCESS: Botão Quit Challenge criado no canto superior direito")

    def aceitar_carta_carrossel(self, carta_path, tipos, page=0):
        # NOVA RESTRIÇÃO: Verificar se é tentativa de trocar Challenge por outra carta que não seja Activity
        idx = getattr(self, 'carrossel_idx_selecao', 0)
        carta_carrossel_atual = getattr(self, 'carta_carrossel_para_troca', None)
        
        # CORREÇÃO: Se carta_carrossel_atual é None, verificar se é uma posição back_card
        if carta_carrossel_atual is None and hasattr(self, 'cards') and idx < len(self.cards):
            carta_na_posicao = self.cards[idx]
            if os.path.basename(carta_na_posicao).startswith("back_card_"):
                carta_carrossel_atual = carta_na_posicao
                print(f"DEBUG: [aceitar_carta_carrossel] Posição {idx} é back_card: {carta_carrossel_atual}")
        
        print(f"DEBUG: [aceitar_carta_carrossel] ===== INICIANDO VERIFICAÇÃO DE TROCA =====")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_path (inventário): {carta_path}")
        print(f"DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual: {carta_carrossel_atual}")
        print(f"DEBUG: [aceitar_carta_carrossel] carrossel_idx_selecao: {idx}")
        print(f"DEBUG: [aceitar_carta_carrossel] tipos: {tipos}")
        
        # IMPORTANTE: Verificar restrição Activity antes de qualquer processamento
        is_inventario_activity = "Activity" in os.path.basename(carta_path)
        if is_inventario_activity:
            challenges_no_inventario = len(self.inventario.get('challenges', []))
            print(f"DEBUG: [aceitar_carta_carrossel] Tentativa de colocar Activity no carrossel")
            print(f"DEBUG: [aceitar_carta_carrossel] Challenges no inventário: {challenges_no_inventario}")
            print(f"DEBUG: [aceitar_carta_carrossel] Lista de Challenges: {[os.path.basename(c) for c in self.inventario.get('challenges', [])]}")
            
            if challenges_no_inventario > 0:
                if carta_carrossel_atual:
                    is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                    if is_carrossel_activity:
                        print("DEBUG: RESTRIÇÃO ATIVADA: Não é possível trocar Activity ↔ Activity quando há Challenges no inventário")
                        self._mostrar_mensagem_restricao_activity_activity()
                        return
                else:
                    print("DEBUG: RESTRIÇÃO ATIVADA: Não é possível colocar Activity no carrossel vazio quando há Challenges no inventário")
                    self._mostrar_mensagem_restricao_activity_activity()
                    return
        
        if carta_carrossel_atual:
            # Verificar se é uma carta back_card (posição vazia)
            is_back_card = os.path.basename(carta_carrossel_atual).startswith("back_card_")
            
            if is_back_card:
                print("DEBUG: [aceitar_carta_carrossel] Posição vazia (back_card) - fazendo colocação simples")
                # É uma colocação em posição vazia, não uma troca
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Flag posição {idx} atualizada para True (virada para cima)")
                
                # Inicializar card_stats para a carta nova
                print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Inicializando card_stats para carta na posição {idx}")
                try:
                    message_size = self._get_card_message_size_from_database(carta_path)
                    new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = new_stats
                        print(f"DEBUG: [aceitar_carta_carrossel] COLOCAÇÃO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                    else:
                        print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCAÇÃO - card_stats não inicializado ou índice inválido")
                except Exception as e:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO COLOCAÇÃO ao obter message_size: {e}")
                    if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                        self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
                if "Challenge" in os.path.basename(carta_path):
                    turno_aceitacao = self._current_turn_number
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Challenge aceite - registando turno {turno_aceitacao}")
                    self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
                
                # CORREÇÃO PROBLEMA 2: SEMPRE resetar valores ao reativar carta no carrossel
                # Isto garante que To send = message_size, Rxd = 0, Lost = 0
                self._reset_card_values_on_activation(carta_path, idx)
                print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] CORREÇÃO APLICADA - Carta sempre resetada ao reativar")
                
                # CORREÇÃO CRÍTICA: Restaurar valores preservados se existirem
                # NOTA: Este código será substituído pelo reset acima para garantir comportamento consistente
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] IGNORANDO valores preservados - sempre resetar: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento mesmo assim
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do mapeamento de preservados")
                    
                    # Também remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_COLOCACAO] Activity removida do backup root")
                
                # Remover carta do inventário
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do inventário {t}")
                        break
                
                print("DEBUG: Colocação concluída com sucesso!")
            else:
                # É uma troca real entre duas cartas
                # Verificar tipos das cartas
                is_carrossel_challenge = "Challenge" in os.path.basename(carta_carrossel_atual)
                is_carrossel_activity = "Activity" in os.path.basename(carta_carrossel_atual)
                is_inventario_challenge = "Challenge" in os.path.basename(carta_path)
                
                print(f"DEBUG: [aceitar_carta_carrossel] Verificando restrições:")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel é Challenge: {is_carrossel_challenge}")
                print(f"DEBUG: [aceitar_carta_carrossel] Carrossel é Activity: {is_carrossel_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Inventário é Activity: {is_inventario_activity}")
                print(f"DEBUG: [aceitar_carta_carrossel] Inventário é Challenge: {is_inventario_challenge}")
                
                # RESTRIÇÃO 1: Challenge só pode ser trocado por Activity
                if is_carrossel_challenge and not is_inventario_activity:
                    print("DEBUG: RESTRIÇÃO: Challenge só pode ser trocado por Activity")
                    self._mostrar_mensagem_restricao_challenge_activity()
                    return
                
                # Fazer a troca entre a carta do carrossel e a carta selecionada do inventário
                print(f"DEBUG: Fazendo troca - Carta do carrossel: {carta_carrossel_atual}")
                print(f"DEBUG: Carta do inventário: {carta_path}")
                print(f"DEBUG: Índice do carrossel: {idx}")
                
                # 1. Colocar a carta do inventário no lugar da carta do carrossel
                self.cards[idx] = carta_path
                self.selected_card_idx = idx
                
                # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
                if not hasattr(self, 'card_face_up_flags'):
                    self.card_face_up_flags = [False, False, False, False]
                if idx < len(self.card_face_up_flags):
                    self.card_face_up_flags[idx] = True
                    print(f"DEBUG: [aceitar_carta_carrossel] TROCA - Flag posição {idx} atualizada para True (virada para cima)")
                
                # CORREÇÃO PROBLEMA 2: SEMPRE resetar valores ao reativar carta no carrossel (troca)
                # Isto garante que To send = message_size, Rxd = 0, Lost = 0
                self._reset_card_values_on_activation(carta_path, idx)
                print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] CORREÇÃO APLICADA - Carta sempre resetada ao reativar (troca)")
                
                # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
                if "Challenge" in os.path.basename(carta_path):
                    turno_aceitacao = self._current_turn_number
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] Challenge aceite - registando turno {turno_aceitacao}")
                    self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] Challenge registado para tracking: {os.path.basename(carta_path)}")
                
                # CORREÇÃO CRÍTICA: IGNORAR valores preservados - sempre resetar
                if (hasattr(self, '_activity_preserved_stats') and 
                    carta_path in self._activity_preserved_stats):
                    
                    preserved_stats = self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_TROCA] IGNORANDO valores preservados - sempre resetar: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento pois a carta está de volta ao carrossel
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do mapeamento de preservados")
                    
                    # Também remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL] Activity removida do backup root")
                
                # 2. Remover a carta do inventário
                for t in tipos:
                    if carta_path in self.inventario.get(t, []):
                        self.inventario[t].remove(carta_path)
                        print(f"DEBUG: Removida carta {carta_path} do inventário {t}")
                        break
                
                # 3. Adicionar a carta que estava no carrossel ao inventário (só se não for back_card)
                if not is_back_card:
                    # Determinar o tipo da carta que estava no carrossel
                    carta_tipo_carrossel = None
                    
                    # Primeiro, verificar se a carta já estava no inventário
                    for t in tipos:
                        if carta_carrossel_atual in self.inventario.get(t, []):
                            carta_tipo_carrossel = t
                            break
                    
                    # Se não encontrou, tentar determinar pelo caminho da carta
                    if not carta_tipo_carrossel:
                        carta_basename = os.path.basename(carta_carrossel_atual).lower()
                        carta_dirname = os.path.dirname(carta_carrossel_atual).lower()
                        
                        # Verificar se o nome do arquivo ou pasta contém o tipo
                        for t in tipos:
                            if t in carta_basename or t in carta_dirname:
                                carta_tipo_carrossel = t
                                break
                        
                        # Último recurso: usar o primeiro tipo disponível
                        if not carta_tipo_carrossel:
                            carta_tipo_carrossel = tipos[0]
                    
                    # Adicionar a carta do carrossel ao inventário
                    if carta_tipo_carrossel in self.inventario:
                        self.inventario[carta_tipo_carrossel].append(carta_carrossel_atual)
                        print(f"DEBUG: Adicionada carta {carta_carrossel_atual} ao inventário {carta_tipo_carrossel}")
                    else:
                        print(f"DEBUG: ERRO - Tipo {carta_tipo_carrossel} não encontrado no inventário")
                
                # 4. Limpar variáveis temporárias
                self.carta_carrossel_para_troca = None
                
                if is_back_card:
                    print("DEBUG: Colocação em posição vazia concluída com sucesso!")
                else:
                    print("DEBUG: Troca concluída com sucesso!")
        else:
            print("DEBUG: [aceitar_carta_carrossel] carta_carrossel_atual é None - fazendo substituição normal")
            # Comportamento original - apenas substitui a carta virada para baixo
            self.cards[idx] = carta_path
            self.selected_card_idx = idx
            
            # CORREÇÃO CRÍTICA: Inicializar card_stats com message_size correto para carta nova
            print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO - Inicializando card_stats para nova carta na posição {idx}")
            try:
                message_size = self._get_card_message_size_from_database(carta_path)
                new_stats = {"To send": message_size, "Rxd": 0, "Lost": 0}
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = new_stats
                    print(f"DEBUG: [aceitar_carta_carrossel] CORREÇÃO - Carta {os.path.basename(carta_path)} inicializada: To send={message_size}, Rxd=0, Lost=0")
                else:
                    print(f"DEBUG: [aceitar_carta_carrossel] ERRO - card_stats não inicializado ou índice inválido")
            except Exception as e:
                print(f"DEBUG: [aceitar_carta_carrossel] ERRO ao obter message_size: {e}")
                # Fallback para valores padrão
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {"To send": 0, "Rxd": 0, "Lost": 0}
            
            # REGISTRO TEMPORAL: Se for Challenge sendo aceite, registar turno de início
            if "Challenge" in os.path.basename(carta_path):
                turno_aceitacao = self._current_turn_number
                print(f"DEBUG: [ACEITAR_CARROSSEL_SUBSTITUICAO] Challenge aceite - registando turno {turno_aceitacao}")
                self._register_challenge_start_turn(carta_path, turno_especifico=turno_aceitacao)
            
            # CORREÇÃO CRÍTICA: Restaurar valores preservados da Activity se existirem (SOBRESCREVE valores iniciais)
            if (hasattr(self, '_activity_preserved_stats') and 
                carta_path in self._activity_preserved_stats):
                
                preserved_stats = self._activity_preserved_stats[carta_path]
                # Atualizar card_stats com valores preservados (SOBRESCREVE os valores iniciais acima)
                if hasattr(self, 'card_stats') and idx < len(self.card_stats):
                    self.card_stats[idx] = {
                        "To send": preserved_stats["To send"],
                        "Rxd": preserved_stats["Rxd"],
                        "Lost": preserved_stats["Lost"]
                    }
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] SOBREPOSIÇÃO - Valores preservados restaurados para posição {idx}: To send={preserved_stats['To send']}, Rxd={preserved_stats['Rxd']}, Lost={preserved_stats['Lost']}")
                    
                    # Remover do mapeamento pois a carta está de volta ao carrossel
                    del self._activity_preserved_stats[carta_path]
                    print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do mapeamento de preservados")
                    
                    # Também remover do backup root se existir
                    root = self.master
                    if (hasattr(root, '_activity_preserved_stats') and 
                        carta_path in root._activity_preserved_stats):
                        del root._activity_preserved_stats[carta_path]
                        print(f"DEBUG: [ACEITAR_CARROSSEL_SIMPLES] Activity removida do backup root")
            
            # Remover carta do inventário activities/challenges
            for t in tipos:
                if carta_path in self.inventario.get(t, []):
                    self.inventario[t].remove(carta_path)
        
        # Voltar à interface principal
        self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)

    def show_card_fullscreen_next_phase_selection(self, carta_path, tipos, page=0):
        """
        Mostra carta em fullscreen no modo Next Phase com apenas X e ✔
        Usado quando Next Phase está ativo e o utilizador clica numa carta do inventário
        """
        print(f"DEBUG: show_card_fullscreen_next_phase_selection chamado - Next Phase ativo")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # IMPORTANTE: Verificar se a TopBar existe, se não, criá-la
        if not hasattr(self, 'topbar_label') or not self.topbar_label.winfo_exists():
            print("DEBUG: TopBar não existe no fullscreen Next Phase, criando...")
            screen_width = self.winfo_screenwidth()
            topbar_img_path = os.path.join(IMG_DIR, f"TopBar_{self.player_color.lower()}.png")
            img = Image.open(topbar_img_path).convert("RGBA")
            img = img.resize((screen_width, 60), Image.Resampling.LANCZOS)
            topbar_img = ImageTk.PhotoImage(img)
            self.topbar_label = tk.Label(self, image=topbar_img, bg="black", borderwidth=0, highlightthickness=0)
            self.topbar_label.image = topbar_img  # type: ignore[attr-defined]
            self.topbar_label.pack(side="top", fill="x")
            print("DEBUG: TopBar criada com sucesso no fullscreen Next Phase")

        # Mostrar carta em fullscreen
        pil_img = Image.open(carta_path)
        img_w, img_h = pil_img.size
        max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
        ratio = min(max_w/img_w, max_h/img_h)
        new_w, new_h = int(img_w*ratio), int(img_h*ratio)
        pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        carta_img = ImageTk.PhotoImage(pil_img)
        carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
        carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
        carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
        
        # Botão X no canto superior esquerdo - volta para a página de inventário Activities/Challenges
        def voltar_inventario():
            print("DEBUG: Voltando para página de inventário Activities/Challenges do modo Next Phase")
            self.show_inventory_matrix_carrossel(tipos, page)
        
        btn_x = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), bg="#AAAAAA", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, command=voltar_inventario, cursor="hand2", activebackground="#CCCCCC")
        btn_x.place(relx=0.02, rely=0, anchor="nw")
        
        # Botão Switch no canto superior direito - aceita carta para o carrossel e vai para dashboard
        # APENAS se Final Phase NÃO estiver ativo
        final_phase_active = getattr(self, '_final_phase_active', False)
        
        # VERIFICAR SE DEVE MOSTRAR BOTÃO SWITCH
        is_activity_card = "Activity" in os.path.basename(carta_path)
        is_challenge_card = "Challenge" in os.path.basename(carta_path)
        challenges_no_inventario = len(self.inventario.get('challenges', []))
        activities_no_inventario = len(self.inventario.get('activities', []))
        
        print(f"DEBUG: [NEXT PHASE] === VERIFICAÇÃO BOTÃO SWITCH ===")
        print(f"DEBUG: [NEXT PHASE] final_phase_active: {final_phase_active}")
        print(f"DEBUG: [NEXT PHASE] is_activity_card: {is_activity_card}")
        print(f"DEBUG: [NEXT PHASE] is_challenge_card: {is_challenge_card}")
        print(f"DEBUG: [NEXT PHASE] challenges_no_inventario: {challenges_no_inventario}")
        print(f"DEBUG: [NEXT PHASE] activities_no_inventario: {activities_no_inventario}")
        
        # Lógica de disponibilidade do botão switch:
        # CORREÇÃO: Verificar se há espaços vazios no carrossel OU cartas para trocar
        # - Se há espaços vazios (back_card) em posições acessíveis: sempre permitir
        # - Se não há espaços vazios: verificar se há cartas para trocar
        should_show_switch = False
        
        # Primeiro, verificar se há posições vazias acessíveis no carrossel
        has_empty_accessible_positions = False
        if hasattr(self, 'cards'):
            user_ids = self._check_user_inventory_for_carousel_access()
            for i, carta_path_carrossel in enumerate(self.cards):
                carta_basename = os.path.basename(carta_path_carrossel)
                is_back_card = carta_basename.startswith("back_card_")
                required_user_id = i + 1
                has_user_id = required_user_id in user_ids
                if is_back_card and has_user_id:
                    has_empty_accessible_positions = True
                    print(f"DEBUG: [NEXT PHASE] Posição {i} vazia e acessível (User ID {required_user_id})")
                    break
        
        print(f"DEBUG: [NEXT PHASE] has_empty_accessible_positions: {has_empty_accessible_positions}")
        
        # LÓGICA CORRIGIDA: Activity NÃO pode mostrar switch quando há Challenges no inventário
        # MESMO que haja posições vazias
        if is_activity_card and challenges_no_inventario > 0:
            should_show_switch = False
            print(f"DEBUG: [NEXT PHASE] ERROR: Activity NÃO pode mostrar switch - há {challenges_no_inventario} Challenges no inventário (restrição Activity→Activity sempre aplicada)")
        elif has_empty_accessible_positions:
            # Se há posições vazias acessíveis E não é Activity com Challenges, permitir
            should_show_switch = True
            print(f"DEBUG: [NEXT PHASE] SUCCESS: Há posições vazias acessíveis - botão switch permitido (colocação)")
        else:
            # Se não há posições vazias, verificar se há cartas para trocar
            if is_activity_card:
                # CORREÇÃO: Activity pode trocar com outra Activity do inventário OU com Activity do carrossel
                # Contar Activities totais (inventário + carrossel)
                activities_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Activity" in os.path.basename(carta_carrossel):
                            activities_no_carrossel += 1
                
                total_activities = activities_no_inventario + activities_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Activities no inventário: {activities_no_inventario}, no carrossel: {activities_no_carrossel}, total: {total_activities}")
                
                # Activity pode trocar se há pelo menos uma outra Activity (total > 1)
                if total_activities > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] SUCCESS: Activity com {total_activities} Activities disponíveis (inventário + carrossel) - botão switch permitido (troca Activity→Activity)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ERROR: Activity sem outras Activities para trocar (total: {total_activities}) - botão switch NÃO criado")
            elif is_challenge_card:
                # CORREÇÃO: Challenge pode trocar com outro Challenge do inventário OU com Challenge do carrossel
                # Contar Challenges totais (inventário + carrossel)
                challenges_no_carrossel = 0
                if hasattr(self, 'cards'):
                    for carta_carrossel in self.cards:
                        if "Challenge" in os.path.basename(carta_carrossel):
                            challenges_no_carrossel += 1
                
                total_challenges = challenges_no_inventario + challenges_no_carrossel
                print(f"DEBUG: [NEXT PHASE] Challenges no inventário: {challenges_no_inventario}, no carrossel: {challenges_no_carrossel}, total: {total_challenges}")
                
                # Challenge pode trocar se há pelo menos um outro Challenge (total > 1)
                if total_challenges > 1:
                    should_show_switch = True
                    print(f"DEBUG: [NEXT PHASE] SUCCESS: Challenge com {total_challenges} Challenges disponíveis (inventário + carrossel) - botão switch permitido (troca)")
                else:
                    print(f"DEBUG: [NEXT PHASE] ERROR: Challenge sem outros Challenges para trocar (total: {total_challenges}) - botão switch NÃO criado")
            else:
                print(f"DEBUG: [NEXT PHASE] ERROR: Carta não é Activity nem Challenge - botão switch NÃO criado")
        
        # Só criar botão switch se Final Phase não estiver ativo E se houver cartas disponíveis para trocar
        if not final_phase_active and should_show_switch:
            def aceitar_carta():
                print("DEBUG: [NEXT PHASE] *** aceitar_carta CHAMADA - SWITCH BUTTON CLICKED! ***")
                print(f"DEBUG: [NEXT PHASE] carta_path: {carta_path}")
                print(f"DEBUG: [NEXT PHASE] tipos: {tipos}")
                print(f"DEBUG: [NEXT PHASE] page: {page}")
                
                # CORREÇÃO: Aplicar a mesma lógica de detecção de substituição
                print("DEBUG: [NEXT PHASE] Verificando se vai substituir carta no carrossel")
                
                # Detectar posição de destino
                posicao_destino = getattr(self, 'carrossel_idx_selecao', None)
                if posicao_destino is None:
                    # Se não há seleção específica, usar primeira posição acessível
                    for i in range(len(self.cards)):
                        if self._can_access_carousel_position(i):
                            posicao_destino = i
                            break
                
                # Verificar se a posição de destino contém uma carta real (não back_card)
                vai_substituir_carta = False
                if posicao_destino is not None and posicao_destino < len(self.cards):
                    carta_na_posicao_destino = self.cards[posicao_destino]
                    vai_substituir_carta = not os.path.basename(carta_na_posicao_destino).startswith("back_card_")
                
                if vai_substituir_carta:
                    print("DEBUG: [NEXT PHASE] Vai substituir carta existente - mostrando overlay de confirmação")
                    self._mostrar_overlay_confirmacao_troca(carta_path, tipos, page)
                else:
                    print("DEBUG: [NEXT PHASE] Vai colocar em posição vazia - indo diretamente para aceitar carta")
                    self.aceitar_carta_carrossel(carta_path, tipos, page)
            
            try:
                switch_img_path = os.path.join(IMG_DIR, "switch_card.png")
                if os.path.exists(switch_img_path):
                    switch_img = ImageTk.PhotoImage(Image.open(switch_img_path).resize((48, 48)))
                    btn_switch_next_phase = tk.Button(self, image=switch_img, bg="#FF9800", borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    btn_switch_next_phase.image = switch_img  # Manter referência
                    print(f"DEBUG: [NEXT PHASE] Botão Switch criado com imagem switch_card.png")
                else:
                    # Fallback para botão texto se imagem não existir
                    btn_switch_next_phase = tk.Button(self, text="⇄", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                    print(f"DEBUG: [NEXT PHASE] Botão Switch criado com texto (imagem não encontrada em {switch_img_path})")
            except Exception as e:
                # Fallback para botão texto em caso de erro
                btn_switch_next_phase = tk.Button(self, text="⇄", font=("Helvetica", 20, "bold"), bg="#FF9800", fg="white", width=2, height=1, borderwidth=0, highlightthickness=0, cursor="hand2", activebackground="#E68900", command=aceitar_carta)
                print(f"DEBUG: [NEXT PHASE] Botão Switch criado com texto (erro ao carregar imagem: {e})")
            
            # POSICIONAMENTO ESPECÍFICO POR TIPO DE CARTA:
            if is_activity_card:
                # Activities: Switch no canto superior direito
                btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                print(f"DEBUG: [NEXT PHASE] Botão Switch Activity posicionado no canto superior direito")
            else:  # is_challenge_card
                # CORREÇÃO: Challenges: Switch também no canto superior direito (ao lado do quit se houver)
                # Se quit button estiver presente, switch fica um pouco mais à esquerda
                next_phase_active = getattr(self, '_next_phase_active', False)
                if not final_phase_active and not next_phase_active:
                    # Quit button vai estar presente, switch fica mais à esquerda
                    btn_switch_next_phase.place(relx=0.90, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Botão Switch Challenge posicionado no canto superior direito (à esquerda do quit)")
                else:
                    # Quit button não vai estar presente, switch pode ficar no canto
                    btn_switch_next_phase.place(relx=0.98, rely=0, anchor="ne")
                    print(f"DEBUG: [NEXT PHASE] Botão Switch Challenge posicionado no canto superior direito")
            
            print(f"DEBUG: [NEXT PHASE] Botão Switch configurado e posicionado")
        else:
            if not should_show_switch:
                print(f"DEBUG: [NEXT PHASE] Botão Switch NÃO criado - sem cartas disponíveis para trocar")
            else:
                print(f"DEBUG: [NEXT PHASE] Botão Switch NÃO criado - Final Phase está ativo")
        
        # BOTÃO QUIT CHALLENGE (apenas para Challenges, canto superior direito)
        # CORREÇÃO: Não deve aparecer quando Next Phase está ativo OU Final Phase está ativo
        next_phase_active = getattr(self, '_next_phase_active', False)
        if is_challenge_card and not final_phase_active and not next_phase_active:
            print(f"DEBUG: [NEXT PHASE] Criando botão Quit Challenge no canto superior direito")
            
            # Botão vermelho com símbolo de check (✓) para quit challenge
            btn_quit_challenge = tk.Button(
                self, 
                text="✓", 
                font=("Helvetica", 24, "bold"), 
                bg="#DC143C", 
                fg="white", 
                width=2, 
                height=1, 
                borderwidth=0, 
                highlightthickness=0, 
                cursor="hand2", 
                activebackground="#B22222"
            )
            # Challenge: Quit sempre no canto superior direito
            btn_quit_challenge.place(relx=0.98, rely=0, anchor="ne")
            
            # Comando do botão quit
            def mostrar_confirmacao_quit():
                print(f"DEBUG: [QUIT_CHALLENGE] Iniciando confirmação de quit para carta: {os.path.basename(carta_path)}")
                self._mostrar_overlay_quit_challenge(carta_path)
            
            btn_quit_challenge.config(command=mostrar_confirmacao_quit)
            print(f"DEBUG: [NEXT PHASE] SUCCESS: Botão Quit Challenge criado no canto superior direito")
        else:
            if next_phase_active:
                print(f"DEBUG: [NEXT PHASE] ERROR: Botão Quit Challenge NÃO criado - Next Phase está ativo")
            elif final_phase_active:
                print(f"DEBUG: [NEXT PHASE] ERROR: Botão Quit Challenge NÃO criado - Final Phase está ativo")
            elif not is_challenge_card:
                print(f"DEBUG: [NEXT PHASE] ERROR: Botão Quit Challenge NÃO criado - não é carta Challenge")
        
        print("DEBUG: Fullscreen Next Phase configurado - apenas X disponível durante Final Phase")

    def add_more_action_event_cards(self, min_actions=5, min_events=6):
        """
        Adiciona mais cartas de Actions/Events ao inventário se houver poucas.
        Usa filtragem baseada na base de dados para adicionar apenas cartas válidas.
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print("DEBUG: [add_more_action_event_cards] Base de dados não disponível")
            return
        
        player_color = self.player_color.lower()
        base_path = "/Users/joaop_27h1t5j/Desktop/IST/Bolsa/NetMaster"
        
        # Verificar Actions - NÃO ADICIONAR mais Actions, manter apenas Action_31.png e Action_46.png
        current_actions = len(self.inventario.get("actions", []))
        print(f"DEBUG: [add_more_action_event_cards] Actions atuais: {current_actions} (mantendo apenas Action_31.png e Action_46.png, não adicionando mais)")
        
        # Verificar Events
        current_events = len(self.inventario.get("events", []))
        if current_events < min_events:
            print(f"DEBUG: [add_more_action_event_cards] Events insuficientes ({current_events}/{min_events}), adicionando mais...")
            events_path = os.path.join(base_path, "Events", "Residential-level")
            if os.path.exists(events_path):
                try:
                    files = os.listdir(events_path)
                    event_files = [os.path.join(events_path, f) for f in files if f.lower().endswith('.png')]
                    
                    valid_events = []
                    for card_file in event_files:
                        filename = os.path.basename(card_file)
                        match = re.search(r'Event_(\d+)\.', filename)
                        if match:
                            # ESPECIAL: Incluir APENAS Event_55 e Event_14
                            if filename == "Event_55.png" or filename == "Event_14.png":
                                if card_file not in self.inventario.get("events", []):
                                    valid_events.append(card_file)
                                    print(f"DEBUG: [add_more_action_event_cards] Event PERMITIDO: {filename}")
                            else:
                                print(f"DEBUG: [add_more_action_event_cards] Event IGNORADO (não é Event_55 nem Event_14): {filename}")
                    
                    # Adicionar cartas até atingir o mínimo
                    needed = min_events - current_events
                    for i in range(min(needed, len(valid_events))):
                        self.inventario["events"].append(valid_events[i])
                        print(f"DEBUG: [add_more_action_event_cards] Event adicionado: {os.path.basename(valid_events[i])}")
                
                except Exception as e:
                    print(f"DEBUG: [add_more_action_event_cards] Erro ao adicionar Events: {e}")
        
        print(f"DEBUG: [add_more_action_event_cards] Resultado final - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def _filter_action_event_cards(self, cartas_paths, card_type):
        """
        Filtra cartas de Actions/Events baseado no target e player_choice.
        Mostra cartas que:
        1. Têm target igual à cor do jogador atual, OU
        2. Têm target None e player_choice True (jogador pode escolher alvo), OU
        3. Têm target None e player_choice False/None (carta fica sempre com quem a tirou)
        """
        if not hasattr(self, 'card_database') or not self.card_database:
            print(f"DEBUG: [_filter_action_event_cards] Base de dados não disponível - mostrando todas as cartas")
            return cartas_paths
        
        filtered_cards = []
        player_color = self.player_color.lower()
        
        for carta_path in cartas_paths:
            try:
                # Extrair ID da carta do nome do arquivo
                filename = os.path.basename(carta_path)
                if card_type == "actions":
                    # Action_1.png -> action_1
                    match = re.search(r'Action_(\d+)\.', filename)
                    if match:
                        card_id = f"action_{match.group(1)}"
                        card_data = self.card_database.get_action(card_id)
                    else:
                        continue
                elif card_type == "events":
                    # Event_1.png -> event_1
                    match = re.search(r'Event_(\d+)\.', filename)
                    if match:
                        card_id = f"event_{match.group(1)}"
                        card_data = self.card_database.get_event(card_id)
                    else:
                        continue
                else:
                    continue
                
                if card_data:
                    # Para Events, usar target_player; para Actions, usar target
                    if card_type == "events":
                        target = getattr(card_data, 'target_player', None)
                    else:
                        target = getattr(card_data, 'target', None)
                    player_choice = getattr(card_data, 'player_choice', False)
                    
                    # CRITÉRIO DE FILTRAGEM CORRIGIDO:
                    # 1. Target específico igual à cor do jogador
                    # 2. Target None com player_choice True (jogador escolhe alvo)
                    # 3. Target None com player_choice False/None (carta fica com quem tirou)
                    if (target == player_color or 
                        (target is None and player_choice) or 
                        (target is None and not player_choice)):
                        filtered_cards.append(carta_path)
                        if target == player_color:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target={target} - direcionada para jogador)")
                        elif target is None and player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=True - jogador escolhe)")
                        elif target is None and not player_choice:
                            print(f"DEBUG: [_filter_action_event_cards] Carta ACEITA: {filename} (target=None, player_choice=False - fica com quem tirou)")
                    else:
                        print(f"DEBUG: [_filter_action_event_cards] Carta REJEITADA: {filename} (target={target}, player_choice={player_choice} - não aplicável)")
                else:
                    print(f"DEBUG: [_filter_action_event_cards] Carta não encontrada na base de dados: {card_id}")
                    
            except Exception as e:
                print(f"DEBUG: [_filter_action_event_cards] Erro ao processar carta {filename}: {e}")
                continue
        
        print(f"DEBUG: [_filter_action_event_cards] Resultado final {card_type}: {len(filtered_cards)}/{len(cartas_paths)} cartas")
        return filtered_cards

    def reload_action_event_inventory(self):
        """
        Função de conveniência para recarregar o inventário de Actions/Events
        com mais cartas válidas para o jogador atual.
        """
        print("DEBUG: [reload_action_event_inventory] Recarregando inventário de Actions/Events...")
        
        # Limpar inventário atual (opcional)
        # self.inventario["actions"] = []
        # self.inventario["events"] = []
        
        # Adicionar mais cartas
        self.add_more_action_event_cards(min_actions=10, min_events=12)
        
        print(f"DEBUG: [reload_action_event_inventory] Inventário atualizado - Actions: {len(self.inventario.get('actions', []))}, Events: {len(self.inventario.get('events', []))}")

    def processar_challenge_aceite(self, carta_challenge_path):
        """
        Processa a aceitação de uma carta Challenge implementando a lógica complexa de substituição:
        - Se há Activities ativas no carrossel: substitui uma Activity (com reset de valores)
        - Se há múltiplas Activities: jogador escolhe qual substituir
        - Se só há Challenges ativas: Challenge vai para inventário
        - Activity substituída vai para inventário Activities/Challenges
        """
        print(f"DEBUG: [processar_challenge_aceite] Processando Challenge: {os.path.basename(carta_challenge_path)}")
        
        # CORREÇÃO PROBLEMA 1: Verificar se Challenge já foi processado para evitar duplo processamento
        if hasattr(self, '_challenge_sendo_processado') and self._challenge_sendo_processado == carta_challenge_path:
            print(f"DEBUG: [processar_challenge_aceite] WARNING:  Challenge já está sendo processado - ignorando chamada duplicada")
            return
        
        # Marcar Challenge como sendo processado
        self._challenge_sendo_processado = carta_challenge_path
        
        # FECHAR A STORE se estiver aberta
        if hasattr(self, 'store_window') and self.store_window:
            print(f"DEBUG: [processar_challenge_aceite] Fechando Store...")
            try:
                self.store_window.destroy()
                self.store_window = None
                print(f"DEBUG: [processar_challenge_aceite] Store fechada com sucesso")
            except Exception as e:
                print(f"DEBUG: [processar_challenge_aceite] Erro ao fechar Store: {e}")
        
        # Desabilitar botão Store (Challenge aceite)
        self.disable_store_button()
        print(f"DEBUG: [processar_challenge_aceite] Botão Store desabilitado")
        
        try:
            # REGISTRO TEMPORAL: Challenge aceite no turno atual
            turno_aceitacao_real = self._current_turn_number
            print(f"DEBUG: [processar_challenge_aceite] Registando Challenge com turno específico: {turno_aceitacao_real}")
            self._register_challenge_start_turn(carta_challenge_path, turno_especifico=turno_aceitacao_real)
            
            print(f"DEBUG: [processar_challenge_aceite] Challenge {os.path.basename(carta_challenge_path)} registado para turno {turno_aceitacao_real}")
            print(f"DEBUG: [processar_challenge_aceite] _current_turn_number atual: {self._current_turn_number}")
            print(f"DEBUG: [processar_challenge_aceite] Turno de registo usado: {turno_aceitacao_real}")
            
            # BACKUP MÚLTIPLO E ROBUSTO para garantir persistência durante toda a operação
            try:
                # Backup no master
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_challenge_start_turns_backup'):
                        self.master._challenge_start_turns_backup = {}
                    self.master._challenge_start_turns_backup[carta_challenge_path] = turno_aceitacao_real
                    print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no master backup com turno {turno_aceitacao_real}")
                
                # NOVO: Backup no root (principal)
                if hasattr(self, 'winfo_toplevel'):
                    root = self.winfo_toplevel()
                    if root:
                        if not hasattr(root, '_backup_challenge_tracking'):
                            root._backup_challenge_tracking = {}
                        root._backup_challenge_tracking[carta_challenge_path] = turno_aceitacao_real
                        print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no root backup com turno {turno_aceitacao_real}")
                
                # NOVO: Backup imediato no _backup_turn_counters para persistir durante reconstruções
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_backup_turn_counters'):
                        self.master._backup_turn_counters = {}
                    if '_challenge_start_turns' not in self.master._backup_turn_counters:
                        self.master._backup_turn_counters['_challenge_start_turns'] = {}
                    self.master._backup_turn_counters['_challenge_start_turns'][carta_challenge_path] = turno_aceitacao_real
                    print(f"DEBUG: [processar_challenge_aceite] Challenge salvo no _backup_turn_counters com turno {turno_aceitacao_real}")
                
                print(f"DEBUG: [processar_challenge_aceite] ✅ TRACKING TOTALMENTE PROTEGIDO com 3 backups independentes")
                
            except Exception as e:
                print(f"DEBUG: [processar_challenge_aceite] Erro no backup múltiplo: {e}")
            
            # Primeiro, garantir que Challenge está no inventário
            if 'challenges' not in self.inventario:
                self.inventario['challenges'] = []
            if carta_challenge_path not in self.inventario['challenges']:
                self.inventario['challenges'].append(carta_challenge_path)
                print(f"DEBUG: [processar_challenge_aceite] Challenge adicionado ao inventário")
            
            # Verificar Activities ativas no carrossel
            activities_ativas = []
            for i, carta_carrossel in enumerate(self.cards):
                if carta_carrossel and "Activity" in os.path.basename(carta_carrossel):
                    activities_ativas.append((i, carta_carrossel))
            
            print(f"DEBUG: [processar_challenge_aceite] Activities ativas encontradas: {len(activities_ativas)}")
            for idx, carta in activities_ativas:
                print(f"DEBUG: [processar_challenge_aceite]   Posição {idx}: {os.path.basename(carta)}")
            
            if len(activities_ativas) == 0:
                # Caso 1: Não há Activities ativas - Challenge vai direto para inventário
                print("DEBUG: [processar_challenge_aceite] Nenhuma Activity ativa - Challenge vai para inventário")
                # Challenge já foi adicionado ao inventário acima
                
            elif len(activities_ativas) == 1:
                # Caso 2: Uma Activity ativa - substitui automaticamente
                idx_activity, carta_activity = activities_ativas[0]
                print(f"DEBUG: [processar_challenge_aceite] Uma Activity ativa - substituindo automaticamente posição {idx_activity}")
                self._substituir_activity_por_challenge(idx_activity, carta_activity, carta_challenge_path)
                
            else:
                # Caso 3: Múltiplas Activities ativas - jogador escolhe
                print(f"DEBUG: [processar_challenge_aceite] {len(activities_ativas)} Activities ativas - jogador deve escolher")
                self._mostrar_selecao_activity_para_substituir(activities_ativas, carta_challenge_path)
                
        finally:
            # Limpar marcador de processamento após 2 segundos para permitir futuras operações
            self.after(2000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [processar_challenge_aceite] Marcador de processamento será limpo em 2 segundos")
    
    def _substituir_activity_por_challenge(self, idx_carrossel, carta_activity_path, carta_challenge_path):
        """
        Executa a substituição de uma Activity por uma Challenge no carrossel:
        - CORRECCIÓN: Reseta card_stats e barras de progresso para valores da nova Challenge
        - Move Activity para inventário
        - Remove Challenge do inventário
        - Coloca Challenge no carrossel
        """
        try:
            print(f"DEBUG: [_substituir_activity_por_challenge] INÍCIO - Substituindo Activity posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Activity: {os.path.basename(carta_activity_path)}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge: {os.path.basename(carta_challenge_path)}")
            
            # 1. RESETAR VALORES DA ACTIVITY (To send volta ao inicial, Rxd e Lost = 0)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Resetando valores...")
            self._resetar_valores_activity(carta_activity_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 1: Valores resetados")
            
            # 2. MOVER ACTIVITY PARA INVENTÁRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Movendo Activity para inventário...")
            if 'activities' not in self.inventario:
                self.inventario['activities'] = []
            if carta_activity_path not in self.inventario['activities']:
                self.inventario['activities'].append(carta_activity_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Activity movida para inventário")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 2: Activity movida")
            
            # 3. REMOVER CHALLENGE DO INVENTÁRIO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Removendo Challenge do inventário...")
            if carta_challenge_path in self.inventario.get('challenges', []):
                self.inventario['challenges'].remove(carta_challenge_path)
                print(f"DEBUG: [_substituir_activity_por_challenge] Challenge removido do inventário")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 3: Challenge removido")
            
            # 4. COLOCAR CHALLENGE NO CARROSSEL
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Colocando Challenge no carrossel...")
            self.cards[idx_carrossel] = carta_challenge_path
            
            # CORREÇÃO CRÍTICA: Atualizar flag da carta como virada para cima (True)
            if not hasattr(self, 'card_face_up_flags'):
                self.card_face_up_flags = [False, False, False, False]
            if idx_carrossel < len(self.card_face_up_flags):
                self.card_face_up_flags[idx_carrossel] = True
                print(f"DEBUG: [_substituir_activity_por_challenge] Flag posição {idx_carrossel} atualizada para True (virada para cima)")
            
            # CORREÇÃO CRÍTICA: GARANTIR REGISTO IMEDIATO E BACKUP SEGURO
            print(f"DEBUG: [_substituir_activity_por_challenge] === VERIFICAÇÃO CRÍTICA DO TRACKING ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Estado atual do tracking: {self._challenge_start_turns}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Procurando registo para: {os.path.basename(carta_challenge_path)}")
            
            # CORREÇÃO FUNDAMENTAL: Primeiro tentar recuperar do backup antes de verificar tracking local
            turno_ja_registado = None
            challenge_basename = os.path.basename(carta_challenge_path)
            
            # 1. Verificar tracking local
            turno_ja_registado = self._challenge_start_turns.get(carta_challenge_path)
            
            # 2. Se não encontrou por caminho exato, procurar por basename
            if turno_ja_registado is None:
                for tracked_path, turno in self._challenge_start_turns.items():
                    if os.path.basename(tracked_path) == challenge_basename:
                        turno_ja_registado = turno
                        print(f"DEBUG: [_substituir_activity_por_challenge] Challenge encontrado por basename: {turno}")
                        # Migrar chave para caminho correto
                        del self._challenge_start_turns[tracked_path]
                        self._challenge_start_turns[carta_challenge_path] = turno
                        print(f"DEBUG: [_substituir_activity_por_challenge] Chave migrada para caminho correto")
                        break
            
            # 3. NOVO: Se não encontrou no tracking local, tentar recuperar dos backups
            if turno_ja_registado is None:
                print(f"DEBUG: [_substituir_activity_por_challenge] ⚠️ Challenge não encontrado no tracking local - tentando backups...")
                
                # Verificar backup no root
                try:
                    if hasattr(self, 'winfo_toplevel'):
                        root = self.winfo_toplevel()
                        if root and hasattr(root, '_backup_challenge_tracking'):
                            for backup_path, backup_turno in root._backup_challenge_tracking.items():
                                if os.path.basename(backup_path) == challenge_basename:
                                    turno_ja_registado = backup_turno
                                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Challenge recuperado do backup ROOT: turno {backup_turno}")
                                    break
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao verificar backup ROOT: {e}")
                
                # Verificar backup no master
                if turno_ja_registado is None:
                    try:
                        if hasattr(self, 'master') and hasattr(self.master, '_challenge_start_turns_backup'):
                            for backup_path, backup_turno in self.master._challenge_start_turns_backup.items():
                                if os.path.basename(backup_path) == challenge_basename:
                                    turno_ja_registado = backup_turno
                                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Challenge recuperado do backup MASTER: turno {backup_turno}")
                                    break
                    except Exception as e:
                        print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao verificar backup MASTER: {e}")
                
                # Se encontrou nos backups, restaurar no tracking local
                if turno_ja_registado is not None:
                    self._challenge_start_turns[carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Tracking restaurado dos backups: {challenge_basename} = turno {turno_ja_registado}")
            
            if turno_ja_registado is not None:
                print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Challenge {challenge_basename} tem tracking: turno {turno_ja_registado}")
                print(f"DEBUG: [_substituir_activity_por_challenge] PRESERVANDO turno de registo existente - NÃO sobrescrever!")
            else:
                # FALLBACK CRÍTICO: Se não foi registado em lugar nenhum, registar AGORA com turno atual
                print(f"DEBUG: [_substituir_activity_por_challenge] ❌ Challenge NÃO encontrado em local nenhum - REGISTANDO AGORA!")
                
                turno_aceitacao = self._current_turn_number
                self._register_challenge_start_turn(carta_challenge_path, turno_especifico=turno_aceitacao)
                turno_ja_registado = turno_aceitacao
                print(f"DEBUG: [_substituir_activity_por_challenge] ✅ Challenge {challenge_basename} registado para turno {turno_aceitacao}")
            
            # BACKUP IMEDIATO APÓS VERIFICAÇÃO/REGISTO
            print(f"DEBUG: [_substituir_activity_por_challenge] === BACKUP IMEDIATO PÓS-REGISTO ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Tracking final antes do backup: {self._challenge_start_turns}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge_13 no tracking: {carta_challenge_path in self._challenge_start_turns}")
            if carta_challenge_path in self._challenge_start_turns:
                print(f"DEBUG: [_substituir_activity_por_challenge] Turno registado: {self._challenge_start_turns[carta_challenge_path]}")
            
            # BACKUP ADICIONAL IMEDIATO no master/root para garantir persistência
            try:
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_challenge_start_turns_backup_imediato'):
                        self.master._challenge_start_turns_backup_imediato = {}
                    self.master._challenge_start_turns_backup_imediato[carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ BACKUP IMEDIATO no master: Challenge_13={turno_ja_registado}")
                
                if hasattr(self, 'winfo_toplevel'):
                    root = self.winfo_toplevel()
                    if root:
                        if not hasattr(root, '_challenge_start_turns_backup_imediato'):
                            root._challenge_start_turns_backup_imediato = {}
                        root._challenge_start_turns_backup_imediato[carta_challenge_path] = turno_ja_registado
                        print(f"DEBUG: [_substituir_activity_por_challenge] ✅ BACKUP IMEDIATO no root: Challenge_13={turno_ja_registado}")
                
                # BACKUP CRÍTICO ADICIONAL: Salvar também no _backup_turn_counters para garantir persistência durante reconstrução
                if hasattr(self, 'master') and self.master is not None:
                    if not hasattr(self.master, '_backup_turn_counters'):
                        self.master._backup_turn_counters = {}
                    if '_challenge_start_turns' not in self.master._backup_turn_counters:
                        self.master._backup_turn_counters['_challenge_start_turns'] = {}
                    self.master._backup_turn_counters['_challenge_start_turns'][carta_challenge_path] = turno_ja_registado
                    print(f"DEBUG: [_substituir_activity_por_challenge] ✅ BACKUP ADICIONAL no _backup_turn_counters: {carta_challenge_path}={turno_ja_registado}")
                
            except Exception as e:
                print(f"DEBUG: [_substituir_activity_por_challenge] ERRO no backup imediato: {e}")
            
            print(f"DEBUG: [_substituir_activity_por_challenge] Challenge colocado no carrossel posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 4: Challenge colocado")
            
            # 5. CORREÇÃO CRÍTICA: RESETAR card_stats PARA A NOVA CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 5: Resetando card_stats para Challenge...")
            challenge_message_size = self._get_card_message_size_from_database(carta_challenge_path)
            print(f"DEBUG: [_substituir_activity_por_challenge] Message size da Challenge: {challenge_message_size}")
            
            # Resetar card_stats[idx_carrossel] com valores da Challenge
            if idx_carrossel < len(self.card_stats):
                self.card_stats[idx_carrossel] = {
                    "To send": challenge_message_size,  # Novo message_size da Challenge
                    "Rxd": 0,                          # Sempre 0 para nova carta
                    "Lost": 0                          # Sempre 0 para nova carta
                }
                print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: card_stats[{idx_carrossel}] resetado:")
                print(f"DEBUG: [_substituir_activity_por_challenge]   To send: {challenge_message_size}")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Rxd: 0")
                print(f"DEBUG: [_substituir_activity_por_challenge]   Lost: 0")
            
            # 6. CORREÇÃO CRÍTICA: ATUALIZAR BARRAS DE PROGRESSO PARA A CHALLENGE
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 6: Atualizando barras para Challenge...")
            if hasattr(self, 'progress_bars') and hasattr(self, 'progress_labels'):
                # Configurar barra To send com message_size da Challenge
                if "To send" in self.progress_bars:
                    self.progress_bars["To send"].configure(maximum=challenge_message_size)
                    self.progress_bars["To send"].set(challenge_message_size)  # Barra 100% cheia
                    self.progress_labels["To send"].config(text=str(challenge_message_size))
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra To send: {challenge_message_size}/{challenge_message_size}")
                
                # Resetar Rxd para 0
                if "Rxd" in self.progress_bars:
                    self.progress_bars["Rxd"].set(0)
                    self.progress_labels["Rxd"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra Rxd: 0")
                
                # Resetar Lost para 0
                if "Lost" in self.progress_bars:
                    self.progress_bars["Lost"].set(0)
                    self.progress_labels["Lost"].config(text="0")
                    print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barra Lost: 0")
                
                # Forçar atualização visual
                for stat in ["To send", "Rxd", "Lost"]:
                    if stat in self.progress_bars:
                        self.progress_bars[stat].update_idletasks()
                        self.progress_bars[stat].update()
                    if stat in self.progress_labels:
                        self.progress_labels[stat].update_idletasks()
                        self.progress_labels[stat].update()
                
                self.update_idletasks()
                self.update()
                print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Barras atualizadas e refreshed")
            
            # 7. LIMPAR ESTADO DE SELEÇÃO E PROCESSAMENTO PARA EVITAR CONFLITOS
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Limpando estado de seleção...")
            if hasattr(self, 'selected_carousel_card'):
                self.selected_carousel_card = None
            if hasattr(self, 'selected_carousel_index'):
                self.selected_carousel_index = None
            if hasattr(self, 'carta_carrossel_para_troca'):
                self.carta_carrossel_para_troca = None
            if hasattr(self, 'carrossel_idx_selecao'):
                self.carrossel_idx_selecao = None
            print(f"DEBUG: [_substituir_activity_por_challenge] Estado de seleção limpo")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 7: Estado limpo")
            
            # 8. BACKUP CRÍTICO DOS CONTADORES ANTES DA RECONSTRUÇÃO
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8a: BACKUP CRÍTICO dos contadores...")
            self._backup_turn_counters_before_reconstruction()
            print(f"DEBUG: [_substituir_activity_por_challenge] Backup dos contadores concluído")
            
            # 8b. ATUALIZAR INTERFACE (se estiver visível)
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8b: Atualizando interface...")
            
            # CORREÇÃO CRÍTICA RASPBERRY PI: Sistema de backup múltiplas camadas
            # Garantir que o Challenge recém-registado é preservado antes da reconstrução da interface
            print(f"DEBUG: [_substituir_activity_por_challenge] === BACKUP EMERGENCY MÚLTIPLAS CAMADAS ===")
            print(f"DEBUG: [_substituir_activity_por_challenge] Tracking antes da interface: {self._challenge_start_turns}")
            
            # CAMADA 1: Emergency backup no master (original)
            if hasattr(self, 'master') and self.master is not None:
                if not hasattr(self.master, '_challenge_tracking_emergency_backup'):
                    self.master._challenge_tracking_emergency_backup = {}
                self.master._challenge_tracking_emergency_backup.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 1: Emergency backup no master: {len(self.master._challenge_tracking_emergency_backup)} itens")
            
            # CAMADA 2: Super backup no master
            if hasattr(self, 'master') and hasattr(self.master, '_super_challenge_backup'):
                self.master._super_challenge_backup.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 2: Super backup no master: {len(self.master._super_challenge_backup)} itens")
            
            # CAMADA 3: Super backup no root
            try:
                if hasattr(self.master.master, '_super_challenge_backup'):
                    self.master.master._super_challenge_backup.update(self._challenge_start_turns)
                    print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 3: Super backup no root: {len(self.master.master._super_challenge_backup)} itens")
            except:
                print("DEBUG: [_substituir_activity_por_challenge] CAMADA 3: Root não acessível, pulando")
            
            # CAMADA 4: Backup registry na instância
            if hasattr(self, '_challenge_backup_registry'):
                self._challenge_backup_registry.update(self._challenge_start_turns)
                print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 4: Backup registry na instância: {len(self._challenge_backup_registry)} itens")
            
            # CAMADA 5: Variável temporária global (último recurso)
            import builtins
            if not hasattr(builtins, '_global_challenge_backup'):
                builtins._global_challenge_backup = {}
            builtins._global_challenge_backup.update(self._challenge_start_turns)
            print(f"DEBUG: [_substituir_activity_por_challenge] CAMADA 5: Backup global: {len(builtins._global_challenge_backup)} itens")
            
            print(f"DEBUG: [_substituir_activity_por_challenge] TODAS AS CAMADAS DE BACKUP CRIADAS COM SUCESSO")
            
            if hasattr(self, 'card_labels') and self.card_labels:
                try:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Chamando playerdashboard_interface...")
                    # Recriar interface para mostrar mudanças
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface atualizada")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao atualizar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback interface: {traceback.format_exc()}")
            else:
                print(f"DEBUG: [_substituir_activity_por_challenge] Não há card_labels - criando interface diretamente...")
                try:
                    # BACKUP CRÍTICO DOS CONTADORES ANTES DA CRIAÇÃO
                    self._backup_turn_counters_before_reconstruction()
                    self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                    print(f"DEBUG: [_substituir_activity_por_challenge] Interface criada diretamente")
                except Exception as e:
                    print(f"DEBUG: [_substituir_activity_por_challenge] Erro ao criar interface: {e}")
                    import traceback
                    print(f"DEBUG: [_substituir_activity_por_challenge] Traceback criação: {traceback.format_exc()}")
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 8: Interface processada")
            
            # 9. LIMPAR MARCADOR DE PROCESSAMENTO DEPOIS DE UM BREVE DELAY
            print(f"DEBUG: [_substituir_activity_por_challenge] Passo 9: Programando limpeza...")
            self.after(1000, lambda: setattr(self, '_challenge_sendo_processado', None))
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: SUBSTITUIÇÃO COMPLETA")
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Challenge {os.path.basename(carta_challenge_path)} substitui Activity na posição {idx_carrossel}")
            print(f"DEBUG: [_substituir_activity_por_challenge] SUCCESS: Valores resetados: To send={challenge_message_size}, Rxd=0, Lost=0")
            
        except Exception as e:
            print(f"DEBUG: [_substituir_activity_por_challenge] ERRO CRÍTICO: {e}")
            import traceback
            print(f"DEBUG: [_substituir_activity_por_challenge] Traceback completo: {traceback.format_exc()}")
            # Em caso de erro, tentar voltar à interface principal
            try:
                print(f"DEBUG: [_substituir_activity_por_challenge] Tentando recuperar interface...")
                self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                print(f"DEBUG: [_substituir_activity_por_challenge] Interface recuperada")
            except Exception as e2:
                print(f"DEBUG: [_substituir_activity_por_challenge] ERRO ao recuperar interface: {e2}")
    
    def _resetar_valores_activity(self, carta_activity_path):
        """
        Reseta os valores de uma Activity interrompida por Challenge:
        - To send volta ao valor inicial (message_size)
        - Rxd (recebidos) = 0
        - Lost (perdidos) = 0
        """
        print(f"DEBUG: [_resetar_valores_activity] Resetando valores para {os.path.basename(carta_activity_path)}")
        
        try:
            # Verificar se as barras de progresso existem
            if not hasattr(self, 'progress_bars') or not hasattr(self, 'progress_labels'):
                print(f"DEBUG: [_resetar_valores_activity] Barras de progresso não inicializadas")
                return
            
            # Obter message_size da carta para resetar "To send"
            message_size = self._get_card_message_size(carta_activity_path)
            print(f"DEBUG: [_resetar_valores_activity] Message size da Activity: {message_size}")
            
            # RESETAR "To send" para valor inicial (message_size)
            if "To send" in self.progress_bars:
                self.progress_bars["To send"]["value"] = message_size
                self.progress_bars["To send"]["maximum"] = message_size
                if "To send" in self.progress_labels:
                    self.progress_labels["To send"]["text"] = str(message_size)
                print(f"DEBUG: [_resetar_valores_activity] To send resetado para {message_size}")
            
            # RESETAR "Rxd" para 0
            if "Rxd" in self.progress_bars:
                self.progress_bars["Rxd"]["value"] = 0
                if "Rxd" in self.progress_labels:
                    self.progress_labels["Rxd"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Rxd resetado para 0")
            
            # RESETAR "Lost" para 0
            if "Lost" in self.progress_bars:
                self.progress_bars["Lost"]["value"] = 0
                if "Lost" in self.progress_labels:
                    self.progress_labels["Lost"]["text"] = "0"
                print(f"DEBUG: [_resetar_valores_activity] Lost resetado para 0")
            
            # Forçar atualização visual das barras
            for stat in ["To send", "Rxd", "Lost"]:
                if stat in self.progress_bars:
                    self.progress_bars[stat].update()
                if stat in self.progress_labels:
                    self.progress_labels[stat].update()
            
            print(f"DEBUG: [_resetar_valores_activity] Reset completo - Activity interrompida")
            
        except Exception as e:
            print(f"DEBUG: [_resetar_valores_activity] ERRO ao resetar valores: {e}")
            import traceback
            traceback.print_exc()
    
    def _mostrar_selecao_activity_para_substituir(self, activities_ativas, carta_challenge_path):
        """
        Mostra interface para jogador escolher qual Activity substituir quando há múltiplas ativas.
        """
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Mostrando seleção para {len(activities_ativas)} Activities")
        
        # Limpar widgets
        for widget in self.winfo_children():
            if hasattr(self, 'topbar_label') and widget == self.topbar_label:
                continue
            widget.destroy()
        
        # Título
        title = tk.Label(self, text="Choose Activity to Replace", font=("Helvetica", 20, "bold"), fg="white", bg="black")
        title.place(relx=0.5, y=65, anchor="n")
        
        # Subtítulo
        subtitle = tk.Label(self, text=f"Replace with: {os.path.basename(carta_challenge_path)}", 
                           font=("Helvetica", 14), fg="yellow", bg="black")
        subtitle.place(relx=0.5, y=100, anchor="n")
        
        # Frame para as Activities
        selection_frame = tk.Frame(self, bg="black")
        selection_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        card_w, card_h = 100, 140
        
        # Mostrar cada Activity ativa como opção clicável
        for i, (idx_carrossel, carta_activity_path) in enumerate(activities_ativas):
            try:
                img = ImageTk.PhotoImage(Image.open(carta_activity_path).resize((card_w, card_h)))
                
                # Label da carta
                carta_lbl = tk.Label(selection_frame, image=img, bg="black", cursor="hand2", 
                                   highlightthickness=2, highlightcolor="yellow")
                carta_lbl.image = img  # type: ignore[attr-defined]
                carta_lbl.grid(row=0, column=i, padx=15, pady=10)
                
                # Label com posição no carrossel
                pos_lbl = tk.Label(selection_frame, text=f"Position {idx_carrossel + 1}", 
                                 font=("Helvetica", 12, "bold"), fg="white", bg="black")
                pos_lbl.grid(row=1, column=i, pady=(5, 0))
                
                # Bind do clique para executar substituição
                def fazer_substituicao(idx=idx_carrossel, carta=carta_activity_path):
                    try:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ===== CLIQUE DETECTADO =====")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Jogador escolheu posição {idx}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Activity: {os.path.basename(carta)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Challenge: {os.path.basename(carta_challenge_path)}")
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Chamando _substituir_activity_por_challenge...")
                        self._substituir_activity_por_challenge(idx, carta, carta_challenge_path)
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] _substituir_activity_por_challenge concluída")
                    except Exception as e:
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO ao executar substituição: {e}")
                        import traceback
                        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Traceback: {traceback.format_exc()}")
                        # Em caso de erro, voltar à interface principal
                        try:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Tentando recuperar com playerdashboard_interface...")
                            self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface recuperada com sucesso")
                        except Exception as e2:
                            print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] ERRO crítico ao voltar à interface: {e2}")
                
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Binding clique para Activity {i}: {os.path.basename(carta_activity_path)}")
                
                # Testar se o widget responde a eventos básicos de hover primeiro
                def on_enter(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse entrou na Activity {pos}")
                    lbl.config(highlightbackground="yellow")
                def on_leave(e, lbl=carta_lbl, pos=i):
                    print(f"DEBUG: [HOVER] Mouse saiu da Activity {pos}")
                    lbl.config(highlightbackground="black")
                    
                carta_lbl.bind("<Enter>", on_enter)
                carta_lbl.bind("<Leave>", on_leave)
                
                # Bind de clique com debug detalhado
                carta_lbl.bind("<Button-1>", lambda e, f=fazer_substituicao, pos=i: (
                    print(f"DEBUG: [LAMBDA] ===== CLIQUE RECEBIDO ====="),
                    print(f"DEBUG: [LAMBDA] Widget: {e.widget}"),
                    print(f"DEBUG: [LAMBDA] Coordenadas: x={e.x}, y={e.y}"),
                    print(f"DEBUG: [LAMBDA] Activity posição: {pos}"),
                    print(f"DEBUG: [LAMBDA] Executando função de substituição..."),
                    f(),
                    print(f"DEBUG: [LAMBDA] Função executada!")
                )[-1])
                
                # Verificar se os widgets estão realmente visíveis e interativos
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widget Activity {i} criado:")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Widget: {carta_lbl}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Posição: {carta_lbl.winfo_x()}, {carta_lbl.winfo_y()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Tamanho: {carta_lbl.winfo_width()}x{carta_lbl.winfo_height()}")
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir]   - Cursor: {carta_lbl.cget('cursor')}")
                
            except Exception as e:
                print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Erro ao carregar Activity {carta_activity_path}: {e}")
        
        # Botão cancelar
        cancel_btn = tk.Button(self, text="Cancel", font=("Helvetica", 14, "bold"), 
                              bg="#F44336", fg="white", width=8,
                              command=lambda: (print("DEBUG: [_mostrar_selecao_activity_para_substituir] Botão Cancel clicado"), 
                                             self.playerdashboard_interface(self.player_name, self.saldo, self.other_players)))
        cancel_btn.place(relx=0.5, rely=0.8, anchor="center")
        
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Interface de seleção criada")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Widgets criados: {len(self.winfo_children())} widgets")
        print(f"DEBUG: [_mostrar_selecao_activity_para_substituir] Aguardando clique do jogador...")

    def _mostrar_mensagem_restricao_activity(self):
        """
        Mostra mensagem informando que não é possível trocar Activity ativa 
        enquanto houver Challenges no inventário.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot replace active Activity\nwhile Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar após 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_challenge_activity(self):
        """
        Mostra mensagem informando que Challenge só pode ser trocado por Activity.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_challenge_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=400, height=200)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Challenge can only be\nreplaced with Activity", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=20)
        
        # Auto-fechar após 3 segundos
        self.after(3000, fechar_mensagem)

    def _mostrar_mensagem_restricao_activity_activity(self):
        """
        Mostra mensagem informando que Activity só pode ser trocada por outra Activity 
        se não há Challenges no inventário.
        """
        print("DEBUG: [_mostrar_mensagem_restricao_activity_activity] Mostrando mensagem de restrição")
        
        # Criar popup/overlay com mensagem
        overlay_frame = tk.Frame(self, bg="black", relief="solid", borderwidth=3)
        overlay_frame.place(relx=0.5, rely=0.5, anchor="center", width=450, height=220)
        
        # Título da mensagem
        title_lbl = tk.Label(overlay_frame, text="Restriction", 
                           font=("Helvetica", 18, "bold"), fg="red", bg="black")
        title_lbl.pack(pady=(20, 10))
        
        # Mensagem principal
        message_lbl = tk.Label(overlay_frame, 
                             text="Cannot swap Activity ↔ Activity\nwhen Challenges exist in inventory", 
                             font=("Helvetica", 14), fg="white", bg="black", justify="center")
        message_lbl.pack(pady=10)
        
        # Submensagem
        submessage_lbl = tk.Label(overlay_frame, 
                                text="Use Challenges first", 
                                font=("Helvetica", 12), fg="lightgray", bg="black", justify="center")
        submessage_lbl.pack(pady=5)
        
        # Botão OK
        def fechar_mensagem():
            overlay_frame.destroy()
        
        ok_btn = tk.Button(overlay_frame, text="OK", font=("Helvetica", 14, "bold"), 
                          bg="#4CAF50", fg="white", width=8, command=fechar_mensagem)
        ok_btn.pack(pady=15)
        
        # Auto-fechar após 4 segundos (mais tempo para ler a mensagem)
        self.after(4000, fechar_mensagem)

    def show_card_fullscreen_readonly(self, carta_path, carta_tipo):
        """
        Mostra uma carta em fullscreen apenas para visualização (sem opções de venda).
        Usado para cartas ativas (viradas para cima) que não podem ser vendidas.
        """
        print(f"DEBUG: show_card_fullscreen_readonly chamado para {os.path.basename(carta_path)} (tipo: {carta_tipo})")
        
        # Limpa widgets (menos barra superior)
        for widget in self.winfo_children():
            if widget == self.topbar_label:
                continue
            widget.destroy()
        
        try:
            # Carrega e redimensiona a imagem
            pil_img = Image.open(carta_path)
            img_w, img_h = pil_img.size
            max_w, max_h = self.winfo_screenwidth(), self.winfo_screenheight()
            ratio = min(max_w/img_w, max_h/img_h)
            new_w, new_h = int(img_w*ratio), int(img_h*ratio)
            pil_img = pil_img.resize((new_w, new_h), Image.Resampling.LANCZOS)
            carta_img = ImageTk.PhotoImage(pil_img)
            
            # Mostra a carta centralizada
            carta_real_lbl = tk.Label(self, image=carta_img, bg="black", borderwidth=0, highlightthickness=0)
            carta_real_lbl.image = carta_img  # type: ignore[attr-defined]
            carta_real_lbl.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
            # Função para voltar ao inventário
            def voltar_inventario():
                # Volta para a página de inventário do tipo correspondente
                if hasattr(self, '_current_sell_page') and self._current_sell_page is not None:
                    page = self._current_sell_page
                else:
                    page = 0
                # CORREÇÃO: Usar versão especial after_sale para manter consistência de estado
                self.show_inventory_for_sell_after_sale(carta_tipo, None, page)
            
            # Botão X para fechar - canto superior esquerdo
            x_btn = tk.Button(self, text="✖", font=("Helvetica", 24, "bold"), 
                            bg="#AAAAAA", fg="white", width=2, height=1, 
                            borderwidth=0, highlightthickness=0, 
                            command=voltar_inventario, cursor="hand2", 
                            activebackground="#CCCCCC")
            x_btn.place(relx=0.02, rely=0, anchor="nw")
            
        except Exception as e:
            print(f"DEBUG: Erro ao mostrar carta readonly: {e}")
            # Em caso de erro, volta ao inventário
            page = getattr(self, '_current_sell_page', 0)
            if page is None:
                page = 0
            self.show_inventory_for_sell(carta_tipo, None, page)

# Exemplo de uso isolado:
if __name__ == "__main__":
    root = tk.Tk()
    root.attributes("-fullscreen", True)  
    PlayerDashboard(root, player_color="red", saldo=1000, other_players=["green", "blue", "yellow"])
    check_gpio_key(root)
    root.mainloop()